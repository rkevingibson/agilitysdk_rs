#![allow(
    non_snake_case,
    non_upper_case_globals,
    non_camel_case_types,
    dead_code,
    clippy::all
)]
#[repr(transparent)]
pub struct D3D11On12CreatorID(::windows::core::IUnknown);
impl D3D11On12CreatorID {}
::windows::imp::interface_hierarchy!(D3D11On12CreatorID, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for D3D11On12CreatorID {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for D3D11On12CreatorID {}
impl ::core::fmt::Debug for D3D11On12CreatorID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D11On12CreatorID").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for D3D11On12CreatorID {
    type Vtable = D3D11On12CreatorID_Vtbl;
}
impl ::core::clone::Clone for D3D11On12CreatorID {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for D3D11On12CreatorID {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xedbf5678_2960_4e81_8429_99d4b2630c4e);
}
#[repr(C)]
#[doc(hidden)]
pub struct D3D11On12CreatorID_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
}
#[repr(transparent)]
pub struct D3D9On12CreatorID(::windows::core::IUnknown);
impl D3D9On12CreatorID {}
::windows::imp::interface_hierarchy!(D3D9On12CreatorID, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for D3D9On12CreatorID {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for D3D9On12CreatorID {}
impl ::core::fmt::Debug for D3D9On12CreatorID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D9On12CreatorID").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for D3D9On12CreatorID {
    type Vtable = D3D9On12CreatorID_Vtbl;
}
impl ::core::clone::Clone for D3D9On12CreatorID {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for D3D9On12CreatorID {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xfffcbb7f_15d3_42a2_841e_9d8d32f37ddd);
}
#[repr(C)]
#[doc(hidden)]
pub struct D3D9On12CreatorID_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
}
#[repr(transparent)]
pub struct DirectMLPyTorchCreatorID(::windows::core::IUnknown);
impl DirectMLPyTorchCreatorID {}
::windows::imp::interface_hierarchy!(DirectMLPyTorchCreatorID, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for DirectMLPyTorchCreatorID {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for DirectMLPyTorchCreatorID {}
impl ::core::fmt::Debug for DirectMLPyTorchCreatorID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DirectMLPyTorchCreatorID")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for DirectMLPyTorchCreatorID {
    type Vtable = DirectMLPyTorchCreatorID_Vtbl;
}
impl ::core::clone::Clone for DirectMLPyTorchCreatorID {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for DirectMLPyTorchCreatorID {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xaf029192_fba1_4b05_9116_235e06560354);
}
#[repr(C)]
#[doc(hidden)]
pub struct DirectMLPyTorchCreatorID_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
}
#[repr(transparent)]
pub struct DirectMLTensorFlowCreatorID(::windows::core::IUnknown);
impl DirectMLTensorFlowCreatorID {}
::windows::imp::interface_hierarchy!(DirectMLTensorFlowCreatorID, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for DirectMLTensorFlowCreatorID {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for DirectMLTensorFlowCreatorID {}
impl ::core::fmt::Debug for DirectMLTensorFlowCreatorID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DirectMLTensorFlowCreatorID")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for DirectMLTensorFlowCreatorID {
    type Vtable = DirectMLTensorFlowCreatorID_Vtbl;
}
impl ::core::clone::Clone for DirectMLTensorFlowCreatorID {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for DirectMLTensorFlowCreatorID {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xcb7490ac_8a0f_44ec_9b7b_6f4cafe8e9ab);
}
#[repr(C)]
#[doc(hidden)]
pub struct DirectMLTensorFlowCreatorID_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
}
#[repr(transparent)]
pub struct ID3D12CommandAllocator(::windows::core::IUnknown);
impl ID3D12CommandAllocator {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn Reset(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Reset)(::windows::core::Interface::as_raw(self))
            .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12CommandAllocator,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12CommandAllocator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12CommandAllocator {}
impl ::core::fmt::Debug for ID3D12CommandAllocator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12CommandAllocator")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12CommandAllocator {
    type Vtable = ID3D12CommandAllocator_Vtbl;
}
impl ::core::clone::Clone for ID3D12CommandAllocator {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12CommandAllocator {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x6102dee4_af59_4b09_b999_b44d73f09b24);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12CommandAllocator_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub Reset:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12CommandList(::windows::core::IUnknown);
impl ID3D12CommandList {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).GetType)(::windows::core::Interface::as_raw(self))
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12CommandList,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild
);
impl ::core::cmp::PartialEq for ID3D12CommandList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12CommandList {}
impl ::core::fmt::Debug for ID3D12CommandList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12CommandList").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12CommandList {
    type Vtable = ID3D12CommandList_Vtbl;
}
impl ::core::clone::Clone for ID3D12CommandList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12CommandList {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x7116d91c_e7e4_47ce_b8c6_ec8168f437e5);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12CommandList_Vtbl {
    pub base__: ID3D12DeviceChild_Vtbl,
    pub GetType:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_COMMAND_LIST_TYPE,
}
#[repr(transparent)]
pub struct ID3D12CommandQueue(::windows::core::IUnknown);
impl ID3D12CommandQueue {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn UpdateTileMappings<P0, P1>(
        &self,
        presource: P0,
        numresourceregions: u32,
        presourceregionstartcoordinates: ::core::option::Option<
            *const D3D12_TILED_RESOURCE_COORDINATE,
        >,
        presourceregionsizes: ::core::option::Option<*const D3D12_TILE_REGION_SIZE>,
        pheap: P1,
        numranges: u32,
        prangeflags: ::core::option::Option<*const D3D12_TILE_RANGE_FLAGS>,
        pheaprangestartoffsets: ::core::option::Option<*const u32>,
        prangetilecounts: ::core::option::Option<*const u32>,
        flags: D3D12_TILE_MAPPING_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Heap>,
    {
        (::windows::core::Interface::vtable(self).UpdateTileMappings)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            numresourceregions,
            ::core::mem::transmute(presourceregionstartcoordinates.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(presourceregionsizes.unwrap_or(::std::ptr::null())),
            pheap.into_param().abi(),
            numranges,
            ::core::mem::transmute(prangeflags.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(pheaprangestartoffsets.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(prangetilecounts.unwrap_or(::std::ptr::null())),
            flags,
        )
    }
    pub unsafe fn CopyTileMappings<P0, P1>(
        &self,
        pdstresource: P0,
        pdstregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        psrcresource: P1,
        psrcregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        pregionsize: *const D3D12_TILE_REGION_SIZE,
        flags: D3D12_TILE_MAPPING_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).CopyTileMappings)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            pdstregionstartcoordinate,
            psrcresource.into_param().abi(),
            psrcregionstartcoordinate,
            pregionsize,
            flags,
        )
    }
    pub unsafe fn ExecuteCommandLists(
        &self,
        ppcommandlists: &[::core::option::Option<ID3D12CommandList>],
    ) {
        (::windows::core::Interface::vtable(self).ExecuteCommandLists)(
            ::windows::core::Interface::as_raw(self),
            ppcommandlists.len() as _,
            ::core::mem::transmute(ppcommandlists.as_ptr()),
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).EndEvent)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn Signal<P0>(&self, pfence: P0, value: u64) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self).Signal)(
            ::windows::core::Interface::as_raw(self),
            pfence.into_param().abi(),
            value,
        )
        .ok()
    }
    pub unsafe fn Wait<P0>(&self, pfence: P0, value: u64) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self).Wait)(
            ::windows::core::Interface::as_raw(self),
            pfence.into_param().abi(),
            value,
        )
        .ok()
    }
    pub unsafe fn GetTimestampFrequency(&self) -> ::windows::core::Result<u64> {
        let mut result__ = ::windows::core::zeroed::<u64>();
        (::windows::core::Interface::vtable(self).GetTimestampFrequency)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetClockCalibration(
        &self,
        pgputimestamp: *mut u64,
        pcputimestamp: *mut u64,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetClockCalibration)(
            ::windows::core::Interface::as_raw(self),
            pgputimestamp,
            pcputimestamp,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_COMMAND_QUEUE_DESC {
        let mut result__: D3D12_COMMAND_QUEUE_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12CommandQueue,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12CommandQueue {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12CommandQueue {}
impl ::core::fmt::Debug for ID3D12CommandQueue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12CommandQueue").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12CommandQueue {
    type Vtable = ID3D12CommandQueue_Vtbl;
}
impl ::core::clone::Clone for ID3D12CommandQueue {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12CommandQueue {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x0ec870a6_5d7e_4c22_8cfc_5baae07616ed);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12CommandQueue_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub UpdateTileMappings: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        numresourceregions: u32,
        presourceregionstartcoordinates: *const D3D12_TILED_RESOURCE_COORDINATE,
        presourceregionsizes: *const D3D12_TILE_REGION_SIZE,
        pheap: *mut ::core::ffi::c_void,
        numranges: u32,
        prangeflags: *const D3D12_TILE_RANGE_FLAGS,
        pheaprangestartoffsets: *const u32,
        prangetilecounts: *const u32,
        flags: D3D12_TILE_MAPPING_FLAGS,
    ),
    pub CopyTileMappings: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdstresource: *mut ::core::ffi::c_void,
        pdstregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        psrcresource: *mut ::core::ffi::c_void,
        psrcregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        pregionsize: *const D3D12_TILE_REGION_SIZE,
        flags: D3D12_TILE_MAPPING_FLAGS,
    ),
    pub ExecuteCommandLists: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numcommandlists: u32,
        ppcommandlists: *const *mut ::core::ffi::c_void,
    ),
    pub SetMarker: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        metadata: u32,
        pdata: *const ::core::ffi::c_void,
        size: u32,
    ),
    pub BeginEvent: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        metadata: u32,
        pdata: *const ::core::ffi::c_void,
        size: u32,
    ),
    pub EndEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub Signal: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfence: *mut ::core::ffi::c_void,
        value: u64,
    ) -> ::windows::core::HRESULT,
    pub Wait: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfence: *mut ::core::ffi::c_void,
        value: u64,
    ) -> ::windows::core::HRESULT,
    pub GetTimestampFrequency: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfrequency: *mut u64,
    ) -> ::windows::core::HRESULT,
    pub GetClockCalibration: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pgputimestamp: *mut u64,
        pcputimestamp: *mut u64,
    ) -> ::windows::core::HRESULT,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_COMMAND_QUEUE_DESC,
    ),
}
#[repr(transparent)]
pub struct ID3D12CommandSignature(::windows::core::IUnknown);
impl ID3D12CommandSignature {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12CommandSignature,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12CommandSignature {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12CommandSignature {}
impl ::core::fmt::Debug for ID3D12CommandSignature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12CommandSignature")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12CommandSignature {
    type Vtable = ID3D12CommandSignature_Vtbl;
}
impl ::core::clone::Clone for ID3D12CommandSignature {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12CommandSignature {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xc36a797c_ec80_4f0a_8985_a7b2475082d1);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12CommandSignature_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
}
#[repr(transparent)]
pub struct ID3D12CompatibilityDevice(::windows::core::IUnknown);
impl ID3D12CompatibilityDevice {
    pub unsafe fn CreateSharedResource<P0, P1, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pflags11: ::core::option::Option<
            *const ::windows::Win32::Graphics::Direct3D11on12::D3D11_RESOURCE_FLAGS,
        >,
        compatibilityflags: D3D12_COMPATIBILITY_SHARED_FLAGS,
        plifetimetracker: P0,
        powningswapchain: P1,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeTracker>,
        P1: ::windows::core::IntoParam<ID3D12SwapChainAssistant>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateSharedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(pflags11.unwrap_or(::std::ptr::null())),
            compatibilityflags,
            plifetimetracker.into_param().abi(),
            powningswapchain.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHeap<T>(
        &self,
        pheapdesc: *const D3D12_HEAP_DESC,
        compatibilityflags: D3D12_COMPATIBILITY_SHARED_FLAGS,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateSharedHeap)(
            ::windows::core::Interface::as_raw(self),
            pheapdesc,
            compatibilityflags,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn ReflectSharedProperties<P0>(
        &self,
        pheaporresource: P0,
        reflecttype: D3D12_REFLECT_SHARED_PROPERTY,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Object>,
    {
        (::windows::core::Interface::vtable(self).ReflectSharedProperties)(
            ::windows::core::Interface::as_raw(self),
            pheaporresource.into_param().abi(),
            reflecttype,
            pdata,
            datasize,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12CompatibilityDevice, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12CompatibilityDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12CompatibilityDevice {}
impl ::core::fmt::Debug for ID3D12CompatibilityDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12CompatibilityDevice")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12CompatibilityDevice {
    type Vtable = ID3D12CompatibilityDevice_Vtbl;
}
impl ::core::clone::Clone for ID3D12CompatibilityDevice {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12CompatibilityDevice {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x8f1c0e3c_fae3_4a82_b098_bfe1708207ff);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12CompatibilityDevice_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CreateSharedResource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pflags11: *const ::windows::Win32::Graphics::Direct3D11on12::D3D11_RESOURCE_FLAGS,
        compatibilityflags: D3D12_COMPATIBILITY_SHARED_FLAGS,
        plifetimetracker: *mut ::core::ffi::c_void,
        powningswapchain: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateSharedHeap: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheapdesc: *const D3D12_HEAP_DESC,
        compatibilityflags: D3D12_COMPATIBILITY_SHARED_FLAGS,
        riid: *const ::windows::core::GUID,
        ppheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub ReflectSharedProperties: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheaporresource: *mut ::core::ffi::c_void,
        reflecttype: D3D12_REFLECT_SHARED_PROPERTY,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Debug(::windows::core::IUnknown);
impl ID3D12Debug {
    pub unsafe fn EnableDebugLayer(&self) {
        (::windows::core::Interface::vtable(self).EnableDebugLayer)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12Debug, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12Debug {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Debug {}
impl ::core::fmt::Debug for ID3D12Debug {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Debug").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Debug {
    type Vtable = ID3D12Debug_Vtbl;
}
impl ::core::clone::Clone for ID3D12Debug {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Debug {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x344488b7_6846_474b_b989_f027448245e0);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Debug_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub EnableDebugLayer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[repr(transparent)]
pub struct ID3D12Debug1(::windows::core::IUnknown);
impl ID3D12Debug1 {
    pub unsafe fn EnableDebugLayer(&self) {
        (::windows::core::Interface::vtable(self).EnableDebugLayer)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn SetEnableGPUBasedValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetEnableGPUBasedValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
    pub unsafe fn SetEnableSynchronizedCommandQueueValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetEnableSynchronizedCommandQueueValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12Debug1, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12Debug1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Debug1 {}
impl ::core::fmt::Debug for ID3D12Debug1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Debug1").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Debug1 {
    type Vtable = ID3D12Debug1_Vtbl;
}
impl ::core::clone::Clone for ID3D12Debug1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Debug1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xaffaa4ca_63fe_4d8e_b8ad_159000af4304);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Debug1_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub EnableDebugLayer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub SetEnableGPUBasedValidation: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enable: ::windows::Win32::Foundation::BOOL,
    ),
    pub SetEnableSynchronizedCommandQueueValidation: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enable: ::windows::Win32::Foundation::BOOL,
    ),
}
#[repr(transparent)]
pub struct ID3D12Debug2(::windows::core::IUnknown);
impl ID3D12Debug2 {
    pub unsafe fn SetGPUBasedValidationFlags(&self, flags: D3D12_GPU_BASED_VALIDATION_FLAGS) {
        (::windows::core::Interface::vtable(self).SetGPUBasedValidationFlags)(
            ::windows::core::Interface::as_raw(self),
            flags,
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12Debug2, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12Debug2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Debug2 {}
impl ::core::fmt::Debug for ID3D12Debug2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Debug2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Debug2 {
    type Vtable = ID3D12Debug2_Vtbl;
}
impl ::core::clone::Clone for ID3D12Debug2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Debug2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x93a665c4_a3b2_4e5d_b692_a26ae14e3374);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Debug2_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetGPUBasedValidationFlags: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        flags: D3D12_GPU_BASED_VALIDATION_FLAGS,
    ),
}
#[repr(transparent)]
pub struct ID3D12Debug3(::windows::core::IUnknown);
impl ID3D12Debug3 {
    pub unsafe fn EnableDebugLayer(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .EnableDebugLayer)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetEnableGPUBasedValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetEnableGPUBasedValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
    pub unsafe fn SetEnableSynchronizedCommandQueueValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetEnableSynchronizedCommandQueueValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
    pub unsafe fn SetGPUBasedValidationFlags(&self, flags: D3D12_GPU_BASED_VALIDATION_FLAGS) {
        (::windows::core::Interface::vtable(self).SetGPUBasedValidationFlags)(
            ::windows::core::Interface::as_raw(self),
            flags,
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12Debug3, ::windows::core::IUnknown, ID3D12Debug);
impl ::core::cmp::PartialEq for ID3D12Debug3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Debug3 {}
impl ::core::fmt::Debug for ID3D12Debug3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Debug3").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Debug3 {
    type Vtable = ID3D12Debug3_Vtbl;
}
impl ::core::clone::Clone for ID3D12Debug3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Debug3 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x5cf4e58f_f671_4ff1_a542_3686e3d153d1);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Debug3_Vtbl {
    pub base__: ID3D12Debug_Vtbl,
    pub SetEnableGPUBasedValidation: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enable: ::windows::Win32::Foundation::BOOL,
    ),
    pub SetEnableSynchronizedCommandQueueValidation: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enable: ::windows::Win32::Foundation::BOOL,
    ),
    pub SetGPUBasedValidationFlags: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        flags: D3D12_GPU_BASED_VALIDATION_FLAGS,
    ),
}
#[repr(transparent)]
pub struct ID3D12Debug4(::windows::core::IUnknown);
impl ID3D12Debug4 {
    pub unsafe fn EnableDebugLayer(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EnableDebugLayer)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetEnableGPUBasedValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetEnableGPUBasedValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
    pub unsafe fn SetEnableSynchronizedCommandQueueValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetEnableSynchronizedCommandQueueValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
    pub unsafe fn SetGPUBasedValidationFlags(&self, flags: D3D12_GPU_BASED_VALIDATION_FLAGS) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetGPUBasedValidationFlags)(::windows::core::Interface::as_raw(self), flags)
    }
    pub unsafe fn DisableDebugLayer(&self) {
        (::windows::core::Interface::vtable(self).DisableDebugLayer)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Debug4,
    ::windows::core::IUnknown,
    ID3D12Debug,
    ID3D12Debug3
);
impl ::core::cmp::PartialEq for ID3D12Debug4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Debug4 {}
impl ::core::fmt::Debug for ID3D12Debug4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Debug4").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Debug4 {
    type Vtable = ID3D12Debug4_Vtbl;
}
impl ::core::clone::Clone for ID3D12Debug4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Debug4 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x014b816e_9ec5_4a2f_a845_ffbe441ce13a);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Debug4_Vtbl {
    pub base__: ID3D12Debug3_Vtbl,
    pub DisableDebugLayer: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[repr(transparent)]
pub struct ID3D12Debug5(::windows::core::IUnknown);
impl ID3D12Debug5 {
    pub unsafe fn EnableDebugLayer(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EnableDebugLayer)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetEnableGPUBasedValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetEnableGPUBasedValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
    pub unsafe fn SetEnableSynchronizedCommandQueueValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetEnableSynchronizedCommandQueueValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
    pub unsafe fn SetGPUBasedValidationFlags(&self, flags: D3D12_GPU_BASED_VALIDATION_FLAGS) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetGPUBasedValidationFlags)(::windows::core::Interface::as_raw(self), flags)
    }
    pub unsafe fn DisableDebugLayer(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .DisableDebugLayer)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetEnableAutoName<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetEnableAutoName)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Debug5,
    ::windows::core::IUnknown,
    ID3D12Debug,
    ID3D12Debug3,
    ID3D12Debug4
);
impl ::core::cmp::PartialEq for ID3D12Debug5 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Debug5 {}
impl ::core::fmt::Debug for ID3D12Debug5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Debug5").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Debug5 {
    type Vtable = ID3D12Debug5_Vtbl;
}
impl ::core::clone::Clone for ID3D12Debug5 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Debug5 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x548d6b12_09fa_40e0_9069_5dcd589a52c9);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Debug5_Vtbl {
    pub base__: ID3D12Debug4_Vtbl,
    pub SetEnableAutoName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enable: ::windows::Win32::Foundation::BOOL,
    ),
}
#[repr(transparent)]
pub struct ID3D12Debug6(::windows::core::IUnknown);
impl ID3D12Debug6 {
    pub unsafe fn EnableDebugLayer(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .EnableDebugLayer)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetEnableGPUBasedValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetEnableGPUBasedValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
    pub unsafe fn SetEnableSynchronizedCommandQueueValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetEnableSynchronizedCommandQueueValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
    pub unsafe fn SetGPUBasedValidationFlags(&self, flags: D3D12_GPU_BASED_VALIDATION_FLAGS) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetGPUBasedValidationFlags)(::windows::core::Interface::as_raw(self), flags)
    }
    pub unsafe fn DisableDebugLayer(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DisableDebugLayer)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetEnableAutoName<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetEnableAutoName)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
    pub unsafe fn SetForceLegacyBarrierValidation<P0>(&self, enable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetForceLegacyBarrierValidation)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Debug6,
    ::windows::core::IUnknown,
    ID3D12Debug,
    ID3D12Debug3,
    ID3D12Debug4,
    ID3D12Debug5
);
impl ::core::cmp::PartialEq for ID3D12Debug6 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Debug6 {}
impl ::core::fmt::Debug for ID3D12Debug6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Debug6").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Debug6 {
    type Vtable = ID3D12Debug6_Vtbl;
}
impl ::core::clone::Clone for ID3D12Debug6 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Debug6 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x82a816d6_5d01_4157_97d0_4975463fd1ed);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Debug6_Vtbl {
    pub base__: ID3D12Debug5_Vtbl,
    pub SetForceLegacyBarrierValidation: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enable: ::windows::Win32::Foundation::BOOL,
    ),
}
#[repr(transparent)]
pub struct ID3D12DebugCommandList(::windows::core::IUnknown);
impl ID3D12DebugCommandList {
    pub unsafe fn AssertResourceState<P0>(
        &self,
        presource: P0,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).AssertResourceState)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            state,
        )
    }
    pub unsafe fn SetFeatureMask(&self, mask: D3D12_DEBUG_FEATURE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFeatureMask)(
            ::windows::core::Interface::as_raw(self),
            mask,
        )
        .ok()
    }
    pub unsafe fn GetFeatureMask(&self) -> D3D12_DEBUG_FEATURE {
        (::windows::core::Interface::vtable(self).GetFeatureMask)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12DebugCommandList, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12DebugCommandList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DebugCommandList {}
impl ::core::fmt::Debug for ID3D12DebugCommandList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DebugCommandList")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DebugCommandList {
    type Vtable = ID3D12DebugCommandList_Vtbl;
}
impl ::core::clone::Clone for ID3D12DebugCommandList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DebugCommandList {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x09e0bf36_54ac_484f_8847_4baeeab6053f);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DebugCommandList_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub AssertResourceState: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL,
    pub SetFeatureMask: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        mask: D3D12_DEBUG_FEATURE,
    ) -> ::windows::core::HRESULT,
    pub GetFeatureMask:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_DEBUG_FEATURE,
}
#[repr(transparent)]
pub struct ID3D12DebugCommandList1(::windows::core::IUnknown);
impl ID3D12DebugCommandList1 {
    pub unsafe fn AssertResourceState<P0>(
        &self,
        presource: P0,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).AssertResourceState)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            state,
        )
    }
    pub unsafe fn SetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDebugParameter)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            pdata,
            datasize,
        )
        .ok()
    }
    pub unsafe fn GetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDebugParameter)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            pdata,
            datasize,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12DebugCommandList1, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12DebugCommandList1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DebugCommandList1 {}
impl ::core::fmt::Debug for ID3D12DebugCommandList1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DebugCommandList1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DebugCommandList1 {
    type Vtable = ID3D12DebugCommandList1_Vtbl;
}
impl ::core::clone::Clone for ID3D12DebugCommandList1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DebugCommandList1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x102ca951_311b_4b01_b11f_ecb83e061b37);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DebugCommandList1_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub AssertResourceState: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL,
    pub SetDebugParameter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::HRESULT,
    pub GetDebugParameter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DebugCommandList2(::windows::core::IUnknown);
impl ID3D12DebugCommandList2 {
    pub unsafe fn AssertResourceState<P0>(
        &self,
        presource: P0,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .AssertResourceState)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            state,
        )
    }
    pub unsafe fn SetFeatureMask(&self, mask: D3D12_DEBUG_FEATURE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetFeatureMask)(::windows::core::Interface::as_raw(self), mask)
        .ok()
    }
    pub unsafe fn GetFeatureMask(&self) -> D3D12_DEBUG_FEATURE {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetFeatureMask)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDebugParameter)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            pdata,
            datasize,
        )
        .ok()
    }
    pub unsafe fn GetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDebugParameter)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            pdata,
            datasize,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DebugCommandList2,
    ::windows::core::IUnknown,
    ID3D12DebugCommandList
);
impl ::core::cmp::PartialEq for ID3D12DebugCommandList2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DebugCommandList2 {}
impl ::core::fmt::Debug for ID3D12DebugCommandList2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DebugCommandList2")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DebugCommandList2 {
    type Vtable = ID3D12DebugCommandList2_Vtbl;
}
impl ::core::clone::Clone for ID3D12DebugCommandList2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DebugCommandList2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xaeb575cf_4e06_48be_ba3b_c450fc96652e);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DebugCommandList2_Vtbl {
    pub base__: ID3D12DebugCommandList_Vtbl,
    pub SetDebugParameter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::HRESULT,
    pub GetDebugParameter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DebugCommandList3(::windows::core::IUnknown);
impl ID3D12DebugCommandList3 {
    pub unsafe fn AssertResourceState<P0>(
        &self,
        presource: P0,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .AssertResourceState)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            state,
        )
    }
    pub unsafe fn SetFeatureMask(&self, mask: D3D12_DEBUG_FEATURE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetFeatureMask)(::windows::core::Interface::as_raw(self), mask)
        .ok()
    }
    pub unsafe fn GetFeatureMask(&self) -> D3D12_DEBUG_FEATURE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetFeatureMask)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetDebugParameter)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            pdata,
            datasize,
        )
        .ok()
    }
    pub unsafe fn GetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetDebugParameter)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            pdata,
            datasize,
        )
        .ok()
    }
    pub unsafe fn AssertResourceAccess<P0>(
        &self,
        presource: P0,
        subresource: u32,
        access: D3D12_BARRIER_ACCESS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).AssertResourceAccess)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            access,
        )
    }
    pub unsafe fn AssertTextureLayout<P0>(
        &self,
        presource: P0,
        subresource: u32,
        layout: D3D12_BARRIER_LAYOUT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).AssertTextureLayout)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            layout,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DebugCommandList3,
    ::windows::core::IUnknown,
    ID3D12DebugCommandList,
    ID3D12DebugCommandList2
);
impl ::core::cmp::PartialEq for ID3D12DebugCommandList3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DebugCommandList3 {}
impl ::core::fmt::Debug for ID3D12DebugCommandList3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DebugCommandList3")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DebugCommandList3 {
    type Vtable = ID3D12DebugCommandList3_Vtbl;
}
impl ::core::clone::Clone for ID3D12DebugCommandList3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DebugCommandList3 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x197d5e15_4d37_4d34_af78_724cd70fdb1f);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DebugCommandList3_Vtbl {
    pub base__: ID3D12DebugCommandList2_Vtbl,
    pub AssertResourceAccess: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        subresource: u32,
        access: D3D12_BARRIER_ACCESS,
    ),
    pub AssertTextureLayout: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        subresource: u32,
        layout: D3D12_BARRIER_LAYOUT,
    ),
}
#[repr(transparent)]
pub struct ID3D12DebugCommandQueue(::windows::core::IUnknown);
impl ID3D12DebugCommandQueue {
    pub unsafe fn AssertResourceState<P0>(
        &self,
        presource: P0,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).AssertResourceState)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            state,
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12DebugCommandQueue, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12DebugCommandQueue {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DebugCommandQueue {}
impl ::core::fmt::Debug for ID3D12DebugCommandQueue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DebugCommandQueue")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DebugCommandQueue {
    type Vtable = ID3D12DebugCommandQueue_Vtbl;
}
impl ::core::clone::Clone for ID3D12DebugCommandQueue {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DebugCommandQueue {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x09e0bf36_54ac_484f_8847_4baeeab6053a);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DebugCommandQueue_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub AssertResourceState: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL,
}
#[repr(transparent)]
pub struct ID3D12DebugCommandQueue1(::windows::core::IUnknown);
impl ID3D12DebugCommandQueue1 {
    pub unsafe fn AssertResourceState<P0>(
        &self,
        presource: P0,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .AssertResourceState)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            state,
        )
    }
    pub unsafe fn AssertResourceAccess<P0>(
        &self,
        presource: P0,
        subresource: u32,
        access: D3D12_BARRIER_ACCESS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).AssertResourceAccess)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            access,
        )
    }
    pub unsafe fn AssertTextureLayout<P0>(
        &self,
        presource: P0,
        subresource: u32,
        layout: D3D12_BARRIER_LAYOUT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).AssertTextureLayout)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            layout,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DebugCommandQueue1,
    ::windows::core::IUnknown,
    ID3D12DebugCommandQueue
);
impl ::core::cmp::PartialEq for ID3D12DebugCommandQueue1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DebugCommandQueue1 {}
impl ::core::fmt::Debug for ID3D12DebugCommandQueue1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DebugCommandQueue1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DebugCommandQueue1 {
    type Vtable = ID3D12DebugCommandQueue1_Vtbl;
}
impl ::core::clone::Clone for ID3D12DebugCommandQueue1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DebugCommandQueue1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x16be35a2_bfd6_49f2_bcae_eaae4aff862d);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DebugCommandQueue1_Vtbl {
    pub base__: ID3D12DebugCommandQueue_Vtbl,
    pub AssertResourceAccess: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        subresource: u32,
        access: D3D12_BARRIER_ACCESS,
    ),
    pub AssertTextureLayout: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        subresource: u32,
        layout: D3D12_BARRIER_LAYOUT,
    ),
}
#[repr(transparent)]
pub struct ID3D12DebugDevice(::windows::core::IUnknown);
impl ID3D12DebugDevice {
    pub unsafe fn SetFeatureMask(&self, mask: D3D12_DEBUG_FEATURE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFeatureMask)(
            ::windows::core::Interface::as_raw(self),
            mask,
        )
        .ok()
    }
    pub unsafe fn GetFeatureMask(&self) -> D3D12_DEBUG_FEATURE {
        (::windows::core::Interface::vtable(self).GetFeatureMask)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn ReportLiveDeviceObjects(
        &self,
        flags: D3D12_RLDO_FLAGS,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ReportLiveDeviceObjects)(
            ::windows::core::Interface::as_raw(self),
            flags,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12DebugDevice, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12DebugDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DebugDevice {}
impl ::core::fmt::Debug for ID3D12DebugDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DebugDevice").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DebugDevice {
    type Vtable = ID3D12DebugDevice_Vtbl;
}
impl ::core::clone::Clone for ID3D12DebugDevice {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DebugDevice {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x3febd6dd_4973_4787_8194_e45f9e28923e);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DebugDevice_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetFeatureMask: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        mask: D3D12_DEBUG_FEATURE,
    ) -> ::windows::core::HRESULT,
    pub GetFeatureMask:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_DEBUG_FEATURE,
    pub ReportLiveDeviceObjects: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        flags: D3D12_RLDO_FLAGS,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DebugDevice1(::windows::core::IUnknown);
impl ID3D12DebugDevice1 {
    pub unsafe fn SetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDebugParameter)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            pdata,
            datasize,
        )
        .ok()
    }
    pub unsafe fn GetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDebugParameter)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            pdata,
            datasize,
        )
        .ok()
    }
    pub unsafe fn ReportLiveDeviceObjects(
        &self,
        flags: D3D12_RLDO_FLAGS,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ReportLiveDeviceObjects)(
            ::windows::core::Interface::as_raw(self),
            flags,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12DebugDevice1, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12DebugDevice1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DebugDevice1 {}
impl ::core::fmt::Debug for ID3D12DebugDevice1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DebugDevice1").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DebugDevice1 {
    type Vtable = ID3D12DebugDevice1_Vtbl;
}
impl ::core::clone::Clone for ID3D12DebugDevice1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DebugDevice1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xa9b71770_d099_4a65_a698_3dee10020f88);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DebugDevice1_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetDebugParameter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::HRESULT,
    pub GetDebugParameter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::HRESULT,
    pub ReportLiveDeviceObjects: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        flags: D3D12_RLDO_FLAGS,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DebugDevice2(::windows::core::IUnknown);
impl ID3D12DebugDevice2 {
    pub unsafe fn SetFeatureMask(&self, mask: D3D12_DEBUG_FEATURE) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetFeatureMask)(::windows::core::Interface::as_raw(self), mask)
        .ok()
    }
    pub unsafe fn GetFeatureMask(&self) -> D3D12_DEBUG_FEATURE {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetFeatureMask)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ReportLiveDeviceObjects(
        &self,
        flags: D3D12_RLDO_FLAGS,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .ReportLiveDeviceObjects)(::windows::core::Interface::as_raw(self), flags)
        .ok()
    }
    pub unsafe fn SetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetDebugParameter)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            pdata,
            datasize,
        )
        .ok()
    }
    pub unsafe fn GetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDebugParameter)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            pdata,
            datasize,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DebugDevice2,
    ::windows::core::IUnknown,
    ID3D12DebugDevice
);
impl ::core::cmp::PartialEq for ID3D12DebugDevice2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DebugDevice2 {}
impl ::core::fmt::Debug for ID3D12DebugDevice2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DebugDevice2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DebugDevice2 {
    type Vtable = ID3D12DebugDevice2_Vtbl;
}
impl ::core::clone::Clone for ID3D12DebugDevice2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DebugDevice2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x60eccbc1_378d_4df1_894c_f8ac5ce4d7dd);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DebugDevice2_Vtbl {
    pub base__: ID3D12DebugDevice_Vtbl,
    pub SetDebugParameter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::HRESULT,
    pub GetDebugParameter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DescriptorHeap(::windows::core::IUnknown);
impl ID3D12DescriptorHeap {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_DESCRIPTOR_HEAP_DESC {
        let mut result__: D3D12_DESCRIPTOR_HEAP_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetCPUDescriptorHandleForHeapStart(&self) -> D3D12_CPU_DESCRIPTOR_HANDLE {
        let mut result__: D3D12_CPU_DESCRIPTOR_HANDLE = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetCPUDescriptorHandleForHeapStart)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetGPUDescriptorHandleForHeapStart(&self) -> D3D12_GPU_DESCRIPTOR_HANDLE {
        let mut result__: D3D12_GPU_DESCRIPTOR_HANDLE = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetGPUDescriptorHandleForHeapStart)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DescriptorHeap,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12DescriptorHeap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DescriptorHeap {}
impl ::core::fmt::Debug for ID3D12DescriptorHeap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DescriptorHeap")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DescriptorHeap {
    type Vtable = ID3D12DescriptorHeap_Vtbl;
}
impl ::core::clone::Clone for ID3D12DescriptorHeap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DescriptorHeap {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x8efb471d_616c_4f49_90f7_127bb763fa51);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DescriptorHeap_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_DESCRIPTOR_HEAP_DESC,
    ),
    pub GetCPUDescriptorHandleForHeapStart: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_CPU_DESCRIPTOR_HANDLE,
    ),
    pub GetGPUDescriptorHandleForHeapStart: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_GPU_DESCRIPTOR_HANDLE,
    ),
}
#[repr(transparent)]
pub struct ID3D12Device(::windows::core::IUnknown);
impl ID3D12Device {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNodeCount)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self).GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self).CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self).CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self).CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self).CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self).CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self).OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDeviceRemovedReason)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self).GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetAdapterLuid)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(ID3D12Device, ::windows::core::IUnknown, ID3D12Object);
impl ::core::cmp::PartialEq for ID3D12Device {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device {}
impl ::core::fmt::Debug for ID3D12Device {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device {
    type Vtable = ID3D12Device_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x189819f1_1db6_4b57_be54_1821339b85f7);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device_Vtbl {
    pub base__: ID3D12Object_Vtbl,
    pub GetNodeCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub CreateCommandQueue: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
        riid: *const ::windows::core::GUID,
        ppcommandqueue: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateCommandAllocator: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        r#type: D3D12_COMMAND_LIST_TYPE,
        riid: *const ::windows::core::GUID,
        ppcommandallocator: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateGraphicsPipelineState: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateComputePipelineState: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateCommandList: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: *mut ::core::ffi::c_void,
        pinitialstate: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppcommandlist: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CheckFeatureSupport: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::HRESULT,
    pub CreateDescriptorHeap: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub GetDescriptorHandleIncrementSize: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32,
    pub CreateRootSignature: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        nodemask: u32,
        pblobwithrootsignature: *const ::core::ffi::c_void,
        bloblengthinbytes: usize,
        riid: *const ::windows::core::GUID,
        ppvrootsignature: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateConstantBufferView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_CONSTANT_BUFFER_VIEW_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ),
    pub CreateShaderResourceView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_SHADER_RESOURCE_VIEW_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ),
    pub CreateUnorderedAccessView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        pcounterresource: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_UNORDERED_ACCESS_VIEW_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ),
    pub CreateRenderTargetView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_RENDER_TARGET_VIEW_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ),
    pub CreateDepthStencilView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_DEPTH_STENCIL_VIEW_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ),
    pub CreateSampler: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ),
    pub CopyDescriptors: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: *const u32,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: *const u32,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ),
    pub CopyDescriptorsSimple: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ),
    pub GetResourceAllocationInfo: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_RESOURCE_ALLOCATION_INFO,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
    ),
    pub GetCustomHeapProperties: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_HEAP_PROPERTIES,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ),
    pub CreateCommittedResource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateHeap: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_HEAP_DESC,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreatePlacedResource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheap: *mut ::core::ffi::c_void,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateReservedResource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateSharedHandle: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pobject: *mut ::core::ffi::c_void,
        pattributes: *const ::windows::Win32::Security::SECURITY_ATTRIBUTES,
        access: u32,
        name: ::windows::core::PCWSTR,
        phandle: *mut ::windows::Win32::Foundation::HANDLE,
    ) -> ::windows::core::HRESULT,
    pub OpenSharedHandle: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        nthandle: ::windows::Win32::Foundation::HANDLE,
        riid: *const ::windows::core::GUID,
        ppvobj: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub OpenSharedHandleByName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        name: ::windows::core::PCWSTR,
        access: u32,
        pnthandle: *mut ::windows::Win32::Foundation::HANDLE,
    ) -> ::windows::core::HRESULT,
    pub MakeResident: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numobjects: u32,
        ppobjects: *const *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub Evict: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numobjects: u32,
        ppobjects: *const *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateFence: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
        riid: *const ::windows::core::GUID,
        ppfence: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub GetDeviceRemovedReason:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub GetCopyableFootprints: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: *mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT,
        pnumrows: *mut u32,
        prowsizeinbytes: *mut u64,
        ptotalbytes: *mut u64,
    ),
    pub CreateQueryHeap: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub SetStablePowerState: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enable: ::windows::Win32::Foundation::BOOL,
    ) -> ::windows::core::HRESULT,
    pub CreateCommandSignature: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvcommandsignature: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub GetResourceTiling: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ptiledresource: *mut ::core::ffi::c_void,
        pnumtilesforentireresource: *mut u32,
        ppackedmipdesc: *mut D3D12_PACKED_MIP_INFO,
        pstandardtileshapefornonpackedmips: *mut D3D12_TILE_SHAPE,
        pnumsubresourcetilings: *mut u32,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ),
    pub GetAdapterLuid: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut ::windows::Win32::Foundation::LUID,
    ),
}
#[repr(transparent)]
pub struct ID3D12Device1(::windows::core::IUnknown);
impl ID3D12Device1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).base__.GetNodeCount)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).base__.CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device
);
impl ::core::cmp::PartialEq for ID3D12Device1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device1 {}
impl ::core::fmt::Debug for ID3D12Device1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device1").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device1 {
    type Vtable = ID3D12Device1_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x77acce80_638e_4e65_8895_c1f23386863e);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device1_Vtbl {
    pub base__: ID3D12Device_Vtbl,
    pub CreatePipelineLibrary: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        plibraryblob: *const ::core::ffi::c_void,
        bloblength: usize,
        riid: *const ::windows::core::GUID,
        pppipelinelibrary: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub SetEventOnMultipleFenceCompletion: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ppfences: *const *mut ::core::ffi::c_void,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: ::windows::Win32::Foundation::HANDLE,
    )
        -> ::windows::core::HRESULT,
    pub SetResidencyPriority: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numobjects: u32,
        ppobjects: *const *mut ::core::ffi::c_void,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Device10(::windows::core::IUnknown);
impl ID3D12Device10 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateLifetimeTracker<P0, T>(&self, powner: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeOwner>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateLifetimeTracker)(
            ::windows::core::Interface::as_raw(self),
            powner.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn RemoveDevice(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .RemoveDevice)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: ::core::option::Option<*mut D3D12_META_COMMAND_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommands)(
            ::windows::core::Interface::as_raw(self),
            pnummetacommands,
            ::core::mem::transmute(pdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: ::core::option::Option<*mut u32>,
        pparametercount: *mut u32,
        pparameterdescs: ::core::option::Option<*mut D3D12_META_COMMAND_PARAMETER_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommandParameters)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            stage,
            ::core::mem::transmute(ptotalstructuresizeinbytes.unwrap_or(::std::ptr::null_mut())),
            pparametercount,
            ::core::mem::transmute(pparameterdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateMetaCommand<T>(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        creationparametersdatasizeinbytes: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            nodemask,
            ::core::mem::transmute(pcreationparametersdata.unwrap_or(::std::ptr::null())),
            creationparametersdatasizeinbytes,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStateObject<T>(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateStateObject)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetRaytracingAccelerationStructurePrebuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pinfo,
        )
    }
    pub unsafe fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckDriverMatchingIdentifier)(
            ::windows::core::Interface::as_raw(self),
            serializeddatatype,
            pidentifiertocheck,
        )
    }
    pub unsafe fn SetBackgroundProcessingMode<P0>(
        &self,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: P0,
        pbfurthermeasurementsdesired: ::core::option::Option<
            *mut ::windows::Win32::Foundation::BOOL,
        >,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetBackgroundProcessingMode)(
            ::windows::core::Interface::as_raw(self),
            mode,
            measurementsaction,
            heventtosignaluponcompletion.into_param().abi(),
            ::core::mem::transmute(pbfurthermeasurementsdesired.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn AddToStateObject<P0, T>(
        &self,
        paddition: *const D3D12_STATE_OBJECT_DESC,
        pstateobjecttogrowfrom: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .AddToStateObject)(
            ::windows::core::Interface::as_raw(self),
            paddition,
            pstateobjecttogrowfrom.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession1<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetResourceAllocationInfo2(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetResourceAllocationInfo2)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateCommittedResource2<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateCommittedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource1<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreatePlacedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSamplerFeedbackUnorderedAccessView<P0, P1>(
        &self,
        ptargetedresource: P0,
        pfeedbackresource: P1,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateSamplerFeedbackUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            ptargetedresource.into_param().abi(),
            pfeedbackresource.into_param().abi(),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn GetCopyableFootprints1(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC1,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetCopyableFootprints1)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateShaderCacheSession<T>(
        &self,
        pdesc: *const D3D12_SHADER_CACHE_SESSION_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateShaderCacheSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn ShaderCacheControl(
        &self,
        kinds: D3D12_SHADER_CACHE_KIND_FLAGS,
        control: D3D12_SHADER_CACHE_CONTROL_FLAGS,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .ShaderCacheControl)(::windows::core::Interface::as_raw(self), kinds, control)
        .ok()
    }
    pub unsafe fn CreateCommandQueue1<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
        creatorid: *const ::windows::core::GUID,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateCommandQueue1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            creatorid,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource3<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateCommittedResource3)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource2<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreatePlacedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource2<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateReservedResource2)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device10,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3,
    ID3D12Device4,
    ID3D12Device5,
    ID3D12Device6,
    ID3D12Device7,
    ID3D12Device8,
    ID3D12Device9
);
impl ::core::cmp::PartialEq for ID3D12Device10 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device10 {}
impl ::core::fmt::Debug for ID3D12Device10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device10").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device10 {
    type Vtable = ID3D12Device10_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device10 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device10 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x517f8718_aa66_49f9_b02b_a7ab89c06031);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device10_Vtbl {
    pub base__: ID3D12Device9_Vtbl,
    pub CreateCommittedResource3: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pprotectedsession: *mut ::core::ffi::c_void,
        numcastableformats: u32,
        pcastableformats: *const DXGI_FORMAT,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreatePlacedResource2: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheap: *mut ::core::ffi::c_void,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        numcastableformats: u32,
        pcastableformats: *const DXGI_FORMAT,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateReservedResource2: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_RESOURCE_DESC,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pprotectedsession: *mut ::core::ffi::c_void,
        numcastableformats: u32,
        pcastableformats: *const DXGI_FORMAT,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Device11(::windows::core::IUnknown);
impl ID3D12Device11 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateLifetimeTracker<P0, T>(&self, powner: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeOwner>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateLifetimeTracker)(
            ::windows::core::Interface::as_raw(self),
            powner.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn RemoveDevice(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RemoveDevice)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: ::core::option::Option<*mut D3D12_META_COMMAND_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommands)(
            ::windows::core::Interface::as_raw(self),
            pnummetacommands,
            ::core::mem::transmute(pdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: ::core::option::Option<*mut u32>,
        pparametercount: *mut u32,
        pparameterdescs: ::core::option::Option<*mut D3D12_META_COMMAND_PARAMETER_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommandParameters)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            stage,
            ::core::mem::transmute(ptotalstructuresizeinbytes.unwrap_or(::std::ptr::null_mut())),
            pparametercount,
            ::core::mem::transmute(pparameterdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateMetaCommand<T>(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        creationparametersdatasizeinbytes: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            nodemask,
            ::core::mem::transmute(pcreationparametersdata.unwrap_or(::std::ptr::null())),
            creationparametersdatasizeinbytes,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStateObject<T>(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateStateObject)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetRaytracingAccelerationStructurePrebuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pinfo,
        )
    }
    pub unsafe fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckDriverMatchingIdentifier)(
            ::windows::core::Interface::as_raw(self),
            serializeddatatype,
            pidentifiertocheck,
        )
    }
    pub unsafe fn SetBackgroundProcessingMode<P0>(
        &self,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: P0,
        pbfurthermeasurementsdesired: ::core::option::Option<
            *mut ::windows::Win32::Foundation::BOOL,
        >,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetBackgroundProcessingMode)(
            ::windows::core::Interface::as_raw(self),
            mode,
            measurementsaction,
            heventtosignaluponcompletion.into_param().abi(),
            ::core::mem::transmute(pbfurthermeasurementsdesired.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn AddToStateObject<P0, T>(
        &self,
        paddition: *const D3D12_STATE_OBJECT_DESC,
        pstateobjecttogrowfrom: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .AddToStateObject)(
            ::windows::core::Interface::as_raw(self),
            paddition,
            pstateobjecttogrowfrom.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession1<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetResourceAllocationInfo2(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo2)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateCommittedResource2<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateCommittedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource1<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreatePlacedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSamplerFeedbackUnorderedAccessView<P0, P1>(
        &self,
        ptargetedresource: P0,
        pfeedbackresource: P1,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateSamplerFeedbackUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            ptargetedresource.into_param().abi(),
            pfeedbackresource.into_param().abi(),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn GetCopyableFootprints1(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC1,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetCopyableFootprints1)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateShaderCacheSession<T>(
        &self,
        pdesc: *const D3D12_SHADER_CACHE_SESSION_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateShaderCacheSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn ShaderCacheControl(
        &self,
        kinds: D3D12_SHADER_CACHE_KIND_FLAGS,
        control: D3D12_SHADER_CACHE_CONTROL_FLAGS,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ShaderCacheControl)(::windows::core::Interface::as_raw(self), kinds, control)
        .ok()
    }
    pub unsafe fn CreateCommandQueue1<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
        creatorid: *const ::windows::core::GUID,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateCommandQueue1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            creatorid,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource3<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateCommittedResource3)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource2<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreatePlacedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource2<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateReservedResource2)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSampler2(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC2,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self).CreateSampler2)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device11,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3,
    ID3D12Device4,
    ID3D12Device5,
    ID3D12Device6,
    ID3D12Device7,
    ID3D12Device8,
    ID3D12Device9,
    ID3D12Device10
);
impl ::core::cmp::PartialEq for ID3D12Device11 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device11 {}
impl ::core::fmt::Debug for ID3D12Device11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device11").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device11 {
    type Vtable = ID3D12Device11_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device11 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device11 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x5405c344_d457_444e_b4dd_2366e45aee39);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device11_Vtbl {
    pub base__: ID3D12Device10_Vtbl,
    pub CreateSampler2: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_SAMPLER_DESC2,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ),
}
#[repr(transparent)]
pub struct ID3D12Device12(::windows::core::IUnknown);
impl ID3D12Device12 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateLifetimeTracker<P0, T>(&self, powner: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeOwner>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateLifetimeTracker)(
            ::windows::core::Interface::as_raw(self),
            powner.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn RemoveDevice(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RemoveDevice)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: ::core::option::Option<*mut D3D12_META_COMMAND_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommands)(
            ::windows::core::Interface::as_raw(self),
            pnummetacommands,
            ::core::mem::transmute(pdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: ::core::option::Option<*mut u32>,
        pparametercount: *mut u32,
        pparameterdescs: ::core::option::Option<*mut D3D12_META_COMMAND_PARAMETER_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommandParameters)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            stage,
            ::core::mem::transmute(ptotalstructuresizeinbytes.unwrap_or(::std::ptr::null_mut())),
            pparametercount,
            ::core::mem::transmute(pparameterdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateMetaCommand<T>(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        creationparametersdatasizeinbytes: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            nodemask,
            ::core::mem::transmute(pcreationparametersdata.unwrap_or(::std::ptr::null())),
            creationparametersdatasizeinbytes,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStateObject<T>(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateStateObject)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetRaytracingAccelerationStructurePrebuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pinfo,
        )
    }
    pub unsafe fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckDriverMatchingIdentifier)(
            ::windows::core::Interface::as_raw(self),
            serializeddatatype,
            pidentifiertocheck,
        )
    }
    pub unsafe fn SetBackgroundProcessingMode<P0>(
        &self,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: P0,
        pbfurthermeasurementsdesired: ::core::option::Option<
            *mut ::windows::Win32::Foundation::BOOL,
        >,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetBackgroundProcessingMode)(
            ::windows::core::Interface::as_raw(self),
            mode,
            measurementsaction,
            heventtosignaluponcompletion.into_param().abi(),
            ::core::mem::transmute(pbfurthermeasurementsdesired.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn AddToStateObject<P0, T>(
        &self,
        paddition: *const D3D12_STATE_OBJECT_DESC,
        pstateobjecttogrowfrom: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .AddToStateObject)(
            ::windows::core::Interface::as_raw(self),
            paddition,
            pstateobjecttogrowfrom.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession1<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetResourceAllocationInfo2(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo2)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateCommittedResource2<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource1<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSamplerFeedbackUnorderedAccessView<P0, P1>(
        &self,
        ptargetedresource: P0,
        pfeedbackresource: P1,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateSamplerFeedbackUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            ptargetedresource.into_param().abi(),
            pfeedbackresource.into_param().abi(),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn GetCopyableFootprints1(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC1,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints1)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateShaderCacheSession<T>(
        &self,
        pdesc: *const D3D12_SHADER_CACHE_SESSION_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateShaderCacheSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn ShaderCacheControl(
        &self,
        kinds: D3D12_SHADER_CACHE_KIND_FLAGS,
        control: D3D12_SHADER_CACHE_CONTROL_FLAGS,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ShaderCacheControl)(::windows::core::Interface::as_raw(self), kinds, control)
        .ok()
    }
    pub unsafe fn CreateCommandQueue1<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
        creatorid: *const ::windows::core::GUID,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateCommandQueue1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            creatorid,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource3<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateCommittedResource3)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource2<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreatePlacedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource2<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateReservedResource2)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSampler2(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC2,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateSampler2)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn GetResourceAllocationInfo3(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        pnumcastableformats: ::core::option::Option<*const u32>,
        ppcastableformats: ::core::option::Option<*const *const DXGI_FORMAT>,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetResourceAllocationInfo3)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(pnumcastableformats.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(ppcastableformats.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device12,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3,
    ID3D12Device4,
    ID3D12Device5,
    ID3D12Device6,
    ID3D12Device7,
    ID3D12Device8,
    ID3D12Device9,
    ID3D12Device10,
    ID3D12Device11
);
impl ::core::cmp::PartialEq for ID3D12Device12 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device12 {}
impl ::core::fmt::Debug for ID3D12Device12 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device12").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device12 {
    type Vtable = ID3D12Device12_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device12 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device12 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x5af5c532_4c91_4cd0_b541_15a405395fc5);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device12_Vtbl {
    pub base__: ID3D12Device11_Vtbl,
    pub GetResourceAllocationInfo3: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_RESOURCE_ALLOCATION_INFO,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        pnumcastableformats: *const u32,
        ppcastableformats: *const *const DXGI_FORMAT,
        presourceallocationinfo1: *mut D3D12_RESOURCE_ALLOCATION_INFO1,
    ),
}
#[repr(transparent)]
pub struct ID3D12Device13(::windows::core::IUnknown);
impl ID3D12Device13 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateLifetimeTracker<P0, T>(&self, powner: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeOwner>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateLifetimeTracker)(
            ::windows::core::Interface::as_raw(self),
            powner.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn RemoveDevice(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RemoveDevice)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: ::core::option::Option<*mut D3D12_META_COMMAND_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommands)(
            ::windows::core::Interface::as_raw(self),
            pnummetacommands,
            ::core::mem::transmute(pdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: ::core::option::Option<*mut u32>,
        pparametercount: *mut u32,
        pparameterdescs: ::core::option::Option<*mut D3D12_META_COMMAND_PARAMETER_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommandParameters)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            stage,
            ::core::mem::transmute(ptotalstructuresizeinbytes.unwrap_or(::std::ptr::null_mut())),
            pparametercount,
            ::core::mem::transmute(pparameterdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateMetaCommand<T>(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        creationparametersdatasizeinbytes: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            nodemask,
            ::core::mem::transmute(pcreationparametersdata.unwrap_or(::std::ptr::null())),
            creationparametersdatasizeinbytes,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStateObject<T>(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateStateObject)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetRaytracingAccelerationStructurePrebuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pinfo,
        )
    }
    pub unsafe fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckDriverMatchingIdentifier)(
            ::windows::core::Interface::as_raw(self),
            serializeddatatype,
            pidentifiertocheck,
        )
    }
    pub unsafe fn SetBackgroundProcessingMode<P0>(
        &self,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: P0,
        pbfurthermeasurementsdesired: ::core::option::Option<
            *mut ::windows::Win32::Foundation::BOOL,
        >,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetBackgroundProcessingMode)(
            ::windows::core::Interface::as_raw(self),
            mode,
            measurementsaction,
            heventtosignaluponcompletion.into_param().abi(),
            ::core::mem::transmute(pbfurthermeasurementsdesired.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn AddToStateObject<P0, T>(
        &self,
        paddition: *const D3D12_STATE_OBJECT_DESC,
        pstateobjecttogrowfrom: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .AddToStateObject)(
            ::windows::core::Interface::as_raw(self),
            paddition,
            pstateobjecttogrowfrom.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession1<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetResourceAllocationInfo2(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo2)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateCommittedResource2<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource1<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSamplerFeedbackUnorderedAccessView<P0, P1>(
        &self,
        ptargetedresource: P0,
        pfeedbackresource: P1,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSamplerFeedbackUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            ptargetedresource.into_param().abi(),
            pfeedbackresource.into_param().abi(),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn GetCopyableFootprints1(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC1,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints1)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateShaderCacheSession<T>(
        &self,
        pdesc: *const D3D12_SHADER_CACHE_SESSION_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateShaderCacheSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn ShaderCacheControl(
        &self,
        kinds: D3D12_SHADER_CACHE_KIND_FLAGS,
        control: D3D12_SHADER_CACHE_CONTROL_FLAGS,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ShaderCacheControl)(::windows::core::Interface::as_raw(self), kinds, control)
        .ok()
    }
    pub unsafe fn CreateCommandQueue1<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
        creatorid: *const ::windows::core::GUID,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            creatorid,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource3<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateCommittedResource3)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource2<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreatePlacedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource2<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateReservedResource2)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSampler2(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC2,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateSampler2)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn GetResourceAllocationInfo3(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        pnumcastableformats: ::core::option::Option<*const u32>,
        ppcastableformats: ::core::option::Option<*const *const DXGI_FORMAT>,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetResourceAllocationInfo3)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(pnumcastableformats.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(ppcastableformats.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn OpenExistingHeapFromAddress1<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
        size: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).OpenExistingHeapFromAddress1)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            size,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device13,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3,
    ID3D12Device4,
    ID3D12Device5,
    ID3D12Device6,
    ID3D12Device7,
    ID3D12Device8,
    ID3D12Device9,
    ID3D12Device10,
    ID3D12Device11,
    ID3D12Device12
);
impl ::core::cmp::PartialEq for ID3D12Device13 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device13 {}
impl ::core::fmt::Debug for ID3D12Device13 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device13").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device13 {
    type Vtable = ID3D12Device13_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device13 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device13 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x14eecffc_4df8_40f7_a118_5c816f45695e);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device13_Vtbl {
    pub base__: ID3D12Device12_Vtbl,
    pub OpenExistingHeapFromAddress1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        paddress: *const ::core::ffi::c_void,
        size: usize,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Device2(::windows::core::IUnknown);
impl ID3D12Device2 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device2,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1
);
impl ::core::cmp::PartialEq for ID3D12Device2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device2 {}
impl ::core::fmt::Debug for ID3D12Device2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device2 {
    type Vtable = ID3D12Device2_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x30baa41e_b15b_475c_a0bb_1af5c5b64328);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device2_Vtbl {
    pub base__: ID3D12Device1_Vtbl,
    pub CreatePipelineState: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Device3(::windows::core::IUnknown);
impl ID3D12Device3 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self).EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device3,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2
);
impl ::core::cmp::PartialEq for ID3D12Device3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device3 {}
impl ::core::fmt::Debug for ID3D12Device3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device3").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device3 {
    type Vtable = ID3D12Device3_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device3 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x81dadc15_2bad_4392_93c5_101345c4aa98);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device3_Vtbl {
    pub base__: ID3D12Device2_Vtbl,
    pub OpenExistingHeapFromAddress: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        paddress: *const ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub OpenExistingHeapFromFileMapping: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        hfilemapping: ::windows::Win32::Foundation::HANDLE,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub EnqueueMakeResident: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        flags: D3D12_RESIDENCY_FLAGS,
        numobjects: u32,
        ppobjects: *const *mut ::core::ffi::c_void,
        pfencetosignal: *mut ::core::ffi::c_void,
        fencevaluetosignal: u64,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Device4(::windows::core::IUnknown);
impl ID3D12Device4 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device4,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3
);
impl ::core::cmp::PartialEq for ID3D12Device4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device4 {}
impl ::core::fmt::Debug for ID3D12Device4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device4").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device4 {
    type Vtable = ID3D12Device4_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device4 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xe865df17_a9ee_46f9_a463_3098315aa2e5);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device4_Vtbl {
    pub base__: ID3D12Device3_Vtbl,
    pub CreateCommandList1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
        riid: *const ::windows::core::GUID,
        ppcommandlist: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
        riid: *const ::windows::core::GUID,
        ppsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateCommittedResource1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pprotectedsession: *mut ::core::ffi::c_void,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateHeap1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateReservedResource1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pprotectedsession: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub GetResourceAllocationInfo1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_RESOURCE_ALLOCATION_INFO,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: *mut D3D12_RESOURCE_ALLOCATION_INFO1,
    ),
}
#[repr(transparent)]
pub struct ID3D12Device5(::windows::core::IUnknown);
impl ID3D12Device5 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateLifetimeTracker<P0, T>(&self, powner: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeOwner>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateLifetimeTracker)(
            ::windows::core::Interface::as_raw(self),
            powner.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn RemoveDevice(&self) {
        (::windows::core::Interface::vtable(self).RemoveDevice)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: ::core::option::Option<*mut D3D12_META_COMMAND_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).EnumerateMetaCommands)(
            ::windows::core::Interface::as_raw(self),
            pnummetacommands,
            ::core::mem::transmute(pdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: ::core::option::Option<*mut u32>,
        pparametercount: *mut u32,
        pparameterdescs: ::core::option::Option<*mut D3D12_META_COMMAND_PARAMETER_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).EnumerateMetaCommandParameters)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            stage,
            ::core::mem::transmute(ptotalstructuresizeinbytes.unwrap_or(::std::ptr::null_mut())),
            pparametercount,
            ::core::mem::transmute(pparameterdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateMetaCommand<T>(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        creationparametersdatasizeinbytes: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            nodemask,
            ::core::mem::transmute(pcreationparametersdata.unwrap_or(::std::ptr::null())),
            creationparametersdatasizeinbytes,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStateObject<T>(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateStateObject)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ) {
        (::windows::core::Interface::vtable(self).GetRaytracingAccelerationStructurePrebuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pinfo,
        )
    }
    pub unsafe fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
        (::windows::core::Interface::vtable(self).CheckDriverMatchingIdentifier)(
            ::windows::core::Interface::as_raw(self),
            serializeddatatype,
            pidentifiertocheck,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device5,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3,
    ID3D12Device4
);
impl ::core::cmp::PartialEq for ID3D12Device5 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device5 {}
impl ::core::fmt::Debug for ID3D12Device5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device5").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device5 {
    type Vtable = ID3D12Device5_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device5 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device5 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x8b4f173b_2fea_4b80_8f58_4307191ab95d);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device5_Vtbl {
    pub base__: ID3D12Device4_Vtbl,
    pub CreateLifetimeTracker: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        powner: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvtracker: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub RemoveDevice: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub EnumerateMetaCommands: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pnummetacommands: *mut u32,
        pdescs: *mut D3D12_META_COMMAND_DESC,
    ) -> ::windows::core::HRESULT,
    pub EnumerateMetaCommandParameters: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: *mut u32,
        pparametercount: *mut u32,
        pparameterdescs: *mut D3D12_META_COMMAND_PARAMETER_DESC,
    ) -> ::windows::core::HRESULT,
    pub CreateMetaCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: *const ::core::ffi::c_void,
        creationparametersdatasizeinbytes: usize,
        riid: *const ::windows::core::GUID,
        ppmetacommand: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateStateObject: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
        riid: *const ::windows::core::GUID,
        ppstateobject: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub GetRaytracingAccelerationStructurePrebuildInfo: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ),
    pub CheckDriverMatchingIdentifier:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
            serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
            pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
        ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS,
}
#[repr(transparent)]
pub struct ID3D12Device6(::windows::core::IUnknown);
impl ID3D12Device6 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateLifetimeTracker<P0, T>(&self, powner: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeOwner>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateLifetimeTracker)(
            ::windows::core::Interface::as_raw(self),
            powner.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn RemoveDevice(&self) {
        (::windows::core::Interface::vtable(self).base__.RemoveDevice)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: ::core::option::Option<*mut D3D12_META_COMMAND_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .EnumerateMetaCommands)(
            ::windows::core::Interface::as_raw(self),
            pnummetacommands,
            ::core::mem::transmute(pdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: ::core::option::Option<*mut u32>,
        pparametercount: *mut u32,
        pparameterdescs: ::core::option::Option<*mut D3D12_META_COMMAND_PARAMETER_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .EnumerateMetaCommandParameters)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            stage,
            ::core::mem::transmute(ptotalstructuresizeinbytes.unwrap_or(::std::ptr::null_mut())),
            pparametercount,
            ::core::mem::transmute(pparameterdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateMetaCommand<T>(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        creationparametersdatasizeinbytes: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            nodemask,
            ::core::mem::transmute(pcreationparametersdata.unwrap_or(::std::ptr::null())),
            creationparametersdatasizeinbytes,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStateObject<T>(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateStateObject)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetRaytracingAccelerationStructurePrebuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pinfo,
        )
    }
    pub unsafe fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .CheckDriverMatchingIdentifier)(
            ::windows::core::Interface::as_raw(self),
            serializeddatatype,
            pidentifiertocheck,
        )
    }
    pub unsafe fn SetBackgroundProcessingMode<P0>(
        &self,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: P0,
        pbfurthermeasurementsdesired: ::core::option::Option<
            *mut ::windows::Win32::Foundation::BOOL,
        >,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).SetBackgroundProcessingMode)(
            ::windows::core::Interface::as_raw(self),
            mode,
            measurementsaction,
            heventtosignaluponcompletion.into_param().abi(),
            ::core::mem::transmute(pbfurthermeasurementsdesired.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device6,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3,
    ID3D12Device4,
    ID3D12Device5
);
impl ::core::cmp::PartialEq for ID3D12Device6 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device6 {}
impl ::core::fmt::Debug for ID3D12Device6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device6").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device6 {
    type Vtable = ID3D12Device6_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device6 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device6 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xc70b221b_40e4_4a17_89af_025a0727a6dc);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device6_Vtbl {
    pub base__: ID3D12Device5_Vtbl,
    pub SetBackgroundProcessingMode: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: ::windows::Win32::Foundation::HANDLE,
        pbfurthermeasurementsdesired: *mut ::windows::Win32::Foundation::BOOL,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Device7(::windows::core::IUnknown);
impl ID3D12Device7 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateLifetimeTracker<P0, T>(&self, powner: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeOwner>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateLifetimeTracker)(
            ::windows::core::Interface::as_raw(self),
            powner.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn RemoveDevice(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .RemoveDevice)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: ::core::option::Option<*mut D3D12_META_COMMAND_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EnumerateMetaCommands)(
            ::windows::core::Interface::as_raw(self),
            pnummetacommands,
            ::core::mem::transmute(pdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: ::core::option::Option<*mut u32>,
        pparametercount: *mut u32,
        pparameterdescs: ::core::option::Option<*mut D3D12_META_COMMAND_PARAMETER_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EnumerateMetaCommandParameters)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            stage,
            ::core::mem::transmute(ptotalstructuresizeinbytes.unwrap_or(::std::ptr::null_mut())),
            pparametercount,
            ::core::mem::transmute(pparameterdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateMetaCommand<T>(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        creationparametersdatasizeinbytes: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            nodemask,
            ::core::mem::transmute(pcreationparametersdata.unwrap_or(::std::ptr::null())),
            creationparametersdatasizeinbytes,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStateObject<T>(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateStateObject)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetRaytracingAccelerationStructurePrebuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pinfo,
        )
    }
    pub unsafe fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CheckDriverMatchingIdentifier)(
            ::windows::core::Interface::as_raw(self),
            serializeddatatype,
            pidentifiertocheck,
        )
    }
    pub unsafe fn SetBackgroundProcessingMode<P0>(
        &self,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: P0,
        pbfurthermeasurementsdesired: ::core::option::Option<
            *mut ::windows::Win32::Foundation::BOOL,
        >,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetBackgroundProcessingMode)(
            ::windows::core::Interface::as_raw(self),
            mode,
            measurementsaction,
            heventtosignaluponcompletion.into_param().abi(),
            ::core::mem::transmute(pbfurthermeasurementsdesired.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn AddToStateObject<P0, T>(
        &self,
        paddition: *const D3D12_STATE_OBJECT_DESC,
        pstateobjecttogrowfrom: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).AddToStateObject)(
            ::windows::core::Interface::as_raw(self),
            paddition,
            pstateobjecttogrowfrom.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession1<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateProtectedResourceSession1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device7,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3,
    ID3D12Device4,
    ID3D12Device5,
    ID3D12Device6
);
impl ::core::cmp::PartialEq for ID3D12Device7 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device7 {}
impl ::core::fmt::Debug for ID3D12Device7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device7").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device7 {
    type Vtable = ID3D12Device7_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device7 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device7 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x5c014b53_68a1_4b9b_8bd1_dd6046b9358b);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device7_Vtbl {
    pub base__: ID3D12Device6_Vtbl,
    pub AddToStateObject: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        paddition: *const D3D12_STATE_OBJECT_DESC,
        pstateobjecttogrowfrom: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppnewstateobject: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateProtectedResourceSession1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
        riid: *const ::windows::core::GUID,
        ppsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Device8(::windows::core::IUnknown);
impl ID3D12Device8 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateLifetimeTracker<P0, T>(&self, powner: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeOwner>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateLifetimeTracker)(
            ::windows::core::Interface::as_raw(self),
            powner.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn RemoveDevice(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .RemoveDevice)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: ::core::option::Option<*mut D3D12_META_COMMAND_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EnumerateMetaCommands)(
            ::windows::core::Interface::as_raw(self),
            pnummetacommands,
            ::core::mem::transmute(pdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: ::core::option::Option<*mut u32>,
        pparametercount: *mut u32,
        pparameterdescs: ::core::option::Option<*mut D3D12_META_COMMAND_PARAMETER_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EnumerateMetaCommandParameters)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            stage,
            ::core::mem::transmute(ptotalstructuresizeinbytes.unwrap_or(::std::ptr::null_mut())),
            pparametercount,
            ::core::mem::transmute(pparameterdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateMetaCommand<T>(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        creationparametersdatasizeinbytes: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            nodemask,
            ::core::mem::transmute(pcreationparametersdata.unwrap_or(::std::ptr::null())),
            creationparametersdatasizeinbytes,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStateObject<T>(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateStateObject)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetRaytracingAccelerationStructurePrebuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pinfo,
        )
    }
    pub unsafe fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CheckDriverMatchingIdentifier)(
            ::windows::core::Interface::as_raw(self),
            serializeddatatype,
            pidentifiertocheck,
        )
    }
    pub unsafe fn SetBackgroundProcessingMode<P0>(
        &self,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: P0,
        pbfurthermeasurementsdesired: ::core::option::Option<
            *mut ::windows::Win32::Foundation::BOOL,
        >,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetBackgroundProcessingMode)(
            ::windows::core::Interface::as_raw(self),
            mode,
            measurementsaction,
            heventtosignaluponcompletion.into_param().abi(),
            ::core::mem::transmute(pbfurthermeasurementsdesired.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn AddToStateObject<P0, T>(
        &self,
        paddition: *const D3D12_STATE_OBJECT_DESC,
        pstateobjecttogrowfrom: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .AddToStateObject)(
            ::windows::core::Interface::as_raw(self),
            paddition,
            pstateobjecttogrowfrom.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession1<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateProtectedResourceSession1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetResourceAllocationInfo2(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetResourceAllocationInfo2)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateCommittedResource2<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateCommittedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource1<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreatePlacedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSamplerFeedbackUnorderedAccessView<P0, P1>(
        &self,
        ptargetedresource: P0,
        pfeedbackresource: P1,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).CreateSamplerFeedbackUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            ptargetedresource.into_param().abi(),
            pfeedbackresource.into_param().abi(),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn GetCopyableFootprints1(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC1,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self).GetCopyableFootprints1)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device8,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3,
    ID3D12Device4,
    ID3D12Device5,
    ID3D12Device6,
    ID3D12Device7
);
impl ::core::cmp::PartialEq for ID3D12Device8 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device8 {}
impl ::core::fmt::Debug for ID3D12Device8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device8").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device8 {
    type Vtable = ID3D12Device8_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device8 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device8 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x9218e6bb_f944_4f7e_a75c_b1b2c7b701f3);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device8_Vtbl {
    pub base__: ID3D12Device7_Vtbl,
    pub GetResourceAllocationInfo2: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_RESOURCE_ALLOCATION_INFO,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        presourceallocationinfo1: *mut D3D12_RESOURCE_ALLOCATION_INFO1,
    ),
    pub CreateCommittedResource2: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pprotectedsession: *mut ::core::ffi::c_void,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreatePlacedResource1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheap: *mut ::core::ffi::c_void,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateSamplerFeedbackUnorderedAccessView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ptargetedresource: *mut ::core::ffi::c_void,
        pfeedbackresource: *mut ::core::ffi::c_void,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ),
    pub GetCopyableFootprints1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presourcedesc: *const D3D12_RESOURCE_DESC1,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: *mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT,
        pnumrows: *mut u32,
        prowsizeinbytes: *mut u64,
        ptotalbytes: *mut u64,
    ),
}
#[repr(transparent)]
pub struct ID3D12Device9(::windows::core::IUnknown);
impl ID3D12Device9 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateLifetimeTracker<P0, T>(&self, powner: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeOwner>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateLifetimeTracker)(
            ::windows::core::Interface::as_raw(self),
            powner.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn RemoveDevice(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .RemoveDevice)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: ::core::option::Option<*mut D3D12_META_COMMAND_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommands)(
            ::windows::core::Interface::as_raw(self),
            pnummetacommands,
            ::core::mem::transmute(pdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: ::core::option::Option<*mut u32>,
        pparametercount: *mut u32,
        pparameterdescs: ::core::option::Option<*mut D3D12_META_COMMAND_PARAMETER_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommandParameters)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            stage,
            ::core::mem::transmute(ptotalstructuresizeinbytes.unwrap_or(::std::ptr::null_mut())),
            pparametercount,
            ::core::mem::transmute(pparameterdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateMetaCommand<T>(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        creationparametersdatasizeinbytes: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            nodemask,
            ::core::mem::transmute(pcreationparametersdata.unwrap_or(::std::ptr::null())),
            creationparametersdatasizeinbytes,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStateObject<T>(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateStateObject)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetRaytracingAccelerationStructurePrebuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pinfo,
        )
    }
    pub unsafe fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CheckDriverMatchingIdentifier)(
            ::windows::core::Interface::as_raw(self),
            serializeddatatype,
            pidentifiertocheck,
        )
    }
    pub unsafe fn SetBackgroundProcessingMode<P0>(
        &self,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: P0,
        pbfurthermeasurementsdesired: ::core::option::Option<
            *mut ::windows::Win32::Foundation::BOOL,
        >,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetBackgroundProcessingMode)(
            ::windows::core::Interface::as_raw(self),
            mode,
            measurementsaction,
            heventtosignaluponcompletion.into_param().abi(),
            ::core::mem::transmute(pbfurthermeasurementsdesired.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn AddToStateObject<P0, T>(
        &self,
        paddition: *const D3D12_STATE_OBJECT_DESC,
        pstateobjecttogrowfrom: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .AddToStateObject)(
            ::windows::core::Interface::as_raw(self),
            paddition,
            pstateobjecttogrowfrom.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession1<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateProtectedResourceSession1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetResourceAllocationInfo2(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetResourceAllocationInfo2)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateCommittedResource2<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateCommittedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource1<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreatePlacedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSamplerFeedbackUnorderedAccessView<P0, P1>(
        &self,
        ptargetedresource: P0,
        pfeedbackresource: P1,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateSamplerFeedbackUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            ptargetedresource.into_param().abi(),
            pfeedbackresource.into_param().abi(),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn GetCopyableFootprints1(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC1,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetCopyableFootprints1)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateShaderCacheSession<T>(
        &self,
        pdesc: *const D3D12_SHADER_CACHE_SESSION_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateShaderCacheSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn ShaderCacheControl(
        &self,
        kinds: D3D12_SHADER_CACHE_KIND_FLAGS,
        control: D3D12_SHADER_CACHE_CONTROL_FLAGS,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ShaderCacheControl)(
            ::windows::core::Interface::as_raw(self),
            kinds,
            control,
        )
        .ok()
    }
    pub unsafe fn CreateCommandQueue1<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
        creatorid: *const ::windows::core::GUID,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateCommandQueue1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            creatorid,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Device9,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3,
    ID3D12Device4,
    ID3D12Device5,
    ID3D12Device6,
    ID3D12Device7,
    ID3D12Device8
);
impl ::core::cmp::PartialEq for ID3D12Device9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Device9 {}
impl ::core::fmt::Debug for ID3D12Device9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Device9").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Device9 {
    type Vtable = ID3D12Device9_Vtbl;
}
impl ::core::clone::Clone for ID3D12Device9 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Device9 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x4c80e962_f032_4f60_bc9e_ebc2cfa1d83c);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Device9_Vtbl {
    pub base__: ID3D12Device8_Vtbl,
    pub CreateShaderCacheSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_SHADER_CACHE_SESSION_DESC,
        riid: *const ::windows::core::GUID,
        ppvsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub ShaderCacheControl: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        kinds: D3D12_SHADER_CACHE_KIND_FLAGS,
        control: D3D12_SHADER_CACHE_CONTROL_FLAGS,
    ) -> ::windows::core::HRESULT,
    pub CreateCommandQueue1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
        creatorid: *const ::windows::core::GUID,
        riid: *const ::windows::core::GUID,
        ppcommandqueue: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DeviceChild(::windows::core::IUnknown);
impl ID3D12DeviceChild {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12DeviceChild, ::windows::core::IUnknown, ID3D12Object);
impl ::core::cmp::PartialEq for ID3D12DeviceChild {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceChild {}
impl ::core::fmt::Debug for ID3D12DeviceChild {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceChild").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceChild {
    type Vtable = ID3D12DeviceChild_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceChild {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceChild {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x905db94b_a00c_4140_9df5_2b64ca9ea357);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceChild_Vtbl {
    pub base__: ID3D12Object_Vtbl,
    pub GetDevice: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvdevice: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DeviceConfiguration(::windows::core::IUnknown);
impl ID3D12DeviceConfiguration {
    pub unsafe fn GetDesc(&self) -> D3D12_DEVICE_CONFIGURATION_DESC {
        let mut result__: D3D12_DEVICE_CONFIGURATION_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetEnabledExperimentalFeatures(
        &self,
        pguids: &mut [::windows::core::GUID],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetEnabledExperimentalFeatures)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pguids.as_ptr()),
            pguids.len() as _,
        )
        .ok()
    }
    pub unsafe fn SerializeVersionedRootSignature(
        &self,
        pdesc: *const D3D12_VERSIONED_ROOT_SIGNATURE_DESC,
        ppresult: *mut ::core::option::Option<ID3DBlob>,
        pperror: ::core::option::Option<*mut ::core::option::Option<ID3DBlob>>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SerializeVersionedRootSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(ppresult),
            ::core::mem::transmute(pperror.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateVersionedRootSignatureDeserializer<T>(
        &self,
        pblob: *const ::core::ffi::c_void,
        size: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVersionedRootSignatureDeserializer)(
            ::windows::core::Interface::as_raw(self),
            pblob,
            size,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(ID3D12DeviceConfiguration, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12DeviceConfiguration {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceConfiguration {}
impl ::core::fmt::Debug for ID3D12DeviceConfiguration {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceConfiguration")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceConfiguration {
    type Vtable = ID3D12DeviceConfiguration_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceConfiguration {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceConfiguration {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x78dbf87b_f766_422b_a61c_c8c446bdb9ad);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceConfiguration_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_DEVICE_CONFIGURATION_DESC,
    ),
    pub GetEnabledExperimentalFeatures: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pguids: *mut ::windows::core::GUID,
        numguids: u32,
    ) -> ::windows::core::HRESULT,
    pub SerializeVersionedRootSignature: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_VERSIONED_ROOT_SIGNATURE_DESC,
        ppresult: *mut *mut ::core::ffi::c_void,
        pperror: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateVersionedRootSignatureDeserializer:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
            pblob: *const ::core::ffi::c_void,
            size: usize,
            riid: *const ::windows::core::GUID,
            ppvdeserializer: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DeviceConfiguration1(::windows::core::IUnknown);
impl ID3D12DeviceConfiguration1 {
    pub unsafe fn GetDesc(&self) -> D3D12_DEVICE_CONFIGURATION_DESC {
        let mut result__: D3D12_DEVICE_CONFIGURATION_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).base__.GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetEnabledExperimentalFeatures(
        &self,
        pguids: &mut [::windows::core::GUID],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetEnabledExperimentalFeatures)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pguids.as_ptr()),
            pguids.len() as _,
        )
        .ok()
    }
    pub unsafe fn SerializeVersionedRootSignature(
        &self,
        pdesc: *const D3D12_VERSIONED_ROOT_SIGNATURE_DESC,
        ppresult: *mut ::core::option::Option<ID3DBlob>,
        pperror: ::core::option::Option<*mut ::core::option::Option<ID3DBlob>>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .SerializeVersionedRootSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(ppresult),
            ::core::mem::transmute(pperror.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateVersionedRootSignatureDeserializer<T>(
        &self,
        pblob: *const ::core::ffi::c_void,
        size: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateVersionedRootSignatureDeserializer)(
            ::windows::core::Interface::as_raw(self),
            pblob,
            size,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary<P0, T>(
        &self,
        plibraryblob: *const ::core::ffi::c_void,
        size: usize,
        rootsignaturesubobjectname: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary)(
            ::windows::core::Interface::as_raw(self),
            plibraryblob,
            size,
            rootsignaturesubobjectname.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DeviceConfiguration1,
    ::windows::core::IUnknown,
    ID3D12DeviceConfiguration
);
impl ::core::cmp::PartialEq for ID3D12DeviceConfiguration1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceConfiguration1 {}
impl ::core::fmt::Debug for ID3D12DeviceConfiguration1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceConfiguration1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceConfiguration1 {
    type Vtable = ID3D12DeviceConfiguration1_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceConfiguration1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceConfiguration1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xed342442_6343_4e16_bb82_a3a577874e56);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceConfiguration1_Vtbl {
    pub base__: ID3D12DeviceConfiguration_Vtbl,
    pub CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
            plibraryblob: *const ::core::ffi::c_void,
            size: usize,
            rootsignaturesubobjectname: ::windows::core::PCWSTR,
            riid: *const ::windows::core::GUID,
            ppvdeserializer: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DeviceExperimental(::windows::core::IUnknown);
impl ID3D12DeviceExperimental {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetNodeCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetNodeCount)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn CreateCommandQueue<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandAllocator<T>(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandAllocator)(
            ::windows::core::Interface::as_raw(self),
            r#type,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateGraphicsPipelineState<T>(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateGraphicsPipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateComputePipelineState<T>(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateComputePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommandList<P0, P1, T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            pcommandallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            feature,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateDescriptorHeap<T>(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDescriptorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdescriptorheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDescriptorHandleIncrementSize)(
            ::windows::core::Interface::as_raw(self),
            descriptorheaptype,
        )
    }
    pub unsafe fn CreateRootSignature<T>(
        &self,
        nodemask: u32,
        pblobwithrootsignature: &[u8],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRootSignature)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(pblobwithrootsignature.as_ptr()),
            pblobwithrootsignature.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateConstantBufferView(
        &self,
        pdesc: ::core::option::Option<*const D3D12_CONSTANT_BUFFER_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateShaderResourceView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_SHADER_RESOURCE_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateUnorderedAccessView<P0, P1>(
        &self,
        presource: P0,
        pcounterresource: P1,
        pdesc: ::core::option::Option<*const D3D12_UNORDERED_ACCESS_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            pcounterresource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateRenderTargetView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_RENDER_TARGET_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateDepthStencilView<P0>(
        &self,
        presource: P0,
        pdesc: ::core::option::Option<*const D3D12_DEPTH_STENCIL_VIEW_DESC>,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pdesc.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSampler)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: ::core::option::Option<*const u32>,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: ::core::option::Option<*const u32>,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptors)(
            ::windows::core::Interface::as_raw(self),
            numdestdescriptorranges,
            pdestdescriptorrangestarts,
            ::core::mem::transmute(pdestdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            numsrcdescriptorranges,
            psrcdescriptorrangestarts,
            ::core::mem::transmute(psrcdescriptorrangesizes.unwrap_or(::std::ptr::null())),
            descriptorheapstype,
        )
    }
    pub unsafe fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyDescriptorsSimple)(
            ::windows::core::Interface::as_raw(self),
            numdescriptors,
            ::core::mem::transmute(destdescriptorrangestart),
            ::core::mem::transmute(srcdescriptorrangestart),
            descriptorheapstype,
        )
    }
    pub unsafe fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        presourcedescs: &[D3D12_RESOURCE_DESC],
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            presourcedescs.len() as _,
            ::core::mem::transmute(presourcedescs.as_ptr()),
        );
        result__
    }
    pub unsafe fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES {
        let mut result__: D3D12_HEAP_PROPERTIES = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCustomHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            nodemask,
            heaptype,
        );
        result__
    }
    pub unsafe fn CreateCommittedResource<T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap<T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource<T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSharedHandle<P0, P1>(
        &self,
        pobject: P0,
        pattributes: ::core::option::Option<*const ::windows::Win32::Security::SECURITY_ATTRIBUTES>,
        access: u32,
        name: P1,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
        P1: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            ::core::mem::transmute(pattributes.unwrap_or(::std::ptr::null())),
            access,
            name.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenSharedHandle<P0, T>(
        &self,
        nthandle: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandle)(
            ::windows::core::Interface::as_raw(self),
            nthandle.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn OpenSharedHandleByName<P0>(
        &self,
        name: P0,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenSharedHandleByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            access,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn MakeResident(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .MakeResident)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn Evict(
        &self,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Evict)(
            ::windows::core::Interface::as_raw(self),
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn CreateFence<T>(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateFence)(
            ::windows::core::Interface::as_raw(self),
            initialvalue,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDeviceRemovedReason)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateQueryHeap<T>(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateQueryHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn SetStablePowerState<P0>(&self, enable: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetStablePowerState)(
            ::windows::core::Interface::as_raw(self),
            enable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateCommandSignature<P0, T>(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandSignature)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            prootsignature.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceTiling<P0>(
        &self,
        ptiledresource: P0,
        pnumtilesforentireresource: ::core::option::Option<*mut u32>,
        ppackedmipdesc: ::core::option::Option<*mut D3D12_PACKED_MIP_INFO>,
        pstandardtileshapefornonpackedmips: ::core::option::Option<*mut D3D12_TILE_SHAPE>,
        pnumsubresourcetilings: ::core::option::Option<*mut u32>,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceTiling)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ::core::mem::transmute(pnumtilesforentireresource.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ppackedmipdesc.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(
                pstandardtileshapefornonpackedmips.unwrap_or(::std::ptr::null_mut()),
            ),
            ::core::mem::transmute(pnumsubresourcetilings.unwrap_or(::std::ptr::null_mut())),
            firstsubresourcetilingtoget,
            psubresourcetilingsfornonpackedmips,
        )
    }
    pub unsafe fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetAdapterLuid)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn CreatePipelineLibrary<T>(&self, plibraryblob: &[u8]) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineLibrary)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn SetEventOnMultipleFenceCompletion<P0>(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetEventOnMultipleFenceCompletion)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(ppfences),
            pfencevalues,
            numfences,
            flags,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetResidencyPriority)(
            ::windows::core::Interface::as_raw(self),
            numobjects,
            ::core::mem::transmute(ppobjects),
            ppriorities,
        )
        .ok()
    }
    pub unsafe fn CreatePipelineState<T>(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePipelineState)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromAddress<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromAddress)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn OpenExistingHeapFromFileMapping<P0, T>(
        &self,
        hfilemapping: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OpenExistingHeapFromFileMapping)(
            ::windows::core::Interface::as_raw(self),
            hfilemapping.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnqueueMakeResident<P0>(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        ppobjects: &[::core::option::Option<ID3D12Pageable>],
        pfencetosignal: P0,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnqueueMakeResident)(
            ::windows::core::Interface::as_raw(self),
            flags,
            ppobjects.len() as _,
            ::core::mem::transmute(ppobjects.as_ptr()),
            pfencetosignal.into_param().abi(),
            fencevaluetosignal,
        )
        .ok()
    }
    pub unsafe fn CreateCommandList1<T>(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandList1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            r#type,
            flags,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource1<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateHeap1<P0, T>(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateHeap1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource1<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateLifetimeTracker<P0, T>(&self, powner: P0) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12LifetimeOwner>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateLifetimeTracker)(
            ::windows::core::Interface::as_raw(self),
            powner.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn RemoveDevice(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RemoveDevice)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: ::core::option::Option<*mut D3D12_META_COMMAND_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommands)(
            ::windows::core::Interface::as_raw(self),
            pnummetacommands,
            ::core::mem::transmute(pdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: ::core::option::Option<*mut u32>,
        pparametercount: *mut u32,
        pparameterdescs: ::core::option::Option<*mut D3D12_META_COMMAND_PARAMETER_DESC>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EnumerateMetaCommandParameters)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            stage,
            ::core::mem::transmute(ptotalstructuresizeinbytes.unwrap_or(::std::ptr::null_mut())),
            pparametercount,
            ::core::mem::transmute(pparameterdescs.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn CreateMetaCommand<T>(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        creationparametersdatasizeinbytes: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            commandid,
            nodemask,
            ::core::mem::transmute(pcreationparametersdata.unwrap_or(::std::ptr::null())),
            creationparametersdatasizeinbytes,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateStateObject<T>(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateStateObject)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetRaytracingAccelerationStructurePrebuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pinfo,
        )
    }
    pub unsafe fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CheckDriverMatchingIdentifier)(
            ::windows::core::Interface::as_raw(self),
            serializeddatatype,
            pidentifiertocheck,
        )
    }
    pub unsafe fn SetBackgroundProcessingMode<P0>(
        &self,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: P0,
        pbfurthermeasurementsdesired: ::core::option::Option<
            *mut ::windows::Win32::Foundation::BOOL,
        >,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetBackgroundProcessingMode)(
            ::windows::core::Interface::as_raw(self),
            mode,
            measurementsaction,
            heventtosignaluponcompletion.into_param().abi(),
            ::core::mem::transmute(pbfurthermeasurementsdesired.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn AddToStateObject<P0, T>(
        &self,
        paddition: *const D3D12_STATE_OBJECT_DESC,
        pstateobjecttogrowfrom: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .AddToStateObject)(
            ::windows::core::Interface::as_raw(self),
            paddition,
            pstateobjecttogrowfrom.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateProtectedResourceSession1<T>(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateProtectedResourceSession1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetResourceAllocationInfo2(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetResourceAllocationInfo2)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn CreateCommittedResource2<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initialresourcestate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource1<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource1)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initialstate,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSamplerFeedbackUnorderedAccessView<P0, P1>(
        &self,
        ptargetedresource: P0,
        pfeedbackresource: P1,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateSamplerFeedbackUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            ptargetedresource.into_param().abi(),
            pfeedbackresource.into_param().abi(),
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn GetCopyableFootprints1(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC1,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: ::core::option::Option<*mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT>,
        pnumrows: ::core::option::Option<*mut u32>,
        prowsizeinbytes: ::core::option::Option<*mut u64>,
        ptotalbytes: ::core::option::Option<*mut u64>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetCopyableFootprints1)(
            ::windows::core::Interface::as_raw(self),
            presourcedesc,
            firstsubresource,
            numsubresources,
            baseoffset,
            ::core::mem::transmute(playouts.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pnumrows.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(prowsizeinbytes.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(ptotalbytes.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn CreateShaderCacheSession<T>(
        &self,
        pdesc: *const D3D12_SHADER_CACHE_SESSION_DESC,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateShaderCacheSession)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn ShaderCacheControl(
        &self,
        kinds: D3D12_SHADER_CACHE_KIND_FLAGS,
        control: D3D12_SHADER_CACHE_CONTROL_FLAGS,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ShaderCacheControl)(::windows::core::Interface::as_raw(self), kinds, control)
        .ok()
    }
    pub unsafe fn CreateCommandQueue1<T>(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
        creatorid: *const ::windows::core::GUID,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CreateCommandQueue1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            creatorid,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateCommittedResource3<P0, T>(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateCommittedResource3)(
            ::windows::core::Interface::as_raw(self),
            pheapproperties,
            heapflags,
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreatePlacedResource2<P0, T>(
        &self,
        pheap: P0,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12Heap>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreatePlacedResource2)(
            ::windows::core::Interface::as_raw(self),
            pheap.into_param().abi(),
            heapoffset,
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateReservedResource2<P0, T>(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: ::core::option::Option<*const D3D12_CLEAR_VALUE>,
        pprotectedsession: P0,
        pcastableformats: ::core::option::Option<&[DXGI_FORMAT]>,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CreateReservedResource2)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            initiallayout,
            ::core::mem::transmute(poptimizedclearvalue.unwrap_or(::std::ptr::null())),
            pprotectedsession.into_param().abi(),
            pcastableformats
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pcastableformats
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn CreateSampler2(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC2,
        destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateSampler2)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ::core::mem::transmute(destdescriptor),
        )
    }
    pub unsafe fn GetResourceAllocationInfo3(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        pnumcastableformats: ::core::option::Option<*const u32>,
        ppcastableformats: ::core::option::Option<*const *const DXGI_FORMAT>,
        presourceallocationinfo1: ::core::option::Option<*mut D3D12_RESOURCE_ALLOCATION_INFO1>,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO {
        let mut result__: D3D12_RESOURCE_ALLOCATION_INFO = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetResourceAllocationInfo3)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            visiblemask,
            numresourcedescs,
            presourcedescs,
            ::core::mem::transmute(pnumcastableformats.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(ppcastableformats.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(presourceallocationinfo1.unwrap_or(::std::ptr::null_mut())),
        );
        result__
    }
    pub unsafe fn OpenExistingHeapFromAddress1<T>(
        &self,
        paddress: *const ::core::ffi::c_void,
        size: usize,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .OpenExistingHeapFromAddress1)(
            ::windows::core::Interface::as_raw(self),
            paddress,
            size,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateRootSignatureFromSubobjectInLibrary<P0, T>(
        &self,
        nodemask: u32,
        plibraryblob: &[u8],
        subobjectname: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateRootSignatureFromSubobjectInLibrary)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            ::core::mem::transmute(plibraryblob.as_ptr()),
            plibraryblob.len() as _,
            subobjectname.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DeviceExperimental,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12Device,
    ID3D12Device1,
    ID3D12Device2,
    ID3D12Device3,
    ID3D12Device4,
    ID3D12Device5,
    ID3D12Device6,
    ID3D12Device7,
    ID3D12Device8,
    ID3D12Device9,
    ID3D12Device10,
    ID3D12Device11,
    ID3D12Device12,
    ID3D12Device13
);
impl ::core::cmp::PartialEq for ID3D12DeviceExperimental {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceExperimental {}
impl ::core::fmt::Debug for ID3D12DeviceExperimental {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceExperimental")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceExperimental {
    type Vtable = ID3D12DeviceExperimental_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceExperimental {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceExperimental {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x5f6e592d_d895_44c2_8e4a_88ad4926d323);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceExperimental_Vtbl {
    pub base__: ID3D12Device13_Vtbl,
    pub CreateRootSignatureFromSubobjectInLibrary:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
            nodemask: u32,
            plibraryblob: *const ::core::ffi::c_void,
            bloblengthinbytes: usize,
            subobjectname: ::windows::core::PCWSTR,
            riid: *const ::windows::core::GUID,
            ppvrootsignature: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DeviceFactory(::windows::core::IUnknown);
impl ID3D12DeviceFactory {
    pub unsafe fn InitializeFromGlobalState(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).InitializeFromGlobalState)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn ApplyToGlobalState(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ApplyToGlobalState)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn SetFlags(
        &self,
        flags: D3D12_DEVICE_FACTORY_FLAGS,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetFlags)(
            ::windows::core::Interface::as_raw(self),
            flags,
        )
        .ok()
    }
    pub unsafe fn GetFlags(&self) -> D3D12_DEVICE_FACTORY_FLAGS {
        (::windows::core::Interface::vtable(self).GetFlags)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetConfigurationInterface<T>(
        &self,
        clsid: *const ::windows::core::GUID,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).GetConfigurationInterface)(
            ::windows::core::Interface::as_raw(self),
            clsid,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn EnableExperimentalFeatures(
        &self,
        numfeatures: u32,
        piids: *const ::windows::core::GUID,
        pconfigurationstructs: ::core::option::Option<*const ::core::ffi::c_void>,
        pconfigurationstructsizes: ::core::option::Option<*const u32>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).EnableExperimentalFeatures)(
            ::windows::core::Interface::as_raw(self),
            numfeatures,
            piids,
            ::core::mem::transmute(pconfigurationstructs.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(pconfigurationstructsizes.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn CreateDevice<P0, T>(
        &self,
        adapter: P0,
        featurelevel: D3D_FEATURE_LEVEL,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).CreateDevice)(
            ::windows::core::Interface::as_raw(self),
            adapter.into_param().abi(),
            featurelevel,
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12DeviceFactory, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12DeviceFactory {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceFactory {}
impl ::core::fmt::Debug for ID3D12DeviceFactory {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceFactory").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceFactory {
    type Vtable = ID3D12DeviceFactory_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceFactory {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceFactory {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x61f307d3_d34e_4e7c_8374_3ba4de23cccb);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceFactory_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub InitializeFromGlobalState:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub ApplyToGlobalState:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub SetFlags: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        flags: D3D12_DEVICE_FACTORY_FLAGS,
    ) -> ::windows::core::HRESULT,
    pub GetFlags:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_DEVICE_FACTORY_FLAGS,
    pub GetConfigurationInterface: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        clsid: *const ::windows::core::GUID,
        iid: *const ::windows::core::GUID,
        ppv: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub EnableExperimentalFeatures: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numfeatures: u32,
        piids: *const ::windows::core::GUID,
        pconfigurationstructs: *const ::core::ffi::c_void,
        pconfigurationstructsizes: *const u32,
    ) -> ::windows::core::HRESULT,
    pub CreateDevice: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        adapter: *mut ::core::ffi::c_void,
        featurelevel: D3D_FEATURE_LEVEL,
        riid: *const ::windows::core::GUID,
        ppvdevice: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DeviceRemovedExtendedData(::windows::core::IUnknown);
impl ID3D12DeviceRemovedExtendedData {
    pub unsafe fn GetAutoBreadcrumbsOutput(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT> {
        let mut result__ = ::windows::core::zeroed::<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT>();
        (::windows::core::Interface::vtable(self).GetAutoBreadcrumbsOutput)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetPageFaultAllocationOutput(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_PAGE_FAULT_OUTPUT> {
        let mut result__ = ::windows::core::zeroed::<D3D12_DRED_PAGE_FAULT_OUTPUT>();
        (::windows::core::Interface::vtable(self).GetPageFaultAllocationOutput)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(ID3D12DeviceRemovedExtendedData, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12DeviceRemovedExtendedData {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceRemovedExtendedData {}
impl ::core::fmt::Debug for ID3D12DeviceRemovedExtendedData {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceRemovedExtendedData")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceRemovedExtendedData {
    type Vtable = ID3D12DeviceRemovedExtendedData_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceRemovedExtendedData {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceRemovedExtendedData {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x98931d33_5ae8_4791_aa3c_1a73a2934e71);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceRemovedExtendedData_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetAutoBreadcrumbsOutput: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        poutput: *mut D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT,
    ) -> ::windows::core::HRESULT,
    pub GetPageFaultAllocationOutput: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        poutput: *mut D3D12_DRED_PAGE_FAULT_OUTPUT,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DeviceRemovedExtendedData1(::windows::core::IUnknown);
impl ID3D12DeviceRemovedExtendedData1 {
    pub unsafe fn GetAutoBreadcrumbsOutput(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT> {
        let mut result__ = ::windows::core::zeroed::<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT>();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetAutoBreadcrumbsOutput)(
            ::windows::core::Interface::as_raw(self), &mut result__
        )
        .from_abi(result__)
    }
    pub unsafe fn GetPageFaultAllocationOutput(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_PAGE_FAULT_OUTPUT> {
        let mut result__ = ::windows::core::zeroed::<D3D12_DRED_PAGE_FAULT_OUTPUT>();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetPageFaultAllocationOutput)(
            ::windows::core::Interface::as_raw(self), &mut result__
        )
        .from_abi(result__)
    }
    pub unsafe fn GetAutoBreadcrumbsOutput1(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1> {
        let mut result__ = ::windows::core::zeroed::<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1>();
        (::windows::core::Interface::vtable(self).GetAutoBreadcrumbsOutput1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetPageFaultAllocationOutput1(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_PAGE_FAULT_OUTPUT1> {
        let mut result__ = ::windows::core::zeroed::<D3D12_DRED_PAGE_FAULT_OUTPUT1>();
        (::windows::core::Interface::vtable(self).GetPageFaultAllocationOutput1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DeviceRemovedExtendedData1,
    ::windows::core::IUnknown,
    ID3D12DeviceRemovedExtendedData
);
impl ::core::cmp::PartialEq for ID3D12DeviceRemovedExtendedData1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceRemovedExtendedData1 {}
impl ::core::fmt::Debug for ID3D12DeviceRemovedExtendedData1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceRemovedExtendedData1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceRemovedExtendedData1 {
    type Vtable = ID3D12DeviceRemovedExtendedData1_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceRemovedExtendedData1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceRemovedExtendedData1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x9727a022_cf1d_4dda_9eba_effa653fc506);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceRemovedExtendedData1_Vtbl {
    pub base__: ID3D12DeviceRemovedExtendedData_Vtbl,
    pub GetAutoBreadcrumbsOutput1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        poutput: *mut D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1,
    ) -> ::windows::core::HRESULT,
    pub GetPageFaultAllocationOutput1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        poutput: *mut D3D12_DRED_PAGE_FAULT_OUTPUT1,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12DeviceRemovedExtendedData2(::windows::core::IUnknown);
impl ID3D12DeviceRemovedExtendedData2 {
    pub unsafe fn GetAutoBreadcrumbsOutput(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT> {
        let mut result__ = ::windows::core::zeroed::<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetAutoBreadcrumbsOutput)(
            ::windows::core::Interface::as_raw(self), &mut result__
        )
        .from_abi(result__)
    }
    pub unsafe fn GetPageFaultAllocationOutput(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_PAGE_FAULT_OUTPUT> {
        let mut result__ = ::windows::core::zeroed::<D3D12_DRED_PAGE_FAULT_OUTPUT>();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetPageFaultAllocationOutput)(
            ::windows::core::Interface::as_raw(self), &mut result__
        )
        .from_abi(result__)
    }
    pub unsafe fn GetAutoBreadcrumbsOutput1(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1> {
        let mut result__ = ::windows::core::zeroed::<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1>();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetAutoBreadcrumbsOutput1)(
            ::windows::core::Interface::as_raw(self), &mut result__
        )
        .from_abi(result__)
    }
    pub unsafe fn GetPageFaultAllocationOutput1(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_PAGE_FAULT_OUTPUT1> {
        let mut result__ = ::windows::core::zeroed::<D3D12_DRED_PAGE_FAULT_OUTPUT1>();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetPageFaultAllocationOutput1)(
            ::windows::core::Interface::as_raw(self), &mut result__
        )
        .from_abi(result__)
    }
    pub unsafe fn GetPageFaultAllocationOutput2(
        &self,
        poutput: *mut D3D12_DRED_PAGE_FAULT_OUTPUT2,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetPageFaultAllocationOutput2)(
            ::windows::core::Interface::as_raw(self),
            poutput,
        )
        .ok()
    }
    pub unsafe fn GetDeviceState(&self) -> D3D12_DRED_DEVICE_STATE {
        (::windows::core::Interface::vtable(self).GetDeviceState)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DeviceRemovedExtendedData2,
    ::windows::core::IUnknown,
    ID3D12DeviceRemovedExtendedData,
    ID3D12DeviceRemovedExtendedData1
);
impl ::core::cmp::PartialEq for ID3D12DeviceRemovedExtendedData2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceRemovedExtendedData2 {}
impl ::core::fmt::Debug for ID3D12DeviceRemovedExtendedData2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceRemovedExtendedData2")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceRemovedExtendedData2 {
    type Vtable = ID3D12DeviceRemovedExtendedData2_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceRemovedExtendedData2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceRemovedExtendedData2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x67fc5816_e4ca_4915_bf18_42541272da54);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceRemovedExtendedData2_Vtbl {
    pub base__: ID3D12DeviceRemovedExtendedData1_Vtbl,
    pub GetPageFaultAllocationOutput2: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        poutput: *mut D3D12_DRED_PAGE_FAULT_OUTPUT2,
    ) -> ::windows::core::HRESULT,
    pub GetDeviceState:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_DRED_DEVICE_STATE,
}
#[repr(transparent)]
pub struct ID3D12DeviceRemovedExtendedDataSettings(::windows::core::IUnknown);
impl ID3D12DeviceRemovedExtendedDataSettings {
    pub unsafe fn SetAutoBreadcrumbsEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self).SetAutoBreadcrumbsEnablement)(
            ::windows::core::Interface::as_raw(self),
            enablement,
        )
    }
    pub unsafe fn SetPageFaultEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self).SetPageFaultEnablement)(
            ::windows::core::Interface::as_raw(self),
            enablement,
        )
    }
    pub unsafe fn SetWatsonDumpEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self).SetWatsonDumpEnablement)(
            ::windows::core::Interface::as_raw(self),
            enablement,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DeviceRemovedExtendedDataSettings,
    ::windows::core::IUnknown
);
impl ::core::cmp::PartialEq for ID3D12DeviceRemovedExtendedDataSettings {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceRemovedExtendedDataSettings {}
impl ::core::fmt::Debug for ID3D12DeviceRemovedExtendedDataSettings {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceRemovedExtendedDataSettings")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceRemovedExtendedDataSettings {
    type Vtable = ID3D12DeviceRemovedExtendedDataSettings_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceRemovedExtendedDataSettings {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceRemovedExtendedDataSettings {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x82bc481c_6b9b_4030_aedb_7ee3d1df1e63);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceRemovedExtendedDataSettings_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetAutoBreadcrumbsEnablement: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enablement: D3D12_DRED_ENABLEMENT,
    ),
    pub SetPageFaultEnablement: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enablement: D3D12_DRED_ENABLEMENT,
    ),
    pub SetWatsonDumpEnablement: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enablement: D3D12_DRED_ENABLEMENT,
    ),
}
#[repr(transparent)]
pub struct ID3D12DeviceRemovedExtendedDataSettings1(::windows::core::IUnknown);
impl ID3D12DeviceRemovedExtendedDataSettings1 {
    pub unsafe fn SetAutoBreadcrumbsEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetAutoBreadcrumbsEnablement)(
            ::windows::core::Interface::as_raw(self), enablement
        )
    }
    pub unsafe fn SetPageFaultEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPageFaultEnablement)(::windows::core::Interface::as_raw(self), enablement)
    }
    pub unsafe fn SetWatsonDumpEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetWatsonDumpEnablement)(::windows::core::Interface::as_raw(self), enablement)
    }
    pub unsafe fn SetBreadcrumbContextEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self).SetBreadcrumbContextEnablement)(
            ::windows::core::Interface::as_raw(self),
            enablement,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DeviceRemovedExtendedDataSettings1,
    ::windows::core::IUnknown,
    ID3D12DeviceRemovedExtendedDataSettings
);
impl ::core::cmp::PartialEq for ID3D12DeviceRemovedExtendedDataSettings1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceRemovedExtendedDataSettings1 {}
impl ::core::fmt::Debug for ID3D12DeviceRemovedExtendedDataSettings1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceRemovedExtendedDataSettings1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceRemovedExtendedDataSettings1 {
    type Vtable = ID3D12DeviceRemovedExtendedDataSettings1_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceRemovedExtendedDataSettings1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceRemovedExtendedDataSettings1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xdbd5ae51_3317_4f0a_adf9_1d7cedcaae0b);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceRemovedExtendedDataSettings1_Vtbl {
    pub base__: ID3D12DeviceRemovedExtendedDataSettings_Vtbl,
    pub SetBreadcrumbContextEnablement: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        enablement: D3D12_DRED_ENABLEMENT,
    ),
}
#[repr(transparent)]
pub struct ID3D12DeviceRemovedExtendedDataSettings2(::windows::core::IUnknown);
impl ID3D12DeviceRemovedExtendedDataSettings2 {
    pub unsafe fn SetAutoBreadcrumbsEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetAutoBreadcrumbsEnablement)(
            ::windows::core::Interface::as_raw(self), enablement
        )
    }
    pub unsafe fn SetPageFaultEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPageFaultEnablement)(::windows::core::Interface::as_raw(self), enablement)
    }
    pub unsafe fn SetWatsonDumpEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetWatsonDumpEnablement)(::windows::core::Interface::as_raw(self), enablement)
    }
    pub unsafe fn SetBreadcrumbContextEnablement(&self, enablement: D3D12_DRED_ENABLEMENT) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetBreadcrumbContextEnablement)(
            ::windows::core::Interface::as_raw(self), enablement
        )
    }
    pub unsafe fn UseMarkersOnlyAutoBreadcrumbs<P0>(&self, markersonly: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).UseMarkersOnlyAutoBreadcrumbs)(
            ::windows::core::Interface::as_raw(self),
            markersonly.into_param().abi(),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12DeviceRemovedExtendedDataSettings2,
    ::windows::core::IUnknown,
    ID3D12DeviceRemovedExtendedDataSettings,
    ID3D12DeviceRemovedExtendedDataSettings1
);
impl ::core::cmp::PartialEq for ID3D12DeviceRemovedExtendedDataSettings2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12DeviceRemovedExtendedDataSettings2 {}
impl ::core::fmt::Debug for ID3D12DeviceRemovedExtendedDataSettings2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12DeviceRemovedExtendedDataSettings2")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12DeviceRemovedExtendedDataSettings2 {
    type Vtable = ID3D12DeviceRemovedExtendedDataSettings2_Vtbl;
}
impl ::core::clone::Clone for ID3D12DeviceRemovedExtendedDataSettings2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12DeviceRemovedExtendedDataSettings2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x61552388_01ab_4008_a436_83db189566ea);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12DeviceRemovedExtendedDataSettings2_Vtbl {
    pub base__: ID3D12DeviceRemovedExtendedDataSettings1_Vtbl,
    pub UseMarkersOnlyAutoBreadcrumbs: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        markersonly: ::windows::Win32::Foundation::BOOL,
    ),
}
#[repr(transparent)]
pub struct ID3D12Fence(::windows::core::IUnknown);
impl ID3D12Fence {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetCompletedValue(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetCompletedValue)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn SetEventOnCompletion<P0>(
        &self,
        value: u64,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self).SetEventOnCompletion)(
            ::windows::core::Interface::as_raw(self),
            value,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn Signal(&self, value: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Signal)(
            ::windows::core::Interface::as_raw(self),
            value,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Fence,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12Fence {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Fence {}
impl ::core::fmt::Debug for ID3D12Fence {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Fence").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Fence {
    type Vtable = ID3D12Fence_Vtbl;
}
impl ::core::clone::Clone for ID3D12Fence {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Fence {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x0a753dcf_c4d8_4b91_adf6_be5a60d95a76);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Fence_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetCompletedValue: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub SetEventOnCompletion: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        value: u64,
        hevent: ::windows::Win32::Foundation::HANDLE,
    ) -> ::windows::core::HRESULT,
    pub Signal: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        value: u64,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Fence1(::windows::core::IUnknown);
impl ID3D12Fence1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetCompletedValue(&self) -> u64 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetCompletedValue)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetEventOnCompletion<P0>(
        &self,
        value: u64,
        hevent: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::HANDLE>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetEventOnCompletion)(
            ::windows::core::Interface::as_raw(self),
            value,
            hevent.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn Signal(&self, value: u64) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Signal)(
            ::windows::core::Interface::as_raw(self),
            value,
        )
        .ok()
    }
    pub unsafe fn GetCreationFlags(&self) -> D3D12_FENCE_FLAGS {
        (::windows::core::Interface::vtable(self).GetCreationFlags)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Fence1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable,
    ID3D12Fence
);
impl ::core::cmp::PartialEq for ID3D12Fence1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Fence1 {}
impl ::core::fmt::Debug for ID3D12Fence1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Fence1").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Fence1 {
    type Vtable = ID3D12Fence1_Vtbl;
}
impl ::core::clone::Clone for ID3D12Fence1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Fence1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x433685fe_e22b_4ca0_a8db_b5b4f4dd0e4a);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Fence1_Vtbl {
    pub base__: ID3D12Fence_Vtbl,
    pub GetCreationFlags:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_FENCE_FLAGS,
}
#[repr(transparent)]
pub struct ID3D12FunctionParameterReflection(::std::ptr::NonNull<::std::ffi::c_void>);
impl ID3D12FunctionParameterReflection {
    pub unsafe fn GetDesc(&self, pdesc: *mut D3D12_PARAMETER_DESC) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
        )
        .ok()
    }
}
impl ::core::cmp::PartialEq for ID3D12FunctionParameterReflection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12FunctionParameterReflection {}
impl ::core::fmt::Debug for ID3D12FunctionParameterReflection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12FunctionParameterReflection")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12FunctionParameterReflection {
    type Vtable = ID3D12FunctionParameterReflection_Vtbl;
}
impl ::core::clone::Clone for ID3D12FunctionParameterReflection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12FunctionParameterReflection_Vtbl {
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *mut D3D12_PARAMETER_DESC,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12FunctionReflection(::std::ptr::NonNull<::std::ffi::c_void>);
impl ID3D12FunctionReflection {
    pub unsafe fn GetDesc(&self, pdesc: *mut D3D12_FUNCTION_DESC) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetConstantBufferByIndex(
        &self,
        bufferindex: u32,
    ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer> {
        (::windows::core::Interface::vtable(self).GetConstantBufferByIndex)(
            ::windows::core::Interface::as_raw(self),
            bufferindex,
        )
    }
    pub unsafe fn GetConstantBufferByName<P0>(
        &self,
        name: P0,
    ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).GetConstantBufferByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
    }
    pub unsafe fn GetResourceBindingDesc(
        &self,
        resourceindex: u32,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetResourceBindingDesc)(
            ::windows::core::Interface::as_raw(self),
            resourceindex,
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetVariableByName<P0>(
        &self,
        name: P0,
    ) -> ::core::option::Option<ID3D12ShaderReflectionVariable>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).GetVariableByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
    }
    pub unsafe fn GetResourceBindingDescByName<P0>(
        &self,
        name: P0,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).GetResourceBindingDescByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetFunctionParameter(
        &self,
        parameterindex: i32,
    ) -> ::core::option::Option<ID3D12FunctionParameterReflection> {
        (::windows::core::Interface::vtable(self).GetFunctionParameter)(
            ::windows::core::Interface::as_raw(self),
            parameterindex,
        )
    }
}
impl ::core::cmp::PartialEq for ID3D12FunctionReflection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12FunctionReflection {}
impl ::core::fmt::Debug for ID3D12FunctionReflection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12FunctionReflection")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12FunctionReflection {
    type Vtable = ID3D12FunctionReflection_Vtbl;
}
impl ::core::clone::Clone for ID3D12FunctionReflection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12FunctionReflection_Vtbl {
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *mut D3D12_FUNCTION_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetConstantBufferByIndex: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        bufferindex: u32,
    ) -> ::core::option::Option<
        ID3D12ShaderReflectionConstantBuffer,
    >,
    pub GetConstantBufferByName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        name: ::windows::core::PCSTR,
    ) -> ::core::option::Option<
        ID3D12ShaderReflectionConstantBuffer,
    >,
    pub GetResourceBindingDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        resourceindex: u32,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetVariableByName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        name: ::windows::core::PCSTR,
    ) -> ::core::option::Option<
        ID3D12ShaderReflectionVariable,
    >,
    pub GetResourceBindingDescByName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        name: ::windows::core::PCSTR,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetFunctionParameter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        parameterindex: i32,
    ) -> ::core::option::Option<
        ID3D12FunctionParameterReflection,
    >,
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandList(::windows::core::IUnknown);
impl ID3D12GraphicsCommandList {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.GetType)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self))
            .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self).Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self).ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self).DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self).DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self).Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self).CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self).IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self),
            primitivetopology,
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self).RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self).RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self).OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self).OMSetStencilRef)(
            ::windows::core::Interface::as_raw(self),
            stencilref,
        )
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self).SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self).ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self).SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self).SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self).SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self).SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self).SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self).SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self).SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self).SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self).SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self).SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self).SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self).SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self).SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self).SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self).SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self).IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self).IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self).SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self).ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self).ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).EndEvent)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandList,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandList {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandList")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandList {
    type Vtable = ID3D12GraphicsCommandList_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandList {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x5b160d0f_ac1b_4185_8ba8_b3ae42a5a455);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandList_Vtbl {
    pub base__: ID3D12CommandList_Vtbl,
    pub Close:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pallocator: *mut ::core::ffi::c_void,
        pinitialstate: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub ClearState: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ppipelinestate: *mut ::core::ffi::c_void,
    ),
    pub DrawInstanced: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ),
    pub DrawIndexedInstanced: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ),
    pub Dispatch: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ),
    pub CopyBufferRegion: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdstbuffer: *mut ::core::ffi::c_void,
        dstoffset: u64,
        psrcbuffer: *mut ::core::ffi::c_void,
        srcoffset: u64,
        numbytes: u64,
    ),
    pub CopyTextureRegion: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: *const D3D12_BOX,
    ),
    pub CopyResource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdstresource: *mut ::core::ffi::c_void,
        psrcresource: *mut ::core::ffi::c_void,
    ),
    pub CopyTiles: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ptiledresource: *mut ::core::ffi::c_void,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: *mut ::core::ffi::c_void,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ),
    pub ResolveSubresource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdstresource: *mut ::core::ffi::c_void,
        dstsubresource: u32,
        psrcresource: *mut ::core::ffi::c_void,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ),
    pub IASetPrimitiveTopology: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        primitivetopology: D3D_PRIMITIVE_TOPOLOGY,
    ),
    pub RSSetViewports: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numviewports: u32,
        pviewports: *const D3D12_VIEWPORT,
    ),
    pub RSSetScissorRects: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numrects: u32,
        prects: *const ::windows::Win32::Foundation::RECT,
    ),
    pub OMSetBlendFactor:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, blendfactor: *const f32),
    pub OMSetStencilRef: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, stencilref: u32),
    pub SetPipelineState: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ppipelinestate: *mut ::core::ffi::c_void,
    ),
    pub ResourceBarrier: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numbarriers: u32,
        pbarriers: *const D3D12_RESOURCE_BARRIER,
    ),
    pub ExecuteBundle: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pcommandlist: *mut ::core::ffi::c_void,
    ),
    pub SetDescriptorHeaps: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numdescriptorheaps: u32,
        ppdescriptorheaps: *const *mut ::core::ffi::c_void,
    ),
    pub SetComputeRootSignature: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        prootsignature: *mut ::core::ffi::c_void,
    ),
    pub SetGraphicsRootSignature: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        prootsignature: *mut ::core::ffi::c_void,
    ),
    pub SetComputeRootDescriptorTable: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ),
    pub SetGraphicsRootDescriptorTable: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ),
    pub SetComputeRoot32BitConstant: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ),
    pub SetGraphicsRoot32BitConstant: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ),
    pub SetComputeRoot32BitConstants: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ),
    pub SetGraphicsRoot32BitConstants: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ),
    pub SetComputeRootConstantBufferView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        bufferlocation: u64,
    ),
    pub SetGraphicsRootConstantBufferView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        bufferlocation: u64,
    ),
    pub SetComputeRootShaderResourceView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        bufferlocation: u64,
    ),
    pub SetGraphicsRootShaderResourceView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        bufferlocation: u64,
    ),
    pub SetComputeRootUnorderedAccessView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        bufferlocation: u64,
    ),
    pub SetGraphicsRootUnorderedAccessView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rootparameterindex: u32,
        bufferlocation: u64,
    ),
    pub IASetIndexBuffer: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pview: *const D3D12_INDEX_BUFFER_VIEW,
    ),
    pub IASetVertexBuffers: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        startslot: u32,
        numviews: u32,
        pviews: *const D3D12_VERTEX_BUFFER_VIEW,
    ),
    pub SOSetTargets: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        startslot: u32,
        numviews: u32,
        pviews: *const D3D12_STREAM_OUTPUT_BUFFER_VIEW,
    ),
    pub OMSetRenderTargets: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        rtssinglehandletodescriptorrange: ::windows::Win32::Foundation::BOOL,
        pdepthstencildescriptor: *const D3D12_CPU_DESCRIPTOR_HANDLE,
    ),
    pub ClearDepthStencilView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        numrects: u32,
        prects: *const ::windows::Win32::Foundation::RECT,
    ),
    pub ClearRenderTargetView: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: *const f32,
        numrects: u32,
        prects: *const ::windows::Win32::Foundation::RECT,
    ),
    pub ClearUnorderedAccessViewUint: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: *mut ::core::ffi::c_void,
        values: *const u32,
        numrects: u32,
        prects: *const ::windows::Win32::Foundation::RECT,
    ),
    pub ClearUnorderedAccessViewFloat: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: *mut ::core::ffi::c_void,
        values: *const f32,
        numrects: u32,
        prects: *const ::windows::Win32::Foundation::RECT,
    ),
    pub DiscardResource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        pregion: *const D3D12_DISCARD_REGION,
    ),
    pub BeginQuery: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    ),
    pub EndQuery: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    ),
    pub ResolveQueryData: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: *mut ::core::ffi::c_void,
        aligneddestinationbufferoffset: u64,
    ),
    pub SetPredication: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pbuffer: *mut ::core::ffi::c_void,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ),
    pub SetMarker: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        metadata: u32,
        pdata: *const ::core::ffi::c_void,
        size: u32,
    ),
    pub BeginEvent: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        metadata: u32,
        pdata: *const ::core::ffi::c_void,
        size: u32,
    ),
    pub EndEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub ExecuteIndirect: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pcommandsignature: *mut ::core::ffi::c_void,
        maxcommandcount: u32,
        pargumentbuffer: *mut ::core::ffi::c_void,
        argumentbufferoffset: u64,
        pcountbuffer: *mut ::core::ffi::c_void,
        countbufferoffset: u64,
    ),
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandList1(::windows::core::IUnknown);
impl ID3D12GraphicsCommandList1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Close)(::windows::core::Interface::as_raw(
            self,
        ))
        .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self).base__.Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self).base__.ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self).base__.Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).base__.CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self)
            .base__
            .IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self), primitivetopology
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self)
            .base__
            .OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .OMSetStencilRef)(::windows::core::Interface::as_raw(self), stencilref)
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self).base__.SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).base__.SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).base__.BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.EndEvent)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).AtomicCopyBufferUINT)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT64<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).AtomicCopyBufferUINT64)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn OMSetDepthBounds(&self, min: f32, max: f32) {
        (::windows::core::Interface::vtable(self).OMSetDepthBounds)(
            ::windows::core::Interface::as_raw(self),
            min,
            max,
        )
    }
    pub unsafe fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ) {
        (::windows::core::Interface::vtable(self).SetSamplePositions)(
            ::windows::core::Interface::as_raw(self),
            numsamplesperpixel,
            numpixels,
            psamplepositions,
        )
    }
    pub unsafe fn ResolveSubresourceRegion<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: P1,
        srcsubresource: u32,
        psrcrect: ::core::option::Option<*const ::windows::Win32::Foundation::RECT>,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ResolveSubresourceRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            dstx,
            dsty,
            psrcresource.into_param().abi(),
            srcsubresource,
            ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null())),
            format,
            resolvemode,
        )
    }
    pub unsafe fn SetViewInstanceMask(&self, mask: u32) {
        (::windows::core::Interface::vtable(self).SetViewInstanceMask)(
            ::windows::core::Interface::as_raw(self),
            mask,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandList1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12GraphicsCommandList
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandList1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandList1 {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandList1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandList1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandList1 {
    type Vtable = ID3D12GraphicsCommandList1_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandList1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandList1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x553103fb_1fe7_4557_bb38_946d7d0e7ca7);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandList1_Vtbl {
    pub base__: ID3D12GraphicsCommandList_Vtbl,
    pub AtomicCopyBufferUINT: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdstbuffer: *mut ::core::ffi::c_void,
        dstoffset: u64,
        psrcbuffer: *mut ::core::ffi::c_void,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const *mut ::core::ffi::c_void,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ),
    pub AtomicCopyBufferUINT64: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdstbuffer: *mut ::core::ffi::c_void,
        dstoffset: u64,
        psrcbuffer: *mut ::core::ffi::c_void,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const *mut ::core::ffi::c_void,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ),
    pub OMSetDepthBounds:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, min: f32, max: f32),
    pub SetSamplePositions: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ),
    pub ResolveSubresourceRegion: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdstresource: *mut ::core::ffi::c_void,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: *mut ::core::ffi::c_void,
        srcsubresource: u32,
        psrcrect: *const ::windows::Win32::Foundation::RECT,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ),
    pub SetViewInstanceMask: unsafe extern "system" fn(this: *mut ::core::ffi::c_void, mask: u32),
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandList2(::windows::core::IUnknown);
impl ID3D12GraphicsCommandList2 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Close)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self), primitivetopology
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .OMSetStencilRef)(::windows::core::Interface::as_raw(self), stencilref)
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .AtomicCopyBufferUINT)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT64<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .AtomicCopyBufferUINT64)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn OMSetDepthBounds(&self, min: f32, max: f32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .OMSetDepthBounds)(::windows::core::Interface::as_raw(self), min, max)
    }
    pub unsafe fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetSamplePositions)(
            ::windows::core::Interface::as_raw(self),
            numsamplesperpixel,
            numpixels,
            psamplepositions,
        )
    }
    pub unsafe fn ResolveSubresourceRegion<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: P1,
        srcsubresource: u32,
        psrcrect: ::core::option::Option<*const ::windows::Win32::Foundation::RECT>,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResolveSubresourceRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            dstx,
            dsty,
            psrcresource.into_param().abi(),
            srcsubresource,
            ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null())),
            format,
            resolvemode,
        )
    }
    pub unsafe fn SetViewInstanceMask(&self, mask: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetViewInstanceMask)(::windows::core::Interface::as_raw(self), mask)
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self).WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandList2,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12GraphicsCommandList,
    ID3D12GraphicsCommandList1
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandList2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandList2 {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandList2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandList2")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandList2 {
    type Vtable = ID3D12GraphicsCommandList2_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandList2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandList2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x38c3e585_ff17_412c_9150_4fc6f9d72a28);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandList2_Vtbl {
    pub base__: ID3D12GraphicsCommandList1_Vtbl,
    pub WriteBufferImmediate: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
    ),
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandList3(::windows::core::IUnknown);
impl ID3D12GraphicsCommandList3 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self), primitivetopology
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .OMSetStencilRef)(::windows::core::Interface::as_raw(self), stencilref)
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .AtomicCopyBufferUINT)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT64<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .AtomicCopyBufferUINT64)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn OMSetDepthBounds(&self, min: f32, max: f32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .OMSetDepthBounds)(::windows::core::Interface::as_raw(self), min, max)
    }
    pub unsafe fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetSamplePositions)(
            ::windows::core::Interface::as_raw(self),
            numsamplesperpixel,
            numpixels,
            psamplepositions,
        )
    }
    pub unsafe fn ResolveSubresourceRegion<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: P1,
        srcsubresource: u32,
        psrcrect: ::core::option::Option<*const ::windows::Win32::Foundation::RECT>,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResolveSubresourceRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            dstx,
            dsty,
            psrcresource.into_param().abi(),
            srcsubresource,
            ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null())),
            format,
            resolvemode,
        )
    }
    pub unsafe fn SetViewInstanceMask(&self, mask: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetViewInstanceMask)(::windows::core::Interface::as_raw(self), mask)
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandList3,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12GraphicsCommandList,
    ID3D12GraphicsCommandList1,
    ID3D12GraphicsCommandList2
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandList3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandList3 {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandList3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandList3")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandList3 {
    type Vtable = ID3D12GraphicsCommandList3_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandList3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandList3 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x6fda83a7_b84c_4e38_9ac8_c7bd22016b3d);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandList3_Vtbl {
    pub base__: ID3D12GraphicsCommandList2_Vtbl,
    pub SetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pprotectedresourcesession: *mut ::core::ffi::c_void,
    ),
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandList4(::windows::core::IUnknown);
impl ID3D12GraphicsCommandList4 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self), primitivetopology
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .OMSetStencilRef)(::windows::core::Interface::as_raw(self), stencilref)
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT64<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT64)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn OMSetDepthBounds(&self, min: f32, max: f32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .OMSetDepthBounds)(::windows::core::Interface::as_raw(self), min, max)
    }
    pub unsafe fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetSamplePositions)(
            ::windows::core::Interface::as_raw(self),
            numsamplesperpixel,
            numpixels,
            psamplepositions,
        )
    }
    pub unsafe fn ResolveSubresourceRegion<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: P1,
        srcsubresource: u32,
        psrcrect: ::core::option::Option<*const ::windows::Win32::Foundation::RECT>,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResolveSubresourceRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            dstx,
            dsty,
            psrcresource.into_param().abi(),
            srcsubresource,
            ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null())),
            format,
            resolvemode,
        )
    }
    pub unsafe fn SetViewInstanceMask(&self, mask: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetViewInstanceMask)(::windows::core::Interface::as_raw(self), mask)
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn BeginRenderPass(
        &self,
        prendertargets: ::core::option::Option<&[D3D12_RENDER_PASS_RENDER_TARGET_DESC]>,
        pdepthstencil: ::core::option::Option<*const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC>,
        flags: D3D12_RENDER_PASS_FLAGS,
    ) {
        (::windows::core::Interface::vtable(self).BeginRenderPass)(
            ::windows::core::Interface::as_raw(self),
            prendertargets
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                prendertargets
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            ::core::mem::transmute(pdepthstencil.unwrap_or(::std::ptr::null())),
            flags,
        )
    }
    pub unsafe fn EndRenderPass(&self) {
        (::windows::core::Interface::vtable(self).EndRenderPass)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn InitializeMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pinitializationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        initializationparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self).InitializeMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pinitializationparametersdata.unwrap_or(::std::ptr::null())),
            initializationparametersdatasizeinbytes,
        )
    }
    pub unsafe fn ExecuteMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pexecutionparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        executionparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self).ExecuteMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pexecutionparametersdata.unwrap_or(::std::ptr::null())),
            executionparametersdatasizeinbytes,
        )
    }
    pub unsafe fn BuildRaytracingAccelerationStructure(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC,
        ppostbuildinfodescs: ::core::option::Option<
            &[D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC],
        >,
    ) {
        (::windows::core::Interface::vtable(self).BuildRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ppostbuildinfodescs
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                ppostbuildinfodescs
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn EmitRaytracingAccelerationStructurePostbuildInfo(
        &self,
        pdesc: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
        psourceaccelerationstructuredata: &[u64],
    ) {
        (::windows::core::Interface::vtable(self).EmitRaytracingAccelerationStructurePostbuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            psourceaccelerationstructuredata.len() as _,
            ::core::mem::transmute(psourceaccelerationstructuredata.as_ptr()),
        )
    }
    pub unsafe fn CopyRaytracingAccelerationStructure(
        &self,
        destaccelerationstructuredata: u64,
        sourceaccelerationstructuredata: u64,
        mode: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE,
    ) {
        (::windows::core::Interface::vtable(self).CopyRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            destaccelerationstructuredata,
            sourceaccelerationstructuredata,
            mode,
        )
    }
    pub unsafe fn SetPipelineState1<P0>(&self, pstateobject: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
    {
        (::windows::core::Interface::vtable(self).SetPipelineState1)(
            ::windows::core::Interface::as_raw(self),
            pstateobject.into_param().abi(),
        )
    }
    pub unsafe fn DispatchRays(&self, pdesc: *const D3D12_DISPATCH_RAYS_DESC) {
        (::windows::core::Interface::vtable(self).DispatchRays)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandList4,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12GraphicsCommandList,
    ID3D12GraphicsCommandList1,
    ID3D12GraphicsCommandList2,
    ID3D12GraphicsCommandList3
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandList4 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandList4 {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandList4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandList4")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandList4 {
    type Vtable = ID3D12GraphicsCommandList4_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandList4 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandList4 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x8754318e_d3a9_4541_98cf_645b50dc4874);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandList4_Vtbl {
    pub base__: ID3D12GraphicsCommandList3_Vtbl,
    pub BeginRenderPass: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numrendertargets: u32,
        prendertargets: *const D3D12_RENDER_PASS_RENDER_TARGET_DESC,
        pdepthstencil: *const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC,
        flags: D3D12_RENDER_PASS_FLAGS,
    ),
    pub EndRenderPass: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub InitializeMetaCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pmetacommand: *mut ::core::ffi::c_void,
        pinitializationparametersdata: *const ::core::ffi::c_void,
        initializationparametersdatasizeinbytes: usize,
    ),
    pub ExecuteMetaCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pmetacommand: *mut ::core::ffi::c_void,
        pexecutionparametersdata: *const ::core::ffi::c_void,
        executionparametersdatasizeinbytes: usize,
    ),
    pub BuildRaytracingAccelerationStructure: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC,
        numpostbuildinfodescs: u32,
        ppostbuildinfodescs: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
    ),
    pub EmitRaytracingAccelerationStructurePostbuildInfo: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
        numsourceaccelerationstructures: u32,
        psourceaccelerationstructuredata: *const u64,
    ),
    pub CopyRaytracingAccelerationStructure: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        destaccelerationstructuredata: u64,
        sourceaccelerationstructuredata: u64,
        mode: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE,
    ),
    pub SetPipelineState1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pstateobject: *mut ::core::ffi::c_void,
    ),
    pub DispatchRays: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_DISPATCH_RAYS_DESC,
    ),
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandList5(::windows::core::IUnknown);
impl ID3D12GraphicsCommandList5 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self), primitivetopology
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetStencilRef)(::windows::core::Interface::as_raw(self), stencilref)
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT64<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT64)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn OMSetDepthBounds(&self, min: f32, max: f32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .OMSetDepthBounds)(::windows::core::Interface::as_raw(self), min, max)
    }
    pub unsafe fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetSamplePositions)(
            ::windows::core::Interface::as_raw(self),
            numsamplesperpixel,
            numpixels,
            psamplepositions,
        )
    }
    pub unsafe fn ResolveSubresourceRegion<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: P1,
        srcsubresource: u32,
        psrcrect: ::core::option::Option<*const ::windows::Win32::Foundation::RECT>,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresourceRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            dstx,
            dsty,
            psrcresource.into_param().abi(),
            srcsubresource,
            ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null())),
            format,
            resolvemode,
        )
    }
    pub unsafe fn SetViewInstanceMask(&self, mask: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetViewInstanceMask)(::windows::core::Interface::as_raw(self), mask)
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn BeginRenderPass(
        &self,
        prendertargets: ::core::option::Option<&[D3D12_RENDER_PASS_RENDER_TARGET_DESC]>,
        pdepthstencil: ::core::option::Option<*const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC>,
        flags: D3D12_RENDER_PASS_FLAGS,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .BeginRenderPass)(
            ::windows::core::Interface::as_raw(self),
            prendertargets
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                prendertargets
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            ::core::mem::transmute(pdepthstencil.unwrap_or(::std::ptr::null())),
            flags,
        )
    }
    pub unsafe fn EndRenderPass(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .EndRenderPass)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn InitializeMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pinitializationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        initializationparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .InitializeMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pinitializationparametersdata.unwrap_or(::std::ptr::null())),
            initializationparametersdatasizeinbytes,
        )
    }
    pub unsafe fn ExecuteMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pexecutionparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        executionparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ExecuteMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pexecutionparametersdata.unwrap_or(::std::ptr::null())),
            executionparametersdatasizeinbytes,
        )
    }
    pub unsafe fn BuildRaytracingAccelerationStructure(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC,
        ppostbuildinfodescs: ::core::option::Option<
            &[D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC],
        >,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .BuildRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ppostbuildinfodescs
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                ppostbuildinfodescs
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn EmitRaytracingAccelerationStructurePostbuildInfo(
        &self,
        pdesc: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
        psourceaccelerationstructuredata: &[u64],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .EmitRaytracingAccelerationStructurePostbuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            psourceaccelerationstructuredata.len() as _,
            ::core::mem::transmute(psourceaccelerationstructuredata.as_ptr()),
        )
    }
    pub unsafe fn CopyRaytracingAccelerationStructure(
        &self,
        destaccelerationstructuredata: u64,
        sourceaccelerationstructuredata: u64,
        mode: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .CopyRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            destaccelerationstructuredata,
            sourceaccelerationstructuredata,
            mode,
        )
    }
    pub unsafe fn SetPipelineState1<P0>(&self, pstateobject: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPipelineState1)(
            ::windows::core::Interface::as_raw(self),
            pstateobject.into_param().abi(),
        )
    }
    pub unsafe fn DispatchRays(&self, pdesc: *const D3D12_DISPATCH_RAYS_DESC) {
        (::windows::core::Interface::vtable(self).base__.DispatchRays)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
        )
    }
    pub unsafe fn RSSetShadingRate(
        &self,
        baseshadingrate: D3D12_SHADING_RATE,
        combiners: ::core::option::Option<*const D3D12_SHADING_RATE_COMBINER>,
    ) {
        (::windows::core::Interface::vtable(self).RSSetShadingRate)(
            ::windows::core::Interface::as_raw(self),
            baseshadingrate,
            ::core::mem::transmute(combiners.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn RSSetShadingRateImage<P0>(&self, shadingrateimage: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).RSSetShadingRateImage)(
            ::windows::core::Interface::as_raw(self),
            shadingrateimage.into_param().abi(),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandList5,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12GraphicsCommandList,
    ID3D12GraphicsCommandList1,
    ID3D12GraphicsCommandList2,
    ID3D12GraphicsCommandList3,
    ID3D12GraphicsCommandList4
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandList5 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandList5 {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandList5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandList5")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandList5 {
    type Vtable = ID3D12GraphicsCommandList5_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandList5 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandList5 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x55050859_4024_474c_87f5_6472eaee44ea);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandList5_Vtbl {
    pub base__: ID3D12GraphicsCommandList4_Vtbl,
    pub RSSetShadingRate: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        baseshadingrate: D3D12_SHADING_RATE,
        combiners: *const D3D12_SHADING_RATE_COMBINER,
    ),
    pub RSSetShadingRateImage: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        shadingrateimage: *mut ::core::ffi::c_void,
    ),
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandList6(::windows::core::IUnknown);
impl ID3D12GraphicsCommandList6 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self), primitivetopology
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetStencilRef)(::windows::core::Interface::as_raw(self), stencilref)
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT64<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT64)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn OMSetDepthBounds(&self, min: f32, max: f32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetDepthBounds)(::windows::core::Interface::as_raw(self), min, max)
    }
    pub unsafe fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetSamplePositions)(
            ::windows::core::Interface::as_raw(self),
            numsamplesperpixel,
            numpixels,
            psamplepositions,
        )
    }
    pub unsafe fn ResolveSubresourceRegion<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: P1,
        srcsubresource: u32,
        psrcrect: ::core::option::Option<*const ::windows::Win32::Foundation::RECT>,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresourceRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            dstx,
            dsty,
            psrcresource.into_param().abi(),
            srcsubresource,
            ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null())),
            format,
            resolvemode,
        )
    }
    pub unsafe fn SetViewInstanceMask(&self, mask: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetViewInstanceMask)(::windows::core::Interface::as_raw(self), mask)
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn BeginRenderPass(
        &self,
        prendertargets: ::core::option::Option<&[D3D12_RENDER_PASS_RENDER_TARGET_DESC]>,
        pdepthstencil: ::core::option::Option<*const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC>,
        flags: D3D12_RENDER_PASS_FLAGS,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .BeginRenderPass)(
            ::windows::core::Interface::as_raw(self),
            prendertargets
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                prendertargets
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            ::core::mem::transmute(pdepthstencil.unwrap_or(::std::ptr::null())),
            flags,
        )
    }
    pub unsafe fn EndRenderPass(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EndRenderPass)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn InitializeMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pinitializationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        initializationparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .InitializeMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pinitializationparametersdata.unwrap_or(::std::ptr::null())),
            initializationparametersdatasizeinbytes,
        )
    }
    pub unsafe fn ExecuteMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pexecutionparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        executionparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ExecuteMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pexecutionparametersdata.unwrap_or(::std::ptr::null())),
            executionparametersdatasizeinbytes,
        )
    }
    pub unsafe fn BuildRaytracingAccelerationStructure(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC,
        ppostbuildinfodescs: ::core::option::Option<
            &[D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC],
        >,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .BuildRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ppostbuildinfodescs
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                ppostbuildinfodescs
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn EmitRaytracingAccelerationStructurePostbuildInfo(
        &self,
        pdesc: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
        psourceaccelerationstructuredata: &[u64],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EmitRaytracingAccelerationStructurePostbuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            psourceaccelerationstructuredata.len() as _,
            ::core::mem::transmute(psourceaccelerationstructuredata.as_ptr()),
        )
    }
    pub unsafe fn CopyRaytracingAccelerationStructure(
        &self,
        destaccelerationstructuredata: u64,
        sourceaccelerationstructuredata: u64,
        mode: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CopyRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            destaccelerationstructuredata,
            sourceaccelerationstructuredata,
            mode,
        )
    }
    pub unsafe fn SetPipelineState1<P0>(&self, pstateobject: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPipelineState1)(
            ::windows::core::Interface::as_raw(self),
            pstateobject.into_param().abi(),
        )
    }
    pub unsafe fn DispatchRays(&self, pdesc: *const D3D12_DISPATCH_RAYS_DESC) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DispatchRays)(::windows::core::Interface::as_raw(self), pdesc)
    }
    pub unsafe fn RSSetShadingRate(
        &self,
        baseshadingrate: D3D12_SHADING_RATE,
        combiners: ::core::option::Option<*const D3D12_SHADING_RATE_COMBINER>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .RSSetShadingRate)(
            ::windows::core::Interface::as_raw(self),
            baseshadingrate,
            ::core::mem::transmute(combiners.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn RSSetShadingRateImage<P0>(&self, shadingrateimage: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .RSSetShadingRateImage)(
            ::windows::core::Interface::as_raw(self),
            shadingrateimage.into_param().abi(),
        )
    }
    pub unsafe fn DispatchMesh(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self).DispatchMesh)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandList6,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12GraphicsCommandList,
    ID3D12GraphicsCommandList1,
    ID3D12GraphicsCommandList2,
    ID3D12GraphicsCommandList3,
    ID3D12GraphicsCommandList4,
    ID3D12GraphicsCommandList5
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandList6 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandList6 {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandList6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandList6")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandList6 {
    type Vtable = ID3D12GraphicsCommandList6_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandList6 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandList6 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xc3827890_e548_4cfa_96cf_5689a9370f80);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandList6_Vtbl {
    pub base__: ID3D12GraphicsCommandList5_Vtbl,
    pub DispatchMesh: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ),
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandList7(::windows::core::IUnknown);
impl ID3D12GraphicsCommandList7 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self), primitivetopology
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetStencilRef)(::windows::core::Interface::as_raw(self), stencilref)
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT64<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT64)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn OMSetDepthBounds(&self, min: f32, max: f32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetDepthBounds)(::windows::core::Interface::as_raw(self), min, max)
    }
    pub unsafe fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetSamplePositions)(
            ::windows::core::Interface::as_raw(self),
            numsamplesperpixel,
            numpixels,
            psamplepositions,
        )
    }
    pub unsafe fn ResolveSubresourceRegion<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: P1,
        srcsubresource: u32,
        psrcrect: ::core::option::Option<*const ::windows::Win32::Foundation::RECT>,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresourceRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            dstx,
            dsty,
            psrcresource.into_param().abi(),
            srcsubresource,
            ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null())),
            format,
            resolvemode,
        )
    }
    pub unsafe fn SetViewInstanceMask(&self, mask: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetViewInstanceMask)(::windows::core::Interface::as_raw(self), mask)
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn BeginRenderPass(
        &self,
        prendertargets: ::core::option::Option<&[D3D12_RENDER_PASS_RENDER_TARGET_DESC]>,
        pdepthstencil: ::core::option::Option<*const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC>,
        flags: D3D12_RENDER_PASS_FLAGS,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .BeginRenderPass)(
            ::windows::core::Interface::as_raw(self),
            prendertargets
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                prendertargets
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            ::core::mem::transmute(pdepthstencil.unwrap_or(::std::ptr::null())),
            flags,
        )
    }
    pub unsafe fn EndRenderPass(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EndRenderPass)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn InitializeMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pinitializationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        initializationparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .InitializeMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pinitializationparametersdata.unwrap_or(::std::ptr::null())),
            initializationparametersdatasizeinbytes,
        )
    }
    pub unsafe fn ExecuteMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pexecutionparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        executionparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ExecuteMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pexecutionparametersdata.unwrap_or(::std::ptr::null())),
            executionparametersdatasizeinbytes,
        )
    }
    pub unsafe fn BuildRaytracingAccelerationStructure(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC,
        ppostbuildinfodescs: ::core::option::Option<
            &[D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC],
        >,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .BuildRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ppostbuildinfodescs
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                ppostbuildinfodescs
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn EmitRaytracingAccelerationStructurePostbuildInfo(
        &self,
        pdesc: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
        psourceaccelerationstructuredata: &[u64],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EmitRaytracingAccelerationStructurePostbuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            psourceaccelerationstructuredata.len() as _,
            ::core::mem::transmute(psourceaccelerationstructuredata.as_ptr()),
        )
    }
    pub unsafe fn CopyRaytracingAccelerationStructure(
        &self,
        destaccelerationstructuredata: u64,
        sourceaccelerationstructuredata: u64,
        mode: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CopyRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            destaccelerationstructuredata,
            sourceaccelerationstructuredata,
            mode,
        )
    }
    pub unsafe fn SetPipelineState1<P0>(&self, pstateobject: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPipelineState1)(
            ::windows::core::Interface::as_raw(self),
            pstateobject.into_param().abi(),
        )
    }
    pub unsafe fn DispatchRays(&self, pdesc: *const D3D12_DISPATCH_RAYS_DESC) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .DispatchRays)(::windows::core::Interface::as_raw(self), pdesc)
    }
    pub unsafe fn RSSetShadingRate(
        &self,
        baseshadingrate: D3D12_SHADING_RATE,
        combiners: ::core::option::Option<*const D3D12_SHADING_RATE_COMBINER>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .RSSetShadingRate)(
            ::windows::core::Interface::as_raw(self),
            baseshadingrate,
            ::core::mem::transmute(combiners.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn RSSetShadingRateImage<P0>(&self, shadingrateimage: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .RSSetShadingRateImage)(
            ::windows::core::Interface::as_raw(self),
            shadingrateimage.into_param().abi(),
        )
    }
    pub unsafe fn DispatchMesh(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self).base__.DispatchMesh)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn Barrier(&self, pbarriergroups: &[D3D12_BARRIER_GROUP]) {
        (::windows::core::Interface::vtable(self).Barrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriergroups.len() as _,
            ::core::mem::transmute(pbarriergroups.as_ptr()),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandList7,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12GraphicsCommandList,
    ID3D12GraphicsCommandList1,
    ID3D12GraphicsCommandList2,
    ID3D12GraphicsCommandList3,
    ID3D12GraphicsCommandList4,
    ID3D12GraphicsCommandList5,
    ID3D12GraphicsCommandList6
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandList7 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandList7 {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandList7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandList7")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandList7 {
    type Vtable = ID3D12GraphicsCommandList7_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandList7 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandList7 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xdd171223_8b61_4769_90e3_160ccde4e2c1);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandList7_Vtbl {
    pub base__: ID3D12GraphicsCommandList6_Vtbl,
    pub Barrier: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numbarriergroups: u32,
        pbarriergroups: *const D3D12_BARRIER_GROUP,
    ),
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandList8(::windows::core::IUnknown);
impl ID3D12GraphicsCommandList8 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self), primitivetopology
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetStencilRef)(::windows::core::Interface::as_raw(self), stencilref)
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT64<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT64)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn OMSetDepthBounds(&self, min: f32, max: f32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetDepthBounds)(::windows::core::Interface::as_raw(self), min, max)
    }
    pub unsafe fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetSamplePositions)(
            ::windows::core::Interface::as_raw(self),
            numsamplesperpixel,
            numpixels,
            psamplepositions,
        )
    }
    pub unsafe fn ResolveSubresourceRegion<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: P1,
        srcsubresource: u32,
        psrcrect: ::core::option::Option<*const ::windows::Win32::Foundation::RECT>,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresourceRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            dstx,
            dsty,
            psrcresource.into_param().abi(),
            srcsubresource,
            ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null())),
            format,
            resolvemode,
        )
    }
    pub unsafe fn SetViewInstanceMask(&self, mask: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetViewInstanceMask)(::windows::core::Interface::as_raw(self), mask)
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn BeginRenderPass(
        &self,
        prendertargets: ::core::option::Option<&[D3D12_RENDER_PASS_RENDER_TARGET_DESC]>,
        pdepthstencil: ::core::option::Option<*const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC>,
        flags: D3D12_RENDER_PASS_FLAGS,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .BeginRenderPass)(
            ::windows::core::Interface::as_raw(self),
            prendertargets
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                prendertargets
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            ::core::mem::transmute(pdepthstencil.unwrap_or(::std::ptr::null())),
            flags,
        )
    }
    pub unsafe fn EndRenderPass(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .EndRenderPass)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn InitializeMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pinitializationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        initializationparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .InitializeMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pinitializationparametersdata.unwrap_or(::std::ptr::null())),
            initializationparametersdatasizeinbytes,
        )
    }
    pub unsafe fn ExecuteMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pexecutionparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        executionparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .ExecuteMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pexecutionparametersdata.unwrap_or(::std::ptr::null())),
            executionparametersdatasizeinbytes,
        )
    }
    pub unsafe fn BuildRaytracingAccelerationStructure(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC,
        ppostbuildinfodescs: ::core::option::Option<
            &[D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC],
        >,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .BuildRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ppostbuildinfodescs
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                ppostbuildinfodescs
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn EmitRaytracingAccelerationStructurePostbuildInfo(
        &self,
        pdesc: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
        psourceaccelerationstructuredata: &[u64],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .EmitRaytracingAccelerationStructurePostbuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            psourceaccelerationstructuredata.len() as _,
            ::core::mem::transmute(psourceaccelerationstructuredata.as_ptr()),
        )
    }
    pub unsafe fn CopyRaytracingAccelerationStructure(
        &self,
        destaccelerationstructuredata: u64,
        sourceaccelerationstructuredata: u64,
        mode: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .CopyRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            destaccelerationstructuredata,
            sourceaccelerationstructuredata,
            mode,
        )
    }
    pub unsafe fn SetPipelineState1<P0>(&self, pstateobject: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPipelineState1)(
            ::windows::core::Interface::as_raw(self),
            pstateobject.into_param().abi(),
        )
    }
    pub unsafe fn DispatchRays(&self, pdesc: *const D3D12_DISPATCH_RAYS_DESC) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .DispatchRays)(::windows::core::Interface::as_raw(self), pdesc)
    }
    pub unsafe fn RSSetShadingRate(
        &self,
        baseshadingrate: D3D12_SHADING_RATE,
        combiners: ::core::option::Option<*const D3D12_SHADING_RATE_COMBINER>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .RSSetShadingRate)(
            ::windows::core::Interface::as_raw(self),
            baseshadingrate,
            ::core::mem::transmute(combiners.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn RSSetShadingRateImage<P0>(&self, shadingrateimage: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .RSSetShadingRateImage)(
            ::windows::core::Interface::as_raw(self),
            shadingrateimage.into_param().abi(),
        )
    }
    pub unsafe fn DispatchMesh(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DispatchMesh)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn Barrier(&self, pbarriergroups: &[D3D12_BARRIER_GROUP]) {
        (::windows::core::Interface::vtable(self).base__.Barrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriergroups.len() as _,
            ::core::mem::transmute(pbarriergroups.as_ptr()),
        )
    }
    pub unsafe fn OMSetFrontAndBackStencilRef(&self, frontstencilref: u32, backstencilref: u32) {
        (::windows::core::Interface::vtable(self).OMSetFrontAndBackStencilRef)(
            ::windows::core::Interface::as_raw(self),
            frontstencilref,
            backstencilref,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandList8,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12GraphicsCommandList,
    ID3D12GraphicsCommandList1,
    ID3D12GraphicsCommandList2,
    ID3D12GraphicsCommandList3,
    ID3D12GraphicsCommandList4,
    ID3D12GraphicsCommandList5,
    ID3D12GraphicsCommandList6,
    ID3D12GraphicsCommandList7
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandList8 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandList8 {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandList8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandList8")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandList8 {
    type Vtable = ID3D12GraphicsCommandList8_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandList8 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandList8 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xee936ef9_599d_4d28_938e_23c4ad05ce51);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandList8_Vtbl {
    pub base__: ID3D12GraphicsCommandList7_Vtbl,
    pub OMSetFrontAndBackStencilRef: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        frontstencilref: u32,
        backstencilref: u32,
    ),
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandList9(::windows::core::IUnknown);
impl ID3D12GraphicsCommandList9 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self), primitivetopology
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetStencilRef)(::windows::core::Interface::as_raw(self), stencilref)
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT64<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT64)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn OMSetDepthBounds(&self, min: f32, max: f32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetDepthBounds)(::windows::core::Interface::as_raw(self), min, max)
    }
    pub unsafe fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetSamplePositions)(
            ::windows::core::Interface::as_raw(self),
            numsamplesperpixel,
            numpixels,
            psamplepositions,
        )
    }
    pub unsafe fn ResolveSubresourceRegion<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: P1,
        srcsubresource: u32,
        psrcrect: ::core::option::Option<*const ::windows::Win32::Foundation::RECT>,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresourceRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            dstx,
            dsty,
            psrcresource.into_param().abi(),
            srcsubresource,
            ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null())),
            format,
            resolvemode,
        )
    }
    pub unsafe fn SetViewInstanceMask(&self, mask: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetViewInstanceMask)(::windows::core::Interface::as_raw(self), mask)
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn BeginRenderPass(
        &self,
        prendertargets: ::core::option::Option<&[D3D12_RENDER_PASS_RENDER_TARGET_DESC]>,
        pdepthstencil: ::core::option::Option<*const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC>,
        flags: D3D12_RENDER_PASS_FLAGS,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginRenderPass)(
            ::windows::core::Interface::as_raw(self),
            prendertargets
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                prendertargets
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            ::core::mem::transmute(pdepthstencil.unwrap_or(::std::ptr::null())),
            flags,
        )
    }
    pub unsafe fn EndRenderPass(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndRenderPass)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn InitializeMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pinitializationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        initializationparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .InitializeMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pinitializationparametersdata.unwrap_or(::std::ptr::null())),
            initializationparametersdatasizeinbytes,
        )
    }
    pub unsafe fn ExecuteMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pexecutionparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        executionparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pexecutionparametersdata.unwrap_or(::std::ptr::null())),
            executionparametersdatasizeinbytes,
        )
    }
    pub unsafe fn BuildRaytracingAccelerationStructure(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC,
        ppostbuildinfodescs: ::core::option::Option<
            &[D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC],
        >,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .BuildRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ppostbuildinfodescs
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                ppostbuildinfodescs
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn EmitRaytracingAccelerationStructurePostbuildInfo(
        &self,
        pdesc: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
        psourceaccelerationstructuredata: &[u64],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .EmitRaytracingAccelerationStructurePostbuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            psourceaccelerationstructuredata.len() as _,
            ::core::mem::transmute(psourceaccelerationstructuredata.as_ptr()),
        )
    }
    pub unsafe fn CopyRaytracingAccelerationStructure(
        &self,
        destaccelerationstructuredata: u64,
        sourceaccelerationstructuredata: u64,
        mode: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            destaccelerationstructuredata,
            sourceaccelerationstructuredata,
            mode,
        )
    }
    pub unsafe fn SetPipelineState1<P0>(&self, pstateobject: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPipelineState1)(
            ::windows::core::Interface::as_raw(self),
            pstateobject.into_param().abi(),
        )
    }
    pub unsafe fn DispatchRays(&self, pdesc: *const D3D12_DISPATCH_RAYS_DESC) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .DispatchRays)(::windows::core::Interface::as_raw(self), pdesc)
    }
    pub unsafe fn RSSetShadingRate(
        &self,
        baseshadingrate: D3D12_SHADING_RATE,
        combiners: ::core::option::Option<*const D3D12_SHADING_RATE_COMBINER>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .RSSetShadingRate)(
            ::windows::core::Interface::as_raw(self),
            baseshadingrate,
            ::core::mem::transmute(combiners.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn RSSetShadingRateImage<P0>(&self, shadingrateimage: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .RSSetShadingRateImage)(
            ::windows::core::Interface::as_raw(self),
            shadingrateimage.into_param().abi(),
        )
    }
    pub unsafe fn DispatchMesh(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .DispatchMesh)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn Barrier(&self, pbarriergroups: &[D3D12_BARRIER_GROUP]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .Barrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriergroups.len() as _,
            ::core::mem::transmute(pbarriergroups.as_ptr()),
        )
    }
    pub unsafe fn OMSetFrontAndBackStencilRef(&self, frontstencilref: u32, backstencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .OMSetFrontAndBackStencilRef)(
            ::windows::core::Interface::as_raw(self),
            frontstencilref,
            backstencilref,
        )
    }
    pub unsafe fn RSSetDepthBias(
        &self,
        depthbias: f32,
        depthbiasclamp: f32,
        slopescaleddepthbias: f32,
    ) {
        (::windows::core::Interface::vtable(self).RSSetDepthBias)(
            ::windows::core::Interface::as_raw(self),
            depthbias,
            depthbiasclamp,
            slopescaleddepthbias,
        )
    }
    pub unsafe fn IASetIndexBufferStripCutValue(
        &self,
        ibstripcutvalue: D3D12_INDEX_BUFFER_STRIP_CUT_VALUE,
    ) {
        (::windows::core::Interface::vtable(self).IASetIndexBufferStripCutValue)(
            ::windows::core::Interface::as_raw(self),
            ibstripcutvalue,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandList9,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12GraphicsCommandList,
    ID3D12GraphicsCommandList1,
    ID3D12GraphicsCommandList2,
    ID3D12GraphicsCommandList3,
    ID3D12GraphicsCommandList4,
    ID3D12GraphicsCommandList5,
    ID3D12GraphicsCommandList6,
    ID3D12GraphicsCommandList7,
    ID3D12GraphicsCommandList8
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandList9 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandList9 {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandList9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandList9")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandList9 {
    type Vtable = ID3D12GraphicsCommandList9_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandList9 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandList9 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x34ed2808_ffe6_4c2b_b11a_cabd2b0c59e1);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandList9_Vtbl {
    pub base__: ID3D12GraphicsCommandList8_Vtbl,
    pub RSSetDepthBias: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        depthbias: f32,
        depthbiasclamp: f32,
        slopescaleddepthbias: f32,
    ),
    pub IASetIndexBufferStripCutValue: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ibstripcutvalue: D3D12_INDEX_BUFFER_STRIP_CUT_VALUE,
    ),
}
#[repr(transparent)]
pub struct ID3D12GraphicsCommandListExperimental(::windows::core::IUnknown);
impl ID3D12GraphicsCommandListExperimental {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0, P1>(
        &self,
        pallocator: P0,
        pinitialstate: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
            pinitialstate.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawInstanced)(
            ::windows::core::Interface::as_raw(self),
            vertexcountperinstance,
            instancecount,
            startvertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DrawIndexedInstanced)(
            ::windows::core::Interface::as_raw(self),
            indexcountperinstance,
            instancecount,
            startindexlocation,
            basevertexlocation,
            startinstancelocation,
        )
    }
    pub unsafe fn Dispatch(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .Dispatch)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn CopyBufferRegion<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        numbytes: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyBufferRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            numbytes,
        )
    }
    pub unsafe fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTextureRegion)(
            ::windows::core::Interface::as_raw(self),
            pdst,
            dstx,
            dsty,
            dstz,
            psrc,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn CopyResource<P0, P1>(&self, pdstresource: P0, psrcresource: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyResource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            psrcresource.into_param().abi(),
        )
    }
    pub unsafe fn CopyTiles<P0, P1>(
        &self,
        ptiledresource: P0,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: P1,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyTiles)(
            ::windows::core::Interface::as_raw(self),
            ptiledresource.into_param().abi(),
            ptileregionstartcoordinate,
            ptileregionsize,
            pbuffer.into_param().abi(),
            bufferstartoffsetinbytes,
            flags,
        )
    }
    pub unsafe fn ResolveSubresource<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        psrcresource: P1,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            psrcresource.into_param().abi(),
            srcsubresource,
            format,
        )
    }
    pub unsafe fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetPrimitiveTopology)(
            ::windows::core::Interface::as_raw(self), primitivetopology
        )
    }
    pub unsafe fn RSSetViewports(&self, pviewports: &[D3D12_VIEWPORT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetViewports)(
            ::windows::core::Interface::as_raw(self),
            pviewports.len() as _,
            ::core::mem::transmute(pviewports.as_ptr()),
        )
    }
    pub unsafe fn RSSetScissorRects(&self, prects: &[::windows::Win32::Foundation::RECT]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetScissorRects)(
            ::windows::core::Interface::as_raw(self),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn OMSetBlendFactor(&self, blendfactor: ::core::option::Option<&[f32; 4]>) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetBlendFactor)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(
                blendfactor
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetStencilRef(&self, stencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetStencilRef)(::windows::core::Interface::as_raw(self), stencilref)
    }
    pub unsafe fn SetPipelineState<P0>(&self, ppipelinestate: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPipelineState)(
            ::windows::core::Interface::as_raw(self),
            ppipelinestate.into_param().abi(),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn ExecuteBundle<P0>(&self, pcommandlist: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12GraphicsCommandList>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteBundle)(
            ::windows::core::Interface::as_raw(self),
            pcommandlist.into_param().abi(),
        )
    }
    pub unsafe fn SetDescriptorHeaps(
        &self,
        ppdescriptorheaps: &[::core::option::Option<ID3D12DescriptorHeap>],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetDescriptorHeaps)(
            ::windows::core::Interface::as_raw(self),
            ppdescriptorheaps.len() as _,
            ::core::mem::transmute(ppdescriptorheaps.as_ptr()),
        )
    }
    pub unsafe fn SetComputeRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetGraphicsRootSignature<P0>(&self, prootsignature: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12RootSignature>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootSignature)(
            ::windows::core::Interface::as_raw(self),
            prootsignature.into_param().abi(),
        )
    }
    pub unsafe fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootDescriptorTable)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            ::core::mem::transmute(basedescriptor),
        )
    }
    pub unsafe fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstant)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            srcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRoot32BitConstants)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            num32bitvaluestoset,
            psrcdata,
            destoffsetin32bitvalues,
        )
    }
    pub unsafe fn SetComputeRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootConstantBufferView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootConstantBufferView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootShaderResourceView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootShaderResourceView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetComputeRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetComputeRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn SetGraphicsRootUnorderedAccessView(
        &self,
        rootparameterindex: u32,
        bufferlocation: u64,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetGraphicsRootUnorderedAccessView)(
            ::windows::core::Interface::as_raw(self),
            rootparameterindex,
            bufferlocation,
        )
    }
    pub unsafe fn IASetIndexBuffer(
        &self,
        pview: ::core::option::Option<*const D3D12_INDEX_BUFFER_VIEW>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetIndexBuffer)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pview.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn IASetVertexBuffers(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_VERTEX_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .IASetVertexBuffers)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn SOSetTargets(
        &self,
        startslot: u32,
        pviews: ::core::option::Option<&[D3D12_STREAM_OUTPUT_BUFFER_VIEW]>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SOSetTargets)(
            ::windows::core::Interface::as_raw(self),
            startslot,
            pviews.as_deref().map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                pviews
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn OMSetRenderTargets<P0>(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
        rtssinglehandletodescriptorrange: P0,
        pdepthstencildescriptor: ::core::option::Option<*const D3D12_CPU_DESCRIPTOR_HANDLE>,
    ) where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetRenderTargets)(
            ::windows::core::Interface::as_raw(self),
            numrendertargetdescriptors,
            ::core::mem::transmute(prendertargetdescriptors.unwrap_or(::std::ptr::null())),
            rtssinglehandletodescriptorrange.into_param().abi(),
            ::core::mem::transmute(pdepthstencildescriptor.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ClearDepthStencilView(
        &self,
        depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearDepthStencilView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(depthstencilview),
            clearflags,
            depth,
            stencil,
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearRenderTargetView(
        &self,
        rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearRenderTargetView)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(rendertargetview),
            ::core::mem::transmute(colorrgba.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewUint<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[u32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewUint)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn ClearUnorderedAccessViewFloat<P0>(
        &self,
        viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: P0,
        values: &[f32; 4],
        prects: &[::windows::Win32::Foundation::RECT],
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ClearUnorderedAccessViewFloat)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(viewgpuhandleincurrentheap),
            ::core::mem::transmute(viewcpuhandle),
            presource.into_param().abi(),
            ::core::mem::transmute(values.as_ptr()),
            prects.len() as _,
            ::core::mem::transmute(prects.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ExecuteIndirect<P0, P1, P2>(
        &self,
        pcommandsignature: P0,
        maxcommandcount: u32,
        pargumentbuffer: P1,
        argumentbufferoffset: u64,
        pcountbuffer: P2,
        countbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12CommandSignature>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
        P2: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteIndirect)(
            ::windows::core::Interface::as_raw(self),
            pcommandsignature.into_param().abi(),
            maxcommandcount,
            pargumentbuffer.into_param().abi(),
            argumentbufferoffset,
            pcountbuffer.into_param().abi(),
            countbufferoffset,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn AtomicCopyBufferUINT64<P0, P1>(
        &self,
        pdstbuffer: P0,
        dstoffset: u64,
        psrcbuffer: P1,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .AtomicCopyBufferUINT64)(
            ::windows::core::Interface::as_raw(self),
            pdstbuffer.into_param().abi(),
            dstoffset,
            psrcbuffer.into_param().abi(),
            srcoffset,
            dependencies,
            ::core::mem::transmute(ppdependentresources),
            pdependentsubresourceranges,
        )
    }
    pub unsafe fn OMSetDepthBounds(&self, min: f32, max: f32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .OMSetDepthBounds)(::windows::core::Interface::as_raw(self), min, max)
    }
    pub unsafe fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetSamplePositions)(
            ::windows::core::Interface::as_raw(self),
            numsamplesperpixel,
            numpixels,
            psamplepositions,
        )
    }
    pub unsafe fn ResolveSubresourceRegion<P0, P1>(
        &self,
        pdstresource: P0,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: P1,
        srcsubresource: u32,
        psrcrect: ::core::option::Option<*const ::windows::Win32::Foundation::RECT>,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ResolveSubresourceRegion)(
            ::windows::core::Interface::as_raw(self),
            pdstresource.into_param().abi(),
            dstsubresource,
            dstx,
            dsty,
            psrcresource.into_param().abi(),
            srcsubresource,
            ::core::mem::transmute(psrcrect.unwrap_or(::std::ptr::null())),
            format,
            resolvemode,
        )
    }
    pub unsafe fn SetViewInstanceMask(&self, mask: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetViewInstanceMask)(::windows::core::Interface::as_raw(self), mask)
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn BeginRenderPass(
        &self,
        prendertargets: ::core::option::Option<&[D3D12_RENDER_PASS_RENDER_TARGET_DESC]>,
        pdepthstencil: ::core::option::Option<*const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC>,
        flags: D3D12_RENDER_PASS_FLAGS,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BeginRenderPass)(
            ::windows::core::Interface::as_raw(self),
            prendertargets
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                prendertargets
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
            ::core::mem::transmute(pdepthstencil.unwrap_or(::std::ptr::null())),
            flags,
        )
    }
    pub unsafe fn EndRenderPass(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EndRenderPass)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn InitializeMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pinitializationparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        initializationparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .InitializeMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pinitializationparametersdata.unwrap_or(::std::ptr::null())),
            initializationparametersdatasizeinbytes,
        )
    }
    pub unsafe fn ExecuteMetaCommand<P0>(
        &self,
        pmetacommand: P0,
        pexecutionparametersdata: ::core::option::Option<*const ::core::ffi::c_void>,
        executionparametersdatasizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12MetaCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .ExecuteMetaCommand)(
            ::windows::core::Interface::as_raw(self),
            pmetacommand.into_param().abi(),
            ::core::mem::transmute(pexecutionparametersdata.unwrap_or(::std::ptr::null())),
            executionparametersdatasizeinbytes,
        )
    }
    pub unsafe fn BuildRaytracingAccelerationStructure(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC,
        ppostbuildinfodescs: ::core::option::Option<
            &[D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC],
        >,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .BuildRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            ppostbuildinfodescs
                .as_deref()
                .map_or(0, |slice| slice.len() as _),
            ::core::mem::transmute(
                ppostbuildinfodescs
                    .as_deref()
                    .map_or(::core::ptr::null(), |slice| slice.as_ptr()),
            ),
        )
    }
    pub unsafe fn EmitRaytracingAccelerationStructurePostbuildInfo(
        &self,
        pdesc: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
        psourceaccelerationstructuredata: &[u64],
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .EmitRaytracingAccelerationStructurePostbuildInfo)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            psourceaccelerationstructuredata.len() as _,
            ::core::mem::transmute(psourceaccelerationstructuredata.as_ptr()),
        )
    }
    pub unsafe fn CopyRaytracingAccelerationStructure(
        &self,
        destaccelerationstructuredata: u64,
        sourceaccelerationstructuredata: u64,
        mode: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .CopyRaytracingAccelerationStructure)(
            ::windows::core::Interface::as_raw(self),
            destaccelerationstructuredata,
            sourceaccelerationstructuredata,
            mode,
        )
    }
    pub unsafe fn SetPipelineState1<P0>(&self, pstateobject: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12StateObject>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPipelineState1)(
            ::windows::core::Interface::as_raw(self),
            pstateobject.into_param().abi(),
        )
    }
    pub unsafe fn DispatchRays(&self, pdesc: *const D3D12_DISPATCH_RAYS_DESC) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .DispatchRays)(::windows::core::Interface::as_raw(self), pdesc)
    }
    pub unsafe fn RSSetShadingRate(
        &self,
        baseshadingrate: D3D12_SHADING_RATE,
        combiners: ::core::option::Option<*const D3D12_SHADING_RATE_COMBINER>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetShadingRate)(
            ::windows::core::Interface::as_raw(self),
            baseshadingrate,
            ::core::mem::transmute(combiners.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn RSSetShadingRateImage<P0>(&self, shadingrateimage: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .RSSetShadingRateImage)(
            ::windows::core::Interface::as_raw(self),
            shadingrateimage.into_param().abi(),
        )
    }
    pub unsafe fn DispatchMesh(
        &self,
        threadgroupcountx: u32,
        threadgroupcounty: u32,
        threadgroupcountz: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .DispatchMesh)(
            ::windows::core::Interface::as_raw(self),
            threadgroupcountx,
            threadgroupcounty,
            threadgroupcountz,
        )
    }
    pub unsafe fn Barrier(&self, pbarriergroups: &[D3D12_BARRIER_GROUP]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Barrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriergroups.len() as _,
            ::core::mem::transmute(pbarriergroups.as_ptr()),
        )
    }
    pub unsafe fn OMSetFrontAndBackStencilRef(&self, frontstencilref: u32, backstencilref: u32) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .OMSetFrontAndBackStencilRef)(
            ::windows::core::Interface::as_raw(self),
            frontstencilref,
            backstencilref,
        )
    }
    pub unsafe fn RSSetDepthBias(
        &self,
        depthbias: f32,
        depthbiasclamp: f32,
        slopescaleddepthbias: f32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .RSSetDepthBias)(
            ::windows::core::Interface::as_raw(self),
            depthbias,
            depthbiasclamp,
            slopescaleddepthbias,
        )
    }
    pub unsafe fn IASetIndexBufferStripCutValue(
        &self,
        ibstripcutvalue: D3D12_INDEX_BUFFER_STRIP_CUT_VALUE,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .IASetIndexBufferStripCutValue)(
            ::windows::core::Interface::as_raw(self),
            ibstripcutvalue,
        )
    }
    pub unsafe fn SetProgram(&self, pdesc: *const D3D12_SET_PROGRAM_DESC) {
        (::windows::core::Interface::vtable(self).SetProgram)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
        )
    }
    pub unsafe fn DispatchGraph(&self, pdesc: *const D3D12_DISPATCH_GRAPH_DESC) {
        (::windows::core::Interface::vtable(self).DispatchGraph)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12GraphicsCommandListExperimental,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12GraphicsCommandList,
    ID3D12GraphicsCommandList1,
    ID3D12GraphicsCommandList2,
    ID3D12GraphicsCommandList3,
    ID3D12GraphicsCommandList4,
    ID3D12GraphicsCommandList5,
    ID3D12GraphicsCommandList6,
    ID3D12GraphicsCommandList7,
    ID3D12GraphicsCommandList8,
    ID3D12GraphicsCommandList9
);
impl ::core::cmp::PartialEq for ID3D12GraphicsCommandListExperimental {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12GraphicsCommandListExperimental {}
impl ::core::fmt::Debug for ID3D12GraphicsCommandListExperimental {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12GraphicsCommandListExperimental")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12GraphicsCommandListExperimental {
    type Vtable = ID3D12GraphicsCommandListExperimental_Vtbl;
}
impl ::core::clone::Clone for ID3D12GraphicsCommandListExperimental {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12GraphicsCommandListExperimental {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x7013c015_d161_4b63_a08c_238552dd8acc);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12GraphicsCommandListExperimental_Vtbl {
    pub base__: ID3D12GraphicsCommandList9_Vtbl,
    pub SetProgram: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_SET_PROGRAM_DESC,
    ),
    pub DispatchGraph: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_DISPATCH_GRAPH_DESC,
    ),
}
#[repr(transparent)]
pub struct ID3D12Heap(::windows::core::IUnknown);
impl ID3D12Heap {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_HEAP_DESC {
        let mut result__: D3D12_HEAP_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Heap,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12Heap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Heap {}
impl ::core::fmt::Debug for ID3D12Heap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Heap").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Heap {
    type Vtable = ID3D12Heap_Vtbl;
}
impl ::core::clone::Clone for ID3D12Heap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Heap {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x6b3b2502_6e51_45b3_90ee_9884265e8df3);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Heap_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetDesc:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, result__: *mut D3D12_HEAP_DESC),
}
#[repr(transparent)]
pub struct ID3D12Heap1(::windows::core::IUnknown);
impl ID3D12Heap1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_HEAP_DESC {
        let mut result__: D3D12_HEAP_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).base__.GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Heap1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable,
    ID3D12Heap
);
impl ::core::cmp::PartialEq for ID3D12Heap1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Heap1 {}
impl ::core::fmt::Debug for ID3D12Heap1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Heap1").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Heap1 {
    type Vtable = ID3D12Heap1_Vtbl;
}
impl ::core::clone::Clone for ID3D12Heap1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Heap1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x572f7389_2168_49e3_9693_d6df5871bf6d);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Heap1_Vtbl {
    pub base__: ID3D12Heap_Vtbl,
    pub GetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12InfoQueue(::windows::core::IUnknown);
impl ID3D12InfoQueue {
    pub unsafe fn SetMessageCountLimit(
        &self,
        messagecountlimit: u64,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetMessageCountLimit)(
            ::windows::core::Interface::as_raw(self),
            messagecountlimit,
        )
        .ok()
    }
    pub unsafe fn ClearStoredMessages(&self) {
        (::windows::core::Interface::vtable(self).ClearStoredMessages)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetMessageA(
        &self,
        messageindex: u64,
        pmessage: ::core::option::Option<*mut D3D12_MESSAGE>,
        pmessagebytelength: *mut usize,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetMessageA)(
            ::windows::core::Interface::as_raw(self),
            messageindex,
            ::core::mem::transmute(pmessage.unwrap_or(::std::ptr::null_mut())),
            pmessagebytelength,
        )
        .ok()
    }
    pub unsafe fn GetNumMessagesAllowedByStorageFilter(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetNumMessagesAllowedByStorageFilter)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetNumMessagesDeniedByStorageFilter(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetNumMessagesDeniedByStorageFilter)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetNumStoredMessages(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetNumStoredMessages)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetNumStoredMessagesAllowedByRetrievalFilter(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetNumStoredMessagesAllowedByRetrievalFilter)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetNumMessagesDiscardedByMessageCountLimit(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetNumMessagesDiscardedByMessageCountLimit)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetMessageCountLimit(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetMessageCountLimit)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn AddStorageFilterEntries(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddStorageFilterEntries)(
            ::windows::core::Interface::as_raw(self),
            pfilter,
        )
        .ok()
    }
    pub unsafe fn GetStorageFilter(
        &self,
        pfilter: ::core::option::Option<*mut D3D12_INFO_QUEUE_FILTER>,
        pfilterbytelength: *mut usize,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetStorageFilter)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pfilter.unwrap_or(::std::ptr::null_mut())),
            pfilterbytelength,
        )
        .ok()
    }
    pub unsafe fn ClearStorageFilter(&self) {
        (::windows::core::Interface::vtable(self).ClearStorageFilter)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn PushEmptyStorageFilter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).PushEmptyStorageFilter)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn PushCopyOfStorageFilter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).PushCopyOfStorageFilter)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn PushStorageFilter(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).PushStorageFilter)(
            ::windows::core::Interface::as_raw(self),
            pfilter,
        )
        .ok()
    }
    pub unsafe fn PopStorageFilter(&self) {
        (::windows::core::Interface::vtable(self).PopStorageFilter)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetStorageFilterStackSize(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetStorageFilterStackSize)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn AddRetrievalFilterEntries(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).AddRetrievalFilterEntries)(
            ::windows::core::Interface::as_raw(self),
            pfilter,
        )
        .ok()
    }
    pub unsafe fn GetRetrievalFilter(
        &self,
        pfilter: ::core::option::Option<*mut D3D12_INFO_QUEUE_FILTER>,
        pfilterbytelength: *mut usize,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetRetrievalFilter)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pfilter.unwrap_or(::std::ptr::null_mut())),
            pfilterbytelength,
        )
        .ok()
    }
    pub unsafe fn ClearRetrievalFilter(&self) {
        (::windows::core::Interface::vtable(self).ClearRetrievalFilter)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn PushEmptyRetrievalFilter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).PushEmptyRetrievalFilter)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn PushCopyOfRetrievalFilter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).PushCopyOfRetrievalFilter)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn PushRetrievalFilter(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).PushRetrievalFilter)(
            ::windows::core::Interface::as_raw(self),
            pfilter,
        )
        .ok()
    }
    pub unsafe fn PopRetrievalFilter(&self) {
        (::windows::core::Interface::vtable(self).PopRetrievalFilter)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetRetrievalFilterStackSize(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetRetrievalFilterStackSize)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn AddMessage<P0>(
        &self,
        category: D3D12_MESSAGE_CATEGORY,
        severity: D3D12_MESSAGE_SEVERITY,
        id: D3D12_MESSAGE_ID,
        pdescription: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).AddMessage)(
            ::windows::core::Interface::as_raw(self),
            category,
            severity,
            id,
            pdescription.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn AddApplicationMessage<P0>(
        &self,
        severity: D3D12_MESSAGE_SEVERITY,
        pdescription: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).AddApplicationMessage)(
            ::windows::core::Interface::as_raw(self),
            severity,
            pdescription.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetBreakOnCategory<P0>(
        &self,
        category: D3D12_MESSAGE_CATEGORY,
        benable: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetBreakOnCategory)(
            ::windows::core::Interface::as_raw(self),
            category,
            benable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetBreakOnSeverity<P0>(
        &self,
        severity: D3D12_MESSAGE_SEVERITY,
        benable: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetBreakOnSeverity)(
            ::windows::core::Interface::as_raw(self),
            severity,
            benable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetBreakOnID<P0>(
        &self,
        id: D3D12_MESSAGE_ID,
        benable: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetBreakOnID)(
            ::windows::core::Interface::as_raw(self),
            id,
            benable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetBreakOnCategory(
        &self,
        category: D3D12_MESSAGE_CATEGORY,
    ) -> ::windows::Win32::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).GetBreakOnCategory)(
            ::windows::core::Interface::as_raw(self),
            category,
        )
    }
    pub unsafe fn GetBreakOnSeverity(
        &self,
        severity: D3D12_MESSAGE_SEVERITY,
    ) -> ::windows::Win32::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).GetBreakOnSeverity)(
            ::windows::core::Interface::as_raw(self),
            severity,
        )
    }
    pub unsafe fn GetBreakOnID(&self, id: D3D12_MESSAGE_ID) -> ::windows::Win32::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).GetBreakOnID)(
            ::windows::core::Interface::as_raw(self),
            id,
        )
    }
    pub unsafe fn SetMuteDebugOutput<P0>(&self, bmute: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).SetMuteDebugOutput)(
            ::windows::core::Interface::as_raw(self),
            bmute.into_param().abi(),
        )
    }
    pub unsafe fn GetMuteDebugOutput(&self) -> ::windows::Win32::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).GetMuteDebugOutput)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12InfoQueue, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12InfoQueue {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12InfoQueue {}
impl ::core::fmt::Debug for ID3D12InfoQueue {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12InfoQueue").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12InfoQueue {
    type Vtable = ID3D12InfoQueue_Vtbl;
}
impl ::core::clone::Clone for ID3D12InfoQueue {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12InfoQueue {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x0742a90b_c387_483f_b946_30a7e4e61458);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12InfoQueue_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetMessageCountLimit: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        messagecountlimit: u64,
    ) -> ::windows::core::HRESULT,
    pub ClearStoredMessages: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub GetMessageA: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        messageindex: u64,
        pmessage: *mut D3D12_MESSAGE,
        pmessagebytelength: *mut usize,
    ) -> ::windows::core::HRESULT,
    pub GetNumMessagesAllowedByStorageFilter:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub GetNumMessagesDeniedByStorageFilter:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub GetNumStoredMessages: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub GetNumStoredMessagesAllowedByRetrievalFilter:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub GetNumMessagesDiscardedByMessageCountLimit:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub GetMessageCountLimit: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub AddStorageFilterEntries: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::HRESULT,
    pub GetStorageFilter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfilter: *mut D3D12_INFO_QUEUE_FILTER,
        pfilterbytelength: *mut usize,
    ) -> ::windows::core::HRESULT,
    pub ClearStorageFilter: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub PushEmptyStorageFilter:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub PushCopyOfStorageFilter:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub PushStorageFilter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::HRESULT,
    pub PopStorageFilter: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub GetStorageFilterStackSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub AddRetrievalFilterEntries: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::HRESULT,
    pub GetRetrievalFilter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfilter: *mut D3D12_INFO_QUEUE_FILTER,
        pfilterbytelength: *mut usize,
    ) -> ::windows::core::HRESULT,
    pub ClearRetrievalFilter: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub PushEmptyRetrievalFilter:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub PushCopyOfRetrievalFilter:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub PushRetrievalFilter: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::HRESULT,
    pub PopRetrievalFilter: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub GetRetrievalFilterStackSize:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub AddMessage: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        category: D3D12_MESSAGE_CATEGORY,
        severity: D3D12_MESSAGE_SEVERITY,
        id: D3D12_MESSAGE_ID,
        pdescription: ::windows::core::PCSTR,
    ) -> ::windows::core::HRESULT,
    pub AddApplicationMessage: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        severity: D3D12_MESSAGE_SEVERITY,
        pdescription: ::windows::core::PCSTR,
    ) -> ::windows::core::HRESULT,
    pub SetBreakOnCategory: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        category: D3D12_MESSAGE_CATEGORY,
        benable: ::windows::Win32::Foundation::BOOL,
    ) -> ::windows::core::HRESULT,
    pub SetBreakOnSeverity: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        severity: D3D12_MESSAGE_SEVERITY,
        benable: ::windows::Win32::Foundation::BOOL,
    ) -> ::windows::core::HRESULT,
    pub SetBreakOnID: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        id: D3D12_MESSAGE_ID,
        benable: ::windows::Win32::Foundation::BOOL,
    ) -> ::windows::core::HRESULT,
    pub GetBreakOnCategory: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        category: D3D12_MESSAGE_CATEGORY,
    ) -> ::windows::Win32::Foundation::BOOL,
    pub GetBreakOnSeverity: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        severity: D3D12_MESSAGE_SEVERITY,
    ) -> ::windows::Win32::Foundation::BOOL,
    pub GetBreakOnID: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        id: D3D12_MESSAGE_ID,
    ) -> ::windows::Win32::Foundation::BOOL,
    pub SetMuteDebugOutput: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        bmute: ::windows::Win32::Foundation::BOOL,
    ),
    pub GetMuteDebugOutput: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
    ) -> ::windows::Win32::Foundation::BOOL,
}
#[repr(transparent)]
pub struct ID3D12InfoQueue1(::windows::core::IUnknown);
impl ID3D12InfoQueue1 {
    pub unsafe fn SetMessageCountLimit(
        &self,
        messagecountlimit: u64,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetMessageCountLimit)(
            ::windows::core::Interface::as_raw(self), messagecountlimit
        )
        .ok()
    }
    pub unsafe fn ClearStoredMessages(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ClearStoredMessages)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetMessageA(
        &self,
        messageindex: u64,
        pmessage: ::core::option::Option<*mut D3D12_MESSAGE>,
        pmessagebytelength: *mut usize,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.GetMessageA)(
            ::windows::core::Interface::as_raw(self),
            messageindex,
            ::core::mem::transmute(pmessage.unwrap_or(::std::ptr::null_mut())),
            pmessagebytelength,
        )
        .ok()
    }
    pub unsafe fn GetNumMessagesAllowedByStorageFilter(&self) -> u64 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetNumMessagesAllowedByStorageFilter)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetNumMessagesDeniedByStorageFilter(&self) -> u64 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetNumMessagesDeniedByStorageFilter)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetNumStoredMessages(&self) -> u64 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetNumStoredMessages)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetNumStoredMessagesAllowedByRetrievalFilter(&self) -> u64 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetNumStoredMessagesAllowedByRetrievalFilter)(
            ::windows::core::Interface::as_raw(self)
        )
    }
    pub unsafe fn GetNumMessagesDiscardedByMessageCountLimit(&self) -> u64 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetNumMessagesDiscardedByMessageCountLimit)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetMessageCountLimit(&self) -> u64 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetMessageCountLimit)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn AddStorageFilterEntries(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .AddStorageFilterEntries)(::windows::core::Interface::as_raw(self), pfilter)
        .ok()
    }
    pub unsafe fn GetStorageFilter(
        &self,
        pfilter: ::core::option::Option<*mut D3D12_INFO_QUEUE_FILTER>,
        pfilterbytelength: *mut usize,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetStorageFilter)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pfilter.unwrap_or(::std::ptr::null_mut())),
            pfilterbytelength,
        )
        .ok()
    }
    pub unsafe fn ClearStorageFilter(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ClearStorageFilter)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn PushEmptyStorageFilter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .PushEmptyStorageFilter)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn PushCopyOfStorageFilter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .PushCopyOfStorageFilter)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn PushStorageFilter(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .PushStorageFilter)(::windows::core::Interface::as_raw(self), pfilter)
        .ok()
    }
    pub unsafe fn PopStorageFilter(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .PopStorageFilter)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetStorageFilterStackSize(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetStorageFilterStackSize)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn AddRetrievalFilterEntries(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .AddRetrievalFilterEntries)(::windows::core::Interface::as_raw(self), pfilter)
        .ok()
    }
    pub unsafe fn GetRetrievalFilter(
        &self,
        pfilter: ::core::option::Option<*mut D3D12_INFO_QUEUE_FILTER>,
        pfilterbytelength: *mut usize,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetRetrievalFilter)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pfilter.unwrap_or(::std::ptr::null_mut())),
            pfilterbytelength,
        )
        .ok()
    }
    pub unsafe fn ClearRetrievalFilter(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ClearRetrievalFilter)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn PushEmptyRetrievalFilter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .PushEmptyRetrievalFilter)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn PushCopyOfRetrievalFilter(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .PushCopyOfRetrievalFilter)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn PushRetrievalFilter(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .PushRetrievalFilter)(::windows::core::Interface::as_raw(self), pfilter)
        .ok()
    }
    pub unsafe fn PopRetrievalFilter(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .PopRetrievalFilter)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetRetrievalFilterStackSize(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetRetrievalFilterStackSize)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn AddMessage<P0>(
        &self,
        category: D3D12_MESSAGE_CATEGORY,
        severity: D3D12_MESSAGE_SEVERITY,
        id: D3D12_MESSAGE_ID,
        pdescription: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).base__.AddMessage)(
            ::windows::core::Interface::as_raw(self),
            category,
            severity,
            id,
            pdescription.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn AddApplicationMessage<P0>(
        &self,
        severity: D3D12_MESSAGE_SEVERITY,
        pdescription: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .AddApplicationMessage)(
            ::windows::core::Interface::as_raw(self),
            severity,
            pdescription.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetBreakOnCategory<P0>(
        &self,
        category: D3D12_MESSAGE_CATEGORY,
        benable: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetBreakOnCategory)(
            ::windows::core::Interface::as_raw(self),
            category,
            benable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetBreakOnSeverity<P0>(
        &self,
        severity: D3D12_MESSAGE_SEVERITY,
        benable: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetBreakOnSeverity)(
            ::windows::core::Interface::as_raw(self),
            severity,
            benable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetBreakOnID<P0>(
        &self,
        id: D3D12_MESSAGE_ID,
        benable: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).base__.SetBreakOnID)(
            ::windows::core::Interface::as_raw(self),
            id,
            benable.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetBreakOnCategory(
        &self,
        category: D3D12_MESSAGE_CATEGORY,
    ) -> ::windows::Win32::Foundation::BOOL {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetBreakOnCategory)(::windows::core::Interface::as_raw(self), category)
    }
    pub unsafe fn GetBreakOnSeverity(
        &self,
        severity: D3D12_MESSAGE_SEVERITY,
    ) -> ::windows::Win32::Foundation::BOOL {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetBreakOnSeverity)(::windows::core::Interface::as_raw(self), severity)
    }
    pub unsafe fn GetBreakOnID(&self, id: D3D12_MESSAGE_ID) -> ::windows::Win32::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).base__.GetBreakOnID)(
            ::windows::core::Interface::as_raw(self),
            id,
        )
    }
    pub unsafe fn SetMuteDebugOutput<P0>(&self, bmute: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetMuteDebugOutput)(
            ::windows::core::Interface::as_raw(self),
            bmute.into_param().abi(),
        )
    }
    pub unsafe fn GetMuteDebugOutput(&self) -> ::windows::Win32::Foundation::BOOL {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetMuteDebugOutput)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn RegisterMessageCallback(
        &self,
        callbackfunc: ::windows::Win32::Graphics::Direct3D12::D3D12MessageFunc,
        callbackfilterflags: D3D12_MESSAGE_CALLBACK_FLAGS,
        pcontext: *const ::core::ffi::c_void,
        pcallbackcookie: *mut u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).RegisterMessageCallback)(
            ::windows::core::Interface::as_raw(self),
            callbackfunc,
            callbackfilterflags,
            pcontext,
            pcallbackcookie,
        )
        .ok()
    }
    pub unsafe fn UnregisterMessageCallback(
        &self,
        callbackcookie: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnregisterMessageCallback)(
            ::windows::core::Interface::as_raw(self),
            callbackcookie,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12InfoQueue1, ::windows::core::IUnknown, ID3D12InfoQueue);
impl ::core::cmp::PartialEq for ID3D12InfoQueue1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12InfoQueue1 {}
impl ::core::fmt::Debug for ID3D12InfoQueue1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12InfoQueue1").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12InfoQueue1 {
    type Vtable = ID3D12InfoQueue1_Vtbl;
}
impl ::core::clone::Clone for ID3D12InfoQueue1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12InfoQueue1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x2852dd88_b484_4c0c_b6b1_67168500e600);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12InfoQueue1_Vtbl {
    pub base__: ID3D12InfoQueue_Vtbl,
    pub RegisterMessageCallback: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        callbackfunc: ::windows::Win32::Graphics::Direct3D12::D3D12MessageFunc,
        callbackfilterflags: D3D12_MESSAGE_CALLBACK_FLAGS,
        pcontext: *const ::core::ffi::c_void,
        pcallbackcookie: *mut u32,
    ) -> ::windows::core::HRESULT,
    pub UnregisterMessageCallback: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        callbackcookie: u32,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12LibraryReflection(::windows::core::IUnknown);
impl ID3D12LibraryReflection {
    pub unsafe fn GetDesc(&self) -> ::windows::core::Result<D3D12_LIBRARY_DESC> {
        let mut result__ = ::windows::core::zeroed::<D3D12_LIBRARY_DESC>();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetFunctionByIndex(
        &self,
        functionindex: i32,
    ) -> ::core::option::Option<ID3D12FunctionReflection> {
        (::windows::core::Interface::vtable(self).GetFunctionByIndex)(
            ::windows::core::Interface::as_raw(self),
            functionindex,
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12LibraryReflection, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12LibraryReflection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12LibraryReflection {}
impl ::core::fmt::Debug for ID3D12LibraryReflection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12LibraryReflection")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12LibraryReflection {
    type Vtable = ID3D12LibraryReflection_Vtbl;
}
impl ::core::clone::Clone for ID3D12LibraryReflection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12LibraryReflection {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x8e349d19_54db_4a56_9dc9_119d87bdb804);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12LibraryReflection_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *mut D3D12_LIBRARY_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetFunctionByIndex:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
            functionindex: i32,
        ) -> ::core::option::Option<ID3D12FunctionReflection>,
}
#[repr(transparent)]
pub struct ID3D12LifetimeOwner(::windows::core::IUnknown);
impl ID3D12LifetimeOwner {
    pub unsafe fn LifetimeStateUpdated(&self, newstate: D3D12_LIFETIME_STATE) {
        (::windows::core::Interface::vtable(self).LifetimeStateUpdated)(
            ::windows::core::Interface::as_raw(self),
            newstate,
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12LifetimeOwner, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12LifetimeOwner {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12LifetimeOwner {}
impl ::core::fmt::Debug for ID3D12LifetimeOwner {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12LifetimeOwner").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12LifetimeOwner {
    type Vtable = ID3D12LifetimeOwner_Vtbl;
}
impl ::core::clone::Clone for ID3D12LifetimeOwner {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12LifetimeOwner {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xe667af9f_cd56_4f46_83ce_032e595d70a8);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12LifetimeOwner_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub LifetimeStateUpdated:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, newstate: D3D12_LIFETIME_STATE),
}
#[repr(transparent)]
pub struct ID3D12LifetimeTracker(::windows::core::IUnknown);
impl ID3D12LifetimeTracker {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn DestroyOwnedObject<P0>(&self, pobject: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
    {
        (::windows::core::Interface::vtable(self).DestroyOwnedObject)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12LifetimeTracker,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild
);
impl ::core::cmp::PartialEq for ID3D12LifetimeTracker {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12LifetimeTracker {}
impl ::core::fmt::Debug for ID3D12LifetimeTracker {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12LifetimeTracker")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12LifetimeTracker {
    type Vtable = ID3D12LifetimeTracker_Vtbl;
}
impl ::core::clone::Clone for ID3D12LifetimeTracker {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12LifetimeTracker {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x3fd03d36_4eb1_424a_a582_494ecb8ba813);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12LifetimeTracker_Vtbl {
    pub base__: ID3D12DeviceChild_Vtbl,
    pub DestroyOwnedObject: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pobject: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12ManualWriteTrackingResource(::windows::core::IUnknown);
impl ID3D12ManualWriteTrackingResource {
    pub unsafe fn TrackWrite(
        &self,
        subresource: u32,
        pwrittenrange: ::core::option::Option<*const D3D12_RANGE>,
    ) {
        (::windows::core::Interface::vtable(self).TrackWrite)(
            ::windows::core::Interface::as_raw(self),
            subresource,
            ::core::mem::transmute(pwrittenrange.unwrap_or(::std::ptr::null())),
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12ManualWriteTrackingResource, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12ManualWriteTrackingResource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12ManualWriteTrackingResource {}
impl ::core::fmt::Debug for ID3D12ManualWriteTrackingResource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12ManualWriteTrackingResource")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12ManualWriteTrackingResource {
    type Vtable = ID3D12ManualWriteTrackingResource_Vtbl;
}
impl ::core::clone::Clone for ID3D12ManualWriteTrackingResource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12ManualWriteTrackingResource {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x86ca3b85_49ad_4b6e_aed5_eddb18540f41);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12ManualWriteTrackingResource_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub TrackWrite: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        subresource: u32,
        pwrittenrange: *const D3D12_RANGE,
    ),
}
#[repr(transparent)]
pub struct ID3D12MetaCommand(::windows::core::IUnknown);
impl ID3D12MetaCommand {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetRequiredParameterResourceSize(
        &self,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        parameterindex: u32,
    ) -> u64 {
        (::windows::core::Interface::vtable(self).GetRequiredParameterResourceSize)(
            ::windows::core::Interface::as_raw(self),
            stage,
            parameterindex,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12MetaCommand,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12MetaCommand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12MetaCommand {}
impl ::core::fmt::Debug for ID3D12MetaCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12MetaCommand").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12MetaCommand {
    type Vtable = ID3D12MetaCommand_Vtbl;
}
impl ::core::clone::Clone for ID3D12MetaCommand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12MetaCommand {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xdbb84c27_36ce_4fc9_b801_f048c46ac570);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12MetaCommand_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetRequiredParameterResourceSize: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        parameterindex: u32,
    ) -> u64,
}
#[repr(transparent)]
pub struct ID3D12Object(::windows::core::IUnknown);
impl ID3D12Object {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self).SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12Object, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12Object {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Object {}
impl ::core::fmt::Debug for ID3D12Object {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Object").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Object {
    type Vtable = ID3D12Object_Vtbl;
}
impl ::core::clone::Clone for ID3D12Object {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Object {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xc4fec28f_7966_4e95_9f94_f431cb56c3b8);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Object_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetPrivateData: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub SetPrivateData: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: *const ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub SetPrivateDataInterface: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        guid: *const ::windows::core::GUID,
        pdata: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub SetName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        name: ::windows::core::PCWSTR,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Pageable(::windows::core::IUnknown);
impl ID3D12Pageable {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Pageable,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild
);
impl ::core::cmp::PartialEq for ID3D12Pageable {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Pageable {}
impl ::core::fmt::Debug for ID3D12Pageable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Pageable").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Pageable {
    type Vtable = ID3D12Pageable_Vtbl;
}
impl ::core::clone::Clone for ID3D12Pageable {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Pageable {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x63ee58fb_1268_4835_86da_f008ce62f0d6);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Pageable_Vtbl {
    pub base__: ID3D12DeviceChild_Vtbl,
}
#[repr(transparent)]
pub struct ID3D12PipelineLibrary(::windows::core::IUnknown);
impl ID3D12PipelineLibrary {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn StorePipeline<P0, P1>(
        &self,
        pname: P0,
        ppipeline: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self).StorePipeline)(
            ::windows::core::Interface::as_raw(self),
            pname.into_param().abi(),
            ppipeline.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn LoadGraphicsPipeline<P0, T>(
        &self,
        pname: P0,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).LoadGraphicsPipeline)(
            ::windows::core::Interface::as_raw(self),
            pname.into_param().abi(),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn LoadComputePipeline<P0, T>(
        &self,
        pname: P0,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).LoadComputePipeline)(
            ::windows::core::Interface::as_raw(self),
            pname.into_param().abi(),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetSerializedSize(&self) -> usize {
        (::windows::core::Interface::vtable(self).GetSerializedSize)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn Serialize(&self, pdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Serialize)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdata.as_ptr()),
            pdata.len() as _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12PipelineLibrary,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild
);
impl ::core::cmp::PartialEq for ID3D12PipelineLibrary {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12PipelineLibrary {}
impl ::core::fmt::Debug for ID3D12PipelineLibrary {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12PipelineLibrary")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12PipelineLibrary {
    type Vtable = ID3D12PipelineLibrary_Vtbl;
}
impl ::core::clone::Clone for ID3D12PipelineLibrary {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12PipelineLibrary {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xc64226a8_9201_46af_b4cc_53fb9ff7414f);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12PipelineLibrary_Vtbl {
    pub base__: ID3D12DeviceChild_Vtbl,
    pub StorePipeline: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pname: ::windows::core::PCWSTR,
        ppipeline: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub LoadGraphicsPipeline: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pname: ::windows::core::PCWSTR,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub LoadComputePipeline: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pname: ::windows::core::PCWSTR,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub GetSerializedSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> usize,
    pub Serialize: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdata: *mut ::core::ffi::c_void,
        datasizeinbytes: usize,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12PipelineLibrary1(::windows::core::IUnknown);
impl ID3D12PipelineLibrary1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn StorePipeline<P0, P1>(
        &self,
        pname: P0,
        ppipeline: P1,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        P1: ::windows::core::IntoParam<ID3D12PipelineState>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .StorePipeline)(
            ::windows::core::Interface::as_raw(self),
            pname.into_param().abi(),
            ppipeline.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn LoadGraphicsPipeline<P0, T>(
        &self,
        pname: P0,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .LoadGraphicsPipeline)(
            ::windows::core::Interface::as_raw(self),
            pname.into_param().abi(),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn LoadComputePipeline<P0, T>(
        &self,
        pname: P0,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .LoadComputePipeline)(
            ::windows::core::Interface::as_raw(self),
            pname.into_param().abi(),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetSerializedSize(&self) -> usize {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetSerializedSize)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Serialize(&self, pdata: &mut [u8]) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Serialize)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pdata.as_ptr()),
            pdata.len() as _,
        )
        .ok()
    }
    pub unsafe fn LoadPipeline<P0, T>(
        &self,
        pname: P0,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).LoadPipeline)(
            ::windows::core::Interface::as_raw(self),
            pname.into_param().abi(),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12PipelineLibrary1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12PipelineLibrary
);
impl ::core::cmp::PartialEq for ID3D12PipelineLibrary1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12PipelineLibrary1 {}
impl ::core::fmt::Debug for ID3D12PipelineLibrary1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12PipelineLibrary1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12PipelineLibrary1 {
    type Vtable = ID3D12PipelineLibrary1_Vtbl;
}
impl ::core::clone::Clone for ID3D12PipelineLibrary1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12PipelineLibrary1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x80eabf42_2568_4e5e_bd82_c37f86961dc3);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12PipelineLibrary1_Vtbl {
    pub base__: ID3D12PipelineLibrary_Vtbl,
    pub LoadPipeline: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pname: ::windows::core::PCWSTR,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12PipelineState(::windows::core::IUnknown);
impl ID3D12PipelineState {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetCachedBlob(&self) -> ::windows::core::Result<ID3DBlob> {
        let mut result__ = ::windows::core::zeroed::<ID3DBlob>();
        (::windows::core::Interface::vtable(self).GetCachedBlob)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12PipelineState,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12PipelineState {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12PipelineState {}
impl ::core::fmt::Debug for ID3D12PipelineState {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12PipelineState").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12PipelineState {
    type Vtable = ID3D12PipelineState_Vtbl;
}
impl ::core::clone::Clone for ID3D12PipelineState {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12PipelineState {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x765a30f3_f624_4c6f_a828_ace948622445);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12PipelineState_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetCachedBlob: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ppblob: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12ProtectedResourceSession(::windows::core::IUnknown);
impl ID3D12ProtectedResourceSession {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetStatusFence<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetStatusFence)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetSessionStatus(&self) -> D3D12_PROTECTED_SESSION_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetSessionStatus)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetDesc(&self) -> D3D12_PROTECTED_RESOURCE_SESSION_DESC {
        let mut result__: D3D12_PROTECTED_RESOURCE_SESSION_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12ProtectedResourceSession,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12ProtectedSession
);
impl ::core::cmp::PartialEq for ID3D12ProtectedResourceSession {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12ProtectedResourceSession {}
impl ::core::fmt::Debug for ID3D12ProtectedResourceSession {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12ProtectedResourceSession")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12ProtectedResourceSession {
    type Vtable = ID3D12ProtectedResourceSession_Vtbl;
}
impl ::core::clone::Clone for ID3D12ProtectedResourceSession {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12ProtectedResourceSession {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x6cd696f4_f289_40cc_8091_5a6c0a099c3d);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12ProtectedResourceSession_Vtbl {
    pub base__: ID3D12ProtectedSession_Vtbl,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_PROTECTED_RESOURCE_SESSION_DESC,
    ),
}
#[repr(transparent)]
pub struct ID3D12ProtectedResourceSession1(::windows::core::IUnknown);
impl ID3D12ProtectedResourceSession1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetStatusFence<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetStatusFence)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetSessionStatus(&self) -> D3D12_PROTECTED_SESSION_STATUS {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetSessionStatus)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetDesc(&self) -> D3D12_PROTECTED_RESOURCE_SESSION_DESC {
        let mut result__: D3D12_PROTECTED_RESOURCE_SESSION_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).base__.GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetDesc1(&self) -> D3D12_PROTECTED_RESOURCE_SESSION_DESC1 {
        let mut result__: D3D12_PROTECTED_RESOURCE_SESSION_DESC1 = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12ProtectedResourceSession1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12ProtectedSession,
    ID3D12ProtectedResourceSession
);
impl ::core::cmp::PartialEq for ID3D12ProtectedResourceSession1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12ProtectedResourceSession1 {}
impl ::core::fmt::Debug for ID3D12ProtectedResourceSession1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12ProtectedResourceSession1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12ProtectedResourceSession1 {
    type Vtable = ID3D12ProtectedResourceSession1_Vtbl;
}
impl ::core::clone::Clone for ID3D12ProtectedResourceSession1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12ProtectedResourceSession1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xd6f12dd6_76fb_406e_8961_4296eefc0409);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12ProtectedResourceSession1_Vtbl {
    pub base__: ID3D12ProtectedResourceSession_Vtbl,
    pub GetDesc1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
    ),
}
#[repr(transparent)]
pub struct ID3D12ProtectedSession(::windows::core::IUnknown);
impl ID3D12ProtectedSession {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetStatusFence<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetStatusFence)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetSessionStatus(&self) -> D3D12_PROTECTED_SESSION_STATUS {
        (::windows::core::Interface::vtable(self).GetSessionStatus)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12ProtectedSession,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild
);
impl ::core::cmp::PartialEq for ID3D12ProtectedSession {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12ProtectedSession {}
impl ::core::fmt::Debug for ID3D12ProtectedSession {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12ProtectedSession")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12ProtectedSession {
    type Vtable = ID3D12ProtectedSession_Vtbl;
}
impl ::core::clone::Clone for ID3D12ProtectedSession {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12ProtectedSession {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xa1533d18_0ac1_4084_85b9_89a96116806b);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12ProtectedSession_Vtbl {
    pub base__: ID3D12DeviceChild_Vtbl,
    pub GetStatusFence: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppfence: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub GetSessionStatus:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_PROTECTED_SESSION_STATUS,
}
#[repr(transparent)]
pub struct ID3D12QueryHeap(::windows::core::IUnknown);
impl ID3D12QueryHeap {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12QueryHeap,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12QueryHeap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12QueryHeap {}
impl ::core::fmt::Debug for ID3D12QueryHeap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12QueryHeap").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12QueryHeap {
    type Vtable = ID3D12QueryHeap_Vtbl;
}
impl ::core::clone::Clone for ID3D12QueryHeap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12QueryHeap {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x0d9658ae_ed45_469e_a61d_970ec583cab4);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12QueryHeap_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
}
#[repr(transparent)]
pub struct ID3D12Resource(::windows::core::IUnknown);
impl ID3D12Resource {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn Map(
        &self,
        subresource: u32,
        preadrange: ::core::option::Option<*const D3D12_RANGE>,
        ppdata: ::core::option::Option<*mut *mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Map)(
            ::windows::core::Interface::as_raw(self),
            subresource,
            ::core::mem::transmute(preadrange.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(ppdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn Unmap(
        &self,
        subresource: u32,
        pwrittenrange: ::core::option::Option<*const D3D12_RANGE>,
    ) {
        (::windows::core::Interface::vtable(self).Unmap)(
            ::windows::core::Interface::as_raw(self),
            subresource,
            ::core::mem::transmute(pwrittenrange.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn GetDesc(&self) -> D3D12_RESOURCE_DESC {
        let mut result__: D3D12_RESOURCE_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetGPUVirtualAddress(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetGPUVirtualAddress)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn WriteToSubresource(
        &self,
        dstsubresource: u32,
        pdstbox: ::core::option::Option<*const D3D12_BOX>,
        psrcdata: *const ::core::ffi::c_void,
        srcrowpitch: u32,
        srcdepthpitch: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).WriteToSubresource)(
            ::windows::core::Interface::as_raw(self),
            dstsubresource,
            ::core::mem::transmute(pdstbox.unwrap_or(::std::ptr::null())),
            psrcdata,
            srcrowpitch,
            srcdepthpitch,
        )
        .ok()
    }
    pub unsafe fn ReadFromSubresource(
        &self,
        pdstdata: *mut ::core::ffi::c_void,
        dstrowpitch: u32,
        dstdepthpitch: u32,
        srcsubresource: u32,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).ReadFromSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstdata,
            dstrowpitch,
            dstdepthpitch,
            srcsubresource,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn GetHeapProperties(
        &self,
        pheapproperties: ::core::option::Option<*mut D3D12_HEAP_PROPERTIES>,
        pheapflags: ::core::option::Option<*mut D3D12_HEAP_FLAGS>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pheapproperties.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pheapflags.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Resource,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12Resource {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Resource {}
impl ::core::fmt::Debug for ID3D12Resource {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Resource").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Resource {
    type Vtable = ID3D12Resource_Vtbl;
}
impl ::core::clone::Clone for ID3D12Resource {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Resource {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x696442be_a72e_4059_bc79_5b5c98040fad);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Resource_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub Map: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        subresource: u32,
        preadrange: *const D3D12_RANGE,
        ppdata: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub Unmap: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        subresource: u32,
        pwrittenrange: *const D3D12_RANGE,
    ),
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_RESOURCE_DESC,
    ),
    pub GetGPUVirtualAddress: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub WriteToSubresource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        dstsubresource: u32,
        pdstbox: *const D3D12_BOX,
        psrcdata: *const ::core::ffi::c_void,
        srcrowpitch: u32,
        srcdepthpitch: u32,
    ) -> ::windows::core::HRESULT,
    pub ReadFromSubresource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdstdata: *mut ::core::ffi::c_void,
        dstrowpitch: u32,
        dstdepthpitch: u32,
        srcsubresource: u32,
        psrcbox: *const D3D12_BOX,
    ) -> ::windows::core::HRESULT,
    pub GetHeapProperties: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pheapproperties: *mut D3D12_HEAP_PROPERTIES,
        pheapflags: *mut D3D12_HEAP_FLAGS,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Resource1(::windows::core::IUnknown);
impl ID3D12Resource1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn Map(
        &self,
        subresource: u32,
        preadrange: ::core::option::Option<*const D3D12_RANGE>,
        ppdata: ::core::option::Option<*mut *mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Map)(
            ::windows::core::Interface::as_raw(self),
            subresource,
            ::core::mem::transmute(preadrange.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(ppdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn Unmap(
        &self,
        subresource: u32,
        pwrittenrange: ::core::option::Option<*const D3D12_RANGE>,
    ) {
        (::windows::core::Interface::vtable(self).base__.Unmap)(
            ::windows::core::Interface::as_raw(self),
            subresource,
            ::core::mem::transmute(pwrittenrange.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn GetDesc(&self) -> D3D12_RESOURCE_DESC {
        let mut result__: D3D12_RESOURCE_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).base__.GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetGPUVirtualAddress(&self) -> u64 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetGPUVirtualAddress)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn WriteToSubresource(
        &self,
        dstsubresource: u32,
        pdstbox: ::core::option::Option<*const D3D12_BOX>,
        psrcdata: *const ::core::ffi::c_void,
        srcrowpitch: u32,
        srcdepthpitch: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .WriteToSubresource)(
            ::windows::core::Interface::as_raw(self),
            dstsubresource,
            ::core::mem::transmute(pdstbox.unwrap_or(::std::ptr::null())),
            psrcdata,
            srcrowpitch,
            srcdepthpitch,
        )
        .ok()
    }
    pub unsafe fn ReadFromSubresource(
        &self,
        pdstdata: *mut ::core::ffi::c_void,
        dstrowpitch: u32,
        dstdepthpitch: u32,
        srcsubresource: u32,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .ReadFromSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstdata,
            dstrowpitch,
            dstdepthpitch,
            srcsubresource,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn GetHeapProperties(
        &self,
        pheapproperties: ::core::option::Option<*mut D3D12_HEAP_PROPERTIES>,
        pheapflags: ::core::option::Option<*mut D3D12_HEAP_FLAGS>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pheapproperties.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pheapflags.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn GetProtectedResourceSession<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Resource1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable,
    ID3D12Resource
);
impl ::core::cmp::PartialEq for ID3D12Resource1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Resource1 {}
impl ::core::fmt::Debug for ID3D12Resource1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Resource1").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Resource1 {
    type Vtable = ID3D12Resource1_Vtbl;
}
impl ::core::clone::Clone for ID3D12Resource1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Resource1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x9d5e227a_4430_4161_88b3_3eca6bb16e19);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Resource1_Vtbl {
    pub base__: ID3D12Resource_Vtbl,
    pub GetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Resource2(::windows::core::IUnknown);
impl ID3D12Resource2 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn Map(
        &self,
        subresource: u32,
        preadrange: ::core::option::Option<*const D3D12_RANGE>,
        ppdata: ::core::option::Option<*mut *mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Map)(
            ::windows::core::Interface::as_raw(self),
            subresource,
            ::core::mem::transmute(preadrange.unwrap_or(::std::ptr::null())),
            ::core::mem::transmute(ppdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn Unmap(
        &self,
        subresource: u32,
        pwrittenrange: ::core::option::Option<*const D3D12_RANGE>,
    ) {
        (::windows::core::Interface::vtable(self).base__.base__.Unmap)(
            ::windows::core::Interface::as_raw(self),
            subresource,
            ::core::mem::transmute(pwrittenrange.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn GetDesc(&self) -> D3D12_RESOURCE_DESC {
        let mut result__: D3D12_RESOURCE_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn GetGPUVirtualAddress(&self) -> u64 {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetGPUVirtualAddress)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn WriteToSubresource(
        &self,
        dstsubresource: u32,
        pdstbox: ::core::option::Option<*const D3D12_BOX>,
        psrcdata: *const ::core::ffi::c_void,
        srcrowpitch: u32,
        srcdepthpitch: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .WriteToSubresource)(
            ::windows::core::Interface::as_raw(self),
            dstsubresource,
            ::core::mem::transmute(pdstbox.unwrap_or(::std::ptr::null())),
            psrcdata,
            srcrowpitch,
            srcdepthpitch,
        )
        .ok()
    }
    pub unsafe fn ReadFromSubresource(
        &self,
        pdstdata: *mut ::core::ffi::c_void,
        dstrowpitch: u32,
        dstdepthpitch: u32,
        srcsubresource: u32,
        psrcbox: ::core::option::Option<*const D3D12_BOX>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ReadFromSubresource)(
            ::windows::core::Interface::as_raw(self),
            pdstdata,
            dstrowpitch,
            dstdepthpitch,
            srcsubresource,
            ::core::mem::transmute(psrcbox.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn GetHeapProperties(
        &self,
        pheapproperties: ::core::option::Option<*mut D3D12_HEAP_PROPERTIES>,
        pheapflags: ::core::option::Option<*mut D3D12_HEAP_FLAGS>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetHeapProperties)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(pheapproperties.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(pheapflags.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn GetProtectedResourceSession<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc1(&self) -> D3D12_RESOURCE_DESC1 {
        let mut result__: D3D12_RESOURCE_DESC1 = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc1)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12Resource2,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable,
    ID3D12Resource,
    ID3D12Resource1
);
impl ::core::cmp::PartialEq for ID3D12Resource2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Resource2 {}
impl ::core::fmt::Debug for ID3D12Resource2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Resource2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Resource2 {
    type Vtable = ID3D12Resource2_Vtbl;
}
impl ::core::clone::Clone for ID3D12Resource2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Resource2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xbe36ec3b_ea85_4aeb_a45a_e9d76404a495);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Resource2_Vtbl {
    pub base__: ID3D12Resource1_Vtbl,
    pub GetDesc1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_RESOURCE_DESC1,
    ),
}
#[repr(transparent)]
pub struct ID3D12RootSignature(::windows::core::IUnknown);
impl ID3D12RootSignature {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12RootSignature,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild
);
impl ::core::cmp::PartialEq for ID3D12RootSignature {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12RootSignature {}
impl ::core::fmt::Debug for ID3D12RootSignature {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12RootSignature").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12RootSignature {
    type Vtable = ID3D12RootSignature_Vtbl;
}
impl ::core::clone::Clone for ID3D12RootSignature {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12RootSignature {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xc54a6b66_72df_4ee8_8be5_a946a1429214);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12RootSignature_Vtbl {
    pub base__: ID3D12DeviceChild_Vtbl,
}
#[repr(transparent)]
pub struct ID3D12RootSignatureDeserializer(::windows::core::IUnknown);
impl ID3D12RootSignatureDeserializer {
    pub unsafe fn GetRootSignatureDesc(&self) -> *mut D3D12_ROOT_SIGNATURE_DESC {
        (::windows::core::Interface::vtable(self).GetRootSignatureDesc)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12RootSignatureDeserializer, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12RootSignatureDeserializer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12RootSignatureDeserializer {}
impl ::core::fmt::Debug for ID3D12RootSignatureDeserializer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12RootSignatureDeserializer")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12RootSignatureDeserializer {
    type Vtable = ID3D12RootSignatureDeserializer_Vtbl;
}
impl ::core::clone::Clone for ID3D12RootSignatureDeserializer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12RootSignatureDeserializer {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x34ab647b_3cc8_46ac_841b_c0965645c046);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12RootSignatureDeserializer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetRootSignatureDesc:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> *mut D3D12_ROOT_SIGNATURE_DESC,
}
#[repr(transparent)]
pub struct ID3D12SDKConfiguration(::windows::core::IUnknown);
impl ID3D12SDKConfiguration {
    pub unsafe fn SetSDKVersion<P0>(
        &self,
        sdkversion: u32,
        sdkpath: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).SetSDKVersion)(
            ::windows::core::Interface::as_raw(self),
            sdkversion,
            sdkpath.into_param().abi(),
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12SDKConfiguration, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12SDKConfiguration {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12SDKConfiguration {}
impl ::core::fmt::Debug for ID3D12SDKConfiguration {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12SDKConfiguration")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12SDKConfiguration {
    type Vtable = ID3D12SDKConfiguration_Vtbl;
}
impl ::core::clone::Clone for ID3D12SDKConfiguration {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12SDKConfiguration {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xe9eb5314_33aa_42b2_a718_d77f58b1f1c7);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12SDKConfiguration_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub SetSDKVersion: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        sdkversion: u32,
        sdkpath: ::windows::core::PCSTR,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12SDKConfiguration1(::windows::core::IUnknown);
impl ID3D12SDKConfiguration1 {
    pub unsafe fn SetSDKVersion<P0>(
        &self,
        sdkversion: u32,
        sdkpath: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetSDKVersion)(
            ::windows::core::Interface::as_raw(self),
            sdkversion,
            sdkpath.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn CreateDeviceFactory<P0, T>(
        &self,
        sdkversion: u32,
        sdkpath: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateDeviceFactory)(
            ::windows::core::Interface::as_raw(self),
            sdkversion,
            sdkpath.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn FreeUnusedSDKs(&self) {
        (::windows::core::Interface::vtable(self).FreeUnusedSDKs)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12SDKConfiguration1,
    ::windows::core::IUnknown,
    ID3D12SDKConfiguration
);
impl ::core::cmp::PartialEq for ID3D12SDKConfiguration1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12SDKConfiguration1 {}
impl ::core::fmt::Debug for ID3D12SDKConfiguration1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12SDKConfiguration1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12SDKConfiguration1 {
    type Vtable = ID3D12SDKConfiguration1_Vtbl;
}
impl ::core::clone::Clone for ID3D12SDKConfiguration1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12SDKConfiguration1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x8aaf9303_ad25_48b9_9a57_d9c37e009d9f);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12SDKConfiguration1_Vtbl {
    pub base__: ID3D12SDKConfiguration_Vtbl,
    pub CreateDeviceFactory: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        sdkversion: u32,
        sdkpath: ::windows::core::PCSTR,
        riid: *const ::windows::core::GUID,
        ppvfactory: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub FreeUnusedSDKs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
}
#[repr(transparent)]
pub struct ID3D12ShaderCacheSession(::windows::core::IUnknown);
impl ID3D12ShaderCacheSession {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).base__.GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn FindValue(
        &self,
        pkey: *const ::core::ffi::c_void,
        keysize: u32,
        pvalue: *mut ::core::ffi::c_void,
        pvaluesize: *mut u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).FindValue)(
            ::windows::core::Interface::as_raw(self),
            pkey,
            keysize,
            pvalue,
            pvaluesize,
        )
        .ok()
    }
    pub unsafe fn StoreValue(
        &self,
        pkey: *const ::core::ffi::c_void,
        keysize: u32,
        pvalue: *const ::core::ffi::c_void,
        valuesize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).StoreValue)(
            ::windows::core::Interface::as_raw(self),
            pkey,
            keysize,
            pvalue,
            valuesize,
        )
        .ok()
    }
    pub unsafe fn SetDeleteOnDestroy(&self) {
        (::windows::core::Interface::vtable(self).SetDeleteOnDestroy)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetDesc(&self) -> D3D12_SHADER_CACHE_SESSION_DESC {
        let mut result__: D3D12_SHADER_CACHE_SESSION_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12ShaderCacheSession,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild
);
impl ::core::cmp::PartialEq for ID3D12ShaderCacheSession {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12ShaderCacheSession {}
impl ::core::fmt::Debug for ID3D12ShaderCacheSession {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12ShaderCacheSession")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12ShaderCacheSession {
    type Vtable = ID3D12ShaderCacheSession_Vtbl;
}
impl ::core::clone::Clone for ID3D12ShaderCacheSession {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12ShaderCacheSession {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x28e2495d_0f64_4ae4_a6ec_129255dc49a8);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12ShaderCacheSession_Vtbl {
    pub base__: ID3D12DeviceChild_Vtbl,
    pub FindValue: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pkey: *const ::core::ffi::c_void,
        keysize: u32,
        pvalue: *mut ::core::ffi::c_void,
        pvaluesize: *mut u32,
    ) -> ::windows::core::HRESULT,
    pub StoreValue: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pkey: *const ::core::ffi::c_void,
        keysize: u32,
        pvalue: *const ::core::ffi::c_void,
        valuesize: u32,
    ) -> ::windows::core::HRESULT,
    pub SetDeleteOnDestroy: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_SHADER_CACHE_SESSION_DESC,
    ),
}
#[repr(transparent)]
pub struct ID3D12ShaderReflection(::windows::core::IUnknown);
impl ID3D12ShaderReflection {
    pub unsafe fn GetDesc(&self, pdesc: *mut D3D12_SHADER_DESC) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetConstantBufferByIndex(
        &self,
        index: u32,
    ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer> {
        (::windows::core::Interface::vtable(self).GetConstantBufferByIndex)(
            ::windows::core::Interface::as_raw(self),
            index,
        )
    }
    pub unsafe fn GetConstantBufferByName<P0>(
        &self,
        name: P0,
    ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).GetConstantBufferByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
    }
    pub unsafe fn GetResourceBindingDesc(
        &self,
        resourceindex: u32,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetResourceBindingDesc)(
            ::windows::core::Interface::as_raw(self),
            resourceindex,
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetInputParameterDesc(
        &self,
        parameterindex: u32,
        pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetInputParameterDesc)(
            ::windows::core::Interface::as_raw(self),
            parameterindex,
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetOutputParameterDesc(
        &self,
        parameterindex: u32,
        pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetOutputParameterDesc)(
            ::windows::core::Interface::as_raw(self),
            parameterindex,
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetPatchConstantParameterDesc(
        &self,
        parameterindex: u32,
        pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetPatchConstantParameterDesc)(
            ::windows::core::Interface::as_raw(self),
            parameterindex,
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetVariableByName<P0>(
        &self,
        name: P0,
    ) -> ::core::option::Option<ID3D12ShaderReflectionVariable>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).GetVariableByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
    }
    pub unsafe fn GetResourceBindingDescByName<P0>(
        &self,
        name: P0,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).GetResourceBindingDescByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetMovInstructionCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetMovInstructionCount)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetMovcInstructionCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetMovcInstructionCount)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetConversionInstructionCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetConversionInstructionCount)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetBitwiseInstructionCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetBitwiseInstructionCount)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetGSInputPrimitive(&self) -> D3D_PRIMITIVE {
        (::windows::core::Interface::vtable(self).GetGSInputPrimitive)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn IsSampleFrequencyShader(&self) -> ::windows::Win32::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).IsSampleFrequencyShader)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetNumInterfaceSlots(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNumInterfaceSlots)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetMinFeatureLevel(&self) -> ::windows::core::Result<D3D_FEATURE_LEVEL> {
        let mut result__ = ::windows::core::zeroed::<D3D_FEATURE_LEVEL>();
        (::windows::core::Interface::vtable(self).GetMinFeatureLevel)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetThreadGroupSize(
        &self,
        psizex: ::core::option::Option<*mut u32>,
        psizey: ::core::option::Option<*mut u32>,
        psizez: ::core::option::Option<*mut u32>,
    ) -> u32 {
        (::windows::core::Interface::vtable(self).GetThreadGroupSize)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(psizex.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(psizey.unwrap_or(::std::ptr::null_mut())),
            ::core::mem::transmute(psizez.unwrap_or(::std::ptr::null_mut())),
        )
    }
    pub unsafe fn GetRequiresFlags(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetRequiresFlags)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12ShaderReflection, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12ShaderReflection {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12ShaderReflection {}
impl ::core::fmt::Debug for ID3D12ShaderReflection {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12ShaderReflection")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12ShaderReflection {
    type Vtable = ID3D12ShaderReflection_Vtbl;
}
impl ::core::clone::Clone for ID3D12ShaderReflection {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12ShaderReflection {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x5a58797d_a72c_478d_8ba2_efc6b0efe88e);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12ShaderReflection_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *mut D3D12_SHADER_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetConstantBufferByIndex: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        index: u32,
    ) -> ::core::option::Option<
        ID3D12ShaderReflectionConstantBuffer,
    >,
    pub GetConstantBufferByName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        name: ::windows::core::PCSTR,
    ) -> ::core::option::Option<
        ID3D12ShaderReflectionConstantBuffer,
    >,
    pub GetResourceBindingDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        resourceindex: u32,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetInputParameterDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        parameterindex: u32,
        pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetOutputParameterDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        parameterindex: u32,
        pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetPatchConstantParameterDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        parameterindex: u32,
        pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetVariableByName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        name: ::windows::core::PCSTR,
    ) -> ::core::option::Option<
        ID3D12ShaderReflectionVariable,
    >,
    pub GetResourceBindingDescByName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        name: ::windows::core::PCSTR,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetMovInstructionCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetMovcInstructionCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetConversionInstructionCount:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetBitwiseInstructionCount:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetGSInputPrimitive:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D_PRIMITIVE,
    pub IsSampleFrequencyShader: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
    )
        -> ::windows::Win32::Foundation::BOOL,
    pub GetNumInterfaceSlots: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetMinFeatureLevel: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        plevel: *mut D3D_FEATURE_LEVEL,
    ) -> ::windows::core::HRESULT,
    pub GetThreadGroupSize: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        psizex: *mut u32,
        psizey: *mut u32,
        psizez: *mut u32,
    ) -> u32,
    pub GetRequiresFlags: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
}
#[repr(transparent)]
pub struct ID3D12ShaderReflectionConstantBuffer(::std::ptr::NonNull<::std::ffi::c_void>);
impl ID3D12ShaderReflectionConstantBuffer {
    pub unsafe fn GetDesc(
        &self,
        pdesc: *mut D3D12_SHADER_BUFFER_DESC,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetVariableByIndex(
        &self,
        index: u32,
    ) -> ::core::option::Option<ID3D12ShaderReflectionVariable> {
        (::windows::core::Interface::vtable(self).GetVariableByIndex)(
            ::windows::core::Interface::as_raw(self),
            index,
        )
    }
    pub unsafe fn GetVariableByName<P0>(
        &self,
        name: P0,
    ) -> ::core::option::Option<ID3D12ShaderReflectionVariable>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).GetVariableByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
    }
}
impl ::core::cmp::PartialEq for ID3D12ShaderReflectionConstantBuffer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12ShaderReflectionConstantBuffer {}
impl ::core::fmt::Debug for ID3D12ShaderReflectionConstantBuffer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12ShaderReflectionConstantBuffer")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12ShaderReflectionConstantBuffer {
    type Vtable = ID3D12ShaderReflectionConstantBuffer_Vtbl;
}
impl ::core::clone::Clone for ID3D12ShaderReflectionConstantBuffer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12ShaderReflectionConstantBuffer_Vtbl {
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *mut D3D12_SHADER_BUFFER_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetVariableByIndex: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        index: u32,
    ) -> ::core::option::Option<
        ID3D12ShaderReflectionVariable,
    >,
    pub GetVariableByName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        name: ::windows::core::PCSTR,
    ) -> ::core::option::Option<
        ID3D12ShaderReflectionVariable,
    >,
}
#[repr(transparent)]
pub struct ID3D12ShaderReflectionType(::std::ptr::NonNull<::std::ffi::c_void>);
impl ID3D12ShaderReflectionType {
    pub unsafe fn GetDesc(
        &self,
        pdesc: *mut D3D12_SHADER_TYPE_DESC,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetMemberTypeByIndex(
        &self,
        index: u32,
    ) -> ::core::option::Option<ID3D12ShaderReflectionType> {
        (::windows::core::Interface::vtable(self).GetMemberTypeByIndex)(
            ::windows::core::Interface::as_raw(self),
            index,
        )
    }
    pub unsafe fn GetMemberTypeByName<P0>(
        &self,
        name: P0,
    ) -> ::core::option::Option<ID3D12ShaderReflectionType>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).GetMemberTypeByName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
    }
    pub unsafe fn GetMemberTypeName(&self, index: u32) -> ::windows::core::PSTR {
        (::windows::core::Interface::vtable(self).GetMemberTypeName)(
            ::windows::core::Interface::as_raw(self),
            index,
        )
    }
    pub unsafe fn IsEqual<P0>(&self, ptype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ShaderReflectionType>,
    {
        (::windows::core::Interface::vtable(self).IsEqual)(
            ::windows::core::Interface::as_raw(self),
            ptype.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetSubType(&self) -> ::core::option::Option<ID3D12ShaderReflectionType> {
        (::windows::core::Interface::vtable(self).GetSubType)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetBaseClass(&self) -> ::core::option::Option<ID3D12ShaderReflectionType> {
        (::windows::core::Interface::vtable(self).GetBaseClass)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetNumInterfaces(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNumInterfaces)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetInterfaceByIndex(
        &self,
        uindex: u32,
    ) -> ::core::option::Option<ID3D12ShaderReflectionType> {
        (::windows::core::Interface::vtable(self).GetInterfaceByIndex)(
            ::windows::core::Interface::as_raw(self),
            uindex,
        )
    }
    pub unsafe fn IsOfType<P0>(&self, ptype: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ShaderReflectionType>,
    {
        (::windows::core::Interface::vtable(self).IsOfType)(
            ::windows::core::Interface::as_raw(self),
            ptype.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ImplementsInterface<P0>(&self, pbase: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12ShaderReflectionType>,
    {
        (::windows::core::Interface::vtable(self).ImplementsInterface)(
            ::windows::core::Interface::as_raw(self),
            pbase.into_param().abi(),
        )
        .ok()
    }
}
impl ::core::cmp::PartialEq for ID3D12ShaderReflectionType {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12ShaderReflectionType {}
impl ::core::fmt::Debug for ID3D12ShaderReflectionType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12ShaderReflectionType")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12ShaderReflectionType {
    type Vtable = ID3D12ShaderReflectionType_Vtbl;
}
impl ::core::clone::Clone for ID3D12ShaderReflectionType {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12ShaderReflectionType_Vtbl {
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *mut D3D12_SHADER_TYPE_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetMemberTypeByIndex:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
            index: u32,
        ) -> ::core::option::Option<ID3D12ShaderReflectionType>,
    pub GetMemberTypeByName:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCSTR,
        ) -> ::core::option::Option<ID3D12ShaderReflectionType>,
    pub GetMemberTypeName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        index: u32,
    ) -> ::windows::core::PSTR,
    pub IsEqual: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ptype: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub GetSubType: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
    )
        -> ::core::option::Option<ID3D12ShaderReflectionType>,
    pub GetBaseClass:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
        ) -> ::core::option::Option<ID3D12ShaderReflectionType>,
    pub GetNumInterfaces: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetInterfaceByIndex:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
            uindex: u32,
        ) -> ::core::option::Option<ID3D12ShaderReflectionType>,
    pub IsOfType: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        ptype: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub ImplementsInterface: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pbase: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12ShaderReflectionVariable(::std::ptr::NonNull<::std::ffi::c_void>);
impl ID3D12ShaderReflectionVariable {
    pub unsafe fn GetDesc(
        &self,
        pdesc: *mut D3D12_SHADER_VARIABLE_DESC,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> ::core::option::Option<ID3D12ShaderReflectionType> {
        (::windows::core::Interface::vtable(self).GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetBuffer(&self) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer> {
        (::windows::core::Interface::vtable(self).GetBuffer)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetInterfaceSlot(&self, uarrayindex: u32) -> u32 {
        (::windows::core::Interface::vtable(self).GetInterfaceSlot)(
            ::windows::core::Interface::as_raw(self),
            uarrayindex,
        )
    }
}
impl ::core::cmp::PartialEq for ID3D12ShaderReflectionVariable {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12ShaderReflectionVariable {}
impl ::core::fmt::Debug for ID3D12ShaderReflectionVariable {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12ShaderReflectionVariable")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12ShaderReflectionVariable {
    type Vtable = ID3D12ShaderReflectionVariable_Vtbl;
}
impl ::core::clone::Clone for ID3D12ShaderReflectionVariable {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12ShaderReflectionVariable_Vtbl {
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *mut D3D12_SHADER_VARIABLE_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetType: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
    )
        -> ::core::option::Option<ID3D12ShaderReflectionType>,
    pub GetBuffer: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
    ) -> ::core::option::Option<
        ID3D12ShaderReflectionConstantBuffer,
    >,
    pub GetInterfaceSlot:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, uarrayindex: u32) -> u32,
}
#[repr(transparent)]
pub struct ID3D12SharingContract(::windows::core::IUnknown);
impl ID3D12SharingContract {
    pub unsafe fn Present<P0, P1>(&self, presource: P0, subresource: u32, window: P1)
    where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
        P1: ::windows::core::IntoParam<::windows::Win32::Foundation::HWND>,
    {
        (::windows::core::Interface::vtable(self).Present)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            subresource,
            window.into_param().abi(),
        )
    }
    pub unsafe fn SharedFenceSignal<P0>(&self, pfence: P0, fencevalue: u64)
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        (::windows::core::Interface::vtable(self).SharedFenceSignal)(
            ::windows::core::Interface::as_raw(self),
            pfence.into_param().abi(),
            fencevalue,
        )
    }
    pub unsafe fn BeginCapturableWork(&self, guid: *const ::windows::core::GUID) {
        (::windows::core::Interface::vtable(self).BeginCapturableWork)(
            ::windows::core::Interface::as_raw(self),
            guid,
        )
    }
    pub unsafe fn EndCapturableWork(&self, guid: *const ::windows::core::GUID) {
        (::windows::core::Interface::vtable(self).EndCapturableWork)(
            ::windows::core::Interface::as_raw(self),
            guid,
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12SharingContract, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12SharingContract {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12SharingContract {}
impl ::core::fmt::Debug for ID3D12SharingContract {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12SharingContract")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12SharingContract {
    type Vtable = ID3D12SharingContract_Vtbl;
}
impl ::core::clone::Clone for ID3D12SharingContract {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12SharingContract {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x0adf7d52_929c_4e61_addb_ffed30de66ef);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12SharingContract_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub Present: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        subresource: u32,
        window: ::windows::Win32::Foundation::HWND,
    ),
    pub SharedFenceSignal: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfence: *mut ::core::ffi::c_void,
        fencevalue: u64,
    ),
    pub BeginCapturableWork: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        guid: *const ::windows::core::GUID,
    ),
    pub EndCapturableWork: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        guid: *const ::windows::core::GUID,
    ),
}
#[repr(transparent)]
pub struct ID3D12StateObject(::windows::core::IUnknown);
impl ID3D12StateObject {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12StateObject,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12StateObject {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12StateObject {}
impl ::core::fmt::Debug for ID3D12StateObject {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12StateObject").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12StateObject {
    type Vtable = ID3D12StateObject_Vtbl;
}
impl ::core::clone::Clone for ID3D12StateObject {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12StateObject {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x47016943_fca8_4594_93ea_af258b55346d);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12StateObject_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
}
#[repr(transparent)]
pub struct ID3D12StateObjectProperties(::windows::core::IUnknown);
impl ID3D12StateObjectProperties {
    pub unsafe fn GetShaderIdentifier<P0>(&self, pexportname: P0) -> *mut ::core::ffi::c_void
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).GetShaderIdentifier)(
            ::windows::core::Interface::as_raw(self),
            pexportname.into_param().abi(),
        )
    }
    pub unsafe fn GetShaderStackSize<P0>(&self, pexportname: P0) -> u64
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).GetShaderStackSize)(
            ::windows::core::Interface::as_raw(self),
            pexportname.into_param().abi(),
        )
    }
    pub unsafe fn GetPipelineStackSize(&self) -> u64 {
        (::windows::core::Interface::vtable(self).GetPipelineStackSize)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn SetPipelineStackSize(&self, pipelinestacksizeinbytes: u64) {
        (::windows::core::Interface::vtable(self).SetPipelineStackSize)(
            ::windows::core::Interface::as_raw(self),
            pipelinestacksizeinbytes,
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12StateObjectProperties, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12StateObjectProperties {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12StateObjectProperties {}
impl ::core::fmt::Debug for ID3D12StateObjectProperties {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12StateObjectProperties")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12StateObjectProperties {
    type Vtable = ID3D12StateObjectProperties_Vtbl;
}
impl ::core::clone::Clone for ID3D12StateObjectProperties {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12StateObjectProperties {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xde5fa827_9bf9_4f26_89ff_d7f56fde3860);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12StateObjectProperties_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetShaderIdentifier: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pexportname: ::windows::core::PCWSTR,
    ) -> *mut ::core::ffi::c_void,
    pub GetShaderStackSize: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pexportname: ::windows::core::PCWSTR,
    ) -> u64,
    pub GetPipelineStackSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u64,
    pub SetPipelineStackSize:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, pipelinestacksizeinbytes: u64),
}
#[repr(transparent)]
pub struct ID3D12StateObjectProperties1(::windows::core::IUnknown);
impl ID3D12StateObjectProperties1 {
    pub unsafe fn GetShaderIdentifier<P0>(&self, pexportname: P0) -> *mut ::core::ffi::c_void
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetShaderIdentifier)(
            ::windows::core::Interface::as_raw(self),
            pexportname.into_param().abi(),
        )
    }
    pub unsafe fn GetShaderStackSize<P0>(&self, pexportname: P0) -> u64
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetShaderStackSize)(
            ::windows::core::Interface::as_raw(self),
            pexportname.into_param().abi(),
        )
    }
    pub unsafe fn GetPipelineStackSize(&self) -> u64 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetPipelineStackSize)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn SetPipelineStackSize(&self, pipelinestacksizeinbytes: u64) {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPipelineStackSize)(
            ::windows::core::Interface::as_raw(self),
            pipelinestacksizeinbytes,
        )
    }
    pub unsafe fn GetProgramIdentifier<P0>(&self, pprogramname: P0) -> D3D12_PROGRAM_IDENTIFIER
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        let mut result__: D3D12_PROGRAM_IDENTIFIER = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetProgramIdentifier)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            pprogramname.into_param().abi(),
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12StateObjectProperties1,
    ::windows::core::IUnknown,
    ID3D12StateObjectProperties
);
impl ::core::cmp::PartialEq for ID3D12StateObjectProperties1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12StateObjectProperties1 {}
impl ::core::fmt::Debug for ID3D12StateObjectProperties1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12StateObjectProperties1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12StateObjectProperties1 {
    type Vtable = ID3D12StateObjectProperties1_Vtbl;
}
impl ::core::clone::Clone for ID3D12StateObjectProperties1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12StateObjectProperties1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x460caac7_1d24_446a_a184_ca67db494138);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12StateObjectProperties1_Vtbl {
    pub base__: ID3D12StateObjectProperties_Vtbl,
    pub GetProgramIdentifier: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_PROGRAM_IDENTIFIER,
        pprogramname: ::windows::core::PCWSTR,
    ),
}
#[repr(transparent)]
pub struct ID3D12SwapChainAssistant(::windows::core::IUnknown);
impl ID3D12SwapChainAssistant {
    pub unsafe fn GetLUID(&self) -> ::windows::Win32::Foundation::LUID {
        let mut result__: ::windows::Win32::Foundation::LUID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetLUID)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetSwapChainObject<T>(&self) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).GetSwapChainObject)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetCurrentResourceAndCommandQueue<T>(
        &self,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).GetCurrentResourceAndCommandQueue)(
            ::windows::core::Interface::as_raw(self),
            riidresource,
            ppvresource,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn InsertImplicitSync(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).InsertImplicitSync)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3D12SwapChainAssistant, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12SwapChainAssistant {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12SwapChainAssistant {}
impl ::core::fmt::Debug for ID3D12SwapChainAssistant {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12SwapChainAssistant")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12SwapChainAssistant {
    type Vtable = ID3D12SwapChainAssistant_Vtbl;
}
impl ::core::clone::Clone for ID3D12SwapChainAssistant {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12SwapChainAssistant {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xf1df64b6_57fd_49cd_8807_c0eb88b45c8f);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12SwapChainAssistant_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetLUID: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut ::windows::Win32::Foundation::LUID,
    ),
    pub GetSwapChainObject: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppv: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub GetCurrentResourceAndCommandQueue: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
        riidqueue: *const ::windows::core::GUID,
        ppvqueue: *mut *mut ::core::ffi::c_void,
    )
        -> ::windows::core::HRESULT,
    pub InsertImplicitSync:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12Tools(::windows::core::IUnknown);
impl ID3D12Tools {
    pub unsafe fn EnableShaderInstrumentation<P0>(&self, benable: P0)
    where
        P0: ::windows::core::IntoParam<::windows::Win32::Foundation::BOOL>,
    {
        (::windows::core::Interface::vtable(self).EnableShaderInstrumentation)(
            ::windows::core::Interface::as_raw(self),
            benable.into_param().abi(),
        )
    }
    pub unsafe fn ShaderInstrumentationEnabled(&self) -> ::windows::Win32::Foundation::BOOL {
        (::windows::core::Interface::vtable(self).ShaderInstrumentationEnabled)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12Tools, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12Tools {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12Tools {}
impl ::core::fmt::Debug for ID3D12Tools {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12Tools").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12Tools {
    type Vtable = ID3D12Tools_Vtbl;
}
impl ::core::clone::Clone for ID3D12Tools {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12Tools {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x7071e1f0_e84b_4b33_974f_12fa49de65c5);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12Tools_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub EnableShaderInstrumentation: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        benable: ::windows::Win32::Foundation::BOOL,
    ),
    pub ShaderInstrumentationEnabled:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::Win32::Foundation::BOOL,
}
#[repr(transparent)]
pub struct ID3D12VersionedRootSignatureDeserializer(::windows::core::IUnknown);
impl ID3D12VersionedRootSignatureDeserializer {
    pub unsafe fn GetRootSignatureDescAtVersion(
        &self,
        converttoversion: D3D_ROOT_SIGNATURE_VERSION,
    ) -> ::windows::core::Result<*mut D3D12_VERSIONED_ROOT_SIGNATURE_DESC> {
        let mut result__ = ::windows::core::zeroed::<*mut D3D12_VERSIONED_ROOT_SIGNATURE_DESC>();
        (::windows::core::Interface::vtable(self).GetRootSignatureDescAtVersion)(
            ::windows::core::Interface::as_raw(self),
            converttoversion,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn GetUnconvertedRootSignatureDesc(
        &self,
    ) -> *mut D3D12_VERSIONED_ROOT_SIGNATURE_DESC {
        (::windows::core::Interface::vtable(self).GetUnconvertedRootSignatureDesc)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VersionedRootSignatureDeserializer,
    ::windows::core::IUnknown
);
impl ::core::cmp::PartialEq for ID3D12VersionedRootSignatureDeserializer {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VersionedRootSignatureDeserializer {}
impl ::core::fmt::Debug for ID3D12VersionedRootSignatureDeserializer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VersionedRootSignatureDeserializer")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VersionedRootSignatureDeserializer {
    type Vtable = ID3D12VersionedRootSignatureDeserializer_Vtbl;
}
impl ::core::clone::Clone for ID3D12VersionedRootSignatureDeserializer {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VersionedRootSignatureDeserializer {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x7f91ce67_090c_4bb7_b78e_ed8ff2e31da0);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VersionedRootSignatureDeserializer_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetRootSignatureDescAtVersion: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        converttoversion: D3D_ROOT_SIGNATURE_VERSION,
        ppdesc: *mut *mut D3D12_VERSIONED_ROOT_SIGNATURE_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetUnconvertedRootSignatureDesc:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
        ) -> *mut D3D12_VERSIONED_ROOT_SIGNATURE_DESC,
}
#[repr(transparent)]
pub struct ID3D12VideoDecodeCommandList(::windows::core::IUnknown);
impl ID3D12VideoDecodeCommandList {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.GetType)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self))
            .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).ClearState)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).EndEvent)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn DecodeFrame<P0>(
        &self,
        pdecoder: P0,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).DecodeFrame)(
            ::windows::core::Interface::as_raw(self),
            pdecoder.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self).WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDecodeCommandList,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList
);
impl ::core::cmp::PartialEq for ID3D12VideoDecodeCommandList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDecodeCommandList {}
impl ::core::fmt::Debug for ID3D12VideoDecodeCommandList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecodeCommandList")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDecodeCommandList {
    type Vtable = ID3D12VideoDecodeCommandList_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDecodeCommandList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecodeCommandList {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x3b60536e_ad29_4e64_a269_f853837e5e53);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecodeCommandList_Vtbl {
    pub base__: ID3D12CommandList_Vtbl,
    pub Close:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pallocator: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub ClearState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub ResourceBarrier: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numbarriers: u32,
        pbarriers: *const D3D12_RESOURCE_BARRIER,
    ),
    pub DiscardResource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        pregion: *const D3D12_DISCARD_REGION,
    ),
    pub BeginQuery: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    ),
    pub EndQuery: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    ),
    pub ResolveQueryData: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: *mut ::core::ffi::c_void,
        aligneddestinationbufferoffset: u64,
    ),
    pub SetPredication: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pbuffer: *mut ::core::ffi::c_void,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ),
    pub SetMarker: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        metadata: u32,
        pdata: *const ::core::ffi::c_void,
        size: u32,
    ),
    pub BeginEvent: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        metadata: u32,
        pdata: *const ::core::ffi::c_void,
        size: u32,
    ),
    pub EndEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub DecodeFrame: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdecoder: *mut ::core::ffi::c_void,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    ),
    pub WriteBufferImmediate: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoDecodeCommandList1(::windows::core::IUnknown);
impl ID3D12VideoDecodeCommandList1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Close)(::windows::core::Interface::as_raw(
            self,
        ))
        .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.ClearState)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).base__.SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).base__.BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.EndEvent)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn DecodeFrame<P0>(
        &self,
        pdecoder: P0,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).base__.DecodeFrame)(
            ::windows::core::Interface::as_raw(self),
            pdecoder.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn DecodeFrame1<P0>(
        &self,
        pdecoder: P0,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).DecodeFrame1)(
            ::windows::core::Interface::as_raw(self),
            pdecoder.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDecodeCommandList1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12VideoDecodeCommandList
);
impl ::core::cmp::PartialEq for ID3D12VideoDecodeCommandList1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDecodeCommandList1 {}
impl ::core::fmt::Debug for ID3D12VideoDecodeCommandList1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecodeCommandList1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDecodeCommandList1 {
    type Vtable = ID3D12VideoDecodeCommandList1_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDecodeCommandList1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecodeCommandList1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xd52f011b_b56e_453c_a05a_a7f311c8f472);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecodeCommandList1_Vtbl {
    pub base__: ID3D12VideoDecodeCommandList_Vtbl,
    pub DecodeFrame1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdecoder: *mut ::core::ffi::c_void,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoDecodeCommandList2(::windows::core::IUnknown);
impl ID3D12VideoDecodeCommandList2 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Close)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ClearState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn DecodeFrame<P0>(
        &self,
        pdecoder: P0,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DecodeFrame)(
            ::windows::core::Interface::as_raw(self),
            pdecoder.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn DecodeFrame1<P0>(
        &self,
        pdecoder: P0,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self).base__.DecodeFrame1)(
            ::windows::core::Interface::as_raw(self),
            pdecoder.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn InitializeExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).InitializeExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pinitializationparameters,
            initializationparameterssizeinbytes,
        )
    }
    pub unsafe fn ExecuteExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).ExecuteExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pexecutionparameters,
            executionparameterssizeinbytes,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDecodeCommandList2,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12VideoDecodeCommandList,
    ID3D12VideoDecodeCommandList1
);
impl ::core::cmp::PartialEq for ID3D12VideoDecodeCommandList2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDecodeCommandList2 {}
impl ::core::fmt::Debug for ID3D12VideoDecodeCommandList2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecodeCommandList2")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDecodeCommandList2 {
    type Vtable = ID3D12VideoDecodeCommandList2_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDecodeCommandList2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecodeCommandList2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x6e120880_c114_4153_8036_d247051e1729);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecodeCommandList2_Vtbl {
    pub base__: ID3D12VideoDecodeCommandList1_Vtbl,
    pub SetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pprotectedresourcesession: *mut ::core::ffi::c_void,
    ),
    pub InitializeExtensionCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pextensioncommand: *mut ::core::ffi::c_void,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    ),
    pub ExecuteExtensionCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pextensioncommand: *mut ::core::ffi::c_void,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoDecodeCommandList3(::windows::core::IUnknown);
impl ID3D12VideoDecodeCommandList3 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ClearState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn DecodeFrame<P0>(
        &self,
        pdecoder: P0,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .DecodeFrame)(
            ::windows::core::Interface::as_raw(self),
            pdecoder.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn DecodeFrame1<P0>(
        &self,
        pdecoder: P0,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoDecoder>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DecodeFrame1)(
            ::windows::core::Interface::as_raw(self),
            pdecoder.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn InitializeExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .InitializeExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pinitializationparameters,
            initializationparameterssizeinbytes,
        )
    }
    pub unsafe fn ExecuteExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ExecuteExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pexecutionparameters,
            executionparameterssizeinbytes,
        )
    }
    pub unsafe fn Barrier(&self, pbarriergroups: &[D3D12_BARRIER_GROUP]) {
        (::windows::core::Interface::vtable(self).Barrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriergroups.len() as _,
            ::core::mem::transmute(pbarriergroups.as_ptr()),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDecodeCommandList3,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12VideoDecodeCommandList,
    ID3D12VideoDecodeCommandList1,
    ID3D12VideoDecodeCommandList2
);
impl ::core::cmp::PartialEq for ID3D12VideoDecodeCommandList3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDecodeCommandList3 {}
impl ::core::fmt::Debug for ID3D12VideoDecodeCommandList3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecodeCommandList3")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDecodeCommandList3 {
    type Vtable = ID3D12VideoDecodeCommandList3_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDecodeCommandList3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecodeCommandList3 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x2aee8c37_9562_42da_8abf_61efeb2e4513);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecodeCommandList3_Vtbl {
    pub base__: ID3D12VideoDecodeCommandList2_Vtbl,
    pub Barrier: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numbarriergroups: u32,
        pbarriergroups: *const D3D12_BARRIER_GROUP,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoDecoder(::windows::core::IUnknown);
impl ID3D12VideoDecoder {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_DECODER_DESC {
        let mut result__: D3D12_VIDEO_DECODER_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDecoder,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12VideoDecoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDecoder {}
impl ::core::fmt::Debug for ID3D12VideoDecoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecoder").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDecoder {
    type Vtable = ID3D12VideoDecoder_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDecoder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecoder {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xc59b6bdc_7720_4074_a136_17a156037470);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecoder_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_VIDEO_DECODER_DESC,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoDecoder1(::windows::core::IUnknown);
impl ID3D12VideoDecoder1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_DECODER_DESC {
        let mut result__: D3D12_VIDEO_DECODER_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).base__.GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDecoder1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable,
    ID3D12VideoDecoder
);
impl ::core::cmp::PartialEq for ID3D12VideoDecoder1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDecoder1 {}
impl ::core::fmt::Debug for ID3D12VideoDecoder1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecoder1").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDecoder1 {
    type Vtable = ID3D12VideoDecoder1_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDecoder1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecoder1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x79a2e5fb_ccd2_469a_9fde_195d10951f7e);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecoder1_Vtbl {
    pub base__: ID3D12VideoDecoder_Vtbl,
    pub GetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VideoDecoderHeap(::windows::core::IUnknown);
impl ID3D12VideoDecoderHeap {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_DECODER_HEAP_DESC {
        let mut result__: D3D12_VIDEO_DECODER_HEAP_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDecoderHeap,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12VideoDecoderHeap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDecoderHeap {}
impl ::core::fmt::Debug for ID3D12VideoDecoderHeap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecoderHeap")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDecoderHeap {
    type Vtable = ID3D12VideoDecoderHeap_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDecoderHeap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecoderHeap {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x0946b7c9_ebf6_4047_bb73_8683e27dbb1f);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecoderHeap_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_VIDEO_DECODER_HEAP_DESC,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoDecoderHeap1(::windows::core::IUnknown);
impl ID3D12VideoDecoderHeap1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_DECODER_HEAP_DESC {
        let mut result__: D3D12_VIDEO_DECODER_HEAP_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).base__.GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDecoderHeap1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable,
    ID3D12VideoDecoderHeap
);
impl ::core::cmp::PartialEq for ID3D12VideoDecoderHeap1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDecoderHeap1 {}
impl ::core::fmt::Debug for ID3D12VideoDecoderHeap1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDecoderHeap1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDecoderHeap1 {
    type Vtable = ID3D12VideoDecoderHeap1_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDecoderHeap1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDecoderHeap1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xda1d98c5_539f_41b2_bf6b_1198a03b6d26);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDecoderHeap1_Vtbl {
    pub base__: ID3D12VideoDecoderHeap_Vtbl,
    pub GetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VideoDevice(::windows::core::IUnknown);
impl ID3D12VideoDevice {
    pub unsafe fn CheckFeatureSupport(
        &self,
        featurevideo: D3D12_FEATURE_VIDEO,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            featurevideo,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateVideoDecoder<T>(
        &self,
        pdesc: *const D3D12_VIDEO_DECODER_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoDecoder)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoDecoderHeap<T>(
        &self,
        pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoDecoderHeap)(
            ::windows::core::Interface::as_raw(self),
            pvideodecoderheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoProcessor<T>(
        &self,
        nodemask: u32,
        poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoProcessor)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            poutputstreamdesc,
            pinputstreamdescs.len() as _,
            ::core::mem::transmute(pinputstreamdescs.as_ptr()),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(ID3D12VideoDevice, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12VideoDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDevice {}
impl ::core::fmt::Debug for ID3D12VideoDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDevice").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDevice {
    type Vtable = ID3D12VideoDevice_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDevice {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDevice {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x1f052807_0b46_4acc_8a89_364f793718a4);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDevice_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub CheckFeatureSupport: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        featurevideo: D3D12_FEATURE_VIDEO,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::HRESULT,
    pub CreateVideoDecoder: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_VIDEO_DECODER_DESC,
        riid: *const ::windows::core::GUID,
        ppvideodecoder: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateVideoDecoderHeap: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
        riid: *const ::windows::core::GUID,
        ppvideodecoderheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateVideoProcessor: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        nodemask: u32,
        poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        numinputstreamdescs: u32,
        pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
        riid: *const ::windows::core::GUID,
        ppvideoprocessor: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VideoDevice1(::windows::core::IUnknown);
impl ID3D12VideoDevice1 {
    pub unsafe fn CheckFeatureSupport(
        &self,
        featurevideo: D3D12_FEATURE_VIDEO,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            featurevideo,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateVideoDecoder<T>(
        &self,
        pdesc: *const D3D12_VIDEO_DECODER_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateVideoDecoder)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoDecoderHeap<T>(
        &self,
        pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateVideoDecoderHeap)(
            ::windows::core::Interface::as_raw(self),
            pvideodecoderheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoProcessor<T>(
        &self,
        nodemask: u32,
        poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateVideoProcessor)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            poutputstreamdesc,
            pinputstreamdescs.len() as _,
            ::core::mem::transmute(pinputstreamdescs.as_ptr()),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoMotionEstimator<P0, T>(
        &self,
        pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoMotionEstimator)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoMotionVectorHeap<P0, T>(
        &self,
        pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoMotionVectorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDevice1,
    ::windows::core::IUnknown,
    ID3D12VideoDevice
);
impl ::core::cmp::PartialEq for ID3D12VideoDevice1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDevice1 {}
impl ::core::fmt::Debug for ID3D12VideoDevice1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDevice1").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDevice1 {
    type Vtable = ID3D12VideoDevice1_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDevice1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDevice1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x981611ad_a144_4c83_9890_f30e26d658ab);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDevice1_Vtbl {
    pub base__: ID3D12VideoDevice_Vtbl,
    pub CreateVideoMotionEstimator: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
        pprotectedresourcesession: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvideomotionestimator: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateVideoMotionVectorHeap: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
        pprotectedresourcesession: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvideomotionvectorheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VideoDevice2(::windows::core::IUnknown);
impl ID3D12VideoDevice2 {
    pub unsafe fn CheckFeatureSupport(
        &self,
        featurevideo: D3D12_FEATURE_VIDEO,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            featurevideo,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateVideoDecoder<T>(
        &self,
        pdesc: *const D3D12_VIDEO_DECODER_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateVideoDecoder)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoDecoderHeap<T>(
        &self,
        pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateVideoDecoderHeap)(
            ::windows::core::Interface::as_raw(self),
            pvideodecoderheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoProcessor<T>(
        &self,
        nodemask: u32,
        poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateVideoProcessor)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            poutputstreamdesc,
            pinputstreamdescs.len() as _,
            ::core::mem::transmute(pinputstreamdescs.as_ptr()),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoMotionEstimator<P0, T>(
        &self,
        pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateVideoMotionEstimator)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoMotionVectorHeap<P0, T>(
        &self,
        pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateVideoMotionVectorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoDecoder1<P0, T>(
        &self,
        pdesc: *const D3D12_VIDEO_DECODER_DESC,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoDecoder1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoDecoderHeap1<P0, T>(
        &self,
        pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoDecoderHeap1)(
            ::windows::core::Interface::as_raw(self),
            pvideodecoderheapdesc,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoProcessor1<P0, T>(
        &self,
        nodemask: u32,
        poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC],
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoProcessor1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            poutputstreamdesc,
            pinputstreamdescs.len() as _,
            ::core::mem::transmute(pinputstreamdescs.as_ptr()),
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoExtensionCommand<P0, T>(
        &self,
        pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC,
        pcreationparameters: *const ::core::ffi::c_void,
        creationparametersdatasizeinbytes: usize,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pcreationparameters,
            creationparametersdatasizeinbytes,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn ExecuteExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
        poutputdata: *mut ::core::ffi::c_void,
        outputdatasizeinbytes: usize,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).ExecuteExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pexecutionparameters,
            executionparameterssizeinbytes,
            poutputdata,
            outputdatasizeinbytes,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDevice2,
    ::windows::core::IUnknown,
    ID3D12VideoDevice,
    ID3D12VideoDevice1
);
impl ::core::cmp::PartialEq for ID3D12VideoDevice2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDevice2 {}
impl ::core::fmt::Debug for ID3D12VideoDevice2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDevice2").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDevice2 {
    type Vtable = ID3D12VideoDevice2_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDevice2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDevice2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xf019ac49_f838_4a95_9b17_579437c8f513);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDevice2_Vtbl {
    pub base__: ID3D12VideoDevice1_Vtbl,
    pub CreateVideoDecoder1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_VIDEO_DECODER_DESC,
        pprotectedresourcesession: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvideodecoder: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateVideoDecoderHeap1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
        pprotectedresourcesession: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvideodecoderheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateVideoProcessor1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        nodemask: u32,
        poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        numinputstreamdescs: u32,
        pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
        pprotectedresourcesession: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvideoprocessor: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateVideoExtensionCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC,
        pcreationparameters: *const ::core::ffi::c_void,
        creationparametersdatasizeinbytes: usize,
        pprotectedresourcesession: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvideoextensioncommand: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub ExecuteExtensionCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pextensioncommand: *mut ::core::ffi::c_void,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
        poutputdata: *mut ::core::ffi::c_void,
        outputdatasizeinbytes: usize,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VideoDevice3(::windows::core::IUnknown);
impl ID3D12VideoDevice3 {
    pub unsafe fn CheckFeatureSupport(
        &self,
        featurevideo: D3D12_FEATURE_VIDEO,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CheckFeatureSupport)(
            ::windows::core::Interface::as_raw(self),
            featurevideo,
            pfeaturesupportdata,
            featuresupportdatasize,
        )
        .ok()
    }
    pub unsafe fn CreateVideoDecoder<T>(
        &self,
        pdesc: *const D3D12_VIDEO_DECODER_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateVideoDecoder)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoDecoderHeap<T>(
        &self,
        pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateVideoDecoderHeap)(
            ::windows::core::Interface::as_raw(self),
            pvideodecoderheapdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoProcessor<T>(
        &self,
        nodemask: u32,
        poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC],
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .CreateVideoProcessor)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            poutputstreamdesc,
            pinputstreamdescs.len() as _,
            ::core::mem::transmute(pinputstreamdescs.as_ptr()),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoMotionEstimator<P0, T>(
        &self,
        pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateVideoMotionEstimator)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoMotionVectorHeap<P0, T>(
        &self,
        pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .CreateVideoMotionVectorHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoDecoder1<P0, T>(
        &self,
        pdesc: *const D3D12_VIDEO_DECODER_DESC,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateVideoDecoder1)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoDecoderHeap1<P0, T>(
        &self,
        pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateVideoDecoderHeap1)(
            ::windows::core::Interface::as_raw(self),
            pvideodecoderheapdesc,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoProcessor1<P0, T>(
        &self,
        nodemask: u32,
        poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        pinputstreamdescs: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC],
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateVideoProcessor1)(
            ::windows::core::Interface::as_raw(self),
            nodemask,
            poutputstreamdesc,
            pinputstreamdescs.len() as _,
            ::core::mem::transmute(pinputstreamdescs.as_ptr()),
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoExtensionCommand<P0, T>(
        &self,
        pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC,
        pcreationparameters: *const ::core::ffi::c_void,
        creationparametersdatasizeinbytes: usize,
        pprotectedresourcesession: P0,
    ) -> ::windows::core::Result<T>
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self)
            .base__
            .CreateVideoExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            pcreationparameters,
            creationparametersdatasizeinbytes,
            pprotectedresourcesession.into_param().abi(),
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn ExecuteExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
        poutputdata: *mut ::core::ffi::c_void,
        outputdatasizeinbytes: usize,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ExecuteExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pexecutionparameters,
            executionparameterssizeinbytes,
            poutputdata,
            outputdatasizeinbytes,
        )
        .ok()
    }
    pub unsafe fn CreateVideoEncoder<T>(
        &self,
        pdesc: *const D3D12_VIDEO_ENCODER_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoEncoder)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateVideoEncoderHeap<T>(
        &self,
        pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC,
    ) -> ::windows::core::Result<T>
    where
        T: ::windows::core::ComInterface,
    {
        let mut result__ = ::std::ptr::null_mut();
        (::windows::core::Interface::vtable(self).CreateVideoEncoderHeap)(
            ::windows::core::Interface::as_raw(self),
            pdesc,
            &<T as ::windows::core::ComInterface>::IID,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoDevice3,
    ::windows::core::IUnknown,
    ID3D12VideoDevice,
    ID3D12VideoDevice1,
    ID3D12VideoDevice2
);
impl ::core::cmp::PartialEq for ID3D12VideoDevice3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoDevice3 {}
impl ::core::fmt::Debug for ID3D12VideoDevice3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoDevice3").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoDevice3 {
    type Vtable = ID3D12VideoDevice3_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoDevice3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoDevice3 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x4243adb4_3a32_4666_973c_0ccc5625dc44);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoDevice3_Vtbl {
    pub base__: ID3D12VideoDevice2_Vtbl,
    pub CreateVideoEncoder: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_VIDEO_ENCODER_DESC,
        riid: *const ::windows::core::GUID,
        ppvideoencoder: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub CreateVideoEncoderHeap: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC,
        riid: *const ::windows::core::GUID,
        ppvideoencoderheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VideoEncodeCommandList(::windows::core::IUnknown);
impl ID3D12VideoEncodeCommandList {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.GetType)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self))
            .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).ClearState)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).EndEvent)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn EstimateMotion<P0>(
        &self,
        pmotionestimator: P0,
        poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT,
        pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoMotionEstimator>,
    {
        (::windows::core::Interface::vtable(self).EstimateMotion)(
            ::windows::core::Interface::as_raw(self),
            pmotionestimator.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn ResolveMotionVectorHeap(
        &self,
        poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT,
        pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT,
    ) {
        (::windows::core::Interface::vtable(self).ResolveMotionVectorHeap)(
            ::windows::core::Interface::as_raw(self),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self).WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoEncodeCommandList,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList
);
impl ::core::cmp::PartialEq for ID3D12VideoEncodeCommandList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoEncodeCommandList {}
impl ::core::fmt::Debug for ID3D12VideoEncodeCommandList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncodeCommandList")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoEncodeCommandList {
    type Vtable = ID3D12VideoEncodeCommandList_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoEncodeCommandList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncodeCommandList {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x8455293a_0cbd_4831_9b39_fbdbab724723);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncodeCommandList_Vtbl {
    pub base__: ID3D12CommandList_Vtbl,
    pub Close:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pallocator: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub ClearState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub ResourceBarrier: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numbarriers: u32,
        pbarriers: *const D3D12_RESOURCE_BARRIER,
    ),
    pub DiscardResource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        pregion: *const D3D12_DISCARD_REGION,
    ),
    pub BeginQuery: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    ),
    pub EndQuery: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    ),
    pub ResolveQueryData: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: *mut ::core::ffi::c_void,
        aligneddestinationbufferoffset: u64,
    ),
    pub SetPredication: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pbuffer: *mut ::core::ffi::c_void,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ),
    pub SetMarker: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        metadata: u32,
        pdata: *const ::core::ffi::c_void,
        size: u32,
    ),
    pub BeginEvent: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        metadata: u32,
        pdata: *const ::core::ffi::c_void,
        size: u32,
    ),
    pub EndEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub EstimateMotion: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pmotionestimator: *mut ::core::ffi::c_void,
        poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT,
        pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT,
    ),
    pub ResolveMotionVectorHeap: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT,
        pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT,
    ),
    pub WriteBufferImmediate: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
    ),
    pub SetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pprotectedresourcesession: *mut ::core::ffi::c_void,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoEncodeCommandList1(::windows::core::IUnknown);
impl ID3D12VideoEncodeCommandList1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Close)(::windows::core::Interface::as_raw(
            self,
        ))
        .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.ClearState)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).base__.SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).base__.BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.EndEvent)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn EstimateMotion<P0>(
        &self,
        pmotionestimator: P0,
        poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT,
        pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoMotionEstimator>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .EstimateMotion)(
            ::windows::core::Interface::as_raw(self),
            pmotionestimator.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn ResolveMotionVectorHeap(
        &self,
        poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT,
        pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResolveMotionVectorHeap)(
            ::windows::core::Interface::as_raw(self),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn InitializeExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).InitializeExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pinitializationparameters,
            initializationparameterssizeinbytes,
        )
    }
    pub unsafe fn ExecuteExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).ExecuteExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pexecutionparameters,
            executionparameterssizeinbytes,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoEncodeCommandList1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12VideoEncodeCommandList
);
impl ::core::cmp::PartialEq for ID3D12VideoEncodeCommandList1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoEncodeCommandList1 {}
impl ::core::fmt::Debug for ID3D12VideoEncodeCommandList1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncodeCommandList1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoEncodeCommandList1 {
    type Vtable = ID3D12VideoEncodeCommandList1_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoEncodeCommandList1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncodeCommandList1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x94971eca_2bdb_4769_88cf_3675ea757ebc);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncodeCommandList1_Vtbl {
    pub base__: ID3D12VideoEncodeCommandList_Vtbl,
    pub InitializeExtensionCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pextensioncommand: *mut ::core::ffi::c_void,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    ),
    pub ExecuteExtensionCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pextensioncommand: *mut ::core::ffi::c_void,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoEncodeCommandList2(::windows::core::IUnknown);
impl ID3D12VideoEncodeCommandList2 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Close)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ClearState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn EstimateMotion<P0>(
        &self,
        pmotionestimator: P0,
        poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT,
        pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoMotionEstimator>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EstimateMotion)(
            ::windows::core::Interface::as_raw(self),
            pmotionestimator.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn ResolveMotionVectorHeap(
        &self,
        poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT,
        pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResolveMotionVectorHeap)(
            ::windows::core::Interface::as_raw(self),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn InitializeExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .InitializeExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pinitializationparameters,
            initializationparameterssizeinbytes,
        )
    }
    pub unsafe fn ExecuteExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ExecuteExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pexecutionparameters,
            executionparameterssizeinbytes,
        )
    }
    pub unsafe fn EncodeFrame<P0, P1>(
        &self,
        pencoder: P0,
        pheap: P1,
        pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS,
        poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoEncoder>,
        P1: ::windows::core::IntoParam<ID3D12VideoEncoderHeap>,
    {
        (::windows::core::Interface::vtable(self).EncodeFrame)(
            ::windows::core::Interface::as_raw(self),
            pencoder.into_param().abi(),
            pheap.into_param().abi(),
            pinputarguments,
            poutputarguments,
        )
    }
    pub unsafe fn ResolveEncoderOutputMetadata(
        &self,
        pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS,
        poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS,
    ) {
        (::windows::core::Interface::vtable(self).ResolveEncoderOutputMetadata)(
            ::windows::core::Interface::as_raw(self),
            pinputarguments,
            poutputarguments,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoEncodeCommandList2,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12VideoEncodeCommandList,
    ID3D12VideoEncodeCommandList1
);
impl ::core::cmp::PartialEq for ID3D12VideoEncodeCommandList2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoEncodeCommandList2 {}
impl ::core::fmt::Debug for ID3D12VideoEncodeCommandList2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncodeCommandList2")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoEncodeCommandList2 {
    type Vtable = ID3D12VideoEncodeCommandList2_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoEncodeCommandList2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncodeCommandList2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x895491e2_e701_46a9_9a1f_8d3480ed867a);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncodeCommandList2_Vtbl {
    pub base__: ID3D12VideoEncodeCommandList1_Vtbl,
    pub EncodeFrame: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pencoder: *mut ::core::ffi::c_void,
        pheap: *mut ::core::ffi::c_void,
        pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS,
        poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS,
    ),
    pub ResolveEncoderOutputMetadata: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS,
        poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoEncodeCommandList3(::windows::core::IUnknown);
impl ID3D12VideoEncodeCommandList3 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ClearState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn EstimateMotion<P0>(
        &self,
        pmotionestimator: P0,
        poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT,
        pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoMotionEstimator>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EstimateMotion)(
            ::windows::core::Interface::as_raw(self),
            pmotionestimator.into_param().abi(),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn ResolveMotionVectorHeap(
        &self,
        poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT,
        pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResolveMotionVectorHeap)(
            ::windows::core::Interface::as_raw(self),
            poutputarguments,
            pinputarguments,
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn InitializeExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .InitializeExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pinitializationparameters,
            initializationparameterssizeinbytes,
        )
    }
    pub unsafe fn ExecuteExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ExecuteExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pexecutionparameters,
            executionparameterssizeinbytes,
        )
    }
    pub unsafe fn EncodeFrame<P0, P1>(
        &self,
        pencoder: P0,
        pheap: P1,
        pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS,
        poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoEncoder>,
        P1: ::windows::core::IntoParam<ID3D12VideoEncoderHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.EncodeFrame)(
            ::windows::core::Interface::as_raw(self),
            pencoder.into_param().abi(),
            pheap.into_param().abi(),
            pinputarguments,
            poutputarguments,
        )
    }
    pub unsafe fn ResolveEncoderOutputMetadata(
        &self,
        pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS,
        poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResolveEncoderOutputMetadata)(
            ::windows::core::Interface::as_raw(self),
            pinputarguments,
            poutputarguments,
        )
    }
    pub unsafe fn Barrier(&self, pbarriergroups: &[D3D12_BARRIER_GROUP]) {
        (::windows::core::Interface::vtable(self).Barrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriergroups.len() as _,
            ::core::mem::transmute(pbarriergroups.as_ptr()),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoEncodeCommandList3,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12VideoEncodeCommandList,
    ID3D12VideoEncodeCommandList1,
    ID3D12VideoEncodeCommandList2
);
impl ::core::cmp::PartialEq for ID3D12VideoEncodeCommandList3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoEncodeCommandList3 {}
impl ::core::fmt::Debug for ID3D12VideoEncodeCommandList3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncodeCommandList3")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoEncodeCommandList3 {
    type Vtable = ID3D12VideoEncodeCommandList3_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoEncodeCommandList3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncodeCommandList3 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x7f027b22_1515_4e85_aa0d_026486580576);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncodeCommandList3_Vtbl {
    pub base__: ID3D12VideoEncodeCommandList2_Vtbl,
    pub Barrier: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numbarriergroups: u32,
        pbarriergroups: *const D3D12_BARRIER_GROUP,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoEncoder(::windows::core::IUnknown);
impl ID3D12VideoEncoder {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetNodeMask(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNodeMask)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetEncoderFlags(&self) -> D3D12_VIDEO_ENCODER_FLAGS {
        (::windows::core::Interface::vtable(self).GetEncoderFlags)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetCodec(&self) -> D3D12_VIDEO_ENCODER_CODEC {
        (::windows::core::Interface::vtable(self).GetCodec)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetCodecProfile(
        &self,
        dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCodecProfile)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(dstprofile),
        )
        .ok()
    }
    pub unsafe fn GetCodecConfiguration(
        &self,
        dstcodecconfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCodecConfiguration)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(dstcodecconfig),
        )
        .ok()
    }
    pub unsafe fn GetInputFormat(&self) -> DXGI_FORMAT {
        (::windows::core::Interface::vtable(self).GetInputFormat)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetMaxMotionEstimationPrecision(
        &self,
    ) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
        (::windows::core::Interface::vtable(self).GetMaxMotionEstimationPrecision)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoEncoder,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12VideoEncoder {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoEncoder {}
impl ::core::fmt::Debug for ID3D12VideoEncoder {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncoder").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoEncoder {
    type Vtable = ID3D12VideoEncoder_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoEncoder {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncoder {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x2e0d212d_8df9_44a6_a770_bb289b182737);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncoder_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetNodeMask: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetEncoderFlags:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_FLAGS,
    pub GetCodec:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_CODEC,
    pub GetCodecProfile: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetCodecConfiguration: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        dstcodecconfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
    ) -> ::windows::core::HRESULT,
    pub GetInputFormat: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> DXGI_FORMAT,
    pub GetMaxMotionEstimationPrecision:
        unsafe extern "system" fn(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE,
}
#[repr(transparent)]
pub struct ID3D12VideoEncoderHeap(::windows::core::IUnknown);
impl ID3D12VideoEncoderHeap {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetNodeMask(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNodeMask)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetEncoderHeapFlags(&self) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS {
        (::windows::core::Interface::vtable(self).GetEncoderHeapFlags)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetCodec(&self) -> D3D12_VIDEO_ENCODER_CODEC {
        (::windows::core::Interface::vtable(self).GetCodec)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetCodecProfile(
        &self,
        dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCodecProfile)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(dstprofile),
        )
        .ok()
    }
    pub unsafe fn GetCodecLevel(
        &self,
        dstlevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetCodecLevel)(
            ::windows::core::Interface::as_raw(self),
            ::core::mem::transmute(dstlevel),
        )
        .ok()
    }
    pub unsafe fn GetResolutionListCount(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetResolutionListCount)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetResolutionList(
        &self,
        presolutionlist: &mut [D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetResolutionList)(
            ::windows::core::Interface::as_raw(self),
            presolutionlist.len() as _,
            ::core::mem::transmute(presolutionlist.as_ptr()),
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoEncoderHeap,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12VideoEncoderHeap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoEncoderHeap {}
impl ::core::fmt::Debug for ID3D12VideoEncoderHeap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoEncoderHeap")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoEncoderHeap {
    type Vtable = ID3D12VideoEncoderHeap_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoEncoderHeap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoEncoderHeap {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x22b35d96_876a_44c0_b25e_fb8c9c7f1c4a);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoEncoderHeap_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetNodeMask: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetEncoderHeapFlags:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS,
    pub GetCodec:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> D3D12_VIDEO_ENCODER_CODEC,
    pub GetCodecProfile: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetCodecLevel: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        dstlevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    ) -> ::windows::core::HRESULT,
    pub GetResolutionListCount: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetResolutionList: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        resolutionslistcount: u32,
        presolutionlist: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VideoExtensionCommand(::windows::core::IUnknown);
impl ID3D12VideoExtensionCommand {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_EXTENSION_COMMAND_DESC {
        let mut result__: D3D12_VIDEO_EXTENSION_COMMAND_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoExtensionCommand,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12VideoExtensionCommand {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoExtensionCommand {}
impl ::core::fmt::Debug for ID3D12VideoExtensionCommand {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoExtensionCommand")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoExtensionCommand {
    type Vtable = ID3D12VideoExtensionCommand_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoExtensionCommand {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoExtensionCommand {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x554e41e8_ae8e_4a8c_b7d2_5b4f274a30e4);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoExtensionCommand_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_VIDEO_EXTENSION_COMMAND_DESC,
    ),
    pub GetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VideoMotionEstimator(::windows::core::IUnknown);
impl ID3D12VideoMotionEstimator {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
        let mut result__: D3D12_VIDEO_MOTION_ESTIMATOR_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoMotionEstimator,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12VideoMotionEstimator {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoMotionEstimator {}
impl ::core::fmt::Debug for ID3D12VideoMotionEstimator {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoMotionEstimator")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoMotionEstimator {
    type Vtable = ID3D12VideoMotionEstimator_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoMotionEstimator {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoMotionEstimator {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x33fdae0e_098b_428f_87bb_34b695de08f8);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoMotionEstimator_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
    ),
    pub GetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VideoMotionVectorHeap(::windows::core::IUnknown);
impl ID3D12VideoMotionVectorHeap {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetDesc(&self) -> D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
        let mut result__: D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoMotionVectorHeap,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12VideoMotionVectorHeap {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoMotionVectorHeap {}
impl ::core::fmt::Debug for ID3D12VideoMotionVectorHeap {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoMotionVectorHeap")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoMotionVectorHeap {
    type Vtable = ID3D12VideoMotionVectorHeap_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoMotionVectorHeap {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoMotionVectorHeap {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x5be17987_743a_4061_834b_23d22daea505);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoMotionVectorHeap_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
    ),
    pub GetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VideoProcessCommandList(::windows::core::IUnknown);
impl ID3D12VideoProcessCommandList {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self).base__.GetType)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(::windows::core::Interface::as_raw(self))
            .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).ClearState)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self).ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self).SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).EndEvent)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn ProcessFrames<P0>(
        &self,
        pvideoprocessor: P0,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS],
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self).ProcessFrames)(
            ::windows::core::Interface::as_raw(self),
            pvideoprocessor.into_param().abi(),
            poutputarguments,
            pinputarguments.len() as _,
            ::core::mem::transmute(pinputarguments.as_ptr()),
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self).WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoProcessCommandList,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList
);
impl ::core::cmp::PartialEq for ID3D12VideoProcessCommandList {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoProcessCommandList {}
impl ::core::fmt::Debug for ID3D12VideoProcessCommandList {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessCommandList")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoProcessCommandList {
    type Vtable = ID3D12VideoProcessCommandList_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoProcessCommandList {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessCommandList {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xaeb2543a_167f_4682_acc8_d159ed4a6209);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessCommandList_Vtbl {
    pub base__: ID3D12CommandList_Vtbl,
    pub Close:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> ::windows::core::HRESULT,
    pub Reset: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pallocator: *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
    pub ClearState: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub ResourceBarrier: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numbarriers: u32,
        pbarriers: *const D3D12_RESOURCE_BARRIER,
    ),
    pub DiscardResource: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        presource: *mut ::core::ffi::c_void,
        pregion: *const D3D12_DISCARD_REGION,
    ),
    pub BeginQuery: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    ),
    pub EndQuery: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    ),
    pub ResolveQueryData: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pqueryheap: *mut ::core::ffi::c_void,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: *mut ::core::ffi::c_void,
        aligneddestinationbufferoffset: u64,
    ),
    pub SetPredication: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pbuffer: *mut ::core::ffi::c_void,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ),
    pub SetMarker: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        metadata: u32,
        pdata: *const ::core::ffi::c_void,
        size: u32,
    ),
    pub BeginEvent: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        metadata: u32,
        pdata: *const ::core::ffi::c_void,
        size: u32,
    ),
    pub EndEvent: unsafe extern "system" fn(this: *mut ::core::ffi::c_void),
    pub ProcessFrames: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pvideoprocessor: *mut ::core::ffi::c_void,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        numinputstreams: u32,
        pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS,
    ),
    pub WriteBufferImmediate: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoProcessCommandList1(::windows::core::IUnknown);
impl ID3D12VideoProcessCommandList1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.Close)(::windows::core::Interface::as_raw(
            self,
        ))
        .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self).base__.ClearState)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self).base__.EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).base__.SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self).base__.BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self).base__.EndEvent)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn ProcessFrames<P0>(
        &self,
        pvideoprocessor: P0,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS],
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ProcessFrames)(
            ::windows::core::Interface::as_raw(self),
            pvideoprocessor.into_param().abi(),
            poutputarguments,
            pinputarguments.len() as _,
            ::core::mem::transmute(pinputarguments.as_ptr()),
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ProcessFrames1<P0>(
        &self,
        pvideoprocessor: P0,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1],
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self).ProcessFrames1)(
            ::windows::core::Interface::as_raw(self),
            pvideoprocessor.into_param().abi(),
            poutputarguments,
            pinputarguments.len() as _,
            ::core::mem::transmute(pinputarguments.as_ptr()),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoProcessCommandList1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12VideoProcessCommandList
);
impl ::core::cmp::PartialEq for ID3D12VideoProcessCommandList1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoProcessCommandList1 {}
impl ::core::fmt::Debug for ID3D12VideoProcessCommandList1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessCommandList1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoProcessCommandList1 {
    type Vtable = ID3D12VideoProcessCommandList1_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoProcessCommandList1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessCommandList1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x542c5c4d_7596_434f_8c93_4efa6766f267);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessCommandList1_Vtbl {
    pub base__: ID3D12VideoProcessCommandList_Vtbl,
    pub ProcessFrames1: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pvideoprocessor: *mut ::core::ffi::c_void,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        numinputstreams: u32,
        pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoProcessCommandList2(::windows::core::IUnknown);
impl ID3D12VideoProcessCommandList2 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).base__.base__.Close)(
            ::windows::core::Interface::as_raw(self),
        )
        .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self).base__.base__.Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ClearState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ProcessFrames<P0>(
        &self,
        pvideoprocessor: P0,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS],
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ProcessFrames)(
            ::windows::core::Interface::as_raw(self),
            pvideoprocessor.into_param().abi(),
            poutputarguments,
            pinputarguments.len() as _,
            ::core::mem::transmute(pinputarguments.as_ptr()),
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ProcessFrames1<P0>(
        &self,
        pvideoprocessor: P0,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1],
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ProcessFrames1)(
            ::windows::core::Interface::as_raw(self),
            pvideoprocessor.into_param().abi(),
            poutputarguments,
            pinputarguments.len() as _,
            ::core::mem::transmute(pinputarguments.as_ptr()),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self).SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn InitializeExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).InitializeExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pinitializationparameters,
            initializationparameterssizeinbytes,
        )
    }
    pub unsafe fn ExecuteExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self).ExecuteExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pexecutionparameters,
            executionparameterssizeinbytes,
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoProcessCommandList2,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12VideoProcessCommandList,
    ID3D12VideoProcessCommandList1
);
impl ::core::cmp::PartialEq for ID3D12VideoProcessCommandList2 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoProcessCommandList2 {}
impl ::core::fmt::Debug for ID3D12VideoProcessCommandList2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessCommandList2")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoProcessCommandList2 {
    type Vtable = ID3D12VideoProcessCommandList2_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoProcessCommandList2 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessCommandList2 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xdb525ae4_6ad6_473c_baa7_59b2e37082e4);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessCommandList2_Vtbl {
    pub base__: ID3D12VideoProcessCommandList1_Vtbl,
    pub SetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pprotectedresourcesession: *mut ::core::ffi::c_void,
    ),
    pub InitializeExtensionCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pextensioncommand: *mut ::core::ffi::c_void,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    ),
    pub ExecuteExtensionCommand: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pextensioncommand: *mut ::core::ffi::c_void,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoProcessCommandList3(::windows::core::IUnknown);
impl ID3D12VideoProcessCommandList3 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetType)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn Close(&self) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Close)(::windows::core::Interface::as_raw(self))
        .ok()
    }
    pub unsafe fn Reset<P0>(&self, pallocator: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<ID3D12CommandAllocator>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .Reset)(
            ::windows::core::Interface::as_raw(self),
            pallocator.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn ClearState(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ClearState)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ResourceBarrier(&self, pbarriers: &[D3D12_RESOURCE_BARRIER]) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResourceBarrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriers.len() as _,
            ::core::mem::transmute(pbarriers.as_ptr()),
        )
    }
    pub unsafe fn DiscardResource<P0>(
        &self,
        presource: P0,
        pregion: ::core::option::Option<*const D3D12_DISCARD_REGION>,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .DiscardResource)(
            ::windows::core::Interface::as_raw(self),
            presource.into_param().abi(),
            ::core::mem::transmute(pregion.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn BeginQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .BeginQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn EndQuery<P0>(&self, pqueryheap: P0, r#type: D3D12_QUERY_TYPE, index: u32)
    where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EndQuery)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            index,
        )
    }
    pub unsafe fn ResolveQueryData<P0, P1>(
        &self,
        pqueryheap: P0,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: P1,
        aligneddestinationbufferoffset: u64,
    ) where
        P0: ::windows::core::IntoParam<ID3D12QueryHeap>,
        P1: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ResolveQueryData)(
            ::windows::core::Interface::as_raw(self),
            pqueryheap.into_param().abi(),
            r#type,
            startindex,
            numqueries,
            pdestinationbuffer.into_param().abi(),
            aligneddestinationbufferoffset,
        )
    }
    pub unsafe fn SetPredication<P0>(
        &self,
        pbuffer: P0,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    ) where
        P0: ::windows::core::IntoParam<ID3D12Resource>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPredication)(
            ::windows::core::Interface::as_raw(self),
            pbuffer.into_param().abi(),
            alignedbufferoffset,
            operation,
        )
    }
    pub unsafe fn SetMarker(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetMarker)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn BeginEvent(
        &self,
        metadata: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
        size: u32,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .BeginEvent)(
            ::windows::core::Interface::as_raw(self),
            metadata,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
            size,
        )
    }
    pub unsafe fn EndEvent(&self) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .EndEvent)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn ProcessFrames<P0>(
        &self,
        pvideoprocessor: P0,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS],
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .ProcessFrames)(
            ::windows::core::Interface::as_raw(self),
            pvideoprocessor.into_param().abi(),
            poutputarguments,
            pinputarguments.len() as _,
            ::core::mem::transmute(pinputarguments.as_ptr()),
        )
    }
    pub unsafe fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: ::core::option::Option<*const D3D12_WRITEBUFFERIMMEDIATE_MODE>,
    ) {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .WriteBufferImmediate)(
            ::windows::core::Interface::as_raw(self),
            count,
            pparams,
            ::core::mem::transmute(pmodes.unwrap_or(::std::ptr::null())),
        )
    }
    pub unsafe fn ProcessFrames1<P0>(
        &self,
        pvideoprocessor: P0,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: &[D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1],
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoProcessor>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .ProcessFrames1)(
            ::windows::core::Interface::as_raw(self),
            pvideoprocessor.into_param().abi(),
            poutputarguments,
            pinputarguments.len() as _,
            ::core::mem::transmute(pinputarguments.as_ptr()),
        )
    }
    pub unsafe fn SetProtectedResourceSession<P0>(&self, pprotectedresourcesession: P0)
    where
        P0: ::windows::core::IntoParam<ID3D12ProtectedResourceSession>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .SetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            pprotectedresourcesession.into_param().abi(),
        )
    }
    pub unsafe fn InitializeExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .InitializeExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pinitializationparameters,
            initializationparameterssizeinbytes,
        )
    }
    pub unsafe fn ExecuteExtensionCommand<P0>(
        &self,
        pextensioncommand: P0,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    ) where
        P0: ::windows::core::IntoParam<ID3D12VideoExtensionCommand>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .ExecuteExtensionCommand)(
            ::windows::core::Interface::as_raw(self),
            pextensioncommand.into_param().abi(),
            pexecutionparameters,
            executionparameterssizeinbytes,
        )
    }
    pub unsafe fn Barrier(&self, pbarriergroups: &[D3D12_BARRIER_GROUP]) {
        (::windows::core::Interface::vtable(self).Barrier)(
            ::windows::core::Interface::as_raw(self),
            pbarriergroups.len() as _,
            ::core::mem::transmute(pbarriergroups.as_ptr()),
        )
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoProcessCommandList3,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12CommandList,
    ID3D12VideoProcessCommandList,
    ID3D12VideoProcessCommandList1,
    ID3D12VideoProcessCommandList2
);
impl ::core::cmp::PartialEq for ID3D12VideoProcessCommandList3 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoProcessCommandList3 {}
impl ::core::fmt::Debug for ID3D12VideoProcessCommandList3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessCommandList3")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoProcessCommandList3 {
    type Vtable = ID3D12VideoProcessCommandList3_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoProcessCommandList3 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessCommandList3 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x1a0a4ca4_9f08_40ce_9558_b411fd2666ff);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessCommandList3_Vtbl {
    pub base__: ID3D12VideoProcessCommandList2_Vtbl,
    pub Barrier: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numbarriergroups: u32,
        pbarriergroups: *const D3D12_BARRIER_GROUP,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoProcessor(::windows::core::IUnknown);
impl ID3D12VideoProcessor {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetNodeMask(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNodeMask)(::windows::core::Interface::as_raw(
            self,
        ))
    }
    pub unsafe fn GetNumInputStreamDescs(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNumInputStreamDescs)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetInputStreamDescs(
        &self,
        pinputstreamdescs: &mut [D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).GetInputStreamDescs)(
            ::windows::core::Interface::as_raw(self),
            pinputstreamdescs.len() as _,
            ::core::mem::transmute(pinputstreamdescs.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn GetOutputStreamDesc(&self) -> D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
        let mut result__: D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetOutputStreamDesc)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
        );
        result__
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoProcessor,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable
);
impl ::core::cmp::PartialEq for ID3D12VideoProcessor {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoProcessor {}
impl ::core::fmt::Debug for ID3D12VideoProcessor {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessor")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoProcessor {
    type Vtable = ID3D12VideoProcessor_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoProcessor {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessor {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x304fdb32_bede_410a_8545_943ac6a46138);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessor_Vtbl {
    pub base__: ID3D12Pageable_Vtbl,
    pub GetNodeMask: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetNumInputStreamDescs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetInputStreamDescs: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        numinputstreamdescs: u32,
        pinputstreamdescs: *mut D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
    ) -> ::windows::core::HRESULT,
    pub GetOutputStreamDesc: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
    ),
}
#[repr(transparent)]
pub struct ID3D12VideoProcessor1(::windows::core::IUnknown);
impl ID3D12VideoProcessor1 {
    pub unsafe fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: ::core::option::Option<*mut ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .GetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdatasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null_mut())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: ::core::option::Option<*const ::core::ffi::c_void>,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateData)(
            ::windows::core::Interface::as_raw(self),
            guid,
            datasize,
            ::core::mem::transmute(pdata.unwrap_or(::std::ptr::null())),
        )
        .ok()
    }
    pub unsafe fn SetPrivateDataInterface<P0>(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: P0,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::IUnknown>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetPrivateDataInterface)(
            ::windows::core::Interface::as_raw(self),
            guid,
            pdata.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn SetName<P0>(&self, name: P0) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .base__
            .SetName)(
            ::windows::core::Interface::as_raw(self),
            name.into_param().abi(),
        )
        .ok()
    }
    pub unsafe fn GetDevice<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self)
            .base__
            .base__
            .base__
            .GetDevice)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
    pub unsafe fn GetNodeMask(&self) -> u32 {
        (::windows::core::Interface::vtable(self).base__.GetNodeMask)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetNumInputStreamDescs(&self) -> u32 {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetNumInputStreamDescs)(::windows::core::Interface::as_raw(self))
    }
    pub unsafe fn GetInputStreamDescs(
        &self,
        pinputstreamdescs: &mut [D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC],
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self)
            .base__
            .GetInputStreamDescs)(
            ::windows::core::Interface::as_raw(self),
            pinputstreamdescs.len() as _,
            ::core::mem::transmute(pinputstreamdescs.as_ptr()),
        )
        .ok()
    }
    pub unsafe fn GetOutputStreamDesc(&self) -> D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
        let mut result__: D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self)
            .base__
            .GetOutputStreamDesc)(::windows::core::Interface::as_raw(self), &mut result__);
        result__
    }
    pub unsafe fn GetProtectedResourceSession<T>(
        &self,
        result__: *mut ::core::option::Option<T>,
    ) -> ::windows::core::Result<()>
    where
        T: ::windows::core::ComInterface,
    {
        (::windows::core::Interface::vtable(self).GetProtectedResourceSession)(
            ::windows::core::Interface::as_raw(self),
            &<T as ::windows::core::ComInterface>::IID,
            result__ as *mut _ as *mut _,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(
    ID3D12VideoProcessor1,
    ::windows::core::IUnknown,
    ID3D12Object,
    ID3D12DeviceChild,
    ID3D12Pageable,
    ID3D12VideoProcessor
);
impl ::core::cmp::PartialEq for ID3D12VideoProcessor1 {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VideoProcessor1 {}
impl ::core::fmt::Debug for ID3D12VideoProcessor1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VideoProcessor1")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VideoProcessor1 {
    type Vtable = ID3D12VideoProcessor1_Vtbl;
}
impl ::core::clone::Clone for ID3D12VideoProcessor1 {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VideoProcessor1 {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xf3cfe615_553f_425c_86d8_ee8c1b1fb01c);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VideoProcessor1_Vtbl {
    pub base__: ID3D12VideoProcessor_Vtbl,
    pub GetProtectedResourceSession: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12VirtualizationGuestDevice(::windows::core::IUnknown);
impl ID3D12VirtualizationGuestDevice {
    pub unsafe fn ShareWithHost<P0>(
        &self,
        pobject: P0,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>
    where
        P0: ::windows::core::IntoParam<ID3D12DeviceChild>,
    {
        let mut result__ = ::windows::core::zeroed::<::windows::Win32::Foundation::HANDLE>();
        (::windows::core::Interface::vtable(self).ShareWithHost)(
            ::windows::core::Interface::as_raw(self),
            pobject.into_param().abi(),
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn CreateFenceFd<P0>(
        &self,
        pfence: P0,
        fencevalue: u64,
    ) -> ::windows::core::Result<i32>
    where
        P0: ::windows::core::IntoParam<ID3D12Fence>,
    {
        let mut result__ = ::windows::core::zeroed::<i32>();
        (::windows::core::Interface::vtable(self).CreateFenceFd)(
            ::windows::core::Interface::as_raw(self),
            pfence.into_param().abi(),
            fencevalue,
            &mut result__,
        )
        .from_abi(result__)
    }
}
::windows::imp::interface_hierarchy!(ID3D12VirtualizationGuestDevice, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12VirtualizationGuestDevice {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12VirtualizationGuestDevice {}
impl ::core::fmt::Debug for ID3D12VirtualizationGuestDevice {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12VirtualizationGuestDevice")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12VirtualizationGuestDevice {
    type Vtable = ID3D12VirtualizationGuestDevice_Vtbl;
}
impl ::core::clone::Clone for ID3D12VirtualizationGuestDevice {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12VirtualizationGuestDevice {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xbc66d368_7373_4943_8757_fc87dc79e476);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12VirtualizationGuestDevice_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub ShareWithHost: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pobject: *mut ::core::ffi::c_void,
        phandle: *mut ::windows::Win32::Foundation::HANDLE,
    ) -> ::windows::core::HRESULT,
    pub CreateFenceFd: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pfence: *mut ::core::ffi::c_void,
        fencevalue: u64,
        pfencefd: *mut i32,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3D12WorkGraphProperties(::windows::core::IUnknown);
impl ID3D12WorkGraphProperties {
    pub unsafe fn GetNumWorkGraphs(&self) -> u32 {
        (::windows::core::Interface::vtable(self).GetNumWorkGraphs)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetProgramName(&self, workgraphindex: u32) -> ::windows::core::PWSTR {
        (::windows::core::Interface::vtable(self).GetProgramName)(
            ::windows::core::Interface::as_raw(self),
            workgraphindex,
        )
    }
    pub unsafe fn GetWorkGraphIndex<P0>(&self, pprogramname: P0) -> u32
    where
        P0: ::windows::core::IntoParam<::windows::core::PCWSTR>,
    {
        (::windows::core::Interface::vtable(self).GetWorkGraphIndex)(
            ::windows::core::Interface::as_raw(self),
            pprogramname.into_param().abi(),
        )
    }
    pub unsafe fn GetNumNodes(&self, workgraphindex: u32) -> u32 {
        (::windows::core::Interface::vtable(self).GetNumNodes)(
            ::windows::core::Interface::as_raw(self),
            workgraphindex,
        )
    }
    pub unsafe fn GetNodeID(&self, workgraphindex: u32, nodeindex: u32) -> D3D12_NODE_ID {
        let mut result__: D3D12_NODE_ID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetNodeID)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            workgraphindex,
            nodeindex,
        );
        result__
    }
    pub unsafe fn GetNodeIndex(&self, workgraphindex: u32, nodeid: D3D12_NODE_ID) -> u32 {
        (::windows::core::Interface::vtable(self).GetNodeIndex)(
            ::windows::core::Interface::as_raw(self),
            workgraphindex,
            ::core::mem::transmute(nodeid),
        )
    }
    pub unsafe fn GetNodeLocalRootArgumentsTableIndex(
        &self,
        workgraphindex: u32,
        nodeindex: u32,
    ) -> u32 {
        (::windows::core::Interface::vtable(self).GetNodeLocalRootArgumentsTableIndex)(
            ::windows::core::Interface::as_raw(self),
            workgraphindex,
            nodeindex,
        )
    }
    pub unsafe fn GetNumEntrypoints(&self, workgraphindex: u32) -> u32 {
        (::windows::core::Interface::vtable(self).GetNumEntrypoints)(
            ::windows::core::Interface::as_raw(self),
            workgraphindex,
        )
    }
    pub unsafe fn GetEntrypointID(
        &self,
        workgraphindex: u32,
        entrypointindex: u32,
    ) -> D3D12_NODE_ID {
        let mut result__: D3D12_NODE_ID = ::core::mem::zeroed();
        (::windows::core::Interface::vtable(self).GetEntrypointID)(
            ::windows::core::Interface::as_raw(self),
            &mut result__,
            workgraphindex,
            entrypointindex,
        );
        result__
    }
    pub unsafe fn GetEntrypointIndex(&self, workgraphindex: u32, nodeid: D3D12_NODE_ID) -> u32 {
        (::windows::core::Interface::vtable(self).GetEntrypointIndex)(
            ::windows::core::Interface::as_raw(self),
            workgraphindex,
            ::core::mem::transmute(nodeid),
        )
    }
    pub unsafe fn GetEntrypointRecordSizeInBytes(
        &self,
        workgraphindex: u32,
        entrypointindex: u32,
    ) -> u32 {
        (::windows::core::Interface::vtable(self).GetEntrypointRecordSizeInBytes)(
            ::windows::core::Interface::as_raw(self),
            workgraphindex,
            entrypointindex,
        )
    }
    pub unsafe fn GetWorkGraphMemoryRequirements(
        &self,
        workgraphindex: u32,
        pworkgraphmemoryrequirements: *mut D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS,
    ) {
        (::windows::core::Interface::vtable(self).GetWorkGraphMemoryRequirements)(
            ::windows::core::Interface::as_raw(self),
            workgraphindex,
            pworkgraphmemoryrequirements,
        )
    }
}
::windows::imp::interface_hierarchy!(ID3D12WorkGraphProperties, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3D12WorkGraphProperties {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3D12WorkGraphProperties {}
impl ::core::fmt::Debug for ID3D12WorkGraphProperties {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3D12WorkGraphProperties")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3D12WorkGraphProperties {
    type Vtable = ID3D12WorkGraphProperties_Vtbl;
}
impl ::core::clone::Clone for ID3D12WorkGraphProperties {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3D12WorkGraphProperties {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x065acf71_f863_4b89_82f4_02e4d5886757);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3D12WorkGraphProperties_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetNumWorkGraphs: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> u32,
    pub GetProgramName: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        workgraphindex: u32,
    ) -> ::windows::core::PWSTR,
    pub GetWorkGraphIndex: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pprogramname: ::windows::core::PCWSTR,
    ) -> u32,
    pub GetNumNodes:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, workgraphindex: u32) -> u32,
    pub GetNodeID: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_NODE_ID,
        workgraphindex: u32,
        nodeindex: u32,
    ),
    pub GetNodeIndex: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        workgraphindex: u32,
        nodeid: D3D12_NODE_ID,
    ) -> u32,
    pub GetNodeLocalRootArgumentsTableIndex: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        workgraphindex: u32,
        nodeindex: u32,
    ) -> u32,
    pub GetNumEntrypoints:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void, workgraphindex: u32) -> u32,
    pub GetEntrypointID: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        result__: *mut D3D12_NODE_ID,
        workgraphindex: u32,
        entrypointindex: u32,
    ),
    pub GetEntrypointIndex: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        workgraphindex: u32,
        nodeid: D3D12_NODE_ID,
    ) -> u32,
    pub GetEntrypointRecordSizeInBytes: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        workgraphindex: u32,
        entrypointindex: u32,
    ) -> u32,
    pub GetWorkGraphMemoryRequirements: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        workgraphindex: u32,
        pworkgraphmemoryrequirements: *mut D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS,
    ),
}
#[repr(transparent)]
pub struct ID3DBlob(::windows::core::IUnknown);
impl ID3DBlob {
    pub unsafe fn GetBufferPointer(&self) -> *mut ::core::ffi::c_void {
        (::windows::core::Interface::vtable(self).GetBufferPointer)(
            ::windows::core::Interface::as_raw(self),
        )
    }
    pub unsafe fn GetBufferSize(&self) -> usize {
        (::windows::core::Interface::vtable(self).GetBufferSize)(
            ::windows::core::Interface::as_raw(self),
        )
    }
}
::windows::imp::interface_hierarchy!(ID3DBlob, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3DBlob {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3DBlob {}
impl ::core::fmt::Debug for ID3DBlob {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3DBlob").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3DBlob {
    type Vtable = ID3DBlob_Vtbl;
}
impl ::core::clone::Clone for ID3DBlob {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3DBlob {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x8ba5fb08_5195_40e2_ac58_0d989c3a0102);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3DBlob_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub GetBufferPointer:
        unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> *mut ::core::ffi::c_void,
    pub GetBufferSize: unsafe extern "system" fn(this: *mut ::core::ffi::c_void) -> usize,
}
#[repr(transparent)]
pub struct ID3DDestructionNotifier(::windows::core::IUnknown);
impl ID3DDestructionNotifier {
    pub unsafe fn RegisterDestructionCallback(
        &self,
        callbackfn: ::windows::Win32::Graphics::Direct3D::PFN_DESTRUCTION_CALLBACK,
        pdata: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<u32> {
        let mut result__ = ::windows::core::zeroed::<u32>();
        (::windows::core::Interface::vtable(self).RegisterDestructionCallback)(
            ::windows::core::Interface::as_raw(self),
            callbackfn,
            pdata,
            &mut result__,
        )
        .from_abi(result__)
    }
    pub unsafe fn UnregisterDestructionCallback(
        &self,
        callbackid: u32,
    ) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).UnregisterDestructionCallback)(
            ::windows::core::Interface::as_raw(self),
            callbackid,
        )
        .ok()
    }
}
::windows::imp::interface_hierarchy!(ID3DDestructionNotifier, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for ID3DDestructionNotifier {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3DDestructionNotifier {}
impl ::core::fmt::Debug for ID3DDestructionNotifier {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3DDestructionNotifier")
            .field(&self.0)
            .finish()
    }
}
unsafe impl ::windows::core::Interface for ID3DDestructionNotifier {
    type Vtable = ID3DDestructionNotifier_Vtbl;
}
impl ::core::clone::Clone for ID3DDestructionNotifier {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for ID3DDestructionNotifier {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0xa06eb39a_50da_425b_8c31_4eecd6c270f3);
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3DDestructionNotifier_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
    pub RegisterDestructionCallback: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        callbackfn: ::windows::Win32::Graphics::Direct3D::PFN_DESTRUCTION_CALLBACK,
        pdata: *const ::core::ffi::c_void,
        pcallbackid: *mut u32,
    ) -> ::windows::core::HRESULT,
    pub UnregisterDestructionCallback: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        callbackid: u32,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct ID3DInclude(::std::ptr::NonNull<::std::ffi::c_void>);
impl ID3DInclude {
    pub unsafe fn Open<P0>(
        &self,
        includetype: D3D_INCLUDE_TYPE,
        pfilename: P0,
        pparentdata: *const ::core::ffi::c_void,
        ppdata: *mut *mut ::core::ffi::c_void,
        pbytes: *mut u32,
    ) -> ::windows::core::Result<()>
    where
        P0: ::windows::core::IntoParam<::windows::core::PCSTR>,
    {
        (::windows::core::Interface::vtable(self).Open)(
            ::windows::core::Interface::as_raw(self),
            includetype,
            pfilename.into_param().abi(),
            pparentdata,
            ppdata,
            pbytes,
        )
        .ok()
    }
    pub unsafe fn Close(&self, pdata: *const ::core::ffi::c_void) -> ::windows::core::Result<()> {
        (::windows::core::Interface::vtable(self).Close)(
            ::windows::core::Interface::as_raw(self),
            pdata,
        )
        .ok()
    }
}
impl ::core::cmp::PartialEq for ID3DInclude {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for ID3DInclude {}
impl ::core::fmt::Debug for ID3DInclude {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("ID3DInclude").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for ID3DInclude {
    type Vtable = ID3DInclude_Vtbl;
}
impl ::core::clone::Clone for ID3DInclude {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
#[repr(C)]
#[doc(hidden)]
pub struct ID3DInclude_Vtbl {
    pub Open: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        includetype: D3D_INCLUDE_TYPE,
        pfilename: ::windows::core::PCSTR,
        pparentdata: *const ::core::ffi::c_void,
        ppdata: *mut *mut ::core::ffi::c_void,
        pbytes: *mut u32,
    ) -> ::windows::core::HRESULT,
    pub Close: unsafe extern "system" fn(
        this: *mut ::core::ffi::c_void,
        pdata: *const ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
}
#[repr(transparent)]
pub struct OpenCLOn12CreatorID(::windows::core::IUnknown);
impl OpenCLOn12CreatorID {}
::windows::imp::interface_hierarchy!(OpenCLOn12CreatorID, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for OpenCLOn12CreatorID {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for OpenCLOn12CreatorID {}
impl ::core::fmt::Debug for OpenCLOn12CreatorID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OpenCLOn12CreatorID").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for OpenCLOn12CreatorID {
    type Vtable = OpenCLOn12CreatorID_Vtbl;
}
impl ::core::clone::Clone for OpenCLOn12CreatorID {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for OpenCLOn12CreatorID {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x3f76bb74_91b5_4a88_b126_20ca0331cd60);
}
#[repr(C)]
#[doc(hidden)]
pub struct OpenCLOn12CreatorID_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
}
#[repr(transparent)]
pub struct OpenGLOn12CreatorID(::windows::core::IUnknown);
impl OpenGLOn12CreatorID {}
::windows::imp::interface_hierarchy!(OpenGLOn12CreatorID, ::windows::core::IUnknown);
impl ::core::cmp::PartialEq for OpenGLOn12CreatorID {
    fn eq(&self, other: &Self) -> bool {
        self.0 == other.0
    }
}
impl ::core::cmp::Eq for OpenGLOn12CreatorID {}
impl ::core::fmt::Debug for OpenGLOn12CreatorID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("OpenGLOn12CreatorID").field(&self.0).finish()
    }
}
unsafe impl ::windows::core::Interface for OpenGLOn12CreatorID {
    type Vtable = OpenGLOn12CreatorID_Vtbl;
}
impl ::core::clone::Clone for OpenGLOn12CreatorID {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}
unsafe impl ::windows::core::ComInterface for OpenGLOn12CreatorID {
    const IID: ::windows::core::GUID =
        ::windows::core::GUID::from_u128(0x6bb3cd34_0d19_45ab_97ed_d720ba3dfc80);
}
#[repr(C)]
#[doc(hidden)]
pub struct OpenGLOn12CreatorID_Vtbl {
    pub base__: ::windows::core::IUnknown_Vtbl,
}
pub const CLSID_D3D12Debug: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xf2352aeb_dd84_49fe_b97b_a9dcfdcc1b4f);
pub const CLSID_D3D12DeviceFactory: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x114863bf_c386_4aee_b39d_8f0bbb062955);
pub const CLSID_D3D12DeviceRemovedExtendedData: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x4a75bbc4_9ff4_4ad8_9f18_abae84dc5ff2);
pub const CLSID_D3D12SDKConfiguration: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x7cda6aca_a03e_49c8_9458_0334d20e07ce);
pub const CLSID_D3D12Tools: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xe38216b1_3c8c_4833_aa09_0a06b65d96c8);
pub const D3D12ExperimentalShaderModels: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x76f5573e_f13a_40f5_b297_81ce9e18933f);
pub const D3D12StateObjectsExperiment: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x398a7fd6_a15a_42c1_9605_4bd9999a61af);
pub const D3D12TiledResourceTier4: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xc9c4725f_a81a_4f56_8c5b_c51039d694fb);
pub const D3D12_16BIT_INDEX_STRIP_CUT_VALUE: u32 = 65535u32;
pub const D3D12_32BIT_INDEX_STRIP_CUT_VALUE: u32 = 4294967295u32;
pub const D3D12_8BIT_INDEX_STRIP_CUT_VALUE: u32 = 255u32;
pub const D3D12_ANISOTROPIC_FILTERING_BIT: u32 = 64u32;
pub const D3D12_APPEND_ALIGNED_ELEMENT: u32 = 4294967295u32;
pub const D3D12_ARRAY_AXIS_ADDRESS_RANGE_BIT_COUNT: u32 = 9u32;
pub const D3D12_CLIP_OR_CULL_DISTANCE_COUNT: u32 = 8u32;
pub const D3D12_CLIP_OR_CULL_DISTANCE_ELEMENT_COUNT: u32 = 2u32;
pub const D3D12_COMMONSHADER_CONSTANT_BUFFER_API_SLOT_COUNT: u32 = 14u32;
pub const D3D12_COMMONSHADER_CONSTANT_BUFFER_COMPONENTS: u32 = 4u32;
pub const D3D12_COMMONSHADER_CONSTANT_BUFFER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_COMMONSHADER_CONSTANT_BUFFER_HW_SLOT_COUNT: u32 = 15u32;
pub const D3D12_COMMONSHADER_CONSTANT_BUFFER_PARTIAL_UPDATE_EXTENTS_BYTE_ALIGNMENT: u32 = 16u32;
pub const D3D12_COMMONSHADER_CONSTANT_BUFFER_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_COMMONSHADER_CONSTANT_BUFFER_REGISTER_COUNT: u32 = 15u32;
pub const D3D12_COMMONSHADER_CONSTANT_BUFFER_REGISTER_READS_PER_INST: u32 = 1u32;
pub const D3D12_COMMONSHADER_CONSTANT_BUFFER_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_COMMONSHADER_FLOWCONTROL_NESTING_LIMIT: u32 = 64u32;
pub const D3D12_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_READS_PER_INST: u32 = 1u32;
pub const D3D12_COMMONSHADER_IMMEDIATE_CONSTANT_BUFFER_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_COMMONSHADER_IMMEDIATE_VALUE_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_COMMONSHADER_INPUT_RESOURCE_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_COMMONSHADER_INPUT_RESOURCE_REGISTER_COUNT: u32 = 128u32;
pub const D3D12_COMMONSHADER_INPUT_RESOURCE_REGISTER_READS_PER_INST: u32 = 1u32;
pub const D3D12_COMMONSHADER_INPUT_RESOURCE_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT: u32 = 128u32;
pub const D3D12_COMMONSHADER_SAMPLER_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_COMMONSHADER_SAMPLER_REGISTER_COUNT: u32 = 16u32;
pub const D3D12_COMMONSHADER_SAMPLER_REGISTER_READS_PER_INST: u32 = 1u32;
pub const D3D12_COMMONSHADER_SAMPLER_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_COMMONSHADER_SAMPLER_SLOT_COUNT: u32 = 16u32;
pub const D3D12_COMMONSHADER_SUBROUTINE_NESTING_LIMIT: u32 = 32u32;
pub const D3D12_COMMONSHADER_TEMP_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_COMMONSHADER_TEMP_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_COMMONSHADER_TEMP_REGISTER_COUNT: u32 = 4096u32;
pub const D3D12_COMMONSHADER_TEMP_REGISTER_READS_PER_INST: u32 = 3u32;
pub const D3D12_COMMONSHADER_TEMP_REGISTER_READ_PORTS: u32 = 3u32;
pub const D3D12_COMMONSHADER_TEXCOORD_RANGE_REDUCTION_MAX: u32 = 10u32;
pub const D3D12_COMMONSHADER_TEXCOORD_RANGE_REDUCTION_MIN: i32 = -10i32;
pub const D3D12_COMMONSHADER_TEXEL_OFFSET_MAX_NEGATIVE: i32 = -8i32;
pub const D3D12_COMMONSHADER_TEXEL_OFFSET_MAX_POSITIVE: u32 = 7u32;
pub const D3D12_CONSTANT_BUFFER_DATA_PLACEMENT_ALIGNMENT: u32 = 256u32;
pub const D3D12_CS_4_X_BUCKET00_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 256u32;
pub const D3D12_CS_4_X_BUCKET00_MAX_NUM_THREADS_PER_GROUP: u32 = 64u32;
pub const D3D12_CS_4_X_BUCKET01_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 240u32;
pub const D3D12_CS_4_X_BUCKET01_MAX_NUM_THREADS_PER_GROUP: u32 = 68u32;
pub const D3D12_CS_4_X_BUCKET02_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 224u32;
pub const D3D12_CS_4_X_BUCKET02_MAX_NUM_THREADS_PER_GROUP: u32 = 72u32;
pub const D3D12_CS_4_X_BUCKET03_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 208u32;
pub const D3D12_CS_4_X_BUCKET03_MAX_NUM_THREADS_PER_GROUP: u32 = 76u32;
pub const D3D12_CS_4_X_BUCKET04_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 192u32;
pub const D3D12_CS_4_X_BUCKET04_MAX_NUM_THREADS_PER_GROUP: u32 = 84u32;
pub const D3D12_CS_4_X_BUCKET05_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 176u32;
pub const D3D12_CS_4_X_BUCKET05_MAX_NUM_THREADS_PER_GROUP: u32 = 92u32;
pub const D3D12_CS_4_X_BUCKET06_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 160u32;
pub const D3D12_CS_4_X_BUCKET06_MAX_NUM_THREADS_PER_GROUP: u32 = 100u32;
pub const D3D12_CS_4_X_BUCKET07_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 144u32;
pub const D3D12_CS_4_X_BUCKET07_MAX_NUM_THREADS_PER_GROUP: u32 = 112u32;
pub const D3D12_CS_4_X_BUCKET08_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 128u32;
pub const D3D12_CS_4_X_BUCKET08_MAX_NUM_THREADS_PER_GROUP: u32 = 128u32;
pub const D3D12_CS_4_X_BUCKET09_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 112u32;
pub const D3D12_CS_4_X_BUCKET09_MAX_NUM_THREADS_PER_GROUP: u32 = 144u32;
pub const D3D12_CS_4_X_BUCKET10_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 96u32;
pub const D3D12_CS_4_X_BUCKET10_MAX_NUM_THREADS_PER_GROUP: u32 = 168u32;
pub const D3D12_CS_4_X_BUCKET11_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 80u32;
pub const D3D12_CS_4_X_BUCKET11_MAX_NUM_THREADS_PER_GROUP: u32 = 204u32;
pub const D3D12_CS_4_X_BUCKET12_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 64u32;
pub const D3D12_CS_4_X_BUCKET12_MAX_NUM_THREADS_PER_GROUP: u32 = 256u32;
pub const D3D12_CS_4_X_BUCKET13_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 48u32;
pub const D3D12_CS_4_X_BUCKET13_MAX_NUM_THREADS_PER_GROUP: u32 = 340u32;
pub const D3D12_CS_4_X_BUCKET14_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 32u32;
pub const D3D12_CS_4_X_BUCKET14_MAX_NUM_THREADS_PER_GROUP: u32 = 512u32;
pub const D3D12_CS_4_X_BUCKET15_MAX_BYTES_TGSM_WRITABLE_PER_THREAD: u32 = 16u32;
pub const D3D12_CS_4_X_BUCKET15_MAX_NUM_THREADS_PER_GROUP: u32 = 768u32;
pub const D3D12_CS_4_X_DISPATCH_MAX_THREAD_GROUPS_IN_Z_DIMENSION: u32 = 1u32;
pub const D3D12_CS_4_X_RAW_UAV_BYTE_ALIGNMENT: u32 = 256u32;
pub const D3D12_CS_4_X_THREAD_GROUP_MAX_THREADS_PER_GROUP: u32 = 768u32;
pub const D3D12_CS_4_X_THREAD_GROUP_MAX_X: u32 = 768u32;
pub const D3D12_CS_4_X_THREAD_GROUP_MAX_Y: u32 = 768u32;
pub const D3D12_CS_4_X_UAV_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_CS_DISPATCH_MAX_THREAD_GROUPS_PER_DIMENSION: u32 = 65535u32;
pub const D3D12_CS_TGSM_REGISTER_COUNT: u32 = 8192u32;
pub const D3D12_CS_TGSM_REGISTER_READS_PER_INST: u32 = 1u32;
pub const D3D12_CS_TGSM_RESOURCE_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_CS_TGSM_RESOURCE_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_CS_THREADGROUPID_REGISTER_COMPONENTS: u32 = 3u32;
pub const D3D12_CS_THREADGROUPID_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_CS_THREADIDINGROUPFLATTENED_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_CS_THREADIDINGROUPFLATTENED_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_CS_THREADIDINGROUP_REGISTER_COMPONENTS: u32 = 3u32;
pub const D3D12_CS_THREADIDINGROUP_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_CS_THREADID_REGISTER_COMPONENTS: u32 = 3u32;
pub const D3D12_CS_THREADID_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_CS_THREAD_GROUP_MAX_THREADS_PER_GROUP: u32 = 1024u32;
pub const D3D12_CS_THREAD_GROUP_MAX_X: u32 = 1024u32;
pub const D3D12_CS_THREAD_GROUP_MAX_Y: u32 = 1024u32;
pub const D3D12_CS_THREAD_GROUP_MAX_Z: u32 = 64u32;
pub const D3D12_CS_THREAD_GROUP_MIN_X: u32 = 1u32;
pub const D3D12_CS_THREAD_GROUP_MIN_Y: u32 = 1u32;
pub const D3D12_CS_THREAD_GROUP_MIN_Z: u32 = 1u32;
pub const D3D12_CS_THREAD_LOCAL_TEMP_REGISTER_POOL: u32 = 16384u32;
pub const D3D12_DEFAULT_BLEND_FACTOR_ALPHA: f32 = 1f32;
pub const D3D12_DEFAULT_BLEND_FACTOR_BLUE: f32 = 1f32;
pub const D3D12_DEFAULT_BLEND_FACTOR_GREEN: f32 = 1f32;
pub const D3D12_DEFAULT_BLEND_FACTOR_RED: f32 = 1f32;
pub const D3D12_DEFAULT_BORDER_COLOR_COMPONENT: f32 = 0f32;
pub const D3D12_DEFAULT_DEPTH_BIAS: u32 = 0u32;
pub const D3D12_DEFAULT_DEPTH_BIAS_CLAMP: f32 = 0f32;
pub const D3D12_DEFAULT_MAX_ANISOTROPY: u32 = 16u32;
pub const D3D12_DEFAULT_MIP_LOD_BIAS: f32 = 0f32;
pub const D3D12_DEFAULT_MSAA_RESOURCE_PLACEMENT_ALIGNMENT: u32 = 4194304u32;
pub const D3D12_DEFAULT_RENDER_TARGET_ARRAY_INDEX: u32 = 0u32;
pub const D3D12_DEFAULT_RESOURCE_PLACEMENT_ALIGNMENT: u32 = 65536u32;
pub const D3D12_DEFAULT_SAMPLE_MASK: u32 = 4294967295u32;
pub const D3D12_DEFAULT_SCISSOR_ENDX: u32 = 0u32;
pub const D3D12_DEFAULT_SCISSOR_ENDY: u32 = 0u32;
pub const D3D12_DEFAULT_SCISSOR_STARTX: u32 = 0u32;
pub const D3D12_DEFAULT_SCISSOR_STARTY: u32 = 0u32;
pub const D3D12_DEFAULT_SLOPE_SCALED_DEPTH_BIAS: f32 = 0f32;
pub const D3D12_DEFAULT_STENCIL_READ_MASK: u32 = 255u32;
pub const D3D12_DEFAULT_STENCIL_REFERENCE: u32 = 0u32;
pub const D3D12_DEFAULT_STENCIL_WRITE_MASK: u32 = 255u32;
pub const D3D12_DEFAULT_VIEWPORT_AND_SCISSORRECT_INDEX: u32 = 0u32;
pub const D3D12_DEFAULT_VIEWPORT_HEIGHT: u32 = 0u32;
pub const D3D12_DEFAULT_VIEWPORT_MAX_DEPTH: f32 = 0f32;
pub const D3D12_DEFAULT_VIEWPORT_MIN_DEPTH: f32 = 0f32;
pub const D3D12_DEFAULT_VIEWPORT_TOPLEFTX: u32 = 0u32;
pub const D3D12_DEFAULT_VIEWPORT_TOPLEFTY: u32 = 0u32;
pub const D3D12_DEFAULT_VIEWPORT_WIDTH: u32 = 0u32;
pub const D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND: u32 = 4294967295u32;
pub const D3D12_DRIVER_RESERVED_REGISTER_SPACE_VALUES_END: u32 = 4294967287u32;
pub const D3D12_DRIVER_RESERVED_REGISTER_SPACE_VALUES_START: u32 = 4294967280u32;
pub const D3D12_DS_INPUT_CONTROL_POINTS_MAX_TOTAL_SCALARS: u32 = 3968u32;
pub const D3D12_DS_INPUT_CONTROL_POINT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_DS_INPUT_CONTROL_POINT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_DS_INPUT_CONTROL_POINT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_DS_INPUT_CONTROL_POINT_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_DS_INPUT_CONTROL_POINT_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_DS_INPUT_DOMAIN_POINT_REGISTER_COMPONENTS: u32 = 3u32;
pub const D3D12_DS_INPUT_DOMAIN_POINT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_DS_INPUT_DOMAIN_POINT_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_DS_INPUT_DOMAIN_POINT_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_DS_INPUT_DOMAIN_POINT_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_DS_INPUT_PATCH_CONSTANT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_DS_INPUT_PATCH_CONSTANT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_DS_INPUT_PATCH_CONSTANT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_DS_INPUT_PATCH_CONSTANT_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_DS_INPUT_PATCH_CONSTANT_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_DS_INPUT_PRIMITIVE_ID_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_DS_INPUT_PRIMITIVE_ID_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_DS_INPUT_PRIMITIVE_ID_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_DS_INPUT_PRIMITIVE_ID_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_DS_INPUT_PRIMITIVE_ID_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_DS_OUTPUT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_DS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_DS_OUTPUT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_FILTER_REDUCTION_TYPE_MASK: u32 = 3u32;
pub const D3D12_FILTER_REDUCTION_TYPE_SHIFT: u32 = 7u32;
pub const D3D12_FILTER_TYPE_MASK: u32 = 3u32;
pub const D3D12_FLOAT16_FUSED_TOLERANCE_IN_ULP: f64 = 0.6f64;
pub const D3D12_FLOAT32_MAX: f32 = 340282350000000000000000000000000000000f32;
pub const D3D12_FLOAT32_TO_INTEGER_TOLERANCE_IN_ULP: f32 = 0.6f32;
pub const D3D12_FLOAT_TO_SRGB_EXPONENT_DENOMINATOR: f32 = 2.4f32;
pub const D3D12_FLOAT_TO_SRGB_EXPONENT_NUMERATOR: f32 = 1f32;
pub const D3D12_FLOAT_TO_SRGB_OFFSET: f32 = 0.055f32;
pub const D3D12_FLOAT_TO_SRGB_SCALE_1: f32 = 12.92f32;
pub const D3D12_FLOAT_TO_SRGB_SCALE_2: f32 = 1.055f32;
pub const D3D12_FLOAT_TO_SRGB_THRESHOLD: f32 = 0.0031308f32;
pub const D3D12_FTOI_INSTRUCTION_MAX_INPUT: f32 = 2147483600f32;
pub const D3D12_FTOI_INSTRUCTION_MIN_INPUT: f32 = -2147483600f32;
pub const D3D12_FTOU_INSTRUCTION_MAX_INPUT: f32 = 4294967300f32;
pub const D3D12_FTOU_INSTRUCTION_MIN_INPUT: f32 = 0f32;
pub const D3D12_GS_INPUT_INSTANCE_ID_READS_PER_INST: u32 = 2u32;
pub const D3D12_GS_INPUT_INSTANCE_ID_READ_PORTS: u32 = 1u32;
pub const D3D12_GS_INPUT_INSTANCE_ID_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_GS_INPUT_INSTANCE_ID_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_GS_INPUT_INSTANCE_ID_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_GS_INPUT_PRIM_CONST_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_GS_INPUT_PRIM_CONST_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_GS_INPUT_PRIM_CONST_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_GS_INPUT_PRIM_CONST_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_GS_INPUT_PRIM_CONST_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_GS_INPUT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_GS_INPUT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_GS_INPUT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_GS_INPUT_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_GS_INPUT_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_GS_INPUT_REGISTER_VERTICES: u32 = 32u32;
pub const D3D12_GS_MAX_INSTANCE_COUNT: u32 = 32u32;
pub const D3D12_GS_MAX_OUTPUT_VERTEX_COUNT_ACROSS_INSTANCES: u32 = 1024u32;
pub const D3D12_GS_OUTPUT_ELEMENTS: u32 = 32u32;
pub const D3D12_GS_OUTPUT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_GS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_GS_OUTPUT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_HS_CONTROL_POINT_PHASE_INPUT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_HS_CONTROL_POINT_PHASE_OUTPUT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_HS_CONTROL_POINT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_HS_CONTROL_POINT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_HS_CONTROL_POINT_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_HS_CONTROL_POINT_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_HS_FORK_PHASE_INSTANCE_COUNT_UPPER_BOUND: u32 = 4294967295u32;
pub const D3D12_HS_INPUT_FORK_INSTANCE_ID_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_HS_INPUT_FORK_INSTANCE_ID_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_HS_INPUT_FORK_INSTANCE_ID_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_HS_INPUT_FORK_INSTANCE_ID_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_HS_INPUT_FORK_INSTANCE_ID_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_HS_INPUT_JOIN_INSTANCE_ID_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_HS_INPUT_JOIN_INSTANCE_ID_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_HS_INPUT_JOIN_INSTANCE_ID_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_HS_INPUT_JOIN_INSTANCE_ID_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_HS_INPUT_JOIN_INSTANCE_ID_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_HS_INPUT_PRIMITIVE_ID_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_HS_INPUT_PRIMITIVE_ID_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_HS_INPUT_PRIMITIVE_ID_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_HS_INPUT_PRIMITIVE_ID_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_HS_INPUT_PRIMITIVE_ID_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_HS_JOIN_PHASE_INSTANCE_COUNT_UPPER_BOUND: u32 = 4294967295u32;
pub const D3D12_HS_MAXTESSFACTOR_LOWER_BOUND: f32 = 1f32;
pub const D3D12_HS_MAXTESSFACTOR_UPPER_BOUND: f32 = 64f32;
pub const D3D12_HS_OUTPUT_CONTROL_POINTS_MAX_TOTAL_SCALARS: u32 = 3968u32;
pub const D3D12_HS_OUTPUT_CONTROL_POINT_ID_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_HS_OUTPUT_CONTROL_POINT_ID_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_HS_OUTPUT_CONTROL_POINT_ID_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_HS_OUTPUT_CONTROL_POINT_ID_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_HS_OUTPUT_CONTROL_POINT_ID_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_HS_OUTPUT_PATCH_CONSTANT_REGISTER_SCALAR_COMPONENTS: u32 = 128u32;
pub const D3D12_IA_DEFAULT_INDEX_BUFFER_OFFSET_IN_BYTES: u32 = 0u32;
pub const D3D12_IA_DEFAULT_PRIMITIVE_TOPOLOGY: u32 = 0u32;
pub const D3D12_IA_DEFAULT_VERTEX_BUFFER_OFFSET_IN_BYTES: u32 = 0u32;
pub const D3D12_IA_INDEX_INPUT_RESOURCE_SLOT_COUNT: u32 = 1u32;
pub const D3D12_IA_INSTANCE_ID_BIT_COUNT: u32 = 32u32;
pub const D3D12_IA_INTEGER_ARITHMETIC_BIT_COUNT: u32 = 32u32;
pub const D3D12_IA_PATCH_MAX_CONTROL_POINT_COUNT: u32 = 32u32;
pub const D3D12_IA_PRIMITIVE_ID_BIT_COUNT: u32 = 32u32;
pub const D3D12_IA_VERTEX_ID_BIT_COUNT: u32 = 32u32;
pub const D3D12_IA_VERTEX_INPUT_RESOURCE_SLOT_COUNT: u32 = 32u32;
pub const D3D12_IA_VERTEX_INPUT_STRUCTURE_ELEMENTS_COMPONENTS: u32 = 128u32;
pub const D3D12_IA_VERTEX_INPUT_STRUCTURE_ELEMENT_COUNT: u32 = 32u32;
pub const D3D12_INFO_QUEUE_DEFAULT_MESSAGE_COUNT_LIMIT: u32 = 1024u32;
pub const D3D12_INTEGER_DIVIDE_BY_ZERO_QUOTIENT: u32 = 4294967295u32;
pub const D3D12_INTEGER_DIVIDE_BY_ZERO_REMAINDER: u32 = 4294967295u32;
pub const D3D12_KEEP_RENDER_TARGETS_AND_DEPTH_STENCIL: u32 = 4294967295u32;
pub const D3D12_KEEP_UNORDERED_ACCESS_VIEWS: u32 = 4294967295u32;
pub const D3D12_LINEAR_GAMMA: f32 = 1f32;
pub const D3D12_MAG_FILTER_SHIFT: u32 = 2u32;
pub const D3D12_MAJOR_VERSION: u32 = 12u32;
pub const D3D12_MAX_BORDER_COLOR_COMPONENT: f32 = 1f32;
pub const D3D12_MAX_DEPTH: f32 = 1f32;
pub const D3D12_MAX_LIVE_STATIC_SAMPLERS: u32 = 2032u32;
pub const D3D12_MAX_MAXANISOTROPY: u32 = 16u32;
pub const D3D12_MAX_MULTISAMPLE_SAMPLE_COUNT: u32 = 32u32;
pub const D3D12_MAX_POSITION_VALUE: f32 = 34028236000000000000000000000000000f32;
pub const D3D12_MAX_ROOT_COST: u32 = 64u32;
pub const D3D12_MAX_SHADER_VISIBLE_DESCRIPTOR_HEAP_SIZE_TIER_1: u32 = 1000000u32;
pub const D3D12_MAX_SHADER_VISIBLE_DESCRIPTOR_HEAP_SIZE_TIER_2: u32 = 1000000u32;
pub const D3D12_MAX_SHADER_VISIBLE_SAMPLER_HEAP_SIZE: u32 = 2048u32;
pub const D3D12_MAX_TEXTURE_DIMENSION_2_TO_EXP: u32 = 17u32;
pub const D3D12_MAX_VIEW_INSTANCE_COUNT: u32 = 4u32;
pub const D3D12_MINOR_VERSION: u32 = 0u32;
pub const D3D12_MIN_BORDER_COLOR_COMPONENT: f32 = 0f32;
pub const D3D12_MIN_DEPTH: f32 = 0f32;
pub const D3D12_MIN_FILTER_SHIFT: u32 = 4u32;
pub const D3D12_MIN_MAXANISOTROPY: u32 = 0u32;
pub const D3D12_MIP_FILTER_SHIFT: u32 = 0u32;
pub const D3D12_MIP_LOD_BIAS_MAX: f32 = 15.99f32;
pub const D3D12_MIP_LOD_BIAS_MIN: f32 = -16f32;
pub const D3D12_MIP_LOD_FRACTIONAL_BIT_COUNT: u32 = 8u32;
pub const D3D12_MIP_LOD_RANGE_BIT_COUNT: u32 = 8u32;
pub const D3D12_MULTISAMPLE_ANTIALIAS_LINE_WIDTH: f32 = 1.4f32;
pub const D3D12_NONSAMPLE_FETCH_OUT_OF_RANGE_ACCESS_RESULT: u32 = 0u32;
pub const D3D12_OS_RESERVED_REGISTER_SPACE_VALUES_END: u32 = 4294967295u32;
pub const D3D12_OS_RESERVED_REGISTER_SPACE_VALUES_START: u32 = 4294967288u32;
pub const D3D12_PACKED_TILE: u32 = 4294967295u32;
pub const D3D12_PIXEL_ADDRESS_RANGE_BIT_COUNT: u32 = 15u32;
pub const D3D12_PREVIEW_SDK_VERSION: u32 = 711u32;
pub const D3D12_PRE_SCISSOR_PIXEL_ADDRESS_RANGE_BIT_COUNT: u32 = 16u32;
pub const D3D12_PROTECTED_RESOURCES_SESSION_HARDWARE_PROTECTED: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x62b0084e_c70e_4daa_a109_30ff8d5a0482);
pub const D3D12_PS_CS_UAV_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_PS_CS_UAV_REGISTER_COUNT: u32 = 8u32;
pub const D3D12_PS_CS_UAV_REGISTER_READS_PER_INST: u32 = 1u32;
pub const D3D12_PS_CS_UAV_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_PS_FRONTFACING_DEFAULT_VALUE: u32 = 4294967295u32;
pub const D3D12_PS_FRONTFACING_FALSE_VALUE: u32 = 0u32;
pub const D3D12_PS_FRONTFACING_TRUE_VALUE: u32 = 4294967295u32;
pub const D3D12_PS_INPUT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_PS_INPUT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_PS_INPUT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_PS_INPUT_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_PS_INPUT_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_PS_LEGACY_PIXEL_CENTER_FRACTIONAL_COMPONENT: f32 = 0f32;
pub const D3D12_PS_OUTPUT_DEPTH_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_PS_OUTPUT_DEPTH_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_PS_OUTPUT_DEPTH_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_PS_OUTPUT_MASK_REGISTER_COMPONENTS: u32 = 1u32;
pub const D3D12_PS_OUTPUT_MASK_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_PS_OUTPUT_MASK_REGISTER_COUNT: u32 = 1u32;
pub const D3D12_PS_OUTPUT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_PS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_PS_OUTPUT_REGISTER_COUNT: u32 = 8u32;
pub const D3D12_PS_PIXEL_CENTER_FRACTIONAL_COMPONENT: f32 = 0.5f32;
pub const D3D12_RAW_UAV_SRV_BYTE_ALIGNMENT: u32 = 16u32;
pub const D3D12_RAYTRACING_AABB_BYTE_ALIGNMENT: u32 = 8u32;
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BYTE_ALIGNMENT: u32 = 256u32;
pub const D3D12_RAYTRACING_INSTANCE_DESCS_BYTE_ALIGNMENT: u32 = 16u32;
pub const D3D12_RAYTRACING_MAX_ATTRIBUTE_SIZE_IN_BYTES: u32 = 32u32;
pub const D3D12_RAYTRACING_MAX_DECLARABLE_TRACE_RECURSION_DEPTH: u32 = 31u32;
pub const D3D12_RAYTRACING_MAX_GEOMETRIES_PER_BOTTOM_LEVEL_ACCELERATION_STRUCTURE: u32 =
    16777216u32;
pub const D3D12_RAYTRACING_MAX_INSTANCES_PER_TOP_LEVEL_ACCELERATION_STRUCTURE: u32 = 16777216u32;
pub const D3D12_RAYTRACING_MAX_PRIMITIVES_PER_BOTTOM_LEVEL_ACCELERATION_STRUCTURE: u32 =
    536870912u32;
pub const D3D12_RAYTRACING_MAX_RAY_GENERATION_SHADER_THREADS: u32 = 1073741824u32;
pub const D3D12_RAYTRACING_MAX_SHADER_RECORD_STRIDE: u32 = 4096u32;
pub const D3D12_RAYTRACING_SHADER_RECORD_BYTE_ALIGNMENT: u32 = 32u32;
pub const D3D12_RAYTRACING_SHADER_TABLE_BYTE_ALIGNMENT: u32 = 64u32;
pub const D3D12_RAYTRACING_TRANSFORM3X4_BYTE_ALIGNMENT: u32 = 16u32;
pub const D3D12_REQ_BLEND_OBJECT_COUNT_PER_DEVICE: u32 = 4096u32;
pub const D3D12_REQ_BUFFER_RESOURCE_TEXEL_COUNT_2_TO_EXP: u32 = 27u32;
pub const D3D12_REQ_CONSTANT_BUFFER_ELEMENT_COUNT: u32 = 4096u32;
pub const D3D12_REQ_DEPTH_STENCIL_OBJECT_COUNT_PER_DEVICE: u32 = 4096u32;
pub const D3D12_REQ_DRAWINDEXED_INDEX_COUNT_2_TO_EXP: u32 = 32u32;
pub const D3D12_REQ_DRAW_VERTEX_COUNT_2_TO_EXP: u32 = 32u32;
pub const D3D12_REQ_FILTERING_HW_ADDRESSABLE_RESOURCE_DIMENSION: u32 = 16384u32;
pub const D3D12_REQ_GS_INVOCATION_32BIT_OUTPUT_COMPONENT_LIMIT: u32 = 1024u32;
pub const D3D12_REQ_IMMEDIATE_CONSTANT_BUFFER_ELEMENT_COUNT: u32 = 4096u32;
pub const D3D12_REQ_MAXANISOTROPY: u32 = 16u32;
pub const D3D12_REQ_MIP_LEVELS: u32 = 15u32;
pub const D3D12_REQ_MULTI_ELEMENT_STRUCTURE_SIZE_IN_BYTES: u32 = 2048u32;
pub const D3D12_REQ_RASTERIZER_OBJECT_COUNT_PER_DEVICE: u32 = 4096u32;
pub const D3D12_REQ_RENDER_TO_BUFFER_WINDOW_WIDTH: u32 = 16384u32;
pub const D3D12_REQ_RESOURCE_SIZE_IN_MEGABYTES_EXPRESSION_A_TERM: u32 = 128u32;
pub const D3D12_REQ_RESOURCE_SIZE_IN_MEGABYTES_EXPRESSION_B_TERM: f32 = 0.25f32;
pub const D3D12_REQ_RESOURCE_SIZE_IN_MEGABYTES_EXPRESSION_C_TERM: u32 = 2048u32;
pub const D3D12_REQ_RESOURCE_VIEW_COUNT_PER_DEVICE_2_TO_EXP: u32 = 20u32;
pub const D3D12_REQ_SAMPLER_OBJECT_COUNT_PER_DEVICE: u32 = 4096u32;
pub const D3D12_REQ_SUBRESOURCES: u32 = 30720u32;
pub const D3D12_REQ_TEXTURE1D_ARRAY_AXIS_DIMENSION: u32 = 2048u32;
pub const D3D12_REQ_TEXTURE1D_U_DIMENSION: u32 = 16384u32;
pub const D3D12_REQ_TEXTURE2D_ARRAY_AXIS_DIMENSION: u32 = 2048u32;
pub const D3D12_REQ_TEXTURE2D_U_OR_V_DIMENSION: u32 = 16384u32;
pub const D3D12_REQ_TEXTURE3D_U_V_OR_W_DIMENSION: u32 = 2048u32;
pub const D3D12_REQ_TEXTURECUBE_DIMENSION: u32 = 16384u32;
pub const D3D12_RESINFO_INSTRUCTION_MISSING_COMPONENT_RETVAL: u32 = 0u32;
pub const D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES: u32 = 4294967295u32;
pub const D3D12_RS_SET_SHADING_RATE_COMBINER_COUNT: u32 = 2u32;
pub const D3D12_SDK_VERSION: u32 = 611u32;
pub const D3D12_SHADER_COMPONENT_MAPPING_MASK: u32 = 7u32;
pub const D3D12_SHADER_COMPONENT_MAPPING_SHIFT: u32 = 3u32;
pub const D3D12_SHADER_IDENTIFIER_SIZE_IN_BYTES: u32 = 32u32;
pub const D3D12_SHADER_MAJOR_VERSION: u32 = 5u32;
pub const D3D12_SHADER_MAX_INSTANCES: u32 = 65535u32;
pub const D3D12_SHADER_MAX_INTERFACES: u32 = 253u32;
pub const D3D12_SHADER_MAX_INTERFACE_CALL_SITES: u32 = 4096u32;
pub const D3D12_SHADER_MAX_TYPES: u32 = 65535u32;
pub const D3D12_SHADER_MINOR_VERSION: u32 = 1u32;
pub const D3D12_SHADING_RATE_VALID_MASK: u32 = 3u32;
pub const D3D12_SHADING_RATE_X_AXIS_SHIFT: u32 = 2u32;
pub const D3D12_SHIFT_INSTRUCTION_PAD_VALUE: u32 = 0u32;
pub const D3D12_SHIFT_INSTRUCTION_SHIFT_VALUE_BIT_COUNT: u32 = 5u32;
pub const D3D12_SIMULTANEOUS_RENDER_TARGET_COUNT: u32 = 8u32;
pub const D3D12_SMALL_MSAA_RESOURCE_PLACEMENT_ALIGNMENT: u32 = 65536u32;
pub const D3D12_SMALL_RESOURCE_PLACEMENT_ALIGNMENT: u32 = 4096u32;
pub const D3D12_SO_BUFFER_MAX_STRIDE_IN_BYTES: u32 = 2048u32;
pub const D3D12_SO_BUFFER_MAX_WRITE_WINDOW_IN_BYTES: u32 = 512u32;
pub const D3D12_SO_BUFFER_SLOT_COUNT: u32 = 4u32;
pub const D3D12_SO_DDI_REGISTER_INDEX_DENOTING_GAP: u32 = 4294967295u32;
pub const D3D12_SO_NO_RASTERIZED_STREAM: u32 = 4294967295u32;
pub const D3D12_SO_OUTPUT_COMPONENT_COUNT: u32 = 128u32;
pub const D3D12_SO_STREAM_COUNT: u32 = 4u32;
pub const D3D12_SPEC_DATE_DAY: u32 = 14u32;
pub const D3D12_SPEC_DATE_MONTH: u32 = 11u32;
pub const D3D12_SPEC_DATE_YEAR: u32 = 2014u32;
pub const D3D12_SPEC_VERSION: f64 = 1.16f64;
pub const D3D12_SRGB_GAMMA: f32 = 2.2f32;
pub const D3D12_SRGB_TO_FLOAT_DENOMINATOR_1: f32 = 12.92f32;
pub const D3D12_SRGB_TO_FLOAT_DENOMINATOR_2: f32 = 1.055f32;
pub const D3D12_SRGB_TO_FLOAT_EXPONENT: f32 = 2.4f32;
pub const D3D12_SRGB_TO_FLOAT_OFFSET: f32 = 0.055f32;
pub const D3D12_SRGB_TO_FLOAT_THRESHOLD: f32 = 0.04045f32;
pub const D3D12_SRGB_TO_FLOAT_TOLERANCE_IN_ULP: f32 = 0.5f32;
pub const D3D12_STANDARD_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_STANDARD_COMPONENT_BIT_COUNT_DOUBLED: u32 = 64u32;
pub const D3D12_STANDARD_MAXIMUM_ELEMENT_ALIGNMENT_BYTE_MULTIPLE: u32 = 4u32;
pub const D3D12_STANDARD_PIXEL_COMPONENT_COUNT: u32 = 128u32;
pub const D3D12_STANDARD_PIXEL_ELEMENT_COUNT: u32 = 32u32;
pub const D3D12_STANDARD_VECTOR_SIZE: u32 = 4u32;
pub const D3D12_STANDARD_VERTEX_ELEMENT_COUNT: u32 = 32u32;
pub const D3D12_STANDARD_VERTEX_TOTAL_COMPONENT_COUNT: u32 = 64u32;
pub const D3D12_SUBPIXEL_FRACTIONAL_BIT_COUNT: u32 = 8u32;
pub const D3D12_SUBTEXEL_FRACTIONAL_BIT_COUNT: u32 = 8u32;
pub const D3D12_SYSTEM_RESERVED_REGISTER_SPACE_VALUES_END: u32 = 4294967295u32;
pub const D3D12_SYSTEM_RESERVED_REGISTER_SPACE_VALUES_START: u32 = 4294967280u32;
pub const D3D12_TESSELLATOR_MAX_EVEN_TESSELLATION_FACTOR: u32 = 64u32;
pub const D3D12_TESSELLATOR_MAX_ISOLINE_DENSITY_TESSELLATION_FACTOR: u32 = 64u32;
pub const D3D12_TESSELLATOR_MAX_ODD_TESSELLATION_FACTOR: u32 = 63u32;
pub const D3D12_TESSELLATOR_MAX_TESSELLATION_FACTOR: u32 = 64u32;
pub const D3D12_TESSELLATOR_MIN_EVEN_TESSELLATION_FACTOR: u32 = 2u32;
pub const D3D12_TESSELLATOR_MIN_ISOLINE_DENSITY_TESSELLATION_FACTOR: u32 = 1u32;
pub const D3D12_TESSELLATOR_MIN_ODD_TESSELLATION_FACTOR: u32 = 1u32;
pub const D3D12_TEXEL_ADDRESS_RANGE_BIT_COUNT: u32 = 16u32;
pub const D3D12_TEXTURE_DATA_PITCH_ALIGNMENT: u32 = 256u32;
pub const D3D12_TEXTURE_DATA_PLACEMENT_ALIGNMENT: u32 = 512u32;
pub const D3D12_TILED_RESOURCE_TILE_SIZE_IN_BYTES: u32 = 65536u32;
pub const D3D12_TRACKED_WORKLOAD_MAX_INSTANCES: u32 = 32u32;
pub const D3D12_UAV_COUNTER_PLACEMENT_ALIGNMENT: u32 = 4096u32;
pub const D3D12_UAV_SLOT_COUNT: u32 = 64u32;
pub const D3D12_UNBOUND_MEMORY_ACCESS_RESULT: u32 = 0u32;
pub const D3D12_VIDEO_DECODE_MAX_ARGUMENTS: u32 = 10u32;
pub const D3D12_VIDEO_DECODE_MAX_HISTOGRAM_COMPONENTS: u32 = 4u32;
pub const D3D12_VIDEO_DECODE_MIN_BITSTREAM_OFFSET_ALIGNMENT: u32 = 256u32;
pub const D3D12_VIDEO_DECODE_MIN_HISTOGRAM_OFFSET_ALIGNMENT: u32 = 256u32;
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_12BIT_PROFILE2: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x17127009_a00f_4ce1_994e_bf4081f6f3f0);
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_12BIT_PROFILE2_420: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x2d80bed6_9cac_4835_9e91_327bbc4f9ee8);
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_PROFILE0: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xb8be4ccb_cf53_46ba_8d59_d6b8a6da5d2a);
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_PROFILE1: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x6936ff0f_45b1_4163_9cc1_646ef6946108);
pub const D3D12_VIDEO_DECODE_PROFILE_AV1_PROFILE2: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x0c5f2aa1_e541_4089_bb7b_98110a19d7c8);
pub const D3D12_VIDEO_DECODE_PROFILE_H264: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x1b81be68_a0c7_11d3_b984_00c04f2e73c5);
pub const D3D12_VIDEO_DECODE_PROFILE_H264_MULTIVIEW: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x705b9d82_76cf_49d6_b7e6_ac8872db013c);
pub const D3D12_VIDEO_DECODE_PROFILE_H264_STEREO: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xf9aaccbb_c2b6_4cfc_8779_5707b1760552);
pub const D3D12_VIDEO_DECODE_PROFILE_H264_STEREO_PROGRESSIVE: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xd79be8da_0cf1_4c81_b82a_69a4e236f43d);
pub const D3D12_VIDEO_DECODE_PROFILE_HEVC_MAIN: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x5b11d51b_2f4c_4452_bcc3_09f2a1160cc0);
pub const D3D12_VIDEO_DECODE_PROFILE_HEVC_MAIN10: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x107af0e0_ef1a_4d19_aba8_67a163073d13);
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG1_AND_MPEG2: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x86695f12_340e_4f04_9fd3_9253dd327460);
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG2: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xee27417f_5e28_4e65_beea_1d26b508adc9);
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG4PT2_ADVSIMPLE_NOGMC: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xed418a9f_010d_4eda_9ae3_9a65358d8d2e);
pub const D3D12_VIDEO_DECODE_PROFILE_MPEG4PT2_SIMPLE: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xefd64d74_c9e8_41d7_a5e9_e9b0e39fa319);
pub const D3D12_VIDEO_DECODE_PROFILE_VC1: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x1b81bea3_a0c7_11d3_b984_00c04f2e73c5);
pub const D3D12_VIDEO_DECODE_PROFILE_VC1_D2010: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x1b81bea4_a0c7_11d3_b984_00c04f2e73c5);
pub const D3D12_VIDEO_DECODE_PROFILE_VP8: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x90b899ea_3a62_4705_88b3_8df04b2744e7);
pub const D3D12_VIDEO_DECODE_PROFILE_VP9: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x463707f8_a1d0_4585_876d_83aa6d60b89e);
pub const D3D12_VIDEO_DECODE_PROFILE_VP9_10BIT_PROFILE2: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xa4c749ef_6ecf_48aa_8448_50a7a1165ff7);
pub const D3D12_VIDEO_DECODE_STATUS_MACROBLOCKS_AFFECTED_UNKNOWN: u32 = 4294967295u32;
pub const D3D12_VIDEO_ENCODER_AV1_INVALID_DPB_RESOURCE_INDEX: u32 = 255u32;
pub const D3D12_VIDEO_ENCODER_AV1_MAX_TILE_COLS: u32 = 64u32;
pub const D3D12_VIDEO_ENCODER_AV1_MAX_TILE_ROWS: u32 = 64u32;
pub const D3D12_VIDEO_ENCODER_AV1_SUPERRES_DENOM_MIN: u32 = 9u32;
pub const D3D12_VIDEO_ENCODER_AV1_SUPERRES_NUM: u32 = 8u32;
pub const D3D12_VIDEO_PROCESS_MAX_FILTERS: u32 = 32u32;
pub const D3D12_VIDEO_PROCESS_STEREO_VIEWS: u32 = 2u32;
pub const D3D12_VIEWPORT_AND_SCISSORRECT_MAX_INDEX: u32 = 15u32;
pub const D3D12_VIEWPORT_AND_SCISSORRECT_OBJECT_COUNT_PER_PIPELINE: u32 = 16u32;
pub const D3D12_VIEWPORT_BOUNDS_MAX: u32 = 32767u32;
pub const D3D12_VIEWPORT_BOUNDS_MIN: i32 = -32768i32;
pub const D3D12_VS_INPUT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_VS_INPUT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_VS_INPUT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_VS_INPUT_REGISTER_READS_PER_INST: u32 = 2u32;
pub const D3D12_VS_INPUT_REGISTER_READ_PORTS: u32 = 1u32;
pub const D3D12_VS_OUTPUT_REGISTER_COMPONENTS: u32 = 4u32;
pub const D3D12_VS_OUTPUT_REGISTER_COMPONENT_BIT_COUNT: u32 = 32u32;
pub const D3D12_VS_OUTPUT_REGISTER_COUNT: u32 = 32u32;
pub const D3D12_WHQL_CONTEXT_COUNT_FOR_RESOURCE_LIMIT: u32 = 10u32;
pub const D3D12_WHQL_DRAWINDEXED_INDEX_COUNT_2_TO_EXP: u32 = 25u32;
pub const D3D12_WHQL_DRAW_VERTEX_COUNT_2_TO_EXP: u32 = 25u32;
pub const D3D_COMPONENT_MASK_W: u32 = 8u32;
pub const D3D_COMPONENT_MASK_X: u32 = 1u32;
pub const D3D_COMPONENT_MASK_Y: u32 = 2u32;
pub const D3D_COMPONENT_MASK_Z: u32 = 4u32;
pub const D3D_FL9_1_DEFAULT_MAX_ANISOTROPY: u32 = 2u32;
pub const D3D_FL9_1_IA_PRIMITIVE_MAX_COUNT: u32 = 65535u32;
pub const D3D_FL9_1_MAX_TEXTURE_REPEAT: u32 = 128u32;
pub const D3D_FL9_1_REQ_TEXTURE1D_U_DIMENSION: u32 = 2048u32;
pub const D3D_FL9_1_REQ_TEXTURE2D_U_OR_V_DIMENSION: u32 = 2048u32;
pub const D3D_FL9_1_REQ_TEXTURE3D_U_V_OR_W_DIMENSION: u32 = 256u32;
pub const D3D_FL9_1_REQ_TEXTURECUBE_DIMENSION: u32 = 512u32;
pub const D3D_FL9_1_SIMULTANEOUS_RENDER_TARGET_COUNT: u32 = 1u32;
pub const D3D_FL9_2_IA_PRIMITIVE_MAX_COUNT: u32 = 1048575u32;
pub const D3D_FL9_2_MAX_TEXTURE_REPEAT: u32 = 2048u32;
pub const D3D_FL9_3_MAX_TEXTURE_REPEAT: u32 = 8192u32;
pub const D3D_FL9_3_REQ_TEXTURE1D_U_DIMENSION: u32 = 4096u32;
pub const D3D_FL9_3_REQ_TEXTURE2D_U_OR_V_DIMENSION: u32 = 4096u32;
pub const D3D_FL9_3_REQ_TEXTURECUBE_DIMENSION: u32 = 4096u32;
pub const D3D_FL9_3_SIMULTANEOUS_RENDER_TARGET_COUNT: u32 = 4u32;
pub const D3D_RETURN_PARAMETER_INDEX: i32 = -1i32;
pub const D3D_SHADER_FEATURE_11_1_DOUBLE_EXTENSIONS: u32 = 32u32;
pub const D3D_SHADER_FEATURE_11_1_SHADER_EXTENSIONS: u32 = 64u32;
pub const D3D_SHADER_FEATURE_64_UAVS: u32 = 8u32;
pub const D3D_SHADER_FEATURE_ADVANCED_TEXTURE_OPS: u32 = 536870912u32;
pub const D3D_SHADER_FEATURE_ATOMIC_INT64_ON_DESCRIPTOR_HEAP_RESOURCE: u32 = 268435456u32;
pub const D3D_SHADER_FEATURE_ATOMIC_INT64_ON_GROUP_SHARED: u32 = 8388608u32;
pub const D3D_SHADER_FEATURE_ATOMIC_INT64_ON_TYPED_RESOURCE: u32 = 4194304u32;
pub const D3D_SHADER_FEATURE_BARYCENTRICS: u32 = 131072u32;
pub const D3D_SHADER_FEATURE_COMPUTE_SHADERS_PLUS_RAW_AND_STRUCTURED_BUFFERS_VIA_SHADER_4_X: u32 =
    2u32;
pub const D3D_SHADER_FEATURE_DERIVATIVES_IN_MESH_AND_AMPLIFICATION_SHADERS: u32 = 16777216u32;
pub const D3D_SHADER_FEATURE_DOUBLES: u32 = 1u32;
pub const D3D_SHADER_FEATURE_INNER_COVERAGE: u32 = 1024u32;
pub const D3D_SHADER_FEATURE_INT64_OPS: u32 = 32768u32;
pub const D3D_SHADER_FEATURE_LEVEL_9_COMPARISON_FILTERING: u32 = 128u32;
pub const D3D_SHADER_FEATURE_MINIMUM_PRECISION: u32 = 16u32;
pub const D3D_SHADER_FEATURE_NATIVE_16BIT_OPS: u32 = 262144u32;
pub const D3D_SHADER_FEATURE_RAYTRACING_TIER_1_1: u32 = 1048576u32;
pub const D3D_SHADER_FEATURE_RESOURCE_DESCRIPTOR_HEAP_INDEXING: u32 = 33554432u32;
pub const D3D_SHADER_FEATURE_ROVS: u32 = 4096u32;
pub const D3D_SHADER_FEATURE_SAMPLER_DESCRIPTOR_HEAP_INDEXING: u32 = 67108864u32;
pub const D3D_SHADER_FEATURE_SAMPLER_FEEDBACK: u32 = 2097152u32;
pub const D3D_SHADER_FEATURE_SHADING_RATE: u32 = 524288u32;
pub const D3D_SHADER_FEATURE_STENCIL_REF: u32 = 512u32;
pub const D3D_SHADER_FEATURE_TILED_RESOURCES: u32 = 256u32;
pub const D3D_SHADER_FEATURE_TYPED_UAV_LOAD_ADDITIONAL_FORMATS: u32 = 2048u32;
pub const D3D_SHADER_FEATURE_UAVS_AT_EVERY_STAGE: u32 = 4u32;
pub const D3D_SHADER_FEATURE_VIEWPORT_AND_RT_ARRAY_INDEX_FROM_ANY_SHADER_FEEDING_RASTERIZER: u32 =
    8192u32;
pub const D3D_SHADER_FEATURE_VIEW_ID: u32 = 65536u32;
pub const D3D_SHADER_FEATURE_WAVE_MMA: u32 = 134217728u32;
pub const D3D_SHADER_FEATURE_WAVE_OPS: u32 = 16384u32;
pub const D3D_SHADER_FEATURE_WRITEABLE_MSAA_TEXTURES: u32 = 1073741824u32;
pub const D3D_SHADER_REQUIRES_11_1_DOUBLE_EXTENSIONS: u32 = 32u32;
pub const D3D_SHADER_REQUIRES_11_1_SHADER_EXTENSIONS: u32 = 64u32;
pub const D3D_SHADER_REQUIRES_64_UAVS: u32 = 8u32;
pub const D3D_SHADER_REQUIRES_ATOMIC_INT64_ON_DESCRIPTOR_HEAP_RESOURCE: u32 = 268435456u32;
pub const D3D_SHADER_REQUIRES_ATOMIC_INT64_ON_GROUP_SHARED: u32 = 8388608u32;
pub const D3D_SHADER_REQUIRES_ATOMIC_INT64_ON_TYPED_RESOURCE: u32 = 4194304u32;
pub const D3D_SHADER_REQUIRES_BARYCENTRICS: u32 = 131072u32;
pub const D3D_SHADER_REQUIRES_DERIVATIVES_IN_MESH_AND_AMPLIFICATION_SHADERS: u32 = 16777216u32;
pub const D3D_SHADER_REQUIRES_DOUBLES: u32 = 1u32;
pub const D3D_SHADER_REQUIRES_EARLY_DEPTH_STENCIL: u32 = 2u32;
pub const D3D_SHADER_REQUIRES_INNER_COVERAGE: u32 = 1024u32;
pub const D3D_SHADER_REQUIRES_INT64_OPS: u32 = 32768u32;
pub const D3D_SHADER_REQUIRES_LEVEL_9_COMPARISON_FILTERING: u32 = 128u32;
pub const D3D_SHADER_REQUIRES_MINIMUM_PRECISION: u32 = 16u32;
pub const D3D_SHADER_REQUIRES_NATIVE_16BIT_OPS: u32 = 262144u32;
pub const D3D_SHADER_REQUIRES_RAYTRACING_TIER_1_1: u32 = 1048576u32;
pub const D3D_SHADER_REQUIRES_RESOURCE_DESCRIPTOR_HEAP_INDEXING: u32 = 33554432u32;
pub const D3D_SHADER_REQUIRES_ROVS: u32 = 4096u32;
pub const D3D_SHADER_REQUIRES_SAMPLER_DESCRIPTOR_HEAP_INDEXING: u32 = 67108864u32;
pub const D3D_SHADER_REQUIRES_SAMPLER_FEEDBACK: u32 = 2097152u32;
pub const D3D_SHADER_REQUIRES_SHADING_RATE: u32 = 524288u32;
pub const D3D_SHADER_REQUIRES_STENCIL_REF: u32 = 512u32;
pub const D3D_SHADER_REQUIRES_TILED_RESOURCES: u32 = 256u32;
pub const D3D_SHADER_REQUIRES_TYPED_UAV_LOAD_ADDITIONAL_FORMATS: u32 = 2048u32;
pub const D3D_SHADER_REQUIRES_UAVS_AT_EVERY_STAGE: u32 = 4u32;
pub const D3D_SHADER_REQUIRES_VIEWPORT_AND_RT_ARRAY_INDEX_FROM_ANY_SHADER_FEEDING_RASTERIZER: u32 =
    8192u32;
pub const D3D_SHADER_REQUIRES_VIEW_ID: u32 = 65536u32;
pub const D3D_SHADER_REQUIRES_WAVE_MMA: u32 = 134217728u32;
pub const D3D_SHADER_REQUIRES_WAVE_OPS: u32 = 16384u32;
pub const D3D_TEXTURE_LAYOUT_64KB_STANDARD_SWIZZLE: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x4c0f29e3_3f5f_4d35_84c9_bc0983b62c28);
pub const D3D_TEXTURE_LAYOUT_ROW_MAJOR: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xb5dc234f_72bb_4bec_9705_8cf258df6b6c);
pub const DXGI_DEBUG_D3D12: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xcf59a98c_a950_4326_91ef_9bbaa17bfd95);
pub const DXGI_FORMAT_DEFINED: u32 = 1u32;
pub const LUID_DEFINED: u32 = 1u32;
pub const WKPDID_CommentStringW: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xd0149dc0_90e8_4ec8_8144_e900ad266bb2);
pub const WKPDID_D3D12UniqueObjectId: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x1b39de15_ec04_4bae_ba4d_8cef79fc04c1);
pub const WKPDID_D3DAutoDebugObjectNameW: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0xd4902e36_757a_4942_9594_b6769afa43cd);
pub const WKPDID_D3DDebugObjectName: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x429b8c22_9188_4b0c_8742_acb0bf85c200);
pub const WKPDID_D3DDebugObjectNameW: ::windows::core::GUID =
    ::windows::core::GUID::from_u128(0x4cca5fd8_921f_42c8_8566_70caf2a9b741);
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_AUTO_BREADCRUMB_OP(pub i32);
pub const D3D12_AUTO_BREADCRUMB_OP_SETMARKER: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(0i32);
pub const D3D12_AUTO_BREADCRUMB_OP_BEGINEVENT: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(1i32);
pub const D3D12_AUTO_BREADCRUMB_OP_ENDEVENT: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(2i32);
pub const D3D12_AUTO_BREADCRUMB_OP_DRAWINSTANCED: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(3i32);
pub const D3D12_AUTO_BREADCRUMB_OP_DRAWINDEXEDINSTANCED: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(4i32);
pub const D3D12_AUTO_BREADCRUMB_OP_EXECUTEINDIRECT: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(5i32);
pub const D3D12_AUTO_BREADCRUMB_OP_DISPATCH: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(6i32);
pub const D3D12_AUTO_BREADCRUMB_OP_COPYBUFFERREGION: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(7i32);
pub const D3D12_AUTO_BREADCRUMB_OP_COPYTEXTUREREGION: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(8i32);
pub const D3D12_AUTO_BREADCRUMB_OP_COPYRESOURCE: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(9i32);
pub const D3D12_AUTO_BREADCRUMB_OP_COPYTILES: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(10i32);
pub const D3D12_AUTO_BREADCRUMB_OP_RESOLVESUBRESOURCE: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(11i32);
pub const D3D12_AUTO_BREADCRUMB_OP_CLEARRENDERTARGETVIEW: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(12i32);
pub const D3D12_AUTO_BREADCRUMB_OP_CLEARUNORDEREDACCESSVIEW: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(13i32);
pub const D3D12_AUTO_BREADCRUMB_OP_CLEARDEPTHSTENCILVIEW: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(14i32);
pub const D3D12_AUTO_BREADCRUMB_OP_RESOURCEBARRIER: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(15i32);
pub const D3D12_AUTO_BREADCRUMB_OP_EXECUTEBUNDLE: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(16i32);
pub const D3D12_AUTO_BREADCRUMB_OP_PRESENT: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(17i32);
pub const D3D12_AUTO_BREADCRUMB_OP_RESOLVEQUERYDATA: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(18i32);
pub const D3D12_AUTO_BREADCRUMB_OP_BEGINSUBMISSION: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(19i32);
pub const D3D12_AUTO_BREADCRUMB_OP_ENDSUBMISSION: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(20i32);
pub const D3D12_AUTO_BREADCRUMB_OP_DECODEFRAME: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(21i32);
pub const D3D12_AUTO_BREADCRUMB_OP_PROCESSFRAMES: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(22i32);
pub const D3D12_AUTO_BREADCRUMB_OP_ATOMICCOPYBUFFERUINT: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(23i32);
pub const D3D12_AUTO_BREADCRUMB_OP_ATOMICCOPYBUFFERUINT64: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(24i32);
pub const D3D12_AUTO_BREADCRUMB_OP_RESOLVESUBRESOURCEREGION: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(25i32);
pub const D3D12_AUTO_BREADCRUMB_OP_WRITEBUFFERIMMEDIATE: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(26i32);
pub const D3D12_AUTO_BREADCRUMB_OP_DECODEFRAME1: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(27i32);
pub const D3D12_AUTO_BREADCRUMB_OP_SETPROTECTEDRESOURCESESSION: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(28i32);
pub const D3D12_AUTO_BREADCRUMB_OP_DECODEFRAME2: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(29i32);
pub const D3D12_AUTO_BREADCRUMB_OP_PROCESSFRAMES1: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(30i32);
pub const D3D12_AUTO_BREADCRUMB_OP_BUILDRAYTRACINGACCELERATIONSTRUCTURE: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(31i32);
pub const D3D12_AUTO_BREADCRUMB_OP_EMITRAYTRACINGACCELERATIONSTRUCTUREPOSTBUILDINFO:
    D3D12_AUTO_BREADCRUMB_OP = D3D12_AUTO_BREADCRUMB_OP(32i32);
pub const D3D12_AUTO_BREADCRUMB_OP_COPYRAYTRACINGACCELERATIONSTRUCTURE: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(33i32);
pub const D3D12_AUTO_BREADCRUMB_OP_DISPATCHRAYS: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(34i32);
pub const D3D12_AUTO_BREADCRUMB_OP_INITIALIZEMETACOMMAND: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(35i32);
pub const D3D12_AUTO_BREADCRUMB_OP_EXECUTEMETACOMMAND: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(36i32);
pub const D3D12_AUTO_BREADCRUMB_OP_ESTIMATEMOTION: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(37i32);
pub const D3D12_AUTO_BREADCRUMB_OP_RESOLVEMOTIONVECTORHEAP: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(38i32);
pub const D3D12_AUTO_BREADCRUMB_OP_SETPIPELINESTATE1: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(39i32);
pub const D3D12_AUTO_BREADCRUMB_OP_INITIALIZEEXTENSIONCOMMAND: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(40i32);
pub const D3D12_AUTO_BREADCRUMB_OP_EXECUTEEXTENSIONCOMMAND: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(41i32);
pub const D3D12_AUTO_BREADCRUMB_OP_DISPATCHMESH: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(42i32);
pub const D3D12_AUTO_BREADCRUMB_OP_ENCODEFRAME: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(43i32);
pub const D3D12_AUTO_BREADCRUMB_OP_RESOLVEENCODEROUTPUTMETADATA: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(44i32);
pub const D3D12_AUTO_BREADCRUMB_OP_BARRIER: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(45i32);
pub const D3D12_AUTO_BREADCRUMB_OP_BEGIN_COMMAND_LIST: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(46i32);
pub const D3D12_AUTO_BREADCRUMB_OP_DISPATCHGRAPH: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(47i32);
pub const D3D12_AUTO_BREADCRUMB_OP_SETPROGRAM: D3D12_AUTO_BREADCRUMB_OP =
    D3D12_AUTO_BREADCRUMB_OP(48i32);
impl ::core::marker::Copy for D3D12_AUTO_BREADCRUMB_OP {}
impl ::core::clone::Clone for D3D12_AUTO_BREADCRUMB_OP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_AUTO_BREADCRUMB_OP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_AUTO_BREADCRUMB_OP {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_AUTO_BREADCRUMB_OP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_AUTO_BREADCRUMB_OP")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_AXIS_SHADING_RATE(pub i32);
pub const D3D12_AXIS_SHADING_RATE_1X: D3D12_AXIS_SHADING_RATE = D3D12_AXIS_SHADING_RATE(0i32);
pub const D3D12_AXIS_SHADING_RATE_2X: D3D12_AXIS_SHADING_RATE = D3D12_AXIS_SHADING_RATE(1i32);
pub const D3D12_AXIS_SHADING_RATE_4X: D3D12_AXIS_SHADING_RATE = D3D12_AXIS_SHADING_RATE(2i32);
impl ::core::marker::Copy for D3D12_AXIS_SHADING_RATE {}
impl ::core::clone::Clone for D3D12_AXIS_SHADING_RATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_AXIS_SHADING_RATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_AXIS_SHADING_RATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_AXIS_SHADING_RATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_AXIS_SHADING_RATE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BACKGROUND_PROCESSING_MODE(pub i32);
pub const D3D12_BACKGROUND_PROCESSING_MODE_ALLOWED: D3D12_BACKGROUND_PROCESSING_MODE =
    D3D12_BACKGROUND_PROCESSING_MODE(0i32);
pub const D3D12_BACKGROUND_PROCESSING_MODE_ALLOW_INTRUSIVE_MEASUREMENTS:
    D3D12_BACKGROUND_PROCESSING_MODE = D3D12_BACKGROUND_PROCESSING_MODE(1i32);
pub const D3D12_BACKGROUND_PROCESSING_MODE_DISABLE_BACKGROUND_WORK:
    D3D12_BACKGROUND_PROCESSING_MODE = D3D12_BACKGROUND_PROCESSING_MODE(2i32);
pub const D3D12_BACKGROUND_PROCESSING_MODE_DISABLE_PROFILING_BY_SYSTEM:
    D3D12_BACKGROUND_PROCESSING_MODE = D3D12_BACKGROUND_PROCESSING_MODE(3i32);
impl ::core::marker::Copy for D3D12_BACKGROUND_PROCESSING_MODE {}
impl ::core::clone::Clone for D3D12_BACKGROUND_PROCESSING_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BACKGROUND_PROCESSING_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BACKGROUND_PROCESSING_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BACKGROUND_PROCESSING_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BACKGROUND_PROCESSING_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BARRIER_ACCESS(pub i32);
pub const D3D12_BARRIER_ACCESS_COMMON: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(0i32);
pub const D3D12_BARRIER_ACCESS_VERTEX_BUFFER: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(1i32);
pub const D3D12_BARRIER_ACCESS_CONSTANT_BUFFER: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(2i32);
pub const D3D12_BARRIER_ACCESS_INDEX_BUFFER: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(4i32);
pub const D3D12_BARRIER_ACCESS_RENDER_TARGET: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(8i32);
pub const D3D12_BARRIER_ACCESS_UNORDERED_ACCESS: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(16i32);
pub const D3D12_BARRIER_ACCESS_DEPTH_STENCIL_WRITE: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(32i32);
pub const D3D12_BARRIER_ACCESS_DEPTH_STENCIL_READ: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(64i32);
pub const D3D12_BARRIER_ACCESS_SHADER_RESOURCE: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(128i32);
pub const D3D12_BARRIER_ACCESS_STREAM_OUTPUT: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(256i32);
pub const D3D12_BARRIER_ACCESS_INDIRECT_ARGUMENT: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(512i32);
pub const D3D12_BARRIER_ACCESS_PREDICATION: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(512i32);
pub const D3D12_BARRIER_ACCESS_COPY_DEST: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(1024i32);
pub const D3D12_BARRIER_ACCESS_COPY_SOURCE: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(2048i32);
pub const D3D12_BARRIER_ACCESS_RESOLVE_DEST: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(4096i32);
pub const D3D12_BARRIER_ACCESS_RESOLVE_SOURCE: D3D12_BARRIER_ACCESS = D3D12_BARRIER_ACCESS(8192i32);
pub const D3D12_BARRIER_ACCESS_RAYTRACING_ACCELERATION_STRUCTURE_READ: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(16384i32);
pub const D3D12_BARRIER_ACCESS_RAYTRACING_ACCELERATION_STRUCTURE_WRITE: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(32768i32);
pub const D3D12_BARRIER_ACCESS_SHADING_RATE_SOURCE: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(65536i32);
pub const D3D12_BARRIER_ACCESS_VIDEO_DECODE_READ: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(131072i32);
pub const D3D12_BARRIER_ACCESS_VIDEO_DECODE_WRITE: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(262144i32);
pub const D3D12_BARRIER_ACCESS_VIDEO_PROCESS_READ: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(524288i32);
pub const D3D12_BARRIER_ACCESS_VIDEO_PROCESS_WRITE: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(1048576i32);
pub const D3D12_BARRIER_ACCESS_VIDEO_ENCODE_READ: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(2097152i32);
pub const D3D12_BARRIER_ACCESS_VIDEO_ENCODE_WRITE: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(4194304i32);
pub const D3D12_BARRIER_ACCESS_NO_ACCESS: D3D12_BARRIER_ACCESS =
    D3D12_BARRIER_ACCESS(-2147483648i32);
impl ::core::marker::Copy for D3D12_BARRIER_ACCESS {}
impl ::core::clone::Clone for D3D12_BARRIER_ACCESS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BARRIER_ACCESS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BARRIER_ACCESS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BARRIER_ACCESS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BARRIER_ACCESS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_BARRIER_ACCESS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_BARRIER_ACCESS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_BARRIER_ACCESS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_BARRIER_ACCESS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_BARRIER_ACCESS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_BARRIER_ACCESS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BARRIER_LAYOUT(pub i32);
pub const D3D12_BARRIER_LAYOUT_UNDEFINED: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(-1i32);
pub const D3D12_BARRIER_LAYOUT_COMMON: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(0i32);
pub const D3D12_BARRIER_LAYOUT_PRESENT: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(0i32);
pub const D3D12_BARRIER_LAYOUT_GENERIC_READ: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(1i32);
pub const D3D12_BARRIER_LAYOUT_RENDER_TARGET: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(2i32);
pub const D3D12_BARRIER_LAYOUT_UNORDERED_ACCESS: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(3i32);
pub const D3D12_BARRIER_LAYOUT_DEPTH_STENCIL_WRITE: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(4i32);
pub const D3D12_BARRIER_LAYOUT_DEPTH_STENCIL_READ: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(5i32);
pub const D3D12_BARRIER_LAYOUT_SHADER_RESOURCE: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(6i32);
pub const D3D12_BARRIER_LAYOUT_COPY_SOURCE: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(7i32);
pub const D3D12_BARRIER_LAYOUT_COPY_DEST: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(8i32);
pub const D3D12_BARRIER_LAYOUT_RESOLVE_SOURCE: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(9i32);
pub const D3D12_BARRIER_LAYOUT_RESOLVE_DEST: D3D12_BARRIER_LAYOUT = D3D12_BARRIER_LAYOUT(10i32);
pub const D3D12_BARRIER_LAYOUT_SHADING_RATE_SOURCE: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(11i32);
pub const D3D12_BARRIER_LAYOUT_VIDEO_DECODE_READ: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(12i32);
pub const D3D12_BARRIER_LAYOUT_VIDEO_DECODE_WRITE: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(13i32);
pub const D3D12_BARRIER_LAYOUT_VIDEO_PROCESS_READ: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(14i32);
pub const D3D12_BARRIER_LAYOUT_VIDEO_PROCESS_WRITE: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(15i32);
pub const D3D12_BARRIER_LAYOUT_VIDEO_ENCODE_READ: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(16i32);
pub const D3D12_BARRIER_LAYOUT_VIDEO_ENCODE_WRITE: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(17i32);
pub const D3D12_BARRIER_LAYOUT_DIRECT_QUEUE_COMMON: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(18i32);
pub const D3D12_BARRIER_LAYOUT_DIRECT_QUEUE_GENERIC_READ: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(19i32);
pub const D3D12_BARRIER_LAYOUT_DIRECT_QUEUE_UNORDERED_ACCESS: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(20i32);
pub const D3D12_BARRIER_LAYOUT_DIRECT_QUEUE_SHADER_RESOURCE: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(21i32);
pub const D3D12_BARRIER_LAYOUT_DIRECT_QUEUE_COPY_SOURCE: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(22i32);
pub const D3D12_BARRIER_LAYOUT_DIRECT_QUEUE_COPY_DEST: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(23i32);
pub const D3D12_BARRIER_LAYOUT_COMPUTE_QUEUE_COMMON: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(24i32);
pub const D3D12_BARRIER_LAYOUT_COMPUTE_QUEUE_GENERIC_READ: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(25i32);
pub const D3D12_BARRIER_LAYOUT_COMPUTE_QUEUE_UNORDERED_ACCESS: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(26i32);
pub const D3D12_BARRIER_LAYOUT_COMPUTE_QUEUE_SHADER_RESOURCE: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(27i32);
pub const D3D12_BARRIER_LAYOUT_COMPUTE_QUEUE_COPY_SOURCE: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(28i32);
pub const D3D12_BARRIER_LAYOUT_COMPUTE_QUEUE_COPY_DEST: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(29i32);
pub const D3D12_BARRIER_LAYOUT_VIDEO_QUEUE_COMMON: D3D12_BARRIER_LAYOUT =
    D3D12_BARRIER_LAYOUT(30i32);
impl ::core::marker::Copy for D3D12_BARRIER_LAYOUT {}
impl ::core::clone::Clone for D3D12_BARRIER_LAYOUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BARRIER_LAYOUT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BARRIER_LAYOUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BARRIER_LAYOUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BARRIER_LAYOUT")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BARRIER_SYNC(pub i32);
pub const D3D12_BARRIER_SYNC_NONE: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(0i32);
pub const D3D12_BARRIER_SYNC_ALL: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(1i32);
pub const D3D12_BARRIER_SYNC_DRAW: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(2i32);
pub const D3D12_BARRIER_SYNC_INDEX_INPUT: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(4i32);
pub const D3D12_BARRIER_SYNC_VERTEX_SHADING: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(8i32);
pub const D3D12_BARRIER_SYNC_PIXEL_SHADING: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(16i32);
pub const D3D12_BARRIER_SYNC_DEPTH_STENCIL: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(32i32);
pub const D3D12_BARRIER_SYNC_RENDER_TARGET: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(64i32);
pub const D3D12_BARRIER_SYNC_COMPUTE_SHADING: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(128i32);
pub const D3D12_BARRIER_SYNC_RAYTRACING: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(256i32);
pub const D3D12_BARRIER_SYNC_COPY: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(512i32);
pub const D3D12_BARRIER_SYNC_RESOLVE: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(1024i32);
pub const D3D12_BARRIER_SYNC_EXECUTE_INDIRECT: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(2048i32);
pub const D3D12_BARRIER_SYNC_PREDICATION: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(2048i32);
pub const D3D12_BARRIER_SYNC_ALL_SHADING: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(4096i32);
pub const D3D12_BARRIER_SYNC_NON_PIXEL_SHADING: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(8192i32);
pub const D3D12_BARRIER_SYNC_EMIT_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO:
    D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(16384i32);
pub const D3D12_BARRIER_SYNC_CLEAR_UNORDERED_ACCESS_VIEW: D3D12_BARRIER_SYNC =
    D3D12_BARRIER_SYNC(32768i32);
pub const D3D12_BARRIER_SYNC_VIDEO_DECODE: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(1048576i32);
pub const D3D12_BARRIER_SYNC_VIDEO_PROCESS: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(2097152i32);
pub const D3D12_BARRIER_SYNC_VIDEO_ENCODE: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(4194304i32);
pub const D3D12_BARRIER_SYNC_BUILD_RAYTRACING_ACCELERATION_STRUCTURE: D3D12_BARRIER_SYNC =
    D3D12_BARRIER_SYNC(8388608i32);
pub const D3D12_BARRIER_SYNC_COPY_RAYTRACING_ACCELERATION_STRUCTURE: D3D12_BARRIER_SYNC =
    D3D12_BARRIER_SYNC(16777216i32);
pub const D3D12_BARRIER_SYNC_SPLIT: D3D12_BARRIER_SYNC = D3D12_BARRIER_SYNC(-2147483648i32);
impl ::core::marker::Copy for D3D12_BARRIER_SYNC {}
impl ::core::clone::Clone for D3D12_BARRIER_SYNC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BARRIER_SYNC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BARRIER_SYNC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BARRIER_SYNC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BARRIER_SYNC").field(&self.0).finish()
    }
}
impl D3D12_BARRIER_SYNC {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_BARRIER_SYNC {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_BARRIER_SYNC {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_BARRIER_SYNC {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_BARRIER_SYNC {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_BARRIER_SYNC {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BARRIER_TYPE(pub i32);
pub const D3D12_BARRIER_TYPE_GLOBAL: D3D12_BARRIER_TYPE = D3D12_BARRIER_TYPE(0i32);
pub const D3D12_BARRIER_TYPE_TEXTURE: D3D12_BARRIER_TYPE = D3D12_BARRIER_TYPE(1i32);
pub const D3D12_BARRIER_TYPE_BUFFER: D3D12_BARRIER_TYPE = D3D12_BARRIER_TYPE(2i32);
impl ::core::marker::Copy for D3D12_BARRIER_TYPE {}
impl ::core::clone::Clone for D3D12_BARRIER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BARRIER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BARRIER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BARRIER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BARRIER_TYPE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BITSTREAM_ENCRYPTION_TYPE(pub i32);
pub const D3D12_BITSTREAM_ENCRYPTION_TYPE_NONE: D3D12_BITSTREAM_ENCRYPTION_TYPE =
    D3D12_BITSTREAM_ENCRYPTION_TYPE(0i32);
impl ::core::marker::Copy for D3D12_BITSTREAM_ENCRYPTION_TYPE {}
impl ::core::clone::Clone for D3D12_BITSTREAM_ENCRYPTION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BITSTREAM_ENCRYPTION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BITSTREAM_ENCRYPTION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BITSTREAM_ENCRYPTION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BITSTREAM_ENCRYPTION_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BLEND(pub i32);
pub const D3D12_BLEND_ZERO: D3D12_BLEND = D3D12_BLEND(1i32);
pub const D3D12_BLEND_ONE: D3D12_BLEND = D3D12_BLEND(2i32);
pub const D3D12_BLEND_SRC_COLOR: D3D12_BLEND = D3D12_BLEND(3i32);
pub const D3D12_BLEND_INV_SRC_COLOR: D3D12_BLEND = D3D12_BLEND(4i32);
pub const D3D12_BLEND_SRC_ALPHA: D3D12_BLEND = D3D12_BLEND(5i32);
pub const D3D12_BLEND_INV_SRC_ALPHA: D3D12_BLEND = D3D12_BLEND(6i32);
pub const D3D12_BLEND_DEST_ALPHA: D3D12_BLEND = D3D12_BLEND(7i32);
pub const D3D12_BLEND_INV_DEST_ALPHA: D3D12_BLEND = D3D12_BLEND(8i32);
pub const D3D12_BLEND_DEST_COLOR: D3D12_BLEND = D3D12_BLEND(9i32);
pub const D3D12_BLEND_INV_DEST_COLOR: D3D12_BLEND = D3D12_BLEND(10i32);
pub const D3D12_BLEND_SRC_ALPHA_SAT: D3D12_BLEND = D3D12_BLEND(11i32);
pub const D3D12_BLEND_BLEND_FACTOR: D3D12_BLEND = D3D12_BLEND(14i32);
pub const D3D12_BLEND_INV_BLEND_FACTOR: D3D12_BLEND = D3D12_BLEND(15i32);
pub const D3D12_BLEND_SRC1_COLOR: D3D12_BLEND = D3D12_BLEND(16i32);
pub const D3D12_BLEND_INV_SRC1_COLOR: D3D12_BLEND = D3D12_BLEND(17i32);
pub const D3D12_BLEND_SRC1_ALPHA: D3D12_BLEND = D3D12_BLEND(18i32);
pub const D3D12_BLEND_INV_SRC1_ALPHA: D3D12_BLEND = D3D12_BLEND(19i32);
pub const D3D12_BLEND_ALPHA_FACTOR: D3D12_BLEND = D3D12_BLEND(20i32);
pub const D3D12_BLEND_INV_ALPHA_FACTOR: D3D12_BLEND = D3D12_BLEND(21i32);
impl ::core::marker::Copy for D3D12_BLEND {}
impl ::core::clone::Clone for D3D12_BLEND {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BLEND {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BLEND {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BLEND {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BLEND").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BLEND_OP(pub i32);
pub const D3D12_BLEND_OP_ADD: D3D12_BLEND_OP = D3D12_BLEND_OP(1i32);
pub const D3D12_BLEND_OP_SUBTRACT: D3D12_BLEND_OP = D3D12_BLEND_OP(2i32);
pub const D3D12_BLEND_OP_REV_SUBTRACT: D3D12_BLEND_OP = D3D12_BLEND_OP(3i32);
pub const D3D12_BLEND_OP_MIN: D3D12_BLEND_OP = D3D12_BLEND_OP(4i32);
pub const D3D12_BLEND_OP_MAX: D3D12_BLEND_OP = D3D12_BLEND_OP(5i32);
impl ::core::marker::Copy for D3D12_BLEND_OP {}
impl ::core::clone::Clone for D3D12_BLEND_OP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BLEND_OP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BLEND_OP {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BLEND_OP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BLEND_OP").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BUFFER_SRV_FLAGS(pub i32);
pub const D3D12_BUFFER_SRV_FLAG_NONE: D3D12_BUFFER_SRV_FLAGS = D3D12_BUFFER_SRV_FLAGS(0i32);
pub const D3D12_BUFFER_SRV_FLAG_RAW: D3D12_BUFFER_SRV_FLAGS = D3D12_BUFFER_SRV_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_BUFFER_SRV_FLAGS {}
impl ::core::clone::Clone for D3D12_BUFFER_SRV_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BUFFER_SRV_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BUFFER_SRV_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BUFFER_SRV_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BUFFER_SRV_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_BUFFER_SRV_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_BUFFER_SRV_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_BUFFER_SRV_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_BUFFER_SRV_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_BUFFER_SRV_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_BUFFER_SRV_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_BUFFER_UAV_FLAGS(pub i32);
pub const D3D12_BUFFER_UAV_FLAG_NONE: D3D12_BUFFER_UAV_FLAGS = D3D12_BUFFER_UAV_FLAGS(0i32);
pub const D3D12_BUFFER_UAV_FLAG_RAW: D3D12_BUFFER_UAV_FLAGS = D3D12_BUFFER_UAV_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_BUFFER_UAV_FLAGS {}
impl ::core::clone::Clone for D3D12_BUFFER_UAV_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_BUFFER_UAV_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_BUFFER_UAV_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_BUFFER_UAV_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_BUFFER_UAV_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_BUFFER_UAV_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_BUFFER_UAV_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_BUFFER_UAV_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_BUFFER_UAV_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_BUFFER_UAV_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_BUFFER_UAV_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_CLEAR_FLAGS(pub i32);
pub const D3D12_CLEAR_FLAG_DEPTH: D3D12_CLEAR_FLAGS = D3D12_CLEAR_FLAGS(1i32);
pub const D3D12_CLEAR_FLAG_STENCIL: D3D12_CLEAR_FLAGS = D3D12_CLEAR_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_CLEAR_FLAGS {}
impl ::core::clone::Clone for D3D12_CLEAR_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_CLEAR_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_CLEAR_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_CLEAR_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_CLEAR_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_CLEAR_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_CLEAR_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_CLEAR_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_CLEAR_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_CLEAR_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_CLEAR_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_COLOR_WRITE_ENABLE(pub i32);
pub const D3D12_COLOR_WRITE_ENABLE_RED: D3D12_COLOR_WRITE_ENABLE = D3D12_COLOR_WRITE_ENABLE(1i32);
pub const D3D12_COLOR_WRITE_ENABLE_GREEN: D3D12_COLOR_WRITE_ENABLE = D3D12_COLOR_WRITE_ENABLE(2i32);
pub const D3D12_COLOR_WRITE_ENABLE_BLUE: D3D12_COLOR_WRITE_ENABLE = D3D12_COLOR_WRITE_ENABLE(4i32);
pub const D3D12_COLOR_WRITE_ENABLE_ALPHA: D3D12_COLOR_WRITE_ENABLE = D3D12_COLOR_WRITE_ENABLE(8i32);
pub const D3D12_COLOR_WRITE_ENABLE_ALL: D3D12_COLOR_WRITE_ENABLE = D3D12_COLOR_WRITE_ENABLE(15i32);
impl ::core::marker::Copy for D3D12_COLOR_WRITE_ENABLE {}
impl ::core::clone::Clone for D3D12_COLOR_WRITE_ENABLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_COLOR_WRITE_ENABLE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_COLOR_WRITE_ENABLE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_COLOR_WRITE_ENABLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_COLOR_WRITE_ENABLE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_COMMAND_LIST_FLAGS(pub i32);
pub const D3D12_COMMAND_LIST_FLAG_NONE: D3D12_COMMAND_LIST_FLAGS = D3D12_COMMAND_LIST_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_COMMAND_LIST_FLAGS {}
impl ::core::clone::Clone for D3D12_COMMAND_LIST_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_COMMAND_LIST_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_COMMAND_LIST_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_COMMAND_LIST_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_COMMAND_LIST_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_COMMAND_LIST_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_COMMAND_LIST_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_COMMAND_LIST_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_COMMAND_LIST_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_COMMAND_LIST_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_COMMAND_LIST_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_COMMAND_LIST_SUPPORT_FLAGS(pub i32);
pub const D3D12_COMMAND_LIST_SUPPORT_FLAG_NONE: D3D12_COMMAND_LIST_SUPPORT_FLAGS =
    D3D12_COMMAND_LIST_SUPPORT_FLAGS(0i32);
pub const D3D12_COMMAND_LIST_SUPPORT_FLAG_DIRECT: D3D12_COMMAND_LIST_SUPPORT_FLAGS =
    D3D12_COMMAND_LIST_SUPPORT_FLAGS(1i32);
pub const D3D12_COMMAND_LIST_SUPPORT_FLAG_BUNDLE: D3D12_COMMAND_LIST_SUPPORT_FLAGS =
    D3D12_COMMAND_LIST_SUPPORT_FLAGS(2i32);
pub const D3D12_COMMAND_LIST_SUPPORT_FLAG_COMPUTE: D3D12_COMMAND_LIST_SUPPORT_FLAGS =
    D3D12_COMMAND_LIST_SUPPORT_FLAGS(4i32);
pub const D3D12_COMMAND_LIST_SUPPORT_FLAG_COPY: D3D12_COMMAND_LIST_SUPPORT_FLAGS =
    D3D12_COMMAND_LIST_SUPPORT_FLAGS(8i32);
pub const D3D12_COMMAND_LIST_SUPPORT_FLAG_VIDEO_DECODE: D3D12_COMMAND_LIST_SUPPORT_FLAGS =
    D3D12_COMMAND_LIST_SUPPORT_FLAGS(16i32);
pub const D3D12_COMMAND_LIST_SUPPORT_FLAG_VIDEO_PROCESS: D3D12_COMMAND_LIST_SUPPORT_FLAGS =
    D3D12_COMMAND_LIST_SUPPORT_FLAGS(32i32);
pub const D3D12_COMMAND_LIST_SUPPORT_FLAG_VIDEO_ENCODE: D3D12_COMMAND_LIST_SUPPORT_FLAGS =
    D3D12_COMMAND_LIST_SUPPORT_FLAGS(64i32);
impl ::core::marker::Copy for D3D12_COMMAND_LIST_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_COMMAND_LIST_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_COMMAND_LIST_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_COMMAND_LIST_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_COMMAND_LIST_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_COMMAND_LIST_SUPPORT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_COMMAND_LIST_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_COMMAND_LIST_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_COMMAND_LIST_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_COMMAND_LIST_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_COMMAND_LIST_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_COMMAND_LIST_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_COMMAND_LIST_TYPE(pub i32);
pub const D3D12_COMMAND_LIST_TYPE_DIRECT: D3D12_COMMAND_LIST_TYPE = D3D12_COMMAND_LIST_TYPE(0i32);
pub const D3D12_COMMAND_LIST_TYPE_BUNDLE: D3D12_COMMAND_LIST_TYPE = D3D12_COMMAND_LIST_TYPE(1i32);
pub const D3D12_COMMAND_LIST_TYPE_COMPUTE: D3D12_COMMAND_LIST_TYPE = D3D12_COMMAND_LIST_TYPE(2i32);
pub const D3D12_COMMAND_LIST_TYPE_COPY: D3D12_COMMAND_LIST_TYPE = D3D12_COMMAND_LIST_TYPE(3i32);
pub const D3D12_COMMAND_LIST_TYPE_VIDEO_DECODE: D3D12_COMMAND_LIST_TYPE =
    D3D12_COMMAND_LIST_TYPE(4i32);
pub const D3D12_COMMAND_LIST_TYPE_VIDEO_PROCESS: D3D12_COMMAND_LIST_TYPE =
    D3D12_COMMAND_LIST_TYPE(5i32);
pub const D3D12_COMMAND_LIST_TYPE_VIDEO_ENCODE: D3D12_COMMAND_LIST_TYPE =
    D3D12_COMMAND_LIST_TYPE(6i32);
pub const D3D12_COMMAND_LIST_TYPE_NONE: D3D12_COMMAND_LIST_TYPE = D3D12_COMMAND_LIST_TYPE(-1i32);
impl ::core::marker::Copy for D3D12_COMMAND_LIST_TYPE {}
impl ::core::clone::Clone for D3D12_COMMAND_LIST_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_COMMAND_LIST_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_COMMAND_LIST_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_COMMAND_LIST_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_COMMAND_LIST_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_COMMAND_POOL_FLAGS(pub i32);
pub const D3D12_COMMAND_POOL_FLAG_NONE: D3D12_COMMAND_POOL_FLAGS = D3D12_COMMAND_POOL_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_COMMAND_POOL_FLAGS {}
impl ::core::clone::Clone for D3D12_COMMAND_POOL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_COMMAND_POOL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_COMMAND_POOL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_COMMAND_POOL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_COMMAND_POOL_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_COMMAND_POOL_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_COMMAND_POOL_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_COMMAND_POOL_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_COMMAND_POOL_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_COMMAND_POOL_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_COMMAND_POOL_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_COMMAND_QUEUE_FLAGS(pub i32);
pub const D3D12_COMMAND_QUEUE_FLAG_NONE: D3D12_COMMAND_QUEUE_FLAGS =
    D3D12_COMMAND_QUEUE_FLAGS(0i32);
pub const D3D12_COMMAND_QUEUE_FLAG_DISABLE_GPU_TIMEOUT: D3D12_COMMAND_QUEUE_FLAGS =
    D3D12_COMMAND_QUEUE_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_COMMAND_QUEUE_FLAGS {}
impl ::core::clone::Clone for D3D12_COMMAND_QUEUE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_COMMAND_QUEUE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_COMMAND_QUEUE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_COMMAND_QUEUE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_COMMAND_QUEUE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_COMMAND_QUEUE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_COMMAND_QUEUE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_COMMAND_QUEUE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_COMMAND_QUEUE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_COMMAND_QUEUE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_COMMAND_QUEUE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_COMMAND_QUEUE_PRIORITY(pub i32);
pub const D3D12_COMMAND_QUEUE_PRIORITY_NORMAL: D3D12_COMMAND_QUEUE_PRIORITY =
    D3D12_COMMAND_QUEUE_PRIORITY(0i32);
pub const D3D12_COMMAND_QUEUE_PRIORITY_HIGH: D3D12_COMMAND_QUEUE_PRIORITY =
    D3D12_COMMAND_QUEUE_PRIORITY(100i32);
pub const D3D12_COMMAND_QUEUE_PRIORITY_GLOBAL_REALTIME: D3D12_COMMAND_QUEUE_PRIORITY =
    D3D12_COMMAND_QUEUE_PRIORITY(10000i32);
impl ::core::marker::Copy for D3D12_COMMAND_QUEUE_PRIORITY {}
impl ::core::clone::Clone for D3D12_COMMAND_QUEUE_PRIORITY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_COMMAND_QUEUE_PRIORITY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_COMMAND_QUEUE_PRIORITY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_COMMAND_QUEUE_PRIORITY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_COMMAND_QUEUE_PRIORITY")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_COMMAND_RECORDER_FLAGS(pub i32);
pub const D3D12_COMMAND_RECORDER_FLAG_NONE: D3D12_COMMAND_RECORDER_FLAGS =
    D3D12_COMMAND_RECORDER_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_COMMAND_RECORDER_FLAGS {}
impl ::core::clone::Clone for D3D12_COMMAND_RECORDER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_COMMAND_RECORDER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_COMMAND_RECORDER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_COMMAND_RECORDER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_COMMAND_RECORDER_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_COMMAND_RECORDER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_COMMAND_RECORDER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_COMMAND_RECORDER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_COMMAND_RECORDER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_COMMAND_RECORDER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_COMMAND_RECORDER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_COMPARISON_FUNC(pub i32);
pub const D3D12_COMPARISON_FUNC_NONE: D3D12_COMPARISON_FUNC = D3D12_COMPARISON_FUNC(0i32);
pub const D3D12_COMPARISON_FUNC_NEVER: D3D12_COMPARISON_FUNC = D3D12_COMPARISON_FUNC(1i32);
pub const D3D12_COMPARISON_FUNC_LESS: D3D12_COMPARISON_FUNC = D3D12_COMPARISON_FUNC(2i32);
pub const D3D12_COMPARISON_FUNC_EQUAL: D3D12_COMPARISON_FUNC = D3D12_COMPARISON_FUNC(3i32);
pub const D3D12_COMPARISON_FUNC_LESS_EQUAL: D3D12_COMPARISON_FUNC = D3D12_COMPARISON_FUNC(4i32);
pub const D3D12_COMPARISON_FUNC_GREATER: D3D12_COMPARISON_FUNC = D3D12_COMPARISON_FUNC(5i32);
pub const D3D12_COMPARISON_FUNC_NOT_EQUAL: D3D12_COMPARISON_FUNC = D3D12_COMPARISON_FUNC(6i32);
pub const D3D12_COMPARISON_FUNC_GREATER_EQUAL: D3D12_COMPARISON_FUNC = D3D12_COMPARISON_FUNC(7i32);
pub const D3D12_COMPARISON_FUNC_ALWAYS: D3D12_COMPARISON_FUNC = D3D12_COMPARISON_FUNC(8i32);
impl ::core::marker::Copy for D3D12_COMPARISON_FUNC {}
impl ::core::clone::Clone for D3D12_COMPARISON_FUNC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_COMPARISON_FUNC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_COMPARISON_FUNC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_COMPARISON_FUNC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_COMPARISON_FUNC")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_COMPATIBILITY_SHARED_FLAGS(pub i32);
pub const D3D12_COMPATIBILITY_SHARED_FLAG_NONE: D3D12_COMPATIBILITY_SHARED_FLAGS =
    D3D12_COMPATIBILITY_SHARED_FLAGS(0i32);
pub const D3D12_COMPATIBILITY_SHARED_FLAG_NON_NT_HANDLE: D3D12_COMPATIBILITY_SHARED_FLAGS =
    D3D12_COMPATIBILITY_SHARED_FLAGS(1i32);
pub const D3D12_COMPATIBILITY_SHARED_FLAG_KEYED_MUTEX: D3D12_COMPATIBILITY_SHARED_FLAGS =
    D3D12_COMPATIBILITY_SHARED_FLAGS(2i32);
pub const D3D12_COMPATIBILITY_SHARED_FLAG_9_ON_12: D3D12_COMPATIBILITY_SHARED_FLAGS =
    D3D12_COMPATIBILITY_SHARED_FLAGS(4i32);
impl ::core::marker::Copy for D3D12_COMPATIBILITY_SHARED_FLAGS {}
impl ::core::clone::Clone for D3D12_COMPATIBILITY_SHARED_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_COMPATIBILITY_SHARED_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_COMPATIBILITY_SHARED_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_COMPATIBILITY_SHARED_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_COMPATIBILITY_SHARED_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_COMPATIBILITY_SHARED_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_COMPATIBILITY_SHARED_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_COMPATIBILITY_SHARED_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_COMPATIBILITY_SHARED_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_COMPATIBILITY_SHARED_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_COMPATIBILITY_SHARED_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_CONSERVATIVE_RASTERIZATION_MODE(pub i32);
pub const D3D12_CONSERVATIVE_RASTERIZATION_MODE_OFF: D3D12_CONSERVATIVE_RASTERIZATION_MODE =
    D3D12_CONSERVATIVE_RASTERIZATION_MODE(0i32);
pub const D3D12_CONSERVATIVE_RASTERIZATION_MODE_ON: D3D12_CONSERVATIVE_RASTERIZATION_MODE =
    D3D12_CONSERVATIVE_RASTERIZATION_MODE(1i32);
impl ::core::marker::Copy for D3D12_CONSERVATIVE_RASTERIZATION_MODE {}
impl ::core::clone::Clone for D3D12_CONSERVATIVE_RASTERIZATION_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_CONSERVATIVE_RASTERIZATION_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_CONSERVATIVE_RASTERIZATION_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_CONSERVATIVE_RASTERIZATION_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_CONSERVATIVE_RASTERIZATION_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_CONSERVATIVE_RASTERIZATION_TIER(pub i32);
pub const D3D12_CONSERVATIVE_RASTERIZATION_TIER_NOT_SUPPORTED:
    D3D12_CONSERVATIVE_RASTERIZATION_TIER = D3D12_CONSERVATIVE_RASTERIZATION_TIER(0i32);
pub const D3D12_CONSERVATIVE_RASTERIZATION_TIER_1: D3D12_CONSERVATIVE_RASTERIZATION_TIER =
    D3D12_CONSERVATIVE_RASTERIZATION_TIER(1i32);
pub const D3D12_CONSERVATIVE_RASTERIZATION_TIER_2: D3D12_CONSERVATIVE_RASTERIZATION_TIER =
    D3D12_CONSERVATIVE_RASTERIZATION_TIER(2i32);
pub const D3D12_CONSERVATIVE_RASTERIZATION_TIER_3: D3D12_CONSERVATIVE_RASTERIZATION_TIER =
    D3D12_CONSERVATIVE_RASTERIZATION_TIER(3i32);
impl ::core::marker::Copy for D3D12_CONSERVATIVE_RASTERIZATION_TIER {}
impl ::core::clone::Clone for D3D12_CONSERVATIVE_RASTERIZATION_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_CONSERVATIVE_RASTERIZATION_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_CONSERVATIVE_RASTERIZATION_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_CONSERVATIVE_RASTERIZATION_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_CONSERVATIVE_RASTERIZATION_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_CPU_PAGE_PROPERTY(pub i32);
pub const D3D12_CPU_PAGE_PROPERTY_UNKNOWN: D3D12_CPU_PAGE_PROPERTY = D3D12_CPU_PAGE_PROPERTY(0i32);
pub const D3D12_CPU_PAGE_PROPERTY_NOT_AVAILABLE: D3D12_CPU_PAGE_PROPERTY =
    D3D12_CPU_PAGE_PROPERTY(1i32);
pub const D3D12_CPU_PAGE_PROPERTY_WRITE_COMBINE: D3D12_CPU_PAGE_PROPERTY =
    D3D12_CPU_PAGE_PROPERTY(2i32);
pub const D3D12_CPU_PAGE_PROPERTY_WRITE_BACK: D3D12_CPU_PAGE_PROPERTY =
    D3D12_CPU_PAGE_PROPERTY(3i32);
impl ::core::marker::Copy for D3D12_CPU_PAGE_PROPERTY {}
impl ::core::clone::Clone for D3D12_CPU_PAGE_PROPERTY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_CPU_PAGE_PROPERTY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_CPU_PAGE_PROPERTY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_CPU_PAGE_PROPERTY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_CPU_PAGE_PROPERTY")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_CROSS_NODE_SHARING_TIER(pub i32);
pub const D3D12_CROSS_NODE_SHARING_TIER_NOT_SUPPORTED: D3D12_CROSS_NODE_SHARING_TIER =
    D3D12_CROSS_NODE_SHARING_TIER(0i32);
pub const D3D12_CROSS_NODE_SHARING_TIER_1_EMULATED: D3D12_CROSS_NODE_SHARING_TIER =
    D3D12_CROSS_NODE_SHARING_TIER(1i32);
pub const D3D12_CROSS_NODE_SHARING_TIER_1: D3D12_CROSS_NODE_SHARING_TIER =
    D3D12_CROSS_NODE_SHARING_TIER(2i32);
pub const D3D12_CROSS_NODE_SHARING_TIER_2: D3D12_CROSS_NODE_SHARING_TIER =
    D3D12_CROSS_NODE_SHARING_TIER(3i32);
pub const D3D12_CROSS_NODE_SHARING_TIER_3: D3D12_CROSS_NODE_SHARING_TIER =
    D3D12_CROSS_NODE_SHARING_TIER(4i32);
impl ::core::marker::Copy for D3D12_CROSS_NODE_SHARING_TIER {}
impl ::core::clone::Clone for D3D12_CROSS_NODE_SHARING_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_CROSS_NODE_SHARING_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_CROSS_NODE_SHARING_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_CROSS_NODE_SHARING_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_CROSS_NODE_SHARING_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_CULL_MODE(pub i32);
pub const D3D12_CULL_MODE_NONE: D3D12_CULL_MODE = D3D12_CULL_MODE(1i32);
pub const D3D12_CULL_MODE_FRONT: D3D12_CULL_MODE = D3D12_CULL_MODE(2i32);
pub const D3D12_CULL_MODE_BACK: D3D12_CULL_MODE = D3D12_CULL_MODE(3i32);
impl ::core::marker::Copy for D3D12_CULL_MODE {}
impl ::core::clone::Clone for D3D12_CULL_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_CULL_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_CULL_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_CULL_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_CULL_MODE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE(pub i32);
pub const D3D12_DEBUG_COMMAND_LIST_PARAMETER_GPU_BASED_VALIDATION_SETTINGS:
    D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE = D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE(0i32);
impl ::core::marker::Copy for D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE {}
impl ::core::clone::Clone for D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DEBUG_DEVICE_PARAMETER_TYPE(pub i32);
pub const D3D12_DEBUG_DEVICE_PARAMETER_FEATURE_FLAGS: D3D12_DEBUG_DEVICE_PARAMETER_TYPE =
    D3D12_DEBUG_DEVICE_PARAMETER_TYPE(0i32);
pub const D3D12_DEBUG_DEVICE_PARAMETER_GPU_BASED_VALIDATION_SETTINGS:
    D3D12_DEBUG_DEVICE_PARAMETER_TYPE = D3D12_DEBUG_DEVICE_PARAMETER_TYPE(1i32);
pub const D3D12_DEBUG_DEVICE_PARAMETER_GPU_SLOWDOWN_PERFORMANCE_FACTOR:
    D3D12_DEBUG_DEVICE_PARAMETER_TYPE = D3D12_DEBUG_DEVICE_PARAMETER_TYPE(2i32);
impl ::core::marker::Copy for D3D12_DEBUG_DEVICE_PARAMETER_TYPE {}
impl ::core::clone::Clone for D3D12_DEBUG_DEVICE_PARAMETER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DEBUG_DEVICE_PARAMETER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DEBUG_DEVICE_PARAMETER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DEBUG_DEVICE_PARAMETER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DEBUG_DEVICE_PARAMETER_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DEBUG_FEATURE(pub i32);
pub const D3D12_DEBUG_FEATURE_NONE: D3D12_DEBUG_FEATURE = D3D12_DEBUG_FEATURE(0i32);
pub const D3D12_DEBUG_FEATURE_ALLOW_BEHAVIOR_CHANGING_DEBUG_AIDS: D3D12_DEBUG_FEATURE =
    D3D12_DEBUG_FEATURE(1i32);
pub const D3D12_DEBUG_FEATURE_CONSERVATIVE_RESOURCE_STATE_TRACKING: D3D12_DEBUG_FEATURE =
    D3D12_DEBUG_FEATURE(2i32);
pub const D3D12_DEBUG_FEATURE_DISABLE_VIRTUALIZED_BUNDLES_VALIDATION: D3D12_DEBUG_FEATURE =
    D3D12_DEBUG_FEATURE(4i32);
pub const D3D12_DEBUG_FEATURE_EMULATE_WINDOWS7: D3D12_DEBUG_FEATURE = D3D12_DEBUG_FEATURE(8i32);
impl ::core::marker::Copy for D3D12_DEBUG_FEATURE {}
impl ::core::clone::Clone for D3D12_DEBUG_FEATURE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DEBUG_FEATURE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DEBUG_FEATURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DEBUG_FEATURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DEBUG_FEATURE").field(&self.0).finish()
    }
}
impl D3D12_DEBUG_FEATURE {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_DEBUG_FEATURE {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_DEBUG_FEATURE {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_DEBUG_FEATURE {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_DEBUG_FEATURE {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_DEBUG_FEATURE {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DEPTH_WRITE_MASK(pub i32);
pub const D3D12_DEPTH_WRITE_MASK_ZERO: D3D12_DEPTH_WRITE_MASK = D3D12_DEPTH_WRITE_MASK(0i32);
pub const D3D12_DEPTH_WRITE_MASK_ALL: D3D12_DEPTH_WRITE_MASK = D3D12_DEPTH_WRITE_MASK(1i32);
impl ::core::marker::Copy for D3D12_DEPTH_WRITE_MASK {}
impl ::core::clone::Clone for D3D12_DEPTH_WRITE_MASK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DEPTH_WRITE_MASK {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DEPTH_WRITE_MASK {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DEPTH_WRITE_MASK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DEPTH_WRITE_MASK")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DESCRIPTOR_HEAP_FLAGS(pub i32);
pub const D3D12_DESCRIPTOR_HEAP_FLAG_NONE: D3D12_DESCRIPTOR_HEAP_FLAGS =
    D3D12_DESCRIPTOR_HEAP_FLAGS(0i32);
pub const D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE: D3D12_DESCRIPTOR_HEAP_FLAGS =
    D3D12_DESCRIPTOR_HEAP_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_DESCRIPTOR_HEAP_FLAGS {}
impl ::core::clone::Clone for D3D12_DESCRIPTOR_HEAP_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DESCRIPTOR_HEAP_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DESCRIPTOR_HEAP_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DESCRIPTOR_HEAP_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DESCRIPTOR_HEAP_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_DESCRIPTOR_HEAP_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_DESCRIPTOR_HEAP_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_DESCRIPTOR_HEAP_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_DESCRIPTOR_HEAP_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_DESCRIPTOR_HEAP_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_DESCRIPTOR_HEAP_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DESCRIPTOR_HEAP_TYPE(pub i32);
pub const D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV: D3D12_DESCRIPTOR_HEAP_TYPE =
    D3D12_DESCRIPTOR_HEAP_TYPE(0i32);
pub const D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER: D3D12_DESCRIPTOR_HEAP_TYPE =
    D3D12_DESCRIPTOR_HEAP_TYPE(1i32);
pub const D3D12_DESCRIPTOR_HEAP_TYPE_RTV: D3D12_DESCRIPTOR_HEAP_TYPE =
    D3D12_DESCRIPTOR_HEAP_TYPE(2i32);
pub const D3D12_DESCRIPTOR_HEAP_TYPE_DSV: D3D12_DESCRIPTOR_HEAP_TYPE =
    D3D12_DESCRIPTOR_HEAP_TYPE(3i32);
pub const D3D12_DESCRIPTOR_HEAP_TYPE_NUM_TYPES: D3D12_DESCRIPTOR_HEAP_TYPE =
    D3D12_DESCRIPTOR_HEAP_TYPE(4i32);
impl ::core::marker::Copy for D3D12_DESCRIPTOR_HEAP_TYPE {}
impl ::core::clone::Clone for D3D12_DESCRIPTOR_HEAP_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DESCRIPTOR_HEAP_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DESCRIPTOR_HEAP_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DESCRIPTOR_HEAP_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DESCRIPTOR_HEAP_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DESCRIPTOR_RANGE_FLAGS(pub i32);
pub const D3D12_DESCRIPTOR_RANGE_FLAG_NONE: D3D12_DESCRIPTOR_RANGE_FLAGS =
    D3D12_DESCRIPTOR_RANGE_FLAGS(0i32);
pub const D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_VOLATILE: D3D12_DESCRIPTOR_RANGE_FLAGS =
    D3D12_DESCRIPTOR_RANGE_FLAGS(1i32);
pub const D3D12_DESCRIPTOR_RANGE_FLAG_DATA_VOLATILE: D3D12_DESCRIPTOR_RANGE_FLAGS =
    D3D12_DESCRIPTOR_RANGE_FLAGS(2i32);
pub const D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE:
    D3D12_DESCRIPTOR_RANGE_FLAGS = D3D12_DESCRIPTOR_RANGE_FLAGS(4i32);
pub const D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC: D3D12_DESCRIPTOR_RANGE_FLAGS =
    D3D12_DESCRIPTOR_RANGE_FLAGS(8i32);
pub const D3D12_DESCRIPTOR_RANGE_FLAG_DESCRIPTORS_STATIC_KEEPING_BUFFER_BOUNDS_CHECKS:
    D3D12_DESCRIPTOR_RANGE_FLAGS = D3D12_DESCRIPTOR_RANGE_FLAGS(65536i32);
impl ::core::marker::Copy for D3D12_DESCRIPTOR_RANGE_FLAGS {}
impl ::core::clone::Clone for D3D12_DESCRIPTOR_RANGE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DESCRIPTOR_RANGE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DESCRIPTOR_RANGE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DESCRIPTOR_RANGE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DESCRIPTOR_RANGE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_DESCRIPTOR_RANGE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_DESCRIPTOR_RANGE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_DESCRIPTOR_RANGE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_DESCRIPTOR_RANGE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_DESCRIPTOR_RANGE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_DESCRIPTOR_RANGE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DESCRIPTOR_RANGE_TYPE(pub i32);
pub const D3D12_DESCRIPTOR_RANGE_TYPE_SRV: D3D12_DESCRIPTOR_RANGE_TYPE =
    D3D12_DESCRIPTOR_RANGE_TYPE(0i32);
pub const D3D12_DESCRIPTOR_RANGE_TYPE_UAV: D3D12_DESCRIPTOR_RANGE_TYPE =
    D3D12_DESCRIPTOR_RANGE_TYPE(1i32);
pub const D3D12_DESCRIPTOR_RANGE_TYPE_CBV: D3D12_DESCRIPTOR_RANGE_TYPE =
    D3D12_DESCRIPTOR_RANGE_TYPE(2i32);
pub const D3D12_DESCRIPTOR_RANGE_TYPE_SAMPLER: D3D12_DESCRIPTOR_RANGE_TYPE =
    D3D12_DESCRIPTOR_RANGE_TYPE(3i32);
impl ::core::marker::Copy for D3D12_DESCRIPTOR_RANGE_TYPE {}
impl ::core::clone::Clone for D3D12_DESCRIPTOR_RANGE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DESCRIPTOR_RANGE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DESCRIPTOR_RANGE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DESCRIPTOR_RANGE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DESCRIPTOR_RANGE_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DEVICE_FACTORY_FLAGS(pub i32);
pub const D3D12_DEVICE_FACTORY_FLAG_NONE: D3D12_DEVICE_FACTORY_FLAGS =
    D3D12_DEVICE_FACTORY_FLAGS(0i32);
pub const D3D12_DEVICE_FACTORY_FLAG_ALLOW_RETURNING_EXISTING_DEVICE: D3D12_DEVICE_FACTORY_FLAGS =
    D3D12_DEVICE_FACTORY_FLAGS(1i32);
pub const D3D12_DEVICE_FACTORY_FLAG_ALLOW_RETURNING_INCOMPATIBLE_EXISTING_DEVICE:
    D3D12_DEVICE_FACTORY_FLAGS = D3D12_DEVICE_FACTORY_FLAGS(2i32);
pub const D3D12_DEVICE_FACTORY_FLAG_DISALLOW_STORING_NEW_DEVICE_AS_SINGLETON:
    D3D12_DEVICE_FACTORY_FLAGS = D3D12_DEVICE_FACTORY_FLAGS(4i32);
impl ::core::marker::Copy for D3D12_DEVICE_FACTORY_FLAGS {}
impl ::core::clone::Clone for D3D12_DEVICE_FACTORY_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DEVICE_FACTORY_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DEVICE_FACTORY_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DEVICE_FACTORY_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DEVICE_FACTORY_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_DEVICE_FACTORY_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_DEVICE_FACTORY_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_DEVICE_FACTORY_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_DEVICE_FACTORY_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_DEVICE_FACTORY_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_DEVICE_FACTORY_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DEVICE_FLAGS(pub i32);
pub const D3D12_DEVICE_FLAG_NONE: D3D12_DEVICE_FLAGS = D3D12_DEVICE_FLAGS(0i32);
pub const D3D12_DEVICE_FLAG_DEBUG_LAYER_ENABLED: D3D12_DEVICE_FLAGS = D3D12_DEVICE_FLAGS(1i32);
pub const D3D12_DEVICE_FLAG_GPU_BASED_VALIDATION_ENABLED: D3D12_DEVICE_FLAGS =
    D3D12_DEVICE_FLAGS(2i32);
pub const D3D12_DEVICE_FLAG_SYNCHRONIZED_COMMAND_QUEUE_VALIDATION_DISABLED: D3D12_DEVICE_FLAGS =
    D3D12_DEVICE_FLAGS(4i32);
pub const D3D12_DEVICE_FLAG_DRED_AUTO_BREADCRUMBS_ENABLED: D3D12_DEVICE_FLAGS =
    D3D12_DEVICE_FLAGS(8i32);
pub const D3D12_DEVICE_FLAG_DRED_PAGE_FAULT_REPORTING_ENABLED: D3D12_DEVICE_FLAGS =
    D3D12_DEVICE_FLAGS(16i32);
pub const D3D12_DEVICE_FLAG_DRED_WATSON_REPORTING_ENABLED: D3D12_DEVICE_FLAGS =
    D3D12_DEVICE_FLAGS(32i32);
pub const D3D12_DEVICE_FLAG_DRED_BREADCRUMB_CONTEXT_ENABLED: D3D12_DEVICE_FLAGS =
    D3D12_DEVICE_FLAGS(64i32);
pub const D3D12_DEVICE_FLAG_DRED_USE_MARKERS_ONLY_BREADCRUMBS: D3D12_DEVICE_FLAGS =
    D3D12_DEVICE_FLAGS(128i32);
pub const D3D12_DEVICE_FLAG_SHADER_INSTRUMENTATION_ENABLED: D3D12_DEVICE_FLAGS =
    D3D12_DEVICE_FLAGS(256i32);
pub const D3D12_DEVICE_FLAG_AUTO_DEBUG_NAME_ENABLED: D3D12_DEVICE_FLAGS =
    D3D12_DEVICE_FLAGS(512i32);
pub const D3D12_DEVICE_FLAG_FORCE_LEGACY_STATE_VALIDATION: D3D12_DEVICE_FLAGS =
    D3D12_DEVICE_FLAGS(1024i32);
impl ::core::marker::Copy for D3D12_DEVICE_FLAGS {}
impl ::core::clone::Clone for D3D12_DEVICE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DEVICE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DEVICE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DEVICE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DEVICE_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_DEVICE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_DEVICE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_DEVICE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_DEVICE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_DEVICE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_DEVICE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DISPATCH_MODE(pub i32);
pub const D3D12_DISPATCH_MODE_NODE_CPU_INPUT: D3D12_DISPATCH_MODE = D3D12_DISPATCH_MODE(0i32);
pub const D3D12_DISPATCH_MODE_NODE_GPU_INPUT: D3D12_DISPATCH_MODE = D3D12_DISPATCH_MODE(1i32);
pub const D3D12_DISPATCH_MODE_MULTI_NODE_CPU_INPUT: D3D12_DISPATCH_MODE = D3D12_DISPATCH_MODE(2i32);
pub const D3D12_DISPATCH_MODE_MULTI_NODE_GPU_INPUT: D3D12_DISPATCH_MODE = D3D12_DISPATCH_MODE(3i32);
impl ::core::marker::Copy for D3D12_DISPATCH_MODE {}
impl ::core::clone::Clone for D3D12_DISPATCH_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DISPATCH_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DISPATCH_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DISPATCH_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DISPATCH_MODE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DRED_ALLOCATION_TYPE(pub i32);
pub const D3D12_DRED_ALLOCATION_TYPE_COMMAND_QUEUE: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(19i32);
pub const D3D12_DRED_ALLOCATION_TYPE_COMMAND_ALLOCATOR: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(20i32);
pub const D3D12_DRED_ALLOCATION_TYPE_PIPELINE_STATE: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(21i32);
pub const D3D12_DRED_ALLOCATION_TYPE_COMMAND_LIST: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(22i32);
pub const D3D12_DRED_ALLOCATION_TYPE_FENCE: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(23i32);
pub const D3D12_DRED_ALLOCATION_TYPE_DESCRIPTOR_HEAP: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(24i32);
pub const D3D12_DRED_ALLOCATION_TYPE_HEAP: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(25i32);
pub const D3D12_DRED_ALLOCATION_TYPE_QUERY_HEAP: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(27i32);
pub const D3D12_DRED_ALLOCATION_TYPE_COMMAND_SIGNATURE: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(28i32);
pub const D3D12_DRED_ALLOCATION_TYPE_PIPELINE_LIBRARY: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(29i32);
pub const D3D12_DRED_ALLOCATION_TYPE_VIDEO_DECODER: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(30i32);
pub const D3D12_DRED_ALLOCATION_TYPE_VIDEO_PROCESSOR: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(32i32);
pub const D3D12_DRED_ALLOCATION_TYPE_RESOURCE: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(34i32);
pub const D3D12_DRED_ALLOCATION_TYPE_PASS: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(35i32);
pub const D3D12_DRED_ALLOCATION_TYPE_CRYPTOSESSION: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(36i32);
pub const D3D12_DRED_ALLOCATION_TYPE_CRYPTOSESSIONPOLICY: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(37i32);
pub const D3D12_DRED_ALLOCATION_TYPE_PROTECTEDRESOURCESESSION: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(38i32);
pub const D3D12_DRED_ALLOCATION_TYPE_VIDEO_DECODER_HEAP: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(39i32);
pub const D3D12_DRED_ALLOCATION_TYPE_COMMAND_POOL: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(40i32);
pub const D3D12_DRED_ALLOCATION_TYPE_COMMAND_RECORDER: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(41i32);
pub const D3D12_DRED_ALLOCATION_TYPE_STATE_OBJECT: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(42i32);
pub const D3D12_DRED_ALLOCATION_TYPE_METACOMMAND: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(43i32);
pub const D3D12_DRED_ALLOCATION_TYPE_SCHEDULINGGROUP: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(44i32);
pub const D3D12_DRED_ALLOCATION_TYPE_VIDEO_MOTION_ESTIMATOR: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(45i32);
pub const D3D12_DRED_ALLOCATION_TYPE_VIDEO_MOTION_VECTOR_HEAP: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(46i32);
pub const D3D12_DRED_ALLOCATION_TYPE_VIDEO_EXTENSION_COMMAND: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(47i32);
pub const D3D12_DRED_ALLOCATION_TYPE_VIDEO_ENCODER: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(48i32);
pub const D3D12_DRED_ALLOCATION_TYPE_VIDEO_ENCODER_HEAP: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(49i32);
pub const D3D12_DRED_ALLOCATION_TYPE_INVALID: D3D12_DRED_ALLOCATION_TYPE =
    D3D12_DRED_ALLOCATION_TYPE(-1i32);
impl ::core::marker::Copy for D3D12_DRED_ALLOCATION_TYPE {}
impl ::core::clone::Clone for D3D12_DRED_ALLOCATION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DRED_ALLOCATION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_ALLOCATION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DRED_ALLOCATION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DRED_ALLOCATION_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DRED_DEVICE_STATE(pub i32);
pub const D3D12_DRED_DEVICE_STATE_UNKNOWN: D3D12_DRED_DEVICE_STATE = D3D12_DRED_DEVICE_STATE(0i32);
pub const D3D12_DRED_DEVICE_STATE_HUNG: D3D12_DRED_DEVICE_STATE = D3D12_DRED_DEVICE_STATE(3i32);
pub const D3D12_DRED_DEVICE_STATE_FAULT: D3D12_DRED_DEVICE_STATE = D3D12_DRED_DEVICE_STATE(6i32);
pub const D3D12_DRED_DEVICE_STATE_PAGEFAULT: D3D12_DRED_DEVICE_STATE =
    D3D12_DRED_DEVICE_STATE(7i32);
impl ::core::marker::Copy for D3D12_DRED_DEVICE_STATE {}
impl ::core::clone::Clone for D3D12_DRED_DEVICE_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DRED_DEVICE_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_DEVICE_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DRED_DEVICE_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DRED_DEVICE_STATE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DRED_ENABLEMENT(pub i32);
pub const D3D12_DRED_ENABLEMENT_SYSTEM_CONTROLLED: D3D12_DRED_ENABLEMENT =
    D3D12_DRED_ENABLEMENT(0i32);
pub const D3D12_DRED_ENABLEMENT_FORCED_OFF: D3D12_DRED_ENABLEMENT = D3D12_DRED_ENABLEMENT(1i32);
pub const D3D12_DRED_ENABLEMENT_FORCED_ON: D3D12_DRED_ENABLEMENT = D3D12_DRED_ENABLEMENT(2i32);
impl ::core::marker::Copy for D3D12_DRED_ENABLEMENT {}
impl ::core::clone::Clone for D3D12_DRED_ENABLEMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DRED_ENABLEMENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_ENABLEMENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DRED_ENABLEMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DRED_ENABLEMENT")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DRED_FLAGS(pub i32);
pub const D3D12_DRED_FLAG_NONE: D3D12_DRED_FLAGS = D3D12_DRED_FLAGS(0i32);
pub const D3D12_DRED_FLAG_FORCE_ENABLE: D3D12_DRED_FLAGS = D3D12_DRED_FLAGS(1i32);
pub const D3D12_DRED_FLAG_DISABLE_AUTOBREADCRUMBS: D3D12_DRED_FLAGS = D3D12_DRED_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_DRED_FLAGS {}
impl ::core::clone::Clone for D3D12_DRED_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DRED_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DRED_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DRED_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_DRED_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_DRED_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_DRED_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_DRED_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_DRED_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_DRED_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DRED_PAGE_FAULT_FLAGS(pub i32);
pub const D3D12_DRED_PAGE_FAULT_FLAGS_NONE: D3D12_DRED_PAGE_FAULT_FLAGS =
    D3D12_DRED_PAGE_FAULT_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_DRED_PAGE_FAULT_FLAGS {}
impl ::core::clone::Clone for D3D12_DRED_PAGE_FAULT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DRED_PAGE_FAULT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_PAGE_FAULT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DRED_PAGE_FAULT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DRED_PAGE_FAULT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_DRED_PAGE_FAULT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_DRED_PAGE_FAULT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_DRED_PAGE_FAULT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_DRED_PAGE_FAULT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_DRED_PAGE_FAULT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_DRED_PAGE_FAULT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DRED_VERSION(pub i32);
pub const D3D12_DRED_VERSION_1_0: D3D12_DRED_VERSION = D3D12_DRED_VERSION(1i32);
pub const D3D12_DRED_VERSION_1_1: D3D12_DRED_VERSION = D3D12_DRED_VERSION(2i32);
pub const D3D12_DRED_VERSION_1_2: D3D12_DRED_VERSION = D3D12_DRED_VERSION(3i32);
pub const D3D12_DRED_VERSION_1_3: D3D12_DRED_VERSION = D3D12_DRED_VERSION(4i32);
impl ::core::marker::Copy for D3D12_DRED_VERSION {}
impl ::core::clone::Clone for D3D12_DRED_VERSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DRED_VERSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_VERSION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DRED_VERSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DRED_VERSION").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS(pub i32);
pub const D3D12_DRIVER_MATCHING_IDENTIFIER_COMPATIBLE_WITH_DEVICE:
    D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS = D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS(0i32);
pub const D3D12_DRIVER_MATCHING_IDENTIFIER_UNSUPPORTED_TYPE:
    D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS = D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS(1i32);
pub const D3D12_DRIVER_MATCHING_IDENTIFIER_UNRECOGNIZED: D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS =
    D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS(2i32);
pub const D3D12_DRIVER_MATCHING_IDENTIFIER_INCOMPATIBLE_VERSION:
    D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS = D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS(3i32);
pub const D3D12_DRIVER_MATCHING_IDENTIFIER_INCOMPATIBLE_TYPE:
    D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS = D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS(4i32);
impl ::core::marker::Copy for D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {}
impl ::core::clone::Clone for D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DSV_DIMENSION(pub i32);
pub const D3D12_DSV_DIMENSION_UNKNOWN: D3D12_DSV_DIMENSION = D3D12_DSV_DIMENSION(0i32);
pub const D3D12_DSV_DIMENSION_TEXTURE1D: D3D12_DSV_DIMENSION = D3D12_DSV_DIMENSION(1i32);
pub const D3D12_DSV_DIMENSION_TEXTURE1DARRAY: D3D12_DSV_DIMENSION = D3D12_DSV_DIMENSION(2i32);
pub const D3D12_DSV_DIMENSION_TEXTURE2D: D3D12_DSV_DIMENSION = D3D12_DSV_DIMENSION(3i32);
pub const D3D12_DSV_DIMENSION_TEXTURE2DARRAY: D3D12_DSV_DIMENSION = D3D12_DSV_DIMENSION(4i32);
pub const D3D12_DSV_DIMENSION_TEXTURE2DMS: D3D12_DSV_DIMENSION = D3D12_DSV_DIMENSION(5i32);
pub const D3D12_DSV_DIMENSION_TEXTURE2DMSARRAY: D3D12_DSV_DIMENSION = D3D12_DSV_DIMENSION(6i32);
impl ::core::marker::Copy for D3D12_DSV_DIMENSION {}
impl ::core::clone::Clone for D3D12_DSV_DIMENSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DSV_DIMENSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DSV_DIMENSION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DSV_DIMENSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DSV_DIMENSION").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_DSV_FLAGS(pub i32);
pub const D3D12_DSV_FLAG_NONE: D3D12_DSV_FLAGS = D3D12_DSV_FLAGS(0i32);
pub const D3D12_DSV_FLAG_READ_ONLY_DEPTH: D3D12_DSV_FLAGS = D3D12_DSV_FLAGS(1i32);
pub const D3D12_DSV_FLAG_READ_ONLY_STENCIL: D3D12_DSV_FLAGS = D3D12_DSV_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_DSV_FLAGS {}
impl ::core::clone::Clone for D3D12_DSV_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_DSV_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_DSV_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_DSV_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_DSV_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_DSV_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_DSV_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_DSV_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_DSV_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_DSV_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_DSV_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_ELEMENTS_LAYOUT(pub i32);
pub const D3D12_ELEMENTS_LAYOUT_ARRAY: D3D12_ELEMENTS_LAYOUT = D3D12_ELEMENTS_LAYOUT(0i32);
pub const D3D12_ELEMENTS_LAYOUT_ARRAY_OF_POINTERS: D3D12_ELEMENTS_LAYOUT =
    D3D12_ELEMENTS_LAYOUT(1i32);
impl ::core::marker::Copy for D3D12_ELEMENTS_LAYOUT {}
impl ::core::clone::Clone for D3D12_ELEMENTS_LAYOUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_ELEMENTS_LAYOUT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_ELEMENTS_LAYOUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_ELEMENTS_LAYOUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_ELEMENTS_LAYOUT")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_EXPORT_FLAGS(pub i32);
pub const D3D12_EXPORT_FLAG_NONE: D3D12_EXPORT_FLAGS = D3D12_EXPORT_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_EXPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_EXPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_EXPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_EXPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_EXPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_EXPORT_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_EXPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_EXPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_EXPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_EXPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_EXPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_EXPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_FEATURE(pub i32);
pub const D3D12_FEATURE_D3D12_OPTIONS: D3D12_FEATURE = D3D12_FEATURE(0i32);
pub const D3D12_FEATURE_ARCHITECTURE: D3D12_FEATURE = D3D12_FEATURE(1i32);
pub const D3D12_FEATURE_FEATURE_LEVELS: D3D12_FEATURE = D3D12_FEATURE(2i32);
pub const D3D12_FEATURE_FORMAT_SUPPORT: D3D12_FEATURE = D3D12_FEATURE(3i32);
pub const D3D12_FEATURE_MULTISAMPLE_QUALITY_LEVELS: D3D12_FEATURE = D3D12_FEATURE(4i32);
pub const D3D12_FEATURE_FORMAT_INFO: D3D12_FEATURE = D3D12_FEATURE(5i32);
pub const D3D12_FEATURE_GPU_VIRTUAL_ADDRESS_SUPPORT: D3D12_FEATURE = D3D12_FEATURE(6i32);
pub const D3D12_FEATURE_SHADER_MODEL: D3D12_FEATURE = D3D12_FEATURE(7i32);
pub const D3D12_FEATURE_D3D12_OPTIONS1: D3D12_FEATURE = D3D12_FEATURE(8i32);
pub const D3D12_FEATURE_D3D12_OPTIONS_EXPERIMENTAL: D3D12_FEATURE = D3D12_FEATURE(9i32);
pub const D3D12_FEATURE_PROTECTED_RESOURCE_SESSION_SUPPORT: D3D12_FEATURE = D3D12_FEATURE(10i32);
pub const D3D12_FEATURE_ROOT_SIGNATURE: D3D12_FEATURE = D3D12_FEATURE(12i32);
pub const D3D12_FEATURE_ARCHITECTURE1: D3D12_FEATURE = D3D12_FEATURE(16i32);
pub const D3D12_FEATURE_D3D12_OPTIONS2: D3D12_FEATURE = D3D12_FEATURE(18i32);
pub const D3D12_FEATURE_SHADER_CACHE: D3D12_FEATURE = D3D12_FEATURE(19i32);
pub const D3D12_FEATURE_COMMAND_QUEUE_PRIORITY: D3D12_FEATURE = D3D12_FEATURE(20i32);
pub const D3D12_FEATURE_D3D12_OPTIONS3: D3D12_FEATURE = D3D12_FEATURE(21i32);
pub const D3D12_FEATURE_EXISTING_HEAPS: D3D12_FEATURE = D3D12_FEATURE(22i32);
pub const D3D12_FEATURE_D3D12_OPTIONS4: D3D12_FEATURE = D3D12_FEATURE(23i32);
pub const D3D12_FEATURE_SERIALIZATION: D3D12_FEATURE = D3D12_FEATURE(24i32);
pub const D3D12_FEATURE_CROSS_NODE: D3D12_FEATURE = D3D12_FEATURE(25i32);
pub const D3D12_FEATURE_D3D12_OPTIONS5: D3D12_FEATURE = D3D12_FEATURE(27i32);
pub const D3D12_FEATURE_DISPLAYABLE: D3D12_FEATURE = D3D12_FEATURE(28i32);
pub const D3D12_FEATURE_D3D12_OPTIONS6: D3D12_FEATURE = D3D12_FEATURE(30i32);
pub const D3D12_FEATURE_QUERY_META_COMMAND: D3D12_FEATURE = D3D12_FEATURE(31i32);
pub const D3D12_FEATURE_D3D12_OPTIONS7: D3D12_FEATURE = D3D12_FEATURE(32i32);
pub const D3D12_FEATURE_PROTECTED_RESOURCE_SESSION_TYPE_COUNT: D3D12_FEATURE = D3D12_FEATURE(33i32);
pub const D3D12_FEATURE_PROTECTED_RESOURCE_SESSION_TYPES: D3D12_FEATURE = D3D12_FEATURE(34i32);
pub const D3D12_FEATURE_D3D12_OPTIONS8: D3D12_FEATURE = D3D12_FEATURE(36i32);
pub const D3D12_FEATURE_D3D12_OPTIONS9: D3D12_FEATURE = D3D12_FEATURE(37i32);
pub const D3D12_FEATURE_WAVE_MMA: D3D12_FEATURE = D3D12_FEATURE(38i32);
pub const D3D12_FEATURE_D3D12_OPTIONS10: D3D12_FEATURE = D3D12_FEATURE(39i32);
pub const D3D12_FEATURE_D3D12_OPTIONS11: D3D12_FEATURE = D3D12_FEATURE(40i32);
pub const D3D12_FEATURE_D3D12_OPTIONS12: D3D12_FEATURE = D3D12_FEATURE(41i32);
pub const D3D12_FEATURE_D3D12_OPTIONS13: D3D12_FEATURE = D3D12_FEATURE(42i32);
pub const D3D12_FEATURE_D3D12_OPTIONS14: D3D12_FEATURE = D3D12_FEATURE(43i32);
pub const D3D12_FEATURE_D3D12_OPTIONS15: D3D12_FEATURE = D3D12_FEATURE(44i32);
pub const D3D12_FEATURE_D3D12_OPTIONS16: D3D12_FEATURE = D3D12_FEATURE(45i32);
pub const D3D12_FEATURE_D3D12_OPTIONS17: D3D12_FEATURE = D3D12_FEATURE(46i32);
pub const D3D12_FEATURE_D3D12_OPTIONS18: D3D12_FEATURE = D3D12_FEATURE(47i32);
pub const D3D12_FEATURE_D3D12_OPTIONS19: D3D12_FEATURE = D3D12_FEATURE(48i32);
pub const D3D12_FEATURE_D3D12_OPTIONS20: D3D12_FEATURE = D3D12_FEATURE(49i32);
impl ::core::marker::Copy for D3D12_FEATURE {}
impl ::core::clone::Clone for D3D12_FEATURE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_FEATURE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_FEATURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_FEATURE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_FEATURE_VIDEO(pub i32);
pub const D3D12_FEATURE_VIDEO_DECODE_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(0i32);
pub const D3D12_FEATURE_VIDEO_DECODE_PROFILES: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(1i32);
pub const D3D12_FEATURE_VIDEO_DECODE_FORMATS: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(2i32);
pub const D3D12_FEATURE_VIDEO_DECODE_CONVERSION_SUPPORT: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(3i32);
pub const D3D12_FEATURE_VIDEO_PROCESS_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(5i32);
pub const D3D12_FEATURE_VIDEO_PROCESS_MAX_INPUT_STREAMS: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(6i32);
pub const D3D12_FEATURE_VIDEO_PROCESS_REFERENCE_INFO: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(7i32);
pub const D3D12_FEATURE_VIDEO_DECODER_HEAP_SIZE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(8i32);
pub const D3D12_FEATURE_VIDEO_PROCESSOR_SIZE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(9i32);
pub const D3D12_FEATURE_VIDEO_DECODE_PROFILE_COUNT: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(10i32);
pub const D3D12_FEATURE_VIDEO_DECODE_FORMAT_COUNT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(11i32);
pub const D3D12_FEATURE_VIDEO_ARCHITECTURE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(17i32);
pub const D3D12_FEATURE_VIDEO_DECODE_HISTOGRAM: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(18i32);
pub const D3D12_FEATURE_VIDEO_FEATURE_AREA_SUPPORT: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(19i32);
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(20i32);
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_SIZE: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(21i32);
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_COUNT: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(22i32);
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMANDS: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(23i32);
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(24i32);
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_PARAMETERS: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(25i32);
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SUPPORT: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(26i32);
pub const D3D12_FEATURE_VIDEO_EXTENSION_COMMAND_SIZE: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(27i32);
pub const D3D12_FEATURE_VIDEO_DECODE_PROTECTED_RESOURCES: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(28i32);
pub const D3D12_FEATURE_VIDEO_PROCESS_PROTECTED_RESOURCES: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(29i32);
pub const D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(30i32);
pub const D3D12_FEATURE_VIDEO_DECODER_HEAP_SIZE1: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(31i32);
pub const D3D12_FEATURE_VIDEO_PROCESSOR_SIZE1: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(32i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_CODEC: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(33i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_PROFILE_LEVEL: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(34i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(35i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_OUTPUT_RESOLUTION: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(36i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_INPUT_FORMAT: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(37i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_RATE_CONTROL_MODE: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(38i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_INTRA_REFRESH_MODE: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(39i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(40i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_HEAP_SIZE: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(41i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(42i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_SUPPORT: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(43i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(44i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_RESOURCE_REQUIREMENTS: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(45i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG: D3D12_FEATURE_VIDEO =
    D3D12_FEATURE_VIDEO(46i32);
pub const D3D12_FEATURE_VIDEO_ENCODER_SUPPORT1: D3D12_FEATURE_VIDEO = D3D12_FEATURE_VIDEO(47i32);
impl ::core::marker::Copy for D3D12_FEATURE_VIDEO {}
impl ::core::clone::Clone for D3D12_FEATURE_VIDEO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_FEATURE_VIDEO {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_VIDEO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_FEATURE_VIDEO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_FEATURE_VIDEO").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_FENCE_FLAGS(pub i32);
pub const D3D12_FENCE_FLAG_NONE: D3D12_FENCE_FLAGS = D3D12_FENCE_FLAGS(0i32);
pub const D3D12_FENCE_FLAG_SHARED: D3D12_FENCE_FLAGS = D3D12_FENCE_FLAGS(1i32);
pub const D3D12_FENCE_FLAG_SHARED_CROSS_ADAPTER: D3D12_FENCE_FLAGS = D3D12_FENCE_FLAGS(2i32);
pub const D3D12_FENCE_FLAG_NON_MONITORED: D3D12_FENCE_FLAGS = D3D12_FENCE_FLAGS(4i32);
impl ::core::marker::Copy for D3D12_FENCE_FLAGS {}
impl ::core::clone::Clone for D3D12_FENCE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_FENCE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_FENCE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_FENCE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_FENCE_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_FENCE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_FENCE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_FENCE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_FENCE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_FENCE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_FENCE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_FILL_MODE(pub i32);
pub const D3D12_FILL_MODE_WIREFRAME: D3D12_FILL_MODE = D3D12_FILL_MODE(2i32);
pub const D3D12_FILL_MODE_SOLID: D3D12_FILL_MODE = D3D12_FILL_MODE(3i32);
impl ::core::marker::Copy for D3D12_FILL_MODE {}
impl ::core::clone::Clone for D3D12_FILL_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_FILL_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_FILL_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_FILL_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_FILL_MODE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_FILTER(pub i32);
pub const D3D12_FILTER_MIN_MAG_MIP_POINT: D3D12_FILTER = D3D12_FILTER(0i32);
pub const D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(1i32);
pub const D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT: D3D12_FILTER = D3D12_FILTER(4i32);
pub const D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(5i32);
pub const D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT: D3D12_FILTER = D3D12_FILTER(16i32);
pub const D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(17i32);
pub const D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT: D3D12_FILTER = D3D12_FILTER(20i32);
pub const D3D12_FILTER_MIN_MAG_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(21i32);
pub const D3D12_FILTER_MIN_MAG_ANISOTROPIC_MIP_POINT: D3D12_FILTER = D3D12_FILTER(84i32);
pub const D3D12_FILTER_ANISOTROPIC: D3D12_FILTER = D3D12_FILTER(85i32);
pub const D3D12_FILTER_COMPARISON_MIN_MAG_MIP_POINT: D3D12_FILTER = D3D12_FILTER(128i32);
pub const D3D12_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(129i32);
pub const D3D12_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT: D3D12_FILTER =
    D3D12_FILTER(132i32);
pub const D3D12_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(133i32);
pub const D3D12_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT: D3D12_FILTER = D3D12_FILTER(144i32);
pub const D3D12_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR: D3D12_FILTER =
    D3D12_FILTER(145i32);
pub const D3D12_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT: D3D12_FILTER = D3D12_FILTER(148i32);
pub const D3D12_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(149i32);
pub const D3D12_FILTER_COMPARISON_MIN_MAG_ANISOTROPIC_MIP_POINT: D3D12_FILTER =
    D3D12_FILTER(212i32);
pub const D3D12_FILTER_COMPARISON_ANISOTROPIC: D3D12_FILTER = D3D12_FILTER(213i32);
pub const D3D12_FILTER_MINIMUM_MIN_MAG_MIP_POINT: D3D12_FILTER = D3D12_FILTER(256i32);
pub const D3D12_FILTER_MINIMUM_MIN_MAG_POINT_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(257i32);
pub const D3D12_FILTER_MINIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT: D3D12_FILTER = D3D12_FILTER(260i32);
pub const D3D12_FILTER_MINIMUM_MIN_POINT_MAG_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(261i32);
pub const D3D12_FILTER_MINIMUM_MIN_LINEAR_MAG_MIP_POINT: D3D12_FILTER = D3D12_FILTER(272i32);
pub const D3D12_FILTER_MINIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(273i32);
pub const D3D12_FILTER_MINIMUM_MIN_MAG_LINEAR_MIP_POINT: D3D12_FILTER = D3D12_FILTER(276i32);
pub const D3D12_FILTER_MINIMUM_MIN_MAG_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(277i32);
pub const D3D12_FILTER_MINIMUM_MIN_MAG_ANISOTROPIC_MIP_POINT: D3D12_FILTER = D3D12_FILTER(340i32);
pub const D3D12_FILTER_MINIMUM_ANISOTROPIC: D3D12_FILTER = D3D12_FILTER(341i32);
pub const D3D12_FILTER_MAXIMUM_MIN_MAG_MIP_POINT: D3D12_FILTER = D3D12_FILTER(384i32);
pub const D3D12_FILTER_MAXIMUM_MIN_MAG_POINT_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(385i32);
pub const D3D12_FILTER_MAXIMUM_MIN_POINT_MAG_LINEAR_MIP_POINT: D3D12_FILTER = D3D12_FILTER(388i32);
pub const D3D12_FILTER_MAXIMUM_MIN_POINT_MAG_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(389i32);
pub const D3D12_FILTER_MAXIMUM_MIN_LINEAR_MAG_MIP_POINT: D3D12_FILTER = D3D12_FILTER(400i32);
pub const D3D12_FILTER_MAXIMUM_MIN_LINEAR_MAG_POINT_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(401i32);
pub const D3D12_FILTER_MAXIMUM_MIN_MAG_LINEAR_MIP_POINT: D3D12_FILTER = D3D12_FILTER(404i32);
pub const D3D12_FILTER_MAXIMUM_MIN_MAG_MIP_LINEAR: D3D12_FILTER = D3D12_FILTER(405i32);
pub const D3D12_FILTER_MAXIMUM_MIN_MAG_ANISOTROPIC_MIP_POINT: D3D12_FILTER = D3D12_FILTER(468i32);
pub const D3D12_FILTER_MAXIMUM_ANISOTROPIC: D3D12_FILTER = D3D12_FILTER(469i32);
impl ::core::marker::Copy for D3D12_FILTER {}
impl ::core::clone::Clone for D3D12_FILTER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_FILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_FILTER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_FILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_FILTER").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_FILTER_REDUCTION_TYPE(pub i32);
pub const D3D12_FILTER_REDUCTION_TYPE_STANDARD: D3D12_FILTER_REDUCTION_TYPE =
    D3D12_FILTER_REDUCTION_TYPE(0i32);
pub const D3D12_FILTER_REDUCTION_TYPE_COMPARISON: D3D12_FILTER_REDUCTION_TYPE =
    D3D12_FILTER_REDUCTION_TYPE(1i32);
pub const D3D12_FILTER_REDUCTION_TYPE_MINIMUM: D3D12_FILTER_REDUCTION_TYPE =
    D3D12_FILTER_REDUCTION_TYPE(2i32);
pub const D3D12_FILTER_REDUCTION_TYPE_MAXIMUM: D3D12_FILTER_REDUCTION_TYPE =
    D3D12_FILTER_REDUCTION_TYPE(3i32);
impl ::core::marker::Copy for D3D12_FILTER_REDUCTION_TYPE {}
impl ::core::clone::Clone for D3D12_FILTER_REDUCTION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_FILTER_REDUCTION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_FILTER_REDUCTION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_FILTER_REDUCTION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_FILTER_REDUCTION_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_FILTER_TYPE(pub i32);
pub const D3D12_FILTER_TYPE_POINT: D3D12_FILTER_TYPE = D3D12_FILTER_TYPE(0i32);
pub const D3D12_FILTER_TYPE_LINEAR: D3D12_FILTER_TYPE = D3D12_FILTER_TYPE(1i32);
impl ::core::marker::Copy for D3D12_FILTER_TYPE {}
impl ::core::clone::Clone for D3D12_FILTER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_FILTER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_FILTER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_FILTER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_FILTER_TYPE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_FORMAT_SUPPORT1(pub i32);
pub const D3D12_FORMAT_SUPPORT1_NONE: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(0i32);
pub const D3D12_FORMAT_SUPPORT1_BUFFER: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(1i32);
pub const D3D12_FORMAT_SUPPORT1_IA_VERTEX_BUFFER: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(2i32);
pub const D3D12_FORMAT_SUPPORT1_IA_INDEX_BUFFER: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(4i32);
pub const D3D12_FORMAT_SUPPORT1_SO_BUFFER: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(8i32);
pub const D3D12_FORMAT_SUPPORT1_TEXTURE1D: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(16i32);
pub const D3D12_FORMAT_SUPPORT1_TEXTURE2D: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(32i32);
pub const D3D12_FORMAT_SUPPORT1_TEXTURE3D: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(64i32);
pub const D3D12_FORMAT_SUPPORT1_TEXTURECUBE: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(128i32);
pub const D3D12_FORMAT_SUPPORT1_SHADER_LOAD: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(256i32);
pub const D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(512i32);
pub const D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE_COMPARISON: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(1024i32);
pub const D3D12_FORMAT_SUPPORT1_SHADER_SAMPLE_MONO_TEXT: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(2048i32);
pub const D3D12_FORMAT_SUPPORT1_MIP: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(4096i32);
pub const D3D12_FORMAT_SUPPORT1_RENDER_TARGET: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(16384i32);
pub const D3D12_FORMAT_SUPPORT1_BLENDABLE: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(32768i32);
pub const D3D12_FORMAT_SUPPORT1_DEPTH_STENCIL: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(65536i32);
pub const D3D12_FORMAT_SUPPORT1_MULTISAMPLE_RESOLVE: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(262144i32);
pub const D3D12_FORMAT_SUPPORT1_DISPLAY: D3D12_FORMAT_SUPPORT1 = D3D12_FORMAT_SUPPORT1(524288i32);
pub const D3D12_FORMAT_SUPPORT1_CAST_WITHIN_BIT_LAYOUT: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(1048576i32);
pub const D3D12_FORMAT_SUPPORT1_MULTISAMPLE_RENDERTARGET: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(2097152i32);
pub const D3D12_FORMAT_SUPPORT1_MULTISAMPLE_LOAD: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(4194304i32);
pub const D3D12_FORMAT_SUPPORT1_SHADER_GATHER: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(8388608i32);
pub const D3D12_FORMAT_SUPPORT1_BACK_BUFFER_CAST: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(16777216i32);
pub const D3D12_FORMAT_SUPPORT1_TYPED_UNORDERED_ACCESS_VIEW: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(33554432i32);
pub const D3D12_FORMAT_SUPPORT1_SHADER_GATHER_COMPARISON: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(67108864i32);
pub const D3D12_FORMAT_SUPPORT1_DECODER_OUTPUT: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(134217728i32);
pub const D3D12_FORMAT_SUPPORT1_VIDEO_PROCESSOR_OUTPUT: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(268435456i32);
pub const D3D12_FORMAT_SUPPORT1_VIDEO_PROCESSOR_INPUT: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(536870912i32);
pub const D3D12_FORMAT_SUPPORT1_VIDEO_ENCODER: D3D12_FORMAT_SUPPORT1 =
    D3D12_FORMAT_SUPPORT1(1073741824i32);
impl ::core::marker::Copy for D3D12_FORMAT_SUPPORT1 {}
impl ::core::clone::Clone for D3D12_FORMAT_SUPPORT1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_FORMAT_SUPPORT1 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_FORMAT_SUPPORT1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_FORMAT_SUPPORT1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_FORMAT_SUPPORT1")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_FORMAT_SUPPORT1 {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_FORMAT_SUPPORT1 {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_FORMAT_SUPPORT1 {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_FORMAT_SUPPORT1 {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_FORMAT_SUPPORT1 {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_FORMAT_SUPPORT1 {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_FORMAT_SUPPORT2(pub i32);
pub const D3D12_FORMAT_SUPPORT2_NONE: D3D12_FORMAT_SUPPORT2 = D3D12_FORMAT_SUPPORT2(0i32);
pub const D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_ADD: D3D12_FORMAT_SUPPORT2 = D3D12_FORMAT_SUPPORT2(1i32);
pub const D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_BITWISE_OPS: D3D12_FORMAT_SUPPORT2 =
    D3D12_FORMAT_SUPPORT2(2i32);
pub const D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_COMPARE_STORE_OR_COMPARE_EXCHANGE:
    D3D12_FORMAT_SUPPORT2 = D3D12_FORMAT_SUPPORT2(4i32);
pub const D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_EXCHANGE: D3D12_FORMAT_SUPPORT2 =
    D3D12_FORMAT_SUPPORT2(8i32);
pub const D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_SIGNED_MIN_OR_MAX: D3D12_FORMAT_SUPPORT2 =
    D3D12_FORMAT_SUPPORT2(16i32);
pub const D3D12_FORMAT_SUPPORT2_UAV_ATOMIC_UNSIGNED_MIN_OR_MAX: D3D12_FORMAT_SUPPORT2 =
    D3D12_FORMAT_SUPPORT2(32i32);
pub const D3D12_FORMAT_SUPPORT2_UAV_TYPED_LOAD: D3D12_FORMAT_SUPPORT2 =
    D3D12_FORMAT_SUPPORT2(64i32);
pub const D3D12_FORMAT_SUPPORT2_UAV_TYPED_STORE: D3D12_FORMAT_SUPPORT2 =
    D3D12_FORMAT_SUPPORT2(128i32);
pub const D3D12_FORMAT_SUPPORT2_OUTPUT_MERGER_LOGIC_OP: D3D12_FORMAT_SUPPORT2 =
    D3D12_FORMAT_SUPPORT2(256i32);
pub const D3D12_FORMAT_SUPPORT2_TILED: D3D12_FORMAT_SUPPORT2 = D3D12_FORMAT_SUPPORT2(512i32);
pub const D3D12_FORMAT_SUPPORT2_MULTIPLANE_OVERLAY: D3D12_FORMAT_SUPPORT2 =
    D3D12_FORMAT_SUPPORT2(16384i32);
pub const D3D12_FORMAT_SUPPORT2_SAMPLER_FEEDBACK: D3D12_FORMAT_SUPPORT2 =
    D3D12_FORMAT_SUPPORT2(32768i32);
impl ::core::marker::Copy for D3D12_FORMAT_SUPPORT2 {}
impl ::core::clone::Clone for D3D12_FORMAT_SUPPORT2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_FORMAT_SUPPORT2 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_FORMAT_SUPPORT2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_FORMAT_SUPPORT2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_FORMAT_SUPPORT2")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_FORMAT_SUPPORT2 {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_FORMAT_SUPPORT2 {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_FORMAT_SUPPORT2 {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_FORMAT_SUPPORT2 {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_FORMAT_SUPPORT2 {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_FORMAT_SUPPORT2 {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_GPU_BASED_VALIDATION_FLAGS(pub i32);
pub const D3D12_GPU_BASED_VALIDATION_FLAGS_NONE: D3D12_GPU_BASED_VALIDATION_FLAGS =
    D3D12_GPU_BASED_VALIDATION_FLAGS(0i32);
pub const D3D12_GPU_BASED_VALIDATION_FLAGS_DISABLE_STATE_TRACKING:
    D3D12_GPU_BASED_VALIDATION_FLAGS = D3D12_GPU_BASED_VALIDATION_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_GPU_BASED_VALIDATION_FLAGS {}
impl ::core::clone::Clone for D3D12_GPU_BASED_VALIDATION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_GPU_BASED_VALIDATION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_GPU_BASED_VALIDATION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_GPU_BASED_VALIDATION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_GPU_BASED_VALIDATION_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_GPU_BASED_VALIDATION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_GPU_BASED_VALIDATION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_GPU_BASED_VALIDATION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_GPU_BASED_VALIDATION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_GPU_BASED_VALIDATION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_GPU_BASED_VALIDATION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS(pub i32);
pub const D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAG_NONE:
    D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS =
    D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS(0i32);
pub const D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAG_FRONT_LOAD_CREATE_TRACKING_ONLY_SHADERS : D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS = D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS ( 1i32 ) ;
pub const D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAG_FRONT_LOAD_CREATE_UNGUARDED_VALIDATION_SHADERS : D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS = D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS ( 2i32 ) ;
pub const D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAG_FRONT_LOAD_CREATE_GUARDED_VALIDATION_SHADERS : D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS = D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS ( 4i32 ) ;
pub const D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS_VALID_MASK:
    D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS =
    D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS(7i32);
impl ::core::marker::Copy for D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {}
impl ::core::clone::Clone for D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE(pub i32);
pub const D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_NONE:
    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE =
    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE(0i32);
pub const D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_STATE_TRACKING_ONLY:
    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE =
    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE(1i32);
pub const D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_UNGUARDED_VALIDATION:
    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE =
    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE(2i32);
pub const D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE_GUARDED_VALIDATION:
    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE =
    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE(3i32);
pub const NUM_D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODES:
    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE =
    D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE(4i32);
impl ::core::marker::Copy for D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE {}
impl ::core::clone::Clone for D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_GRAPHICS_STATES(pub i32);
pub const D3D12_GRAPHICS_STATE_NONE: D3D12_GRAPHICS_STATES = D3D12_GRAPHICS_STATES(0i32);
pub const D3D12_GRAPHICS_STATE_IA_VERTEX_BUFFERS: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(1i32);
pub const D3D12_GRAPHICS_STATE_IA_INDEX_BUFFER: D3D12_GRAPHICS_STATES = D3D12_GRAPHICS_STATES(2i32);
pub const D3D12_GRAPHICS_STATE_IA_PRIMITIVE_TOPOLOGY: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(4i32);
pub const D3D12_GRAPHICS_STATE_DESCRIPTOR_HEAP: D3D12_GRAPHICS_STATES = D3D12_GRAPHICS_STATES(8i32);
pub const D3D12_GRAPHICS_STATE_GRAPHICS_ROOT_SIGNATURE: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(16i32);
pub const D3D12_GRAPHICS_STATE_COMPUTE_ROOT_SIGNATURE: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(32i32);
pub const D3D12_GRAPHICS_STATE_RS_VIEWPORTS: D3D12_GRAPHICS_STATES = D3D12_GRAPHICS_STATES(64i32);
pub const D3D12_GRAPHICS_STATE_RS_SCISSOR_RECTS: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(128i32);
pub const D3D12_GRAPHICS_STATE_PREDICATION: D3D12_GRAPHICS_STATES = D3D12_GRAPHICS_STATES(256i32);
pub const D3D12_GRAPHICS_STATE_OM_RENDER_TARGETS: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(512i32);
pub const D3D12_GRAPHICS_STATE_OM_STENCIL_REF: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(1024i32);
pub const D3D12_GRAPHICS_STATE_OM_BLEND_FACTOR: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(2048i32);
pub const D3D12_GRAPHICS_STATE_PIPELINE_STATE: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(4096i32);
pub const D3D12_GRAPHICS_STATE_SO_TARGETS: D3D12_GRAPHICS_STATES = D3D12_GRAPHICS_STATES(8192i32);
pub const D3D12_GRAPHICS_STATE_OM_DEPTH_BOUNDS: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(16384i32);
pub const D3D12_GRAPHICS_STATE_SAMPLE_POSITIONS: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(32768i32);
pub const D3D12_GRAPHICS_STATE_VIEW_INSTANCE_MASK: D3D12_GRAPHICS_STATES =
    D3D12_GRAPHICS_STATES(65536i32);
impl ::core::marker::Copy for D3D12_GRAPHICS_STATES {}
impl ::core::clone::Clone for D3D12_GRAPHICS_STATES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_GRAPHICS_STATES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_GRAPHICS_STATES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_GRAPHICS_STATES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_GRAPHICS_STATES")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_GRAPHICS_STATES {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_GRAPHICS_STATES {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_GRAPHICS_STATES {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_GRAPHICS_STATES {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_GRAPHICS_STATES {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_GRAPHICS_STATES {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_HEAP_FLAGS(pub i32);
pub const D3D12_HEAP_FLAG_NONE: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(0i32);
pub const D3D12_HEAP_FLAG_SHARED: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(1i32);
pub const D3D12_HEAP_FLAG_DENY_BUFFERS: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(4i32);
pub const D3D12_HEAP_FLAG_ALLOW_DISPLAY: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(8i32);
pub const D3D12_HEAP_FLAG_SHARED_CROSS_ADAPTER: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(32i32);
pub const D3D12_HEAP_FLAG_DENY_RT_DS_TEXTURES: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(64i32);
pub const D3D12_HEAP_FLAG_DENY_NON_RT_DS_TEXTURES: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(128i32);
pub const D3D12_HEAP_FLAG_HARDWARE_PROTECTED: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(256i32);
pub const D3D12_HEAP_FLAG_ALLOW_WRITE_WATCH: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(512i32);
pub const D3D12_HEAP_FLAG_ALLOW_SHADER_ATOMICS: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(1024i32);
pub const D3D12_HEAP_FLAG_CREATE_NOT_RESIDENT: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(2048i32);
pub const D3D12_HEAP_FLAG_CREATE_NOT_ZEROED: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(4096i32);
pub const D3D12_HEAP_FLAG_TOOLS_USE_MANUAL_WRITE_TRACKING: D3D12_HEAP_FLAGS =
    D3D12_HEAP_FLAGS(8192i32);
pub const D3D12_HEAP_FLAG_ALLOW_ALL_BUFFERS_AND_TEXTURES: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(0i32);
pub const D3D12_HEAP_FLAG_ALLOW_ONLY_BUFFERS: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(192i32);
pub const D3D12_HEAP_FLAG_ALLOW_ONLY_NON_RT_DS_TEXTURES: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(68i32);
pub const D3D12_HEAP_FLAG_ALLOW_ONLY_RT_DS_TEXTURES: D3D12_HEAP_FLAGS = D3D12_HEAP_FLAGS(132i32);
impl ::core::marker::Copy for D3D12_HEAP_FLAGS {}
impl ::core::clone::Clone for D3D12_HEAP_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_HEAP_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_HEAP_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_HEAP_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_HEAP_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_HEAP_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_HEAP_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_HEAP_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_HEAP_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_HEAP_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_HEAP_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_HEAP_SERIALIZATION_TIER(pub i32);
pub const D3D12_HEAP_SERIALIZATION_TIER_0: D3D12_HEAP_SERIALIZATION_TIER =
    D3D12_HEAP_SERIALIZATION_TIER(0i32);
pub const D3D12_HEAP_SERIALIZATION_TIER_10: D3D12_HEAP_SERIALIZATION_TIER =
    D3D12_HEAP_SERIALIZATION_TIER(10i32);
impl ::core::marker::Copy for D3D12_HEAP_SERIALIZATION_TIER {}
impl ::core::clone::Clone for D3D12_HEAP_SERIALIZATION_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_HEAP_SERIALIZATION_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_HEAP_SERIALIZATION_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_HEAP_SERIALIZATION_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_HEAP_SERIALIZATION_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_HEAP_TYPE(pub i32);
pub const D3D12_HEAP_TYPE_DEFAULT: D3D12_HEAP_TYPE = D3D12_HEAP_TYPE(1i32);
pub const D3D12_HEAP_TYPE_UPLOAD: D3D12_HEAP_TYPE = D3D12_HEAP_TYPE(2i32);
pub const D3D12_HEAP_TYPE_READBACK: D3D12_HEAP_TYPE = D3D12_HEAP_TYPE(3i32);
pub const D3D12_HEAP_TYPE_CUSTOM: D3D12_HEAP_TYPE = D3D12_HEAP_TYPE(4i32);
pub const D3D12_HEAP_TYPE_GPU_UPLOAD: D3D12_HEAP_TYPE = D3D12_HEAP_TYPE(5i32);
impl ::core::marker::Copy for D3D12_HEAP_TYPE {}
impl ::core::clone::Clone for D3D12_HEAP_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_HEAP_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_HEAP_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_HEAP_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_HEAP_TYPE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_HIT_GROUP_TYPE(pub i32);
pub const D3D12_HIT_GROUP_TYPE_TRIANGLES: D3D12_HIT_GROUP_TYPE = D3D12_HIT_GROUP_TYPE(0i32);
pub const D3D12_HIT_GROUP_TYPE_PROCEDURAL_PRIMITIVE: D3D12_HIT_GROUP_TYPE =
    D3D12_HIT_GROUP_TYPE(1i32);
impl ::core::marker::Copy for D3D12_HIT_GROUP_TYPE {}
impl ::core::clone::Clone for D3D12_HIT_GROUP_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_HIT_GROUP_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_HIT_GROUP_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_HIT_GROUP_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_HIT_GROUP_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_HIT_KIND(pub i32);
pub const D3D12_HIT_KIND_TRIANGLE_FRONT_FACE: D3D12_HIT_KIND = D3D12_HIT_KIND(254i32);
pub const D3D12_HIT_KIND_TRIANGLE_BACK_FACE: D3D12_HIT_KIND = D3D12_HIT_KIND(255i32);
impl ::core::marker::Copy for D3D12_HIT_KIND {}
impl ::core::clone::Clone for D3D12_HIT_KIND {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_HIT_KIND {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_HIT_KIND {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_HIT_KIND {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_HIT_KIND").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_INDEX_BUFFER_STRIP_CUT_VALUE(pub i32);
pub const D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_DISABLED: D3D12_INDEX_BUFFER_STRIP_CUT_VALUE =
    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE(0i32);
pub const D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFF: D3D12_INDEX_BUFFER_STRIP_CUT_VALUE =
    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE(1i32);
pub const D3D12_INDEX_BUFFER_STRIP_CUT_VALUE_0xFFFFFFFF: D3D12_INDEX_BUFFER_STRIP_CUT_VALUE =
    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE(2i32);
impl ::core::marker::Copy for D3D12_INDEX_BUFFER_STRIP_CUT_VALUE {}
impl ::core::clone::Clone for D3D12_INDEX_BUFFER_STRIP_CUT_VALUE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_INDEX_BUFFER_STRIP_CUT_VALUE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_INDEX_BUFFER_STRIP_CUT_VALUE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_INDEX_BUFFER_STRIP_CUT_VALUE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_INDEX_BUFFER_STRIP_CUT_VALUE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_INDIRECT_ARGUMENT_TYPE(pub i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_DRAW: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(0i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(1i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(2i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_VERTEX_BUFFER_VIEW: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(3i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_INDEX_BUFFER_VIEW: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(4i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(5i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_CONSTANT_BUFFER_VIEW: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(6i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_SHADER_RESOURCE_VIEW: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(7i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_UNORDERED_ACCESS_VIEW: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(8i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH_RAYS: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(9i32);
pub const D3D12_INDIRECT_ARGUMENT_TYPE_DISPATCH_MESH: D3D12_INDIRECT_ARGUMENT_TYPE =
    D3D12_INDIRECT_ARGUMENT_TYPE(10i32);
impl ::core::marker::Copy for D3D12_INDIRECT_ARGUMENT_TYPE {}
impl ::core::clone::Clone for D3D12_INDIRECT_ARGUMENT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_INDIRECT_ARGUMENT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_INDIRECT_ARGUMENT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_INDIRECT_ARGUMENT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_INDIRECT_ARGUMENT_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_INPUT_CLASSIFICATION(pub i32);
pub const D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA: D3D12_INPUT_CLASSIFICATION =
    D3D12_INPUT_CLASSIFICATION(0i32);
pub const D3D12_INPUT_CLASSIFICATION_PER_INSTANCE_DATA: D3D12_INPUT_CLASSIFICATION =
    D3D12_INPUT_CLASSIFICATION(1i32);
impl ::core::marker::Copy for D3D12_INPUT_CLASSIFICATION {}
impl ::core::clone::Clone for D3D12_INPUT_CLASSIFICATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_INPUT_CLASSIFICATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_INPUT_CLASSIFICATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_INPUT_CLASSIFICATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_INPUT_CLASSIFICATION")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_LIFETIME_STATE(pub i32);
pub const D3D12_LIFETIME_STATE_IN_USE: D3D12_LIFETIME_STATE = D3D12_LIFETIME_STATE(0i32);
pub const D3D12_LIFETIME_STATE_NOT_IN_USE: D3D12_LIFETIME_STATE = D3D12_LIFETIME_STATE(1i32);
impl ::core::marker::Copy for D3D12_LIFETIME_STATE {}
impl ::core::clone::Clone for D3D12_LIFETIME_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_LIFETIME_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_LIFETIME_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_LIFETIME_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_LIFETIME_STATE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_LINE_RASTERIZATION_MODE(pub i32);
pub const D3D12_LINE_RASTERIZATION_MODE_ALIASED: D3D12_LINE_RASTERIZATION_MODE =
    D3D12_LINE_RASTERIZATION_MODE(0i32);
pub const D3D12_LINE_RASTERIZATION_MODE_ALPHA_ANTIALIASED: D3D12_LINE_RASTERIZATION_MODE =
    D3D12_LINE_RASTERIZATION_MODE(1i32);
pub const D3D12_LINE_RASTERIZATION_MODE_QUADRILATERAL_WIDE: D3D12_LINE_RASTERIZATION_MODE =
    D3D12_LINE_RASTERIZATION_MODE(2i32);
pub const D3D12_LINE_RASTERIZATION_MODE_QUADRILATERAL_NARROW: D3D12_LINE_RASTERIZATION_MODE =
    D3D12_LINE_RASTERIZATION_MODE(3i32);
impl ::core::marker::Copy for D3D12_LINE_RASTERIZATION_MODE {}
impl ::core::clone::Clone for D3D12_LINE_RASTERIZATION_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_LINE_RASTERIZATION_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_LINE_RASTERIZATION_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_LINE_RASTERIZATION_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_LINE_RASTERIZATION_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_LOGIC_OP(pub i32);
pub const D3D12_LOGIC_OP_CLEAR: D3D12_LOGIC_OP = D3D12_LOGIC_OP(0i32);
pub const D3D12_LOGIC_OP_SET: D3D12_LOGIC_OP = D3D12_LOGIC_OP(1i32);
pub const D3D12_LOGIC_OP_COPY: D3D12_LOGIC_OP = D3D12_LOGIC_OP(2i32);
pub const D3D12_LOGIC_OP_COPY_INVERTED: D3D12_LOGIC_OP = D3D12_LOGIC_OP(3i32);
pub const D3D12_LOGIC_OP_NOOP: D3D12_LOGIC_OP = D3D12_LOGIC_OP(4i32);
pub const D3D12_LOGIC_OP_INVERT: D3D12_LOGIC_OP = D3D12_LOGIC_OP(5i32);
pub const D3D12_LOGIC_OP_AND: D3D12_LOGIC_OP = D3D12_LOGIC_OP(6i32);
pub const D3D12_LOGIC_OP_NAND: D3D12_LOGIC_OP = D3D12_LOGIC_OP(7i32);
pub const D3D12_LOGIC_OP_OR: D3D12_LOGIC_OP = D3D12_LOGIC_OP(8i32);
pub const D3D12_LOGIC_OP_NOR: D3D12_LOGIC_OP = D3D12_LOGIC_OP(9i32);
pub const D3D12_LOGIC_OP_XOR: D3D12_LOGIC_OP = D3D12_LOGIC_OP(10i32);
pub const D3D12_LOGIC_OP_EQUIV: D3D12_LOGIC_OP = D3D12_LOGIC_OP(11i32);
pub const D3D12_LOGIC_OP_AND_REVERSE: D3D12_LOGIC_OP = D3D12_LOGIC_OP(12i32);
pub const D3D12_LOGIC_OP_AND_INVERTED: D3D12_LOGIC_OP = D3D12_LOGIC_OP(13i32);
pub const D3D12_LOGIC_OP_OR_REVERSE: D3D12_LOGIC_OP = D3D12_LOGIC_OP(14i32);
pub const D3D12_LOGIC_OP_OR_INVERTED: D3D12_LOGIC_OP = D3D12_LOGIC_OP(15i32);
impl ::core::marker::Copy for D3D12_LOGIC_OP {}
impl ::core::clone::Clone for D3D12_LOGIC_OP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_LOGIC_OP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_LOGIC_OP {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_LOGIC_OP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_LOGIC_OP").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_MEASUREMENTS_ACTION(pub i32);
pub const D3D12_MEASUREMENTS_ACTION_KEEP_ALL: D3D12_MEASUREMENTS_ACTION =
    D3D12_MEASUREMENTS_ACTION(0i32);
pub const D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS: D3D12_MEASUREMENTS_ACTION =
    D3D12_MEASUREMENTS_ACTION(1i32);
pub const D3D12_MEASUREMENTS_ACTION_COMMIT_RESULTS_HIGH_PRIORITY: D3D12_MEASUREMENTS_ACTION =
    D3D12_MEASUREMENTS_ACTION(2i32);
pub const D3D12_MEASUREMENTS_ACTION_DISCARD_PREVIOUS: D3D12_MEASUREMENTS_ACTION =
    D3D12_MEASUREMENTS_ACTION(3i32);
impl ::core::marker::Copy for D3D12_MEASUREMENTS_ACTION {}
impl ::core::clone::Clone for D3D12_MEASUREMENTS_ACTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_MEASUREMENTS_ACTION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_MEASUREMENTS_ACTION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_MEASUREMENTS_ACTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_MEASUREMENTS_ACTION")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_MEMORY_POOL(pub i32);
pub const D3D12_MEMORY_POOL_UNKNOWN: D3D12_MEMORY_POOL = D3D12_MEMORY_POOL(0i32);
pub const D3D12_MEMORY_POOL_L0: D3D12_MEMORY_POOL = D3D12_MEMORY_POOL(1i32);
pub const D3D12_MEMORY_POOL_L1: D3D12_MEMORY_POOL = D3D12_MEMORY_POOL(2i32);
impl ::core::marker::Copy for D3D12_MEMORY_POOL {}
impl ::core::clone::Clone for D3D12_MEMORY_POOL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_MEMORY_POOL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_MEMORY_POOL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_MEMORY_POOL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_MEMORY_POOL").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_MESH_SHADER_TIER(pub i32);
pub const D3D12_MESH_SHADER_TIER_NOT_SUPPORTED: D3D12_MESH_SHADER_TIER =
    D3D12_MESH_SHADER_TIER(0i32);
pub const D3D12_MESH_SHADER_TIER_1: D3D12_MESH_SHADER_TIER = D3D12_MESH_SHADER_TIER(10i32);
impl ::core::marker::Copy for D3D12_MESH_SHADER_TIER {}
impl ::core::clone::Clone for D3D12_MESH_SHADER_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_MESH_SHADER_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_MESH_SHADER_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_MESH_SHADER_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_MESH_SHADER_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_MESSAGE_CALLBACK_FLAGS(pub i32);
pub const D3D12_MESSAGE_CALLBACK_FLAG_NONE: D3D12_MESSAGE_CALLBACK_FLAGS =
    D3D12_MESSAGE_CALLBACK_FLAGS(0i32);
pub const D3D12_MESSAGE_CALLBACK_IGNORE_FILTERS: D3D12_MESSAGE_CALLBACK_FLAGS =
    D3D12_MESSAGE_CALLBACK_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_MESSAGE_CALLBACK_FLAGS {}
impl ::core::clone::Clone for D3D12_MESSAGE_CALLBACK_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_MESSAGE_CALLBACK_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_MESSAGE_CALLBACK_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_MESSAGE_CALLBACK_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_MESSAGE_CALLBACK_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_MESSAGE_CALLBACK_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_MESSAGE_CALLBACK_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_MESSAGE_CALLBACK_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_MESSAGE_CALLBACK_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_MESSAGE_CALLBACK_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_MESSAGE_CALLBACK_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_MESSAGE_CATEGORY(pub i32);
pub const D3D12_MESSAGE_CATEGORY_APPLICATION_DEFINED: D3D12_MESSAGE_CATEGORY =
    D3D12_MESSAGE_CATEGORY(0i32);
pub const D3D12_MESSAGE_CATEGORY_MISCELLANEOUS: D3D12_MESSAGE_CATEGORY =
    D3D12_MESSAGE_CATEGORY(1i32);
pub const D3D12_MESSAGE_CATEGORY_INITIALIZATION: D3D12_MESSAGE_CATEGORY =
    D3D12_MESSAGE_CATEGORY(2i32);
pub const D3D12_MESSAGE_CATEGORY_CLEANUP: D3D12_MESSAGE_CATEGORY = D3D12_MESSAGE_CATEGORY(3i32);
pub const D3D12_MESSAGE_CATEGORY_COMPILATION: D3D12_MESSAGE_CATEGORY = D3D12_MESSAGE_CATEGORY(4i32);
pub const D3D12_MESSAGE_CATEGORY_STATE_CREATION: D3D12_MESSAGE_CATEGORY =
    D3D12_MESSAGE_CATEGORY(5i32);
pub const D3D12_MESSAGE_CATEGORY_STATE_SETTING: D3D12_MESSAGE_CATEGORY =
    D3D12_MESSAGE_CATEGORY(6i32);
pub const D3D12_MESSAGE_CATEGORY_STATE_GETTING: D3D12_MESSAGE_CATEGORY =
    D3D12_MESSAGE_CATEGORY(7i32);
pub const D3D12_MESSAGE_CATEGORY_RESOURCE_MANIPULATION: D3D12_MESSAGE_CATEGORY =
    D3D12_MESSAGE_CATEGORY(8i32);
pub const D3D12_MESSAGE_CATEGORY_EXECUTION: D3D12_MESSAGE_CATEGORY = D3D12_MESSAGE_CATEGORY(9i32);
pub const D3D12_MESSAGE_CATEGORY_SHADER: D3D12_MESSAGE_CATEGORY = D3D12_MESSAGE_CATEGORY(10i32);
impl ::core::marker::Copy for D3D12_MESSAGE_CATEGORY {}
impl ::core::clone::Clone for D3D12_MESSAGE_CATEGORY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_MESSAGE_CATEGORY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_MESSAGE_CATEGORY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_MESSAGE_CATEGORY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_MESSAGE_CATEGORY")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_MESSAGE_ID(pub i32);
pub const D3D12_MESSAGE_ID_UNKNOWN: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(0i32);
pub const D3D12_MESSAGE_ID_STRING_FROM_APPLICATION: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_THIS: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(2i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER1: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(3i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER2: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(4i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER3: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(5i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER4: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(6i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER5: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(7i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER6: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(8i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER7: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(9i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER8: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(10i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER9: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(11i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER10: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(12i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER11: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(13i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER12: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(14i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER13: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(15i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER14: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(16i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_PARAMETER15: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(17i32);
pub const D3D12_MESSAGE_ID_CORRUPTED_MULTITHREADING: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(18i32);
pub const D3D12_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(19i32);
pub const D3D12_MESSAGE_ID_GETPRIVATEDATA_MOREDATA: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(20i32);
pub const D3D12_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(21i32);
pub const D3D12_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(24i32);
pub const D3D12_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(25i32);
pub const D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(26i32);
pub const D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(27i32);
pub const D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(28i32);
pub const D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDVIDEOPLANESLICE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(29i32);
pub const D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDPLANESLICE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(30i32);
pub const D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(31i32);
pub const D3D12_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(32i32);
pub const D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(35i32);
pub const D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(36i32);
pub const D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(37i32);
pub const D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(38i32);
pub const D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDVIDEOPLANESLICE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(39i32);
pub const D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDPLANESLICE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(40i32);
pub const D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(41i32);
pub const D3D12_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(42i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(45i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(46i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(47i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(48i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(49i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(52i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(53i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(54i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(55i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(56i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(57i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(58i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(59i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(60i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(61i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(62i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(63i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(64i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(65i32);
pub const D3D12_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(66i32);
pub const D3D12_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(67i32);
pub const D3D12_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(68i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(69i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(70i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(71i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(72i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(73i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(74i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(75i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(76i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(79i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(80i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(81i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(82i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT : D3D12_MESSAGE_ID = D3D12_MESSAGE_ID ( 83i32 ) ;
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(84i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(85i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(86i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(87i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(88i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(89i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(90i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(91i32);
pub const D3D12_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(92i32);
pub const D3D12_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(93i32);
pub const D3D12_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(94i32);
pub const D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(95i32);
pub const D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(96i32);
pub const D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(97i32);
pub const D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(98i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(100i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(101i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(102i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(103i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(104i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(105i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(106i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(107i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(108i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(109i32);
pub const D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(111i32);
pub const D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(112i32);
pub const D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(113i32);
pub const D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(114i32);
pub const D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(115i32);
pub const D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(116i32);
pub const D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(117i32);
pub const D3D12_MESSAGE_ID_GET_PROGRAM_IDENTIFIER_ERROR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(118i32);
pub const D3D12_MESSAGE_ID_GET_WORK_GRAPH_PROPERTIES_ERROR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(119i32);
pub const D3D12_MESSAGE_ID_SET_PROGRAM_ERROR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(120i32);
pub const D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(135i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_ROOT_SIGNATURE_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(200i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_ROOT_SIGNATURE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(201i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_BUFFER_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(202i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(209i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_BUFFER_TOO_SMALL: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(210i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_BUFFER_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(211i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_BUFFER_FORMAT_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(212i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_BUFFER_TOO_SMALL: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(213i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INVALID_PRIMITIVETOPOLOGY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(219i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_STRIDE_UNALIGNED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(221i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_INDEX_OFFSET_UNALIGNED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(222i32);
pub const D3D12_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(232i32);
pub const D3D12_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(233i32);
pub const D3D12_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(234i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(239i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(240i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(245i32);
pub const D3D12_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(253i32);
pub const D3D12_MESSAGE_ID_LIVE_OBJECT_SUMMARY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(255i32);
pub const D3D12_MESSAGE_ID_LIVE_DEVICE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(274i32);
pub const D3D12_MESSAGE_ID_LIVE_SWAPCHAIN: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(275i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(276i32);
pub const D3D12_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDCLASSLINKAGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(277i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDCLASSLINKAGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(278i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAMTORASTERIZER:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(280i32);
pub const D3D12_MESSAGE_ID_CREATEPIXELSHADER_INVALIDCLASSLINKAGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(283i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAM: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(284i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDENTRIES:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(285i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTRIDES:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(286i32);
pub const D3D12_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTRIDES:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(287i32);
pub const D3D12_MESSAGE_ID_CREATEHULLSHADER_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(289i32);
pub const D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERBYTECODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(290i32);
pub const D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(291i32);
pub const D3D12_MESSAGE_ID_CREATEHULLSHADER_INVALIDCLASSLINKAGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(292i32);
pub const D3D12_MESSAGE_ID_CREATEDOMAINSHADER_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(294i32);
pub const D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERBYTECODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(295i32);
pub const D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(296i32);
pub const D3D12_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCLASSLINKAGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(297i32);
pub const D3D12_MESSAGE_ID_RESOURCE_UNMAP_NOTMAPPED: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(310i32);
pub const D3D12_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_MISMATCHED_DATA_SIZE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(318i32);
pub const D3D12_MESSAGE_ID_CREATECOMPUTESHADER_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(321i32);
pub const D3D12_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERBYTECODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(322i32);
pub const D3D12_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCLASSLINKAGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(323i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEFLOATOPSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(331i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEFLOATOPSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(332i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEFLOATOPSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(333i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEFLOATOPSNOTSUPPORTED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(334i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEFLOATOPSNOTSUPPORTED : D3D12_MESSAGE_ID = D3D12_MESSAGE_ID ( 335i32 ) ;
pub const D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEFLOATOPSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(336i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEFLOATOPSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(337i32);
pub const D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(340i32);
pub const D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(341i32);
pub const D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(342i32);
pub const D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDVIDEOPLANESLICE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(343i32);
pub const D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDPLANESLICE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(344i32);
pub const D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDIMENSIONS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(345i32);
pub const D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_UNRECOGNIZEDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(346i32);
pub const D3D12_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(354i32);
pub const D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFORCEDSAMPLECOUNT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(401i32);
pub const D3D12_MESSAGE_ID_CREATEBLENDSTATE_INVALIDLOGICOPS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(403i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEEXTENSIONSNOTSUPPORTED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(410i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEEXTENSIONSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(412i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEEXTENSIONSNOTSUPPORTED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(414i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEEXTENSIONSNOTSUPPORTED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(416i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEEXTENSIONSNOTSUPPORTED : D3D12_MESSAGE_ID = D3D12_MESSAGE_ID ( 418i32 ) ;
pub const D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEEXTENSIONSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(420i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEEXTENSIONSNOTSUPPORTED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(422i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_UAVSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(425i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEHULLSHADER_UAVSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(426i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_UAVSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(427i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_UAVSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(428i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UAVSNOTSUPPORTED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(429i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_UAVSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(430i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_UAVSNOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(431i32);
pub const D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_INVALIDSOURCERECT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(447i32);
pub const D3D12_MESSAGE_ID_DEVICE_CLEARVIEW_EMPTYRECT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(448i32);
pub const D3D12_MESSAGE_ID_UPDATETILEMAPPINGS_INVALID_PARAMETER: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(493i32);
pub const D3D12_MESSAGE_ID_COPYTILEMAPPINGS_INVALID_PARAMETER: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(494i32);
pub const D3D12_MESSAGE_ID_CREATEDEVICE_INVALIDARGS: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(506i32);
pub const D3D12_MESSAGE_ID_CREATEDEVICE_WARNING: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(507i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_TYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(519i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_NULL_POINTER: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(520i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_SUBRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(521i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_RESERVED_BITS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(522i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISSING_BIND_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(523i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_MISC_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(524i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_MATCHING_STATES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(525i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMBINATION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(526i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_BEFORE_AFTER_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(527i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(528i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_SAMPLE_COUNT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(529i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(530i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMBINED_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(531i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_FLAGS_FOR_FORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(532i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_SPLIT_BARRIER: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(533i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_UNMATCHED_END: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(534i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_UNMATCHED_BEGIN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(535i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_FLAG: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(536i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMMAND_LIST_TYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(537i32);
pub const D3D12_MESSAGE_ID_INVALID_SUBRESOURCE_STATE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(538i32);
pub const D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_CONTENTION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(540i32);
pub const D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_RESET: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(541i32);
pub const D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_RESET_BUNDLE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(542i32);
pub const D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_CANNOT_RESET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(543i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_OPEN: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(544i32);
pub const D3D12_MESSAGE_ID_INVALID_BUNDLE_API: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(546i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_CLOSED: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(547i32);
pub const D3D12_MESSAGE_ID_WRONG_COMMAND_ALLOCATOR_TYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(549i32);
pub const D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_SYNC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(552i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_SYNC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(553i32);
pub const D3D12_MESSAGE_ID_SET_DESCRIPTOR_HEAP_INVALID: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(554i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMANDQUEUE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(557i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMANDALLOCATOR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(558i32);
pub const D3D12_MESSAGE_ID_CREATE_PIPELINESTATE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(559i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMANDLIST12: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(560i32);
pub const D3D12_MESSAGE_ID_CREATE_RESOURCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(562i32);
pub const D3D12_MESSAGE_ID_CREATE_DESCRIPTORHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(563i32);
pub const D3D12_MESSAGE_ID_CREATE_ROOTSIGNATURE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(564i32);
pub const D3D12_MESSAGE_ID_CREATE_LIBRARY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(565i32);
pub const D3D12_MESSAGE_ID_CREATE_HEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(566i32);
pub const D3D12_MESSAGE_ID_CREATE_MONITOREDFENCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(567i32);
pub const D3D12_MESSAGE_ID_CREATE_QUERYHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(568i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMANDSIGNATURE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(569i32);
pub const D3D12_MESSAGE_ID_LIVE_COMMANDQUEUE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(570i32);
pub const D3D12_MESSAGE_ID_LIVE_COMMANDALLOCATOR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(571i32);
pub const D3D12_MESSAGE_ID_LIVE_PIPELINESTATE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(572i32);
pub const D3D12_MESSAGE_ID_LIVE_COMMANDLIST12: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(573i32);
pub const D3D12_MESSAGE_ID_LIVE_RESOURCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(575i32);
pub const D3D12_MESSAGE_ID_LIVE_DESCRIPTORHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(576i32);
pub const D3D12_MESSAGE_ID_LIVE_ROOTSIGNATURE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(577i32);
pub const D3D12_MESSAGE_ID_LIVE_LIBRARY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(578i32);
pub const D3D12_MESSAGE_ID_LIVE_HEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(579i32);
pub const D3D12_MESSAGE_ID_LIVE_MONITOREDFENCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(580i32);
pub const D3D12_MESSAGE_ID_LIVE_QUERYHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(581i32);
pub const D3D12_MESSAGE_ID_LIVE_COMMANDSIGNATURE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(582i32);
pub const D3D12_MESSAGE_ID_DESTROY_COMMANDQUEUE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(583i32);
pub const D3D12_MESSAGE_ID_DESTROY_COMMANDALLOCATOR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(584i32);
pub const D3D12_MESSAGE_ID_DESTROY_PIPELINESTATE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(585i32);
pub const D3D12_MESSAGE_ID_DESTROY_COMMANDLIST12: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(586i32);
pub const D3D12_MESSAGE_ID_DESTROY_RESOURCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(588i32);
pub const D3D12_MESSAGE_ID_DESTROY_DESCRIPTORHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(589i32);
pub const D3D12_MESSAGE_ID_DESTROY_ROOTSIGNATURE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(590i32);
pub const D3D12_MESSAGE_ID_DESTROY_LIBRARY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(591i32);
pub const D3D12_MESSAGE_ID_DESTROY_HEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(592i32);
pub const D3D12_MESSAGE_ID_DESTROY_MONITOREDFENCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(593i32);
pub const D3D12_MESSAGE_ID_DESTROY_QUERYHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(594i32);
pub const D3D12_MESSAGE_ID_DESTROY_COMMANDSIGNATURE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(595i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDDIMENSIONS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(597i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDMISCFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(599i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDARG_RETURN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(602i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_OUTOFMEMORY_RETURN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(603i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDDESC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(604i32);
pub const D3D12_MESSAGE_ID_POSSIBLY_INVALID_SUBRESOURCE_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(607i32);
pub const D3D12_MESSAGE_ID_INVALID_USE_OF_NON_RESIDENT_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(608i32);
pub const D3D12_MESSAGE_ID_POSSIBLE_INVALID_USE_OF_NON_RESIDENT_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(609i32);
pub const D3D12_MESSAGE_ID_BUNDLE_PIPELINE_STATE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(610i32);
pub const D3D12_MESSAGE_ID_PRIMITIVE_TOPOLOGY_MISMATCH_PIPELINE_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(611i32);
pub const D3D12_MESSAGE_ID_RENDER_TARGET_FORMAT_MISMATCH_PIPELINE_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(613i32);
pub const D3D12_MESSAGE_ID_RENDER_TARGET_SAMPLE_DESC_MISMATCH_PIPELINE_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(614i32);
pub const D3D12_MESSAGE_ID_DEPTH_STENCIL_FORMAT_MISMATCH_PIPELINE_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(615i32);
pub const D3D12_MESSAGE_ID_DEPTH_STENCIL_SAMPLE_DESC_MISMATCH_PIPELINE_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(616i32);
pub const D3D12_MESSAGE_ID_CREATESHADER_INVALIDBYTECODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(622i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_NULLDESC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(623i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_INVALIDSIZE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(624i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDHEAPTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(625i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDCPUPAGEPROPERTIES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(626i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDMEMORYPOOL: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(627i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_INVALIDPROPERTIES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(628i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_INVALIDALIGNMENT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(629i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_UNRECOGNIZEDMISCFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(630i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_INVALIDMISCFLAGS: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(631i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_INVALIDARG_RETURN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(632i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_OUTOFMEMORY_RETURN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(633i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_NULLHEAPPROPERTIES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(634i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDHEAPTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(635i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDCPUPAGEPROPERTIES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(636i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDMEMORYPOOL: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(637i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALIDHEAPPROPERTIES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(638i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_UNRECOGNIZEDHEAPMISCFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(639i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALIDHEAPMISCFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(640i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALIDARG_RETURN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(641i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_OUTOFMEMORY_RETURN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(642i32);
pub const D3D12_MESSAGE_ID_GETCUSTOMHEAPPROPERTIES_UNRECOGNIZEDHEAPTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(643i32);
pub const D3D12_MESSAGE_ID_GETCUSTOMHEAPPROPERTIES_INVALIDHEAPTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(644i32);
pub const D3D12_MESSAGE_ID_CREATE_DESCRIPTOR_HEAP_INVALID_DESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(645i32);
pub const D3D12_MESSAGE_ID_INVALID_DESCRIPTOR_HANDLE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(646i32);
pub const D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALID_CONSERVATIVERASTERMODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(647i32);
pub const D3D12_MESSAGE_ID_CREATE_CONSTANT_BUFFER_VIEW_INVALID_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(649i32);
pub const D3D12_MESSAGE_ID_CREATE_CONSTANT_BUFFER_VIEW_INVALID_DESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(650i32);
pub const D3D12_MESSAGE_ID_CREATE_UNORDEREDACCESS_VIEW_INVALID_COUNTER_USAGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(652i32);
pub const D3D12_MESSAGE_ID_COPY_DESCRIPTORS_INVALID_RANGES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(653i32);
pub const D3D12_MESSAGE_ID_COPY_DESCRIPTORS_WRITE_ONLY_DESCRIPTOR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(654i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_RTV_FORMAT_NOT_UNKNOWN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(655i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_RENDER_TARGET_COUNT:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(656i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_VERTEX_SHADER_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(657i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INPUTLAYOUT_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(658i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_HS_DS_SIGNATURE_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(659i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_REGISTERINDEX:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(660i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_COMPONENTTYPE:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(661i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_REGISTERMASK:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(662i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_SYSTEMVALUE:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(663i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(664i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_MINPRECISION:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(665i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(666i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_XOR_DS_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(667i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HULL_SHADER_INPUT_TOPOLOGY_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(668i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_DS_CONTROL_POINT_COUNT_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(669i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_DS_TESSELLATOR_DOMAIN_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(670i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(671i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_USE_OF_FORCED_SAMPLE_COUNT:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(672i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_PRIMITIVETOPOLOGY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(673i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_SYSTEMVALUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(674i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0 : D3D12_MESSAGE_ID = D3D12_MESSAGE_ID ( 675i32 ) ;
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING : D3D12_MESSAGE_ID = D3D12_MESSAGE_ID ( 676i32 ) ;
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_PS_OUTPUT_TYPE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(677i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_OM_RENDER_TARGET_DOES_NOT_SUPPORT_LOGIC_OPS : D3D12_MESSAGE_ID = D3D12_MESSAGE_ID ( 678i32 ) ;
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_RENDERTARGETVIEW_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(679i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_DEPTHSTENCILVIEW_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(680i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_GS_INPUT_PRIMITIVE_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(681i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_POSITION_NOT_PRESENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(682i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_MISSING_ROOT_SIGNATURE_FLAGS:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(683i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_INDEX_BUFFER_PROPERTIES:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(684i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INVALID_SAMPLE_DESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(685i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_HS_ROOT_SIGNATURE_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(686i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_DS_ROOT_SIGNATURE_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(687i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_VS_ROOT_SIGNATURE_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(688i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_GS_ROOT_SIGNATURE_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(689i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_PS_ROOT_SIGNATURE_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(690i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_MISSING_ROOT_SIGNATURE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(691i32);
pub const D3D12_MESSAGE_ID_EXECUTE_BUNDLE_OPEN_BUNDLE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(692i32);
pub const D3D12_MESSAGE_ID_EXECUTE_BUNDLE_DESCRIPTOR_HEAP_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(693i32);
pub const D3D12_MESSAGE_ID_EXECUTE_BUNDLE_TYPE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(694i32);
pub const D3D12_MESSAGE_ID_DRAW_EMPTY_SCISSOR_RECTANGLE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(695i32);
pub const D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_BLOB_NOT_FOUND: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(696i32);
pub const D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_DESERIALIZE_FAILED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(697i32);
pub const D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_INVALID_CONFIGURATION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(698i32);
pub const D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_NOT_SUPPORTED_ON_DEVICE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(699i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_NULLRESOURCEPROPERTIES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(700i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_NULLHEAP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(701i32);
pub const D3D12_MESSAGE_ID_GETRESOURCEALLOCATIONINFO_INVALIDRDESCS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(702i32);
pub const D3D12_MESSAGE_ID_MAKERESIDENT_NULLOBJECTARRAY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(703i32);
pub const D3D12_MESSAGE_ID_EVICT_NULLOBJECTARRAY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(705i32);
pub const D3D12_MESSAGE_ID_SET_DESCRIPTOR_TABLE_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(708i32);
pub const D3D12_MESSAGE_ID_SET_ROOT_CONSTANT_INVALID: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(709i32);
pub const D3D12_MESSAGE_ID_SET_ROOT_CONSTANT_BUFFER_VIEW_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(710i32);
pub const D3D12_MESSAGE_ID_SET_ROOT_SHADER_RESOURCE_VIEW_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(711i32);
pub const D3D12_MESSAGE_ID_SET_ROOT_UNORDERED_ACCESS_VIEW_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(712i32);
pub const D3D12_MESSAGE_ID_SET_VERTEX_BUFFERS_INVALID_DESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(713i32);
pub const D3D12_MESSAGE_ID_SET_INDEX_BUFFER_INVALID_DESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(715i32);
pub const D3D12_MESSAGE_ID_SET_STREAM_OUTPUT_BUFFERS_INVALID_DESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(717i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDDIMENSIONALITY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(718i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDLAYOUT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(719i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDDIMENSIONALITY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(720i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDALIGNMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(721i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDMIPLEVELS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(722i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDSAMPLEDESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(723i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDLAYOUT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(724i32);
pub const D3D12_MESSAGE_ID_SET_INDEX_BUFFER_INVALID: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(725i32);
pub const D3D12_MESSAGE_ID_SET_VERTEX_BUFFERS_INVALID: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(726i32);
pub const D3D12_MESSAGE_ID_SET_STREAM_OUTPUT_BUFFERS_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(727i32);
pub const D3D12_MESSAGE_ID_SET_RENDER_TARGETS_INVALID: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(728i32);
pub const D3D12_MESSAGE_ID_CREATEQUERY_HEAP_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(729i32);
pub const D3D12_MESSAGE_ID_BEGIN_END_QUERY_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(731i32);
pub const D3D12_MESSAGE_ID_CLOSE_COMMAND_LIST_OPEN_QUERY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(732i32);
pub const D3D12_MESSAGE_ID_RESOLVE_QUERY_DATA_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(733i32);
pub const D3D12_MESSAGE_ID_SET_PREDICATION_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(734i32);
pub const D3D12_MESSAGE_ID_TIMESTAMPS_NOT_SUPPORTED: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(735i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(737i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(738i32);
pub const D3D12_MESSAGE_ID_GETCOPYABLEFOOTPRINTS_INVALIDSUBRESOURCERANGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(739i32);
pub const D3D12_MESSAGE_ID_GETCOPYABLEFOOTPRINTS_INVALIDBASEOFFSET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(740i32);
pub const D3D12_MESSAGE_ID_GETCOPYABLELAYOUT_INVALIDSUBRESOURCERANGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(739i32);
pub const D3D12_MESSAGE_ID_GETCOPYABLELAYOUT_INVALIDBASEOFFSET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(740i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_HEAP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(741i32);
pub const D3D12_MESSAGE_ID_CREATE_SAMPLER_INVALID: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(742i32);
pub const D3D12_MESSAGE_ID_CREATECOMMANDSIGNATURE_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(743i32);
pub const D3D12_MESSAGE_ID_EXECUTE_INDIRECT_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(744i32);
pub const D3D12_MESSAGE_ID_GETGPUVIRTUALADDRESS_INVALID_RESOURCE_DIMENSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(745i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDCLEARVALUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(815i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_UNRECOGNIZEDCLEARVALUEFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(816i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDCLEARVALUEFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(817i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_CLEARVALUEDENORMFLUSH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(818i32);
pub const D3D12_MESSAGE_ID_CLEARRENDERTARGETVIEW_MISMATCHINGCLEARVALUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(820i32);
pub const D3D12_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_MISMATCHINGCLEARVALUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(821i32);
pub const D3D12_MESSAGE_ID_MAP_INVALIDHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(822i32);
pub const D3D12_MESSAGE_ID_UNMAP_INVALIDHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(823i32);
pub const D3D12_MESSAGE_ID_MAP_INVALIDRESOURCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(824i32);
pub const D3D12_MESSAGE_ID_UNMAP_INVALIDRESOURCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(825i32);
pub const D3D12_MESSAGE_ID_MAP_INVALIDSUBRESOURCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(826i32);
pub const D3D12_MESSAGE_ID_UNMAP_INVALIDSUBRESOURCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(827i32);
pub const D3D12_MESSAGE_ID_MAP_INVALIDRANGE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(828i32);
pub const D3D12_MESSAGE_ID_UNMAP_INVALIDRANGE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(829i32);
pub const D3D12_MESSAGE_ID_MAP_INVALIDDATAPOINTER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(832i32);
pub const D3D12_MESSAGE_ID_MAP_INVALIDARG_RETURN: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(833i32);
pub const D3D12_MESSAGE_ID_MAP_OUTOFMEMORY_RETURN: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(834i32);
pub const D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_BUNDLENOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(835i32);
pub const D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_COMMANDLISTMISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(836i32);
pub const D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_OPENCOMMANDLIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(837i32);
pub const D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_FAILEDCOMMANDLIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(838i32);
pub const D3D12_MESSAGE_ID_COPYBUFFERREGION_NULLDST: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(839i32);
pub const D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALIDDSTRESOURCEDIMENSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(840i32);
pub const D3D12_MESSAGE_ID_COPYBUFFERREGION_DSTRANGEOUTOFBOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(841i32);
pub const D3D12_MESSAGE_ID_COPYBUFFERREGION_NULLSRC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(842i32);
pub const D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALIDSRCRESOURCEDIMENSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(843i32);
pub const D3D12_MESSAGE_ID_COPYBUFFERREGION_SRCRANGEOUTOFBOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(844i32);
pub const D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALIDCOPYFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(845i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_NULLDST: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(846i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDDSTTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(847i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTRESOURCEDIMENSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(848i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(849i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTSUBRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(850i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTOFFSET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(851i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDDSTFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(852i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(853i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTDIMENSIONS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(854i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTROWPITCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(855i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTPLACEMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(856i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTDSPLACEDFOOTPRINTFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(857i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_DSTREGIONOUTOFBOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(858i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_NULLSRC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(859i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDSRCTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(860i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCRESOURCEDIMENSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(861i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(862i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCSUBRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(863i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCOFFSET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(864i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_UNRECOGNIZEDSRCFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(865i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(866i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCDIMENSIONS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(867i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCROWPITCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(868i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCPLACEMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(869i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCDSPLACEDFOOTPRINTFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(870i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_SRCREGIONOUTOFBOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(871i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDDSTCOORDINATES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(872i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDSRCBOX: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(873i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_FORMATMISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(874i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_EMPTYBOX: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(875i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_INVALIDCOPYFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(876i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALID_SUBRESOURCE_INDEX: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(877i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALID_FORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(878i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_RESOURCE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(879i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALID_SAMPLE_COUNT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(880i32);
pub const D3D12_MESSAGE_ID_CREATECOMPUTEPIPELINESTATE_INVALID_SHADER: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(881i32);
pub const D3D12_MESSAGE_ID_CREATECOMPUTEPIPELINESTATE_CS_ROOT_SIGNATURE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(882i32);
pub const D3D12_MESSAGE_ID_CREATECOMPUTEPIPELINESTATE_MISSING_ROOT_SIGNATURE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(883i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_INVALIDCACHEDBLOB: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(884i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBADAPTERMISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(885i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBDRIVERVERSIONMISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(886i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBDESCMISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(887i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CACHEDBLOBIGNORED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(888i32);
pub const D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDHEAP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(889i32);
pub const D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(890i32);
pub const D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDBOX: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(891i32);
pub const D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_INVALIDSUBRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(892i32);
pub const D3D12_MESSAGE_ID_WRITETOSUBRESOURCE_EMPTYBOX: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(893i32);
pub const D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDHEAP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(894i32);
pub const D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(895i32);
pub const D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDBOX: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(896i32);
pub const D3D12_MESSAGE_ID_READFROMSUBRESOURCE_INVALIDSUBRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(897i32);
pub const D3D12_MESSAGE_ID_READFROMSUBRESOURCE_EMPTYBOX: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(898i32);
pub const D3D12_MESSAGE_ID_TOO_MANY_NODES_SPECIFIED: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(899i32);
pub const D3D12_MESSAGE_ID_INVALID_NODE_INDEX: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(900i32);
pub const D3D12_MESSAGE_ID_GETHEAPPROPERTIES_INVALIDRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(901i32);
pub const D3D12_MESSAGE_ID_NODE_MASK_MISMATCH: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(902i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_OUTOFMEMORY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(903i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_MULTIPLE_SWAPCHAIN_BUFFER_REFERENCES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(904i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_TOO_MANY_SWAPCHAIN_REFERENCES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(905i32);
pub const D3D12_MESSAGE_ID_COMMAND_QUEUE_TOO_MANY_SWAPCHAIN_REFERENCES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(906i32);
pub const D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_WRONGSWAPCHAINBUFFERREFERENCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(907i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_SETRENDERTARGETS_INVALIDNUMRENDERTARGETS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(908i32);
pub const D3D12_MESSAGE_ID_CREATE_QUEUE_INVALID_TYPE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(909i32);
pub const D3D12_MESSAGE_ID_CREATE_QUEUE_INVALID_FLAGS: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(910i32);
pub const D3D12_MESSAGE_ID_CREATESHAREDRESOURCE_INVALIDFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(911i32);
pub const D3D12_MESSAGE_ID_CREATESHAREDRESOURCE_INVALIDFORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(912i32);
pub const D3D12_MESSAGE_ID_CREATESHAREDHEAP_INVALIDFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(913i32);
pub const D3D12_MESSAGE_ID_REFLECTSHAREDPROPERTIES_UNRECOGNIZEDPROPERTIES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(914i32);
pub const D3D12_MESSAGE_ID_REFLECTSHAREDPROPERTIES_INVALIDSIZE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(915i32);
pub const D3D12_MESSAGE_ID_REFLECTSHAREDPROPERTIES_INVALIDOBJECT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(916i32);
pub const D3D12_MESSAGE_ID_KEYEDMUTEX_INVALIDOBJECT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(917i32);
pub const D3D12_MESSAGE_ID_KEYEDMUTEX_INVALIDKEY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(918i32);
pub const D3D12_MESSAGE_ID_KEYEDMUTEX_WRONGSTATE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(919i32);
pub const D3D12_MESSAGE_ID_CREATE_QUEUE_INVALID_PRIORITY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(920i32);
pub const D3D12_MESSAGE_ID_OBJECT_DELETED_WHILE_STILL_IN_USE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(921i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_INVALID_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(922i32);
pub const D3D12_MESSAGE_ID_HEAP_ADDRESS_RANGE_HAS_NO_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(923i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_RENDER_TARGET_DELETED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(924i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_ALL_RENDER_TARGETS_HAVE_UNKNOWN_FORMAT:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(925i32);
pub const D3D12_MESSAGE_ID_HEAP_ADDRESS_RANGE_INTERSECTS_MULTIPLE_BUFFERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(926i32);
pub const D3D12_MESSAGE_ID_EXECUTECOMMANDLISTS_GPU_WRITTEN_READBACK_RESOURCE_MAPPED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(927i32);
pub const D3D12_MESSAGE_ID_PROGRAM_FALLBACK_ERROR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(928i32);
pub const D3D12_MESSAGE_ID_UNMAP_RANGE_NOT_EMPTY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(929i32);
pub const D3D12_MESSAGE_ID_MAP_INVALID_NULLRANGE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(930i32);
pub const D3D12_MESSAGE_ID_UNMAP_INVALID_NULLRANGE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(931i32);
pub const D3D12_MESSAGE_ID_NO_GRAPHICS_API_SUPPORT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(932i32);
pub const D3D12_MESSAGE_ID_NO_COMPUTE_API_SUPPORT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(933i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_RESOURCE_FLAGS_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(934i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_ROOT_ARGUMENT_UNINITIALIZED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(935i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_HEAP_INDEX_OUT_OF_BOUNDS:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(936i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_TABLE_REGISTER_INDEX_OUT_OF_BOUNDS:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(937i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_UNINITIALIZED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(938i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_DESCRIPTOR_TYPE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(939i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_SRV_RESOURCE_DIMENSION_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(940i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_UAV_RESOURCE_DIMENSION_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(941i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_INCOMPATIBLE_RESOURCE_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(942i32);
pub const D3D12_MESSAGE_ID_COPYRESOURCE_NULLDST: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(943i32);
pub const D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDDSTRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(944i32);
pub const D3D12_MESSAGE_ID_COPYRESOURCE_NULLSRC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(945i32);
pub const D3D12_MESSAGE_ID_COPYRESOURCE_INVALIDSRCRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(946i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_NULLDST: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(947i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALIDDSTRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(948i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_NULLSRC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(949i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_INVALIDSRCRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(950i32);
pub const D3D12_MESSAGE_ID_PIPELINE_STATE_TYPE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(951i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DISPATCH_ROOT_SIGNATURE_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(952i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DISPATCH_ROOT_SIGNATURE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(953i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_ZERO_BARRIERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(954i32);
pub const D3D12_MESSAGE_ID_BEGIN_END_EVENT_MISMATCH: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(955i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_POSSIBLE_BEFORE_AFTER_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(956i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_BEGIN_END: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(957i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_INVALID_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(958i32);
pub const D3D12_MESSAGE_ID_USE_OF_ZERO_REFCOUNT_OBJECT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(959i32);
pub const D3D12_MESSAGE_ID_OBJECT_EVICTED_WHILE_STILL_IN_USE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(960i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_ROOT_DESCRIPTOR_ACCESS_OUT_OF_BOUNDS:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(961i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_INVALIDLIBRARYBLOB: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(962i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_DRIVERVERSIONMISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(963i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_ADAPTERVERSIONMISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(964i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINELIBRARY_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(965i32);
pub const D3D12_MESSAGE_ID_CREATE_PIPELINELIBRARY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(966i32);
pub const D3D12_MESSAGE_ID_LIVE_PIPELINELIBRARY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(967i32);
pub const D3D12_MESSAGE_ID_DESTROY_PIPELINELIBRARY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(968i32);
pub const D3D12_MESSAGE_ID_STOREPIPELINE_NONAME: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(969i32);
pub const D3D12_MESSAGE_ID_STOREPIPELINE_DUPLICATENAME: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(970i32);
pub const D3D12_MESSAGE_ID_LOADPIPELINE_NAMENOTFOUND: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(971i32);
pub const D3D12_MESSAGE_ID_LOADPIPELINE_INVALIDDESC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(972i32);
pub const D3D12_MESSAGE_ID_PIPELINELIBRARY_SERIALIZE_NOTENOUGHMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(973i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_PS_OUTPUT_RT_OUTPUT_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(974i32);
pub const D3D12_MESSAGE_ID_SETEVENTONMULTIPLEFENCECOMPLETION_INVALIDFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(975i32);
pub const D3D12_MESSAGE_ID_CREATE_QUEUE_VIDEO_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(976i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_ALLOCATOR_VIDEO_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(977i32);
pub const D3D12_MESSAGE_ID_CREATEQUERY_HEAP_VIDEO_DECODE_STATISTICS_NOT_SUPPORTED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(978i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEODECODECOMMANDLIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(979i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEODECODER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(980i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEODECODESTREAM: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(981i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEODECODECOMMANDLIST: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(982i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEODECODER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(983i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEODECODESTREAM: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(984i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEODECODECOMMANDLIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(985i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEODECODER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(986i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEODECODESTREAM: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(987i32);
pub const D3D12_MESSAGE_ID_DECODE_FRAME_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(988i32);
pub const D3D12_MESSAGE_ID_DEPRECATED_API: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(989i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(990i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DESCRIPTOR_TABLE_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(991i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_ROOT_CONSTANT_BUFFER_VIEW_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(992i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_ROOT_SHADER_RESOURCE_VIEW_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(993i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_ROOT_UNORDERED_ACCESS_VIEW_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(994i32);
pub const D3D12_MESSAGE_ID_DISCARD_INVALID_SUBRESOURCE_RANGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(995i32);
pub const D3D12_MESSAGE_ID_DISCARD_ONE_SUBRESOURCE_FOR_MIPS_WITH_RECTS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(996i32);
pub const D3D12_MESSAGE_ID_DISCARD_NO_RECTS_FOR_NON_TEXTURE2D: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(997i32);
pub const D3D12_MESSAGE_ID_COPY_ON_SAME_SUBRESOURCE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(998i32);
pub const D3D12_MESSAGE_ID_SETRESIDENCYPRIORITY_INVALID_PAGEABLE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(999i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1000i32);
pub const D3D12_MESSAGE_ID_STATIC_DESCRIPTOR_INVALID_DESCRIPTOR_CHANGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1001i32);
pub const D3D12_MESSAGE_ID_DATA_STATIC_DESCRIPTOR_INVALID_DATA_CHANGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1002i32);
pub const D3D12_MESSAGE_ID_DATA_STATIC_WHILE_SET_AT_EXECUTE_DESCRIPTOR_INVALID_DATA_CHANGE:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1003i32);
pub const D3D12_MESSAGE_ID_EXECUTE_BUNDLE_STATIC_DESCRIPTOR_DATA_STATIC_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1004i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_RESOURCE_ACCESS_OUT_OF_BOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1005i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_SAMPLER_MODE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1006i32);
pub const D3D12_MESSAGE_ID_CREATE_FENCE_INVALID_FLAGS: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1007i32);
pub const D3D12_MESSAGE_ID_RESOURCE_BARRIER_DUPLICATE_SUBRESOURCE_TRANSITIONS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1008i32);
pub const D3D12_MESSAGE_ID_SETRESIDENCYPRIORITY_INVALID_PRIORITY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1009i32);
pub const D3D12_MESSAGE_ID_CREATE_DESCRIPTOR_HEAP_LARGE_NUM_DESCRIPTORS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1013i32);
pub const D3D12_MESSAGE_ID_BEGIN_EVENT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1014i32);
pub const D3D12_MESSAGE_ID_END_EVENT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1015i32);
pub const D3D12_MESSAGE_ID_CREATEDEVICE_DEBUG_LAYER_STARTUP_OPTIONS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1016i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_DEPTHBOUNDSTEST_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1017i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_DUPLICATE_SUBOBJECT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1018i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_UNKNOWN_SUBOBJECT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1019i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_ZERO_SIZE_STREAM: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1020i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_INVALID_STREAM: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1021i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_CANNOT_DEDUCE_TYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1022i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_STATIC_DESCRIPTOR_RESOURCE_DIMENSION_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1023i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_QUEUE_INSUFFICIENT_PRIVILEGE_FOR_GLOBAL_REALTIME:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1024i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_QUEUE_INSUFFICIENT_HARDWARE_SUPPORT_FOR_GLOBAL_REALTIME : D3D12_MESSAGE_ID = D3D12_MESSAGE_ID ( 1025i32 ) ;
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_ARCHITECTURE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1026i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_DST: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1027i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DST_RESOURCE_DIMENSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1028i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_DST_RANGE_OUT_OF_BOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1029i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_SRC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1030i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_SRC_RESOURCE_DIMENSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1031i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_SRC_RANGE_OUT_OF_BOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1032i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_OFFSET_ALIGNMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1033i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_DEPENDENT_RESOURCES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1034i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_NULL_DEPENDENT_SUBRESOURCE_RANGES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1035i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DEPENDENT_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1036i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DEPENDENT_SUBRESOURCE_RANGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1037i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_DEPENDENT_SUBRESOURCE_OUT_OF_BOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1038i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_DEPENDENT_RANGE_OUT_OF_BOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1039i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_ZERO_DEPENDENCIES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1040i32);
pub const D3D12_MESSAGE_ID_DEVICE_CREATE_SHARED_HANDLE_INVALIDARG: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1041i32);
pub const D3D12_MESSAGE_ID_DESCRIPTOR_HANDLE_WITH_INVALID_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1042i32);
pub const D3D12_MESSAGE_ID_SETDEPTHBOUNDS_INVALIDARGS: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1043i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_RESOURCE_STATE_IMPRECISE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1044i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_PIPELINE_STATE_NOT_SET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1045i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_SHADER_MODEL_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1046i32);
pub const D3D12_MESSAGE_ID_OBJECT_ACCESSED_WHILE_STILL_IN_USE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1047i32);
pub const D3D12_MESSAGE_ID_PROGRAMMABLE_MSAA_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1048i32);
pub const D3D12_MESSAGE_ID_SETSAMPLEPOSITIONS_INVALIDARGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1049i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCEREGION_INVALID_RECT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1050i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEODECODECOMMANDQUEUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1051i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSCOMMANDLIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1052i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSCOMMANDQUEUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1053i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEODECODECOMMANDQUEUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1054i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSCOMMANDLIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1055i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSCOMMANDQUEUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1056i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEODECODECOMMANDQUEUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1057i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSCOMMANDLIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1058i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSCOMMANDQUEUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1059i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSOR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1060i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOPROCESSSTREAM: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1061i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSOR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1062i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOPROCESSSTREAM: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1063i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSOR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1064i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOPROCESSSTREAM: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1065i32);
pub const D3D12_MESSAGE_ID_PROCESS_FRAME_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1066i32);
pub const D3D12_MESSAGE_ID_COPY_INVALIDLAYOUT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1067i32);
pub const D3D12_MESSAGE_ID_CREATE_CRYPTO_SESSION: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1068i32);
pub const D3D12_MESSAGE_ID_CREATE_CRYPTO_SESSION_POLICY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1069i32);
pub const D3D12_MESSAGE_ID_CREATE_PROTECTED_RESOURCE_SESSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1070i32);
pub const D3D12_MESSAGE_ID_LIVE_CRYPTO_SESSION: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1071i32);
pub const D3D12_MESSAGE_ID_LIVE_CRYPTO_SESSION_POLICY: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1072i32);
pub const D3D12_MESSAGE_ID_LIVE_PROTECTED_RESOURCE_SESSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1073i32);
pub const D3D12_MESSAGE_ID_DESTROY_CRYPTO_SESSION: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1074i32);
pub const D3D12_MESSAGE_ID_DESTROY_CRYPTO_SESSION_POLICY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1075i32);
pub const D3D12_MESSAGE_ID_DESTROY_PROTECTED_RESOURCE_SESSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1076i32);
pub const D3D12_MESSAGE_ID_PROTECTED_RESOURCE_SESSION_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1077i32);
pub const D3D12_MESSAGE_ID_FENCE_INVALIDOPERATION: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1078i32);
pub const D3D12_MESSAGE_ID_CREATEQUERY_HEAP_COPY_QUEUE_TIMESTAMPS_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1079i32);
pub const D3D12_MESSAGE_ID_SAMPLEPOSITIONS_MISMATCH_DEFERRED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1080i32);
pub const D3D12_MESSAGE_ID_SAMPLEPOSITIONS_MISMATCH_RECORDTIME_ASSUMEDFROMFIRSTUSE:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1081i32);
pub const D3D12_MESSAGE_ID_SAMPLEPOSITIONS_MISMATCH_RECORDTIME_ASSUMEDFROMCLEAR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1082i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEODECODERHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1083i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEODECODERHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1084i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEODECODERHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1085i32);
pub const D3D12_MESSAGE_ID_OPENEXISTINGHEAP_INVALIDARG_RETURN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1086i32);
pub const D3D12_MESSAGE_ID_OPENEXISTINGHEAP_OUTOFMEMORY_RETURN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1087i32);
pub const D3D12_MESSAGE_ID_OPENEXISTINGHEAP_INVALIDADDRESS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1088i32);
pub const D3D12_MESSAGE_ID_OPENEXISTINGHEAP_INVALIDHANDLE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1089i32);
pub const D3D12_MESSAGE_ID_WRITEBUFFERIMMEDIATE_INVALID_DEST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1090i32);
pub const D3D12_MESSAGE_ID_WRITEBUFFERIMMEDIATE_INVALID_MODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1091i32);
pub const D3D12_MESSAGE_ID_WRITEBUFFERIMMEDIATE_INVALID_ALIGNMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1092i32);
pub const D3D12_MESSAGE_ID_WRITEBUFFERIMMEDIATE_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1093i32);
pub const D3D12_MESSAGE_ID_SETVIEWINSTANCEMASK_INVALIDARGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1094i32);
pub const D3D12_MESSAGE_ID_VIEW_INSTANCING_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1095i32);
pub const D3D12_MESSAGE_ID_VIEW_INSTANCING_INVALIDARGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1096i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_MISMATCH_DECODE_REFERENCE_ONLY_FLAG: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1097i32);
pub const D3D12_MESSAGE_ID_COPYRESOURCE_MISMATCH_DECODE_REFERENCE_ONLY_FLAG: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1098i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEO_DECODE_HEAP_CAPS_FAILURE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1099i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEO_DECODE_HEAP_CAPS_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1100i32);
pub const D3D12_MESSAGE_ID_VIDEO_DECODE_SUPPORT_INVALID_INPUT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1101i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEO_DECODER_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1102i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_METADATA_ERROR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1103i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_VIEW_INSTANCING_VERTEX_SIZE_EXCEEDED:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1104i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_RUNTIME_INTERNAL_ERROR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1105i32);
pub const D3D12_MESSAGE_ID_NO_VIDEO_API_SUPPORT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1106i32);
pub const D3D12_MESSAGE_ID_VIDEO_PROCESS_SUPPORT_INVALID_INPUT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1107i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEO_PROCESSOR_CAPS_FAILURE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1108i32);
pub const D3D12_MESSAGE_ID_VIDEO_PROCESS_SUPPORT_UNSUPPORTED_FORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1109i32);
pub const D3D12_MESSAGE_ID_VIDEO_DECODE_FRAME_INVALID_ARGUMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1110i32);
pub const D3D12_MESSAGE_ID_ENQUEUE_MAKE_RESIDENT_INVALID_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1111i32);
pub const D3D12_MESSAGE_ID_OPENEXISTINGHEAP_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1112i32);
pub const D3D12_MESSAGE_ID_VIDEO_PROCESS_FRAMES_INVALID_ARGUMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1113i32);
pub const D3D12_MESSAGE_ID_VIDEO_DECODE_SUPPORT_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1114i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMANDRECORDER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1115i32);
pub const D3D12_MESSAGE_ID_LIVE_COMMANDRECORDER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1116i32);
pub const D3D12_MESSAGE_ID_DESTROY_COMMANDRECORDER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1117i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_RECORDER_VIDEO_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1118i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_RECORDER_INVALID_SUPPORT_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1119i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_RECORDER_INVALID_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1120i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_RECORDER_MORE_RECORDERS_THAN_LOGICAL_PROCESSORS:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1121i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMANDPOOL: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1122i32);
pub const D3D12_MESSAGE_ID_LIVE_COMMANDPOOL: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1123i32);
pub const D3D12_MESSAGE_ID_DESTROY_COMMANDPOOL: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1124i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_POOL_INVALID_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1125i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_LIST_VIDEO_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1126i32);
pub const D3D12_MESSAGE_ID_COMMAND_RECORDER_SUPPORT_FLAGS_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1127i32);
pub const D3D12_MESSAGE_ID_COMMAND_RECORDER_CONTENTION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1128i32);
pub const D3D12_MESSAGE_ID_COMMAND_RECORDER_USAGE_WITH_CREATECOMMANDLIST_COMMAND_LIST:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1129i32);
pub const D3D12_MESSAGE_ID_COMMAND_ALLOCATOR_USAGE_WITH_CREATECOMMANDLIST1_COMMAND_LIST:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1130i32);
pub const D3D12_MESSAGE_ID_CANNOT_EXECUTE_EMPTY_COMMAND_LIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1131i32);
pub const D3D12_MESSAGE_ID_CANNOT_RESET_COMMAND_POOL_WITH_OPEN_COMMAND_LISTS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1132i32);
pub const D3D12_MESSAGE_ID_CANNOT_USE_COMMAND_RECORDER_WITHOUT_CURRENT_TARGET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1133i32);
pub const D3D12_MESSAGE_ID_CANNOT_CHANGE_COMMAND_RECORDER_TARGET_WHILE_RECORDING: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1134i32);
pub const D3D12_MESSAGE_ID_COMMAND_POOL_SYNC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1135i32);
pub const D3D12_MESSAGE_ID_EVICT_UNDERFLOW: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1136i32);
pub const D3D12_MESSAGE_ID_CREATE_META_COMMAND: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1137i32);
pub const D3D12_MESSAGE_ID_LIVE_META_COMMAND: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1138i32);
pub const D3D12_MESSAGE_ID_DESTROY_META_COMMAND: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1139i32);
pub const D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALID_DST_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1140i32);
pub const D3D12_MESSAGE_ID_COPYBUFFERREGION_INVALID_SRC_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1141i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_DST_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1142i32);
pub const D3D12_MESSAGE_ID_ATOMICCOPYBUFFER_INVALID_SRC_RESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1143i32);
pub const D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_NULL_BUFFER: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1144i32);
pub const D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_NULL_RESOURCE_DESC: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1145i32);
pub const D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1146i32);
pub const D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_INVALID_BUFFER_DIMENSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1147i32);
pub const D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_INVALID_BUFFER_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1148i32);
pub const D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_INVALID_BUFFER_OFFSET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1149i32);
pub const D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_INVALID_RESOURCE_DIMENSION:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1150i32);
pub const D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_INVALID_RESOURCE_FLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1151i32);
pub const D3D12_MESSAGE_ID_CREATEPLACEDRESOURCEONBUFFER_OUTOFMEMORY_RETURN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1152i32);
pub const D3D12_MESSAGE_ID_CANNOT_CREATE_GRAPHICS_AND_VIDEO_COMMAND_RECORDER: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1153i32);
pub const D3D12_MESSAGE_ID_UPDATETILEMAPPINGS_POSSIBLY_MISMATCHING_PROPERTIES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1154i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_LIST_INVALID_COMMAND_LIST_TYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1155i32);
pub const D3D12_MESSAGE_ID_CLEARUNORDEREDACCESSVIEW_INCOMPATIBLE_WITH_STRUCTURED_BUFFERS:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1156i32);
pub const D3D12_MESSAGE_ID_COMPUTE_ONLY_DEVICE_OPERATION_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1157i32);
pub const D3D12_MESSAGE_ID_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1158i32);
pub const D3D12_MESSAGE_ID_EMIT_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_INVALID:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1159i32);
pub const D3D12_MESSAGE_ID_COPY_RAYTRACING_ACCELERATION_STRUCTURE_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1160i32);
pub const D3D12_MESSAGE_ID_DISPATCH_RAYS_INVALID: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1161i32);
pub const D3D12_MESSAGE_ID_GET_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO_INVALID:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1162i32);
pub const D3D12_MESSAGE_ID_CREATE_LIFETIMETRACKER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1163i32);
pub const D3D12_MESSAGE_ID_LIVE_LIFETIMETRACKER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1164i32);
pub const D3D12_MESSAGE_ID_DESTROY_LIFETIMETRACKER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1165i32);
pub const D3D12_MESSAGE_ID_DESTROYOWNEDOBJECT_OBJECTNOTOWNED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1166i32);
pub const D3D12_MESSAGE_ID_CREATE_TRACKEDWORKLOAD: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1167i32);
pub const D3D12_MESSAGE_ID_LIVE_TRACKEDWORKLOAD: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1168i32);
pub const D3D12_MESSAGE_ID_DESTROY_TRACKEDWORKLOAD: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1169i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_ERROR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1170i32);
pub const D3D12_MESSAGE_ID_META_COMMAND_ID_INVALID: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1171i32);
pub const D3D12_MESSAGE_ID_META_COMMAND_UNSUPPORTED_PARAMS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1172i32);
pub const D3D12_MESSAGE_ID_META_COMMAND_FAILED_ENUMERATION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1173i32);
pub const D3D12_MESSAGE_ID_META_COMMAND_PARAMETER_SIZE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1174i32);
pub const D3D12_MESSAGE_ID_UNINITIALIZED_META_COMMAND: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1175i32);
pub const D3D12_MESSAGE_ID_META_COMMAND_INVALID_GPU_VIRTUAL_ADDRESS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1176i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOENCODECOMMANDLIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1177i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOENCODECOMMANDLIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1178i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOENCODECOMMANDLIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1179i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOENCODECOMMANDQUEUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1180i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOENCODECOMMANDQUEUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1181i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOENCODECOMMANDQUEUE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1182i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOMOTIONESTIMATOR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1183i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOMOTIONESTIMATOR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1184i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOMOTIONESTIMATOR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1185i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOMOTIONVECTORHEAP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1186i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOMOTIONVECTORHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1187i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOMOTIONVECTORHEAP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1188i32);
pub const D3D12_MESSAGE_ID_MULTIPLE_TRACKED_WORKLOADS: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1189i32);
pub const D3D12_MESSAGE_ID_MULTIPLE_TRACKED_WORKLOAD_PAIRS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1190i32);
pub const D3D12_MESSAGE_ID_OUT_OF_ORDER_TRACKED_WORKLOAD_PAIR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1191i32);
pub const D3D12_MESSAGE_ID_CANNOT_ADD_TRACKED_WORKLOAD: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1192i32);
pub const D3D12_MESSAGE_ID_INCOMPLETE_TRACKED_WORKLOAD_PAIR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1193i32);
pub const D3D12_MESSAGE_ID_CREATE_STATE_OBJECT_ERROR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1194i32);
pub const D3D12_MESSAGE_ID_GET_SHADER_IDENTIFIER_ERROR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1195i32);
pub const D3D12_MESSAGE_ID_GET_SHADER_STACK_SIZE_ERROR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1196i32);
pub const D3D12_MESSAGE_ID_GET_PIPELINE_STACK_SIZE_ERROR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1197i32);
pub const D3D12_MESSAGE_ID_SET_PIPELINE_STACK_SIZE_ERROR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1198i32);
pub const D3D12_MESSAGE_ID_GET_SHADER_IDENTIFIER_SIZE_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1199i32);
pub const D3D12_MESSAGE_ID_CHECK_DRIVER_MATCHING_IDENTIFIER_INVALID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1200i32);
pub const D3D12_MESSAGE_ID_CHECK_DRIVER_MATCHING_IDENTIFIER_DRIVER_REPORTED_ISSUE:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1201i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_INVALID_RESOURCE_BARRIER: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1202i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_DISALLOWED_API_CALLED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1203i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_CANNOT_NEST_RENDER_PASSES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1204i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_CANNOT_END_WITHOUT_BEGIN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1205i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_CANNOT_CLOSE_COMMAND_LIST: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1206i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_GPU_WORK_WHILE_SUSPENDED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1207i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_MISMATCHING_SUSPEND_RESUME: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1208i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_NO_PRIOR_SUSPEND_WITHIN_EXECUTECOMMANDLISTS:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1209i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_NO_SUBSEQUENT_RESUME_WITHIN_EXECUTECOMMANDLISTS:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1210i32);
pub const D3D12_MESSAGE_ID_TRACKED_WORKLOAD_COMMAND_QUEUE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1211i32);
pub const D3D12_MESSAGE_ID_TRACKED_WORKLOAD_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1212i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_MISMATCHING_NO_ACCESS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1213i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_UNSUPPORTED_RESOLVE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1214i32);
pub const D3D12_MESSAGE_ID_CLEARUNORDEREDACCESSVIEW_INVALID_RESOURCE_PTR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1215i32);
pub const D3D12_MESSAGE_ID_WINDOWS7_FENCE_OUTOFORDER_SIGNAL: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1216i32);
pub const D3D12_MESSAGE_ID_WINDOWS7_FENCE_OUTOFORDER_WAIT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1217i32);
pub const D3D12_MESSAGE_ID_VIDEO_CREATE_MOTION_ESTIMATOR_INVALID_ARGUMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1218i32);
pub const D3D12_MESSAGE_ID_VIDEO_CREATE_MOTION_VECTOR_HEAP_INVALID_ARGUMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1219i32);
pub const D3D12_MESSAGE_ID_ESTIMATE_MOTION_INVALID_ARGUMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1220i32);
pub const D3D12_MESSAGE_ID_RESOLVE_MOTION_VECTOR_HEAP_INVALID_ARGUMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1221i32);
pub const D3D12_MESSAGE_ID_GETGPUVIRTUALADDRESS_INVALID_HEAP_TYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1222i32);
pub const D3D12_MESSAGE_ID_SET_BACKGROUND_PROCESSING_MODE_INVALID_ARGUMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1223i32);
pub const D3D12_MESSAGE_ID_CREATE_COMMAND_LIST_INVALID_COMMAND_LIST_TYPE_FOR_FEATURE_LEVEL:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1224i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOEXTENSIONCOMMAND: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1225i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOEXTENSIONCOMMAND: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1226i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOEXTENSIONCOMMAND: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1227i32);
pub const D3D12_MESSAGE_ID_INVALID_VIDEO_EXTENSION_COMMAND_ID: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1228i32);
pub const D3D12_MESSAGE_ID_VIDEO_EXTENSION_COMMAND_INVALID_ARGUMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1229i32);
pub const D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_NOT_UNIQUE_IN_DXIL_LIBRARY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1230i32);
pub const D3D12_MESSAGE_ID_VARIABLE_SHADING_RATE_NOT_ALLOWED_WITH_TIR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1231i32);
pub const D3D12_MESSAGE_ID_GEOMETRY_SHADER_OUTPUTTING_BOTH_VIEWPORT_ARRAY_INDEX_AND_SHADING_RATE_NOT_SUPPORTED_ON_DEVICE : D3D12_MESSAGE_ID = D3D12_MESSAGE_ID ( 1232i32 ) ;
pub const D3D12_MESSAGE_ID_RSSETSHADING_RATE_INVALID_SHADING_RATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1233i32);
pub const D3D12_MESSAGE_ID_RSSETSHADING_RATE_SHADING_RATE_NOT_PERMITTED_BY_CAP: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1234i32);
pub const D3D12_MESSAGE_ID_RSSETSHADING_RATE_INVALID_COMBINER: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1235i32);
pub const D3D12_MESSAGE_ID_RSSETSHADINGRATEIMAGE_REQUIRES_TIER_2: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1236i32);
pub const D3D12_MESSAGE_ID_RSSETSHADINGRATE_REQUIRES_TIER_1: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1237i32);
pub const D3D12_MESSAGE_ID_SHADING_RATE_IMAGE_INCORRECT_FORMAT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1238i32);
pub const D3D12_MESSAGE_ID_SHADING_RATE_IMAGE_INCORRECT_ARRAY_SIZE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1239i32);
pub const D3D12_MESSAGE_ID_SHADING_RATE_IMAGE_INCORRECT_MIP_LEVEL: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1240i32);
pub const D3D12_MESSAGE_ID_SHADING_RATE_IMAGE_INCORRECT_SAMPLE_COUNT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1241i32);
pub const D3D12_MESSAGE_ID_SHADING_RATE_IMAGE_INCORRECT_SAMPLE_QUALITY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1242i32);
pub const D3D12_MESSAGE_ID_NON_RETAIL_SHADER_MODEL_WONT_VALIDATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1243i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_AS_ROOT_SIGNATURE_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1244i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_MS_ROOT_SIGNATURE_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1245i32);
pub const D3D12_MESSAGE_ID_ADD_TO_STATE_OBJECT_ERROR: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1246i32);
pub const D3D12_MESSAGE_ID_CREATE_PROTECTED_RESOURCE_SESSION_INVALID_ARGUMENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1247i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_MS_PSO_DESC_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1248i32);
pub const D3D12_MESSAGE_ID_CREATEPIPELINESTATE_MS_INCOMPLETE_TYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1249i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_AS_NOT_MS_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1250i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_MS_NOT_PS_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1251i32);
pub const D3D12_MESSAGE_ID_NONZERO_SAMPLER_FEEDBACK_MIP_REGION_WITH_INCOMPATIBLE_FORMAT:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1252i32);
pub const D3D12_MESSAGE_ID_CREATEGRAPHICSPIPELINESTATE_INPUTLAYOUT_SHADER_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1253i32);
pub const D3D12_MESSAGE_ID_EMPTY_DISPATCH: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1254i32);
pub const D3D12_MESSAGE_ID_RESOURCE_FORMAT_REQUIRES_SAMPLER_FEEDBACK_CAPABILITY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1255i32);
pub const D3D12_MESSAGE_ID_SAMPLER_FEEDBACK_MAP_INVALID_MIP_REGION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1256i32);
pub const D3D12_MESSAGE_ID_SAMPLER_FEEDBACK_MAP_INVALID_DIMENSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1257i32);
pub const D3D12_MESSAGE_ID_SAMPLER_FEEDBACK_MAP_INVALID_SAMPLE_COUNT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1258i32);
pub const D3D12_MESSAGE_ID_SAMPLER_FEEDBACK_MAP_INVALID_SAMPLE_QUALITY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1259i32);
pub const D3D12_MESSAGE_ID_SAMPLER_FEEDBACK_MAP_INVALID_LAYOUT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1260i32);
pub const D3D12_MESSAGE_ID_SAMPLER_FEEDBACK_MAP_REQUIRES_UNORDERED_ACCESS_FLAG: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1261i32);
pub const D3D12_MESSAGE_ID_SAMPLER_FEEDBACK_CREATE_UAV_NULL_ARGUMENTS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1262i32);
pub const D3D12_MESSAGE_ID_SAMPLER_FEEDBACK_UAV_REQUIRES_SAMPLER_FEEDBACK_CAPABILITY:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1263i32);
pub const D3D12_MESSAGE_ID_SAMPLER_FEEDBACK_CREATE_UAV_REQUIRES_FEEDBACK_MAP_FORMAT:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1264i32);
pub const D3D12_MESSAGE_ID_CREATEMESHSHADER_INVALIDSHADERBYTECODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1265i32);
pub const D3D12_MESSAGE_ID_CREATEMESHSHADER_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1266i32);
pub const D3D12_MESSAGE_ID_CREATEMESHSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1267i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_SAMPLER_FEEDBACK_TRANSCODE_INVALID_FORMAT:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1268i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_SAMPLER_FEEDBACK_INVALID_MIP_LEVEL_COUNT:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1269i32);
pub const D3D12_MESSAGE_ID_RESOLVESUBRESOURCE_SAMPLER_FEEDBACK_TRANSCODE_ARRAY_SIZE_MISMATCH:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1270i32);
pub const D3D12_MESSAGE_ID_SAMPLER_FEEDBACK_CREATE_UAV_MISMATCHING_TARGETED_RESOURCE:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1271i32);
pub const D3D12_MESSAGE_ID_CREATEMESHSHADER_OUTPUTEXCEEDSMAXSIZE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1272i32);
pub const D3D12_MESSAGE_ID_CREATEMESHSHADER_GROUPSHAREDEXCEEDSMAXSIZE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1273i32);
pub const D3D12_MESSAGE_ID_VERTEX_SHADER_OUTPUTTING_BOTH_VIEWPORT_ARRAY_INDEX_AND_SHADING_RATE_NOT_SUPPORTED_ON_DEVICE : D3D12_MESSAGE_ID = D3D12_MESSAGE_ID ( 1274i32 ) ;
pub const D3D12_MESSAGE_ID_MESH_SHADER_OUTPUTTING_BOTH_VIEWPORT_ARRAY_INDEX_AND_SHADING_RATE_NOT_SUPPORTED_ON_DEVICE : D3D12_MESSAGE_ID = D3D12_MESSAGE_ID ( 1275i32 ) ;
pub const D3D12_MESSAGE_ID_CREATEMESHSHADER_MISMATCHEDASMSPAYLOADSIZE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1276i32);
pub const D3D12_MESSAGE_ID_CREATE_ROOT_SIGNATURE_UNBOUNDED_STATIC_DESCRIPTORS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1277i32);
pub const D3D12_MESSAGE_ID_CREATEAMPLIFICATIONSHADER_INVALIDSHADERBYTECODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1278i32);
pub const D3D12_MESSAGE_ID_CREATEAMPLIFICATIONSHADER_OUTOFMEMORY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1279i32);
pub const D3D12_MESSAGE_ID_CREATE_SHADERCACHESESSION: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1280i32);
pub const D3D12_MESSAGE_ID_LIVE_SHADERCACHESESSION: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1281i32);
pub const D3D12_MESSAGE_ID_DESTROY_SHADERCACHESESSION: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1282i32);
pub const D3D12_MESSAGE_ID_CREATESHADERCACHESESSION_INVALIDARGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1283i32);
pub const D3D12_MESSAGE_ID_CREATESHADERCACHESESSION_DISABLED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1284i32);
pub const D3D12_MESSAGE_ID_CREATESHADERCACHESESSION_ALREADYOPEN: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1285i32);
pub const D3D12_MESSAGE_ID_SHADERCACHECONTROL_DEVELOPERMODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1286i32);
pub const D3D12_MESSAGE_ID_SHADERCACHECONTROL_INVALIDFLAGS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1287i32);
pub const D3D12_MESSAGE_ID_SHADERCACHECONTROL_STATEALREADYSET: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1288i32);
pub const D3D12_MESSAGE_ID_SHADERCACHECONTROL_IGNOREDFLAG: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1289i32);
pub const D3D12_MESSAGE_ID_SHADERCACHESESSION_STOREVALUE_ALREADYPRESENT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1290i32);
pub const D3D12_MESSAGE_ID_SHADERCACHESESSION_STOREVALUE_HASHCOLLISION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1291i32);
pub const D3D12_MESSAGE_ID_SHADERCACHESESSION_STOREVALUE_CACHEFULL: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1292i32);
pub const D3D12_MESSAGE_ID_SHADERCACHESESSION_FINDVALUE_NOTFOUND: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1293i32);
pub const D3D12_MESSAGE_ID_SHADERCACHESESSION_CORRUPT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1294i32);
pub const D3D12_MESSAGE_ID_SHADERCACHESESSION_DISABLED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1295i32);
pub const D3D12_MESSAGE_ID_OVERSIZED_DISPATCH: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1296i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOENCODER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1297i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOENCODER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1298i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOENCODER: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1299i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEOENCODERHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1300i32);
pub const D3D12_MESSAGE_ID_LIVE_VIDEOENCODERHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1301i32);
pub const D3D12_MESSAGE_ID_DESTROY_VIDEOENCODERHEAP: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1302i32);
pub const D3D12_MESSAGE_ID_COPYTEXTUREREGION_MISMATCH_ENCODE_REFERENCE_ONLY_FLAG: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1303i32);
pub const D3D12_MESSAGE_ID_COPYRESOURCE_MISMATCH_ENCODE_REFERENCE_ONLY_FLAG: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1304i32);
pub const D3D12_MESSAGE_ID_ENCODE_FRAME_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1305i32);
pub const D3D12_MESSAGE_ID_ENCODE_FRAME_UNSUPPORTED_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1306i32);
pub const D3D12_MESSAGE_ID_RESOLVE_ENCODER_OUTPUT_METADATA_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1307i32);
pub const D3D12_MESSAGE_ID_RESOLVE_ENCODER_OUTPUT_METADATA_UNSUPPORTED_PARAMETERS:
    D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1308i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEO_ENCODER_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1309i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEO_ENCODER_UNSUPPORTED_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1310i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEO_ENCODER_HEAP_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1311i32);
pub const D3D12_MESSAGE_ID_CREATE_VIDEO_ENCODER_HEAP_UNSUPPORTED_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1312i32);
pub const D3D12_MESSAGE_ID_CREATECOMMANDLIST_NULL_COMMANDALLOCATOR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1313i32);
pub const D3D12_MESSAGE_ID_CLEAR_UNORDERED_ACCESS_VIEW_INVALID_DESCRIPTOR_HANDLE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1314i32);
pub const D3D12_MESSAGE_ID_DESCRIPTOR_HEAP_NOT_SHADER_VISIBLE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1315i32);
pub const D3D12_MESSAGE_ID_CREATEBLENDSTATE_BLENDOP_WARNING: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1316i32);
pub const D3D12_MESSAGE_ID_CREATEBLENDSTATE_BLENDOPALPHA_WARNING: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1317i32);
pub const D3D12_MESSAGE_ID_WRITE_COMBINE_PERFORMANCE_WARNING: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1318i32);
pub const D3D12_MESSAGE_ID_RESOLVE_QUERY_INVALID_QUERY_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1319i32);
pub const D3D12_MESSAGE_ID_SETPRIVATEDATA_NO_ACCESS: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1320i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_STATIC_DESCRIPTOR_SAMPLER_MODE_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1321i32);
pub const D3D12_MESSAGE_ID_GETCOPYABLEFOOTPRINTS_UNSUPPORTED_BUFFER_WIDTH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1322i32);
pub const D3D12_MESSAGE_ID_CREATEMESHSHADER_TOPOLOGY_MISMATCH: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1323i32);
pub const D3D12_MESSAGE_ID_VRS_SUM_COMBINER_REQUIRES_CAPABILITY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1324i32);
pub const D3D12_MESSAGE_ID_SETTING_SHADING_RATE_FROM_MS_REQUIRES_CAPABILITY: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1325i32);
pub const D3D12_MESSAGE_ID_SHADERCACHESESSION_SHADERCACHEDELETE_NOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1326i32);
pub const D3D12_MESSAGE_ID_SHADERCACHECONTROL_SHADERCACHECLEAR_NOTSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1327i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_STATE_IGNORED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1328i32);
pub const D3D12_MESSAGE_ID_UNUSED_CROSS_EXECUTE_SPLIT_BARRIER: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1329i32);
pub const D3D12_MESSAGE_ID_DEVICE_OPEN_SHARED_HANDLE_ACCESS_DENIED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1330i32);
pub const D3D12_MESSAGE_ID_INCOMPATIBLE_BARRIER_VALUES: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1331i32);
pub const D3D12_MESSAGE_ID_INCOMPATIBLE_BARRIER_ACCESS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1332i32);
pub const D3D12_MESSAGE_ID_INCOMPATIBLE_BARRIER_SYNC: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1333i32);
pub const D3D12_MESSAGE_ID_INCOMPATIBLE_BARRIER_LAYOUT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1334i32);
pub const D3D12_MESSAGE_ID_INCOMPATIBLE_BARRIER_TYPE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1335i32);
pub const D3D12_MESSAGE_ID_OUT_OF_BOUNDS_BARRIER_SUBRESOURCE_RANGE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1336i32);
pub const D3D12_MESSAGE_ID_INCOMPATIBLE_BARRIER_RESOURCE_DIMENSION: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1337i32);
pub const D3D12_MESSAGE_ID_SET_SCISSOR_RECTS_INVALID_RECT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1338i32);
pub const D3D12_MESSAGE_ID_SHADING_RATE_SOURCE_REQUIRES_DIMENSION_TEXTURE2D: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1339i32);
pub const D3D12_MESSAGE_ID_BUFFER_BARRIER_SUBREGION_OUT_OF_BOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1340i32);
pub const D3D12_MESSAGE_ID_UNSUPPORTED_BARRIER_LAYOUT: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1341i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALID_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1342i32);
pub const D3D12_MESSAGE_ID_ENHANCED_BARRIERS_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1343i32);
pub const D3D12_MESSAGE_ID_LEGACY_BARRIER_VALIDATION_FORCED_ON: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1346i32);
pub const D3D12_MESSAGE_ID_EMPTY_ROOT_DESCRIPTOR_TABLE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1347i32);
pub const D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_ELEMENT_OFFSET_UNALIGNED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1348i32);
pub const D3D12_MESSAGE_ID_ALPHA_BLEND_FACTOR_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1349i32);
pub const D3D12_MESSAGE_ID_BARRIER_INTEROP_INVALID_LAYOUT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1350i32);
pub const D3D12_MESSAGE_ID_BARRIER_INTEROP_INVALID_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1351i32);
pub const D3D12_MESSAGE_ID_GRAPHICS_PIPELINE_STATE_DESC_ZERO_SAMPLE_MASK: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1352i32);
pub const D3D12_MESSAGE_ID_INDEPENDENT_STENCIL_REF_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1353i32);
pub const D3D12_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INDEPENDENT_MASKS_UNSUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1354i32);
pub const D3D12_MESSAGE_ID_TEXTURE_BARRIER_SUBRESOURCES_OUT_OF_BOUNDS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1355i32);
pub const D3D12_MESSAGE_ID_NON_OPTIMAL_BARRIER_ONLY_EXECUTE_COMMAND_LISTS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1356i32);
pub const D3D12_MESSAGE_ID_EXECUTE_INDIRECT_ZERO_COMMAND_COUNT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1357i32);
pub const D3D12_MESSAGE_ID_GPU_BASED_VALIDATION_INCOMPATIBLE_TEXTURE_LAYOUT: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1358i32);
pub const D3D12_MESSAGE_ID_DYNAMIC_INDEX_BUFFER_STRIP_CUT_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1359i32);
pub const D3D12_MESSAGE_ID_PRIMITIVE_TOPOLOGY_TRIANGLE_FANS_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1360i32);
pub const D3D12_MESSAGE_ID_CREATE_SAMPLER_COMPARISON_FUNC_IGNORED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1361i32);
pub const D3D12_MESSAGE_ID_CREATEHEAP_INVALIDHEAPTYPE: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1362i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCEANDHEAP_INVALIDHEAPTYPE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1363i32);
pub const D3D12_MESSAGE_ID_DYNAMIC_DEPTH_BIAS_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1364i32);
pub const D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_NON_WHOLE_DYNAMIC_DEPTH_BIAS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1365i32);
pub const D3D12_MESSAGE_ID_DYNAMIC_DEPTH_BIAS_FLAG_MISSING: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1366i32);
pub const D3D12_MESSAGE_ID_DYNAMIC_DEPTH_BIAS_NO_PIPELINE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1367i32);
pub const D3D12_MESSAGE_ID_DYNAMIC_INDEX_BUFFER_STRIP_CUT_FLAG_MISSING: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1368i32);
pub const D3D12_MESSAGE_ID_DYNAMIC_INDEX_BUFFER_STRIP_CUT_NO_PIPELINE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1369i32);
pub const D3D12_MESSAGE_ID_NONNORMALIZED_COORDINATE_SAMPLING_NOT_SUPPORTED: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1370i32);
pub const D3D12_MESSAGE_ID_INVALID_CAST_TARGET: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1371i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_COMMANDLIST_INVALID_END_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1372i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_COMMANDLIST_INVALID_START_STATE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1373i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_MISMATCHING_ACCESS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1374i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_MISMATCHING_LOCAL_PRESERVE_PARAMETERS: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1375i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_LOCAL_PRESERVE_RENDER_PARAMETERS_ERROR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1376i32);
pub const D3D12_MESSAGE_ID_RENDER_PASS_LOCAL_DEPTH_STENCIL_ERROR: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1377i32);
pub const D3D12_MESSAGE_ID_DRAW_POTENTIALLY_OUTSIDE_OF_VALID_RENDER_AREA: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1378i32);
pub const D3D12_MESSAGE_ID_CREATERASTERIZERSTATE_INVALID_LINERASTERIZATIONMODE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1379i32);
pub const D3D12_MESSAGE_ID_CREATERESOURCE_INVALIDALIGNMENT_SMALLRESOURCE: D3D12_MESSAGE_ID =
    D3D12_MESSAGE_ID(1380i32);
pub const D3D12_MESSAGE_ID_D3D12_MESSAGES_END: D3D12_MESSAGE_ID = D3D12_MESSAGE_ID(1381i32);
impl ::core::marker::Copy for D3D12_MESSAGE_ID {}
impl ::core::clone::Clone for D3D12_MESSAGE_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_MESSAGE_ID {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_MESSAGE_ID {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_MESSAGE_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_MESSAGE_ID").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_MESSAGE_SEVERITY(pub i32);
pub const D3D12_MESSAGE_SEVERITY_CORRUPTION: D3D12_MESSAGE_SEVERITY = D3D12_MESSAGE_SEVERITY(0i32);
pub const D3D12_MESSAGE_SEVERITY_ERROR: D3D12_MESSAGE_SEVERITY = D3D12_MESSAGE_SEVERITY(1i32);
pub const D3D12_MESSAGE_SEVERITY_WARNING: D3D12_MESSAGE_SEVERITY = D3D12_MESSAGE_SEVERITY(2i32);
pub const D3D12_MESSAGE_SEVERITY_INFO: D3D12_MESSAGE_SEVERITY = D3D12_MESSAGE_SEVERITY(3i32);
pub const D3D12_MESSAGE_SEVERITY_MESSAGE: D3D12_MESSAGE_SEVERITY = D3D12_MESSAGE_SEVERITY(4i32);
impl ::core::marker::Copy for D3D12_MESSAGE_SEVERITY {}
impl ::core::clone::Clone for D3D12_MESSAGE_SEVERITY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_MESSAGE_SEVERITY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_MESSAGE_SEVERITY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_MESSAGE_SEVERITY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_MESSAGE_SEVERITY")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_META_COMMAND_PARAMETER_FLAGS(pub i32);
pub const D3D12_META_COMMAND_PARAMETER_FLAG_INPUT: D3D12_META_COMMAND_PARAMETER_FLAGS =
    D3D12_META_COMMAND_PARAMETER_FLAGS(1i32);
pub const D3D12_META_COMMAND_PARAMETER_FLAG_OUTPUT: D3D12_META_COMMAND_PARAMETER_FLAGS =
    D3D12_META_COMMAND_PARAMETER_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_META_COMMAND_PARAMETER_FLAGS {}
impl ::core::clone::Clone for D3D12_META_COMMAND_PARAMETER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_META_COMMAND_PARAMETER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_META_COMMAND_PARAMETER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_META_COMMAND_PARAMETER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_META_COMMAND_PARAMETER_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_META_COMMAND_PARAMETER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_META_COMMAND_PARAMETER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_META_COMMAND_PARAMETER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_META_COMMAND_PARAMETER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_META_COMMAND_PARAMETER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_META_COMMAND_PARAMETER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_META_COMMAND_PARAMETER_STAGE(pub i32);
pub const D3D12_META_COMMAND_PARAMETER_STAGE_CREATION: D3D12_META_COMMAND_PARAMETER_STAGE =
    D3D12_META_COMMAND_PARAMETER_STAGE(0i32);
pub const D3D12_META_COMMAND_PARAMETER_STAGE_INITIALIZATION: D3D12_META_COMMAND_PARAMETER_STAGE =
    D3D12_META_COMMAND_PARAMETER_STAGE(1i32);
pub const D3D12_META_COMMAND_PARAMETER_STAGE_EXECUTION: D3D12_META_COMMAND_PARAMETER_STAGE =
    D3D12_META_COMMAND_PARAMETER_STAGE(2i32);
impl ::core::marker::Copy for D3D12_META_COMMAND_PARAMETER_STAGE {}
impl ::core::clone::Clone for D3D12_META_COMMAND_PARAMETER_STAGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_META_COMMAND_PARAMETER_STAGE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_META_COMMAND_PARAMETER_STAGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_META_COMMAND_PARAMETER_STAGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_META_COMMAND_PARAMETER_STAGE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_META_COMMAND_PARAMETER_TYPE(pub i32);
pub const D3D12_META_COMMAND_PARAMETER_TYPE_FLOAT: D3D12_META_COMMAND_PARAMETER_TYPE =
    D3D12_META_COMMAND_PARAMETER_TYPE(0i32);
pub const D3D12_META_COMMAND_PARAMETER_TYPE_UINT64: D3D12_META_COMMAND_PARAMETER_TYPE =
    D3D12_META_COMMAND_PARAMETER_TYPE(1i32);
pub const D3D12_META_COMMAND_PARAMETER_TYPE_GPU_VIRTUAL_ADDRESS: D3D12_META_COMMAND_PARAMETER_TYPE =
    D3D12_META_COMMAND_PARAMETER_TYPE(2i32);
pub const D3D12_META_COMMAND_PARAMETER_TYPE_CPU_DESCRIPTOR_HANDLE_HEAP_TYPE_CBV_SRV_UAV:
    D3D12_META_COMMAND_PARAMETER_TYPE = D3D12_META_COMMAND_PARAMETER_TYPE(3i32);
pub const D3D12_META_COMMAND_PARAMETER_TYPE_GPU_DESCRIPTOR_HANDLE_HEAP_TYPE_CBV_SRV_UAV:
    D3D12_META_COMMAND_PARAMETER_TYPE = D3D12_META_COMMAND_PARAMETER_TYPE(4i32);
impl ::core::marker::Copy for D3D12_META_COMMAND_PARAMETER_TYPE {}
impl ::core::clone::Clone for D3D12_META_COMMAND_PARAMETER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_META_COMMAND_PARAMETER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_META_COMMAND_PARAMETER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_META_COMMAND_PARAMETER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_META_COMMAND_PARAMETER_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_MULTIPLE_FENCE_WAIT_FLAGS(pub i32);
pub const D3D12_MULTIPLE_FENCE_WAIT_FLAG_NONE: D3D12_MULTIPLE_FENCE_WAIT_FLAGS =
    D3D12_MULTIPLE_FENCE_WAIT_FLAGS(0i32);
pub const D3D12_MULTIPLE_FENCE_WAIT_FLAG_ANY: D3D12_MULTIPLE_FENCE_WAIT_FLAGS =
    D3D12_MULTIPLE_FENCE_WAIT_FLAGS(1i32);
pub const D3D12_MULTIPLE_FENCE_WAIT_FLAG_ALL: D3D12_MULTIPLE_FENCE_WAIT_FLAGS =
    D3D12_MULTIPLE_FENCE_WAIT_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_MULTIPLE_FENCE_WAIT_FLAGS {}
impl ::core::clone::Clone for D3D12_MULTIPLE_FENCE_WAIT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_MULTIPLE_FENCE_WAIT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_MULTIPLE_FENCE_WAIT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_MULTIPLE_FENCE_WAIT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_MULTIPLE_FENCE_WAIT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_MULTIPLE_FENCE_WAIT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_MULTIPLE_FENCE_WAIT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_MULTIPLE_FENCE_WAIT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_MULTIPLE_FENCE_WAIT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_MULTIPLE_FENCE_WAIT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_MULTIPLE_FENCE_WAIT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS(pub i32);
pub const D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_NONE: D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS =
    D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS(0i32);
pub const D3D12_MULTISAMPLE_QUALITY_LEVELS_FLAG_TILED_RESOURCE:
    D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS = D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {}
impl ::core::clone::Clone for D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_NODE_OVERRIDES_TYPE(pub i32);
pub const D3D12_NODE_OVERRIDES_TYPE_NONE: D3D12_NODE_OVERRIDES_TYPE =
    D3D12_NODE_OVERRIDES_TYPE(0i32);
pub const D3D12_NODE_OVERRIDES_TYPE_BROADCASTING_LAUNCH: D3D12_NODE_OVERRIDES_TYPE =
    D3D12_NODE_OVERRIDES_TYPE(1i32);
pub const D3D12_NODE_OVERRIDES_TYPE_COALESCING_LAUNCH: D3D12_NODE_OVERRIDES_TYPE =
    D3D12_NODE_OVERRIDES_TYPE(2i32);
pub const D3D12_NODE_OVERRIDES_TYPE_THREAD_LAUNCH: D3D12_NODE_OVERRIDES_TYPE =
    D3D12_NODE_OVERRIDES_TYPE(3i32);
impl ::core::marker::Copy for D3D12_NODE_OVERRIDES_TYPE {}
impl ::core::clone::Clone for D3D12_NODE_OVERRIDES_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_NODE_OVERRIDES_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_NODE_OVERRIDES_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_NODE_OVERRIDES_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_NODE_OVERRIDES_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_NODE_TYPE(pub i32);
pub const D3D12_NODE_TYPE_SHADER: D3D12_NODE_TYPE = D3D12_NODE_TYPE(0i32);
impl ::core::marker::Copy for D3D12_NODE_TYPE {}
impl ::core::clone::Clone for D3D12_NODE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_NODE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_NODE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_NODE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_NODE_TYPE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_PIPELINE_STATE_FLAGS(pub i32);
pub const D3D12_PIPELINE_STATE_FLAG_NONE: D3D12_PIPELINE_STATE_FLAGS =
    D3D12_PIPELINE_STATE_FLAGS(0i32);
pub const D3D12_PIPELINE_STATE_FLAG_TOOL_DEBUG: D3D12_PIPELINE_STATE_FLAGS =
    D3D12_PIPELINE_STATE_FLAGS(1i32);
pub const D3D12_PIPELINE_STATE_FLAG_DYNAMIC_DEPTH_BIAS: D3D12_PIPELINE_STATE_FLAGS =
    D3D12_PIPELINE_STATE_FLAGS(4i32);
pub const D3D12_PIPELINE_STATE_FLAG_DYNAMIC_INDEX_BUFFER_STRIP_CUT: D3D12_PIPELINE_STATE_FLAGS =
    D3D12_PIPELINE_STATE_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_PIPELINE_STATE_FLAGS {}
impl ::core::clone::Clone for D3D12_PIPELINE_STATE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_PIPELINE_STATE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_PIPELINE_STATE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_PIPELINE_STATE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_PIPELINE_STATE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_PIPELINE_STATE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_PIPELINE_STATE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_PIPELINE_STATE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_PIPELINE_STATE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_PIPELINE_STATE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_PIPELINE_STATE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(pub i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(0i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VS: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(1i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(2i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DS: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(3i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_HS: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(4i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_GS: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(5i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CS: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(6i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(7i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_BLEND: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(8i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_MASK: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(9i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(10i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(11i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(12i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE:
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE = D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(13i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY:
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE = D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(14i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS:
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE = D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(15i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT:
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE = D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(16i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(17i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_NODE_MASK: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(18i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_CACHED_PSO: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(19i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_FLAGS: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(20i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(21i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(22i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_AS: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(24i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MS: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(25i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL2: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(26i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER1: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(27i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_RASTERIZER2: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(28i32);
pub const D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_MAX_VALID: D3D12_PIPELINE_STATE_SUBOBJECT_TYPE =
    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE(29i32);
impl ::core::marker::Copy for D3D12_PIPELINE_STATE_SUBOBJECT_TYPE {}
impl ::core::clone::Clone for D3D12_PIPELINE_STATE_SUBOBJECT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_PIPELINE_STATE_SUBOBJECT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_PIPELINE_STATE_SUBOBJECT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_PIPELINE_STATE_SUBOBJECT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_PIPELINE_STATE_SUBOBJECT_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_PREDICATION_OP(pub i32);
pub const D3D12_PREDICATION_OP_EQUAL_ZERO: D3D12_PREDICATION_OP = D3D12_PREDICATION_OP(0i32);
pub const D3D12_PREDICATION_OP_NOT_EQUAL_ZERO: D3D12_PREDICATION_OP = D3D12_PREDICATION_OP(1i32);
impl ::core::marker::Copy for D3D12_PREDICATION_OP {}
impl ::core::clone::Clone for D3D12_PREDICATION_OP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_PREDICATION_OP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_PREDICATION_OP {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_PREDICATION_OP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_PREDICATION_OP")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_PRIMITIVE_TOPOLOGY_TYPE(pub i32);
pub const D3D12_PRIMITIVE_TOPOLOGY_TYPE_UNDEFINED: D3D12_PRIMITIVE_TOPOLOGY_TYPE =
    D3D12_PRIMITIVE_TOPOLOGY_TYPE(0i32);
pub const D3D12_PRIMITIVE_TOPOLOGY_TYPE_POINT: D3D12_PRIMITIVE_TOPOLOGY_TYPE =
    D3D12_PRIMITIVE_TOPOLOGY_TYPE(1i32);
pub const D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE: D3D12_PRIMITIVE_TOPOLOGY_TYPE =
    D3D12_PRIMITIVE_TOPOLOGY_TYPE(2i32);
pub const D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE: D3D12_PRIMITIVE_TOPOLOGY_TYPE =
    D3D12_PRIMITIVE_TOPOLOGY_TYPE(3i32);
pub const D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH: D3D12_PRIMITIVE_TOPOLOGY_TYPE =
    D3D12_PRIMITIVE_TOPOLOGY_TYPE(4i32);
impl ::core::marker::Copy for D3D12_PRIMITIVE_TOPOLOGY_TYPE {}
impl ::core::clone::Clone for D3D12_PRIMITIVE_TOPOLOGY_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_PRIMITIVE_TOPOLOGY_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_PRIMITIVE_TOPOLOGY_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_PRIMITIVE_TOPOLOGY_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_PRIMITIVE_TOPOLOGY_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER(pub i32);
pub const D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER_NOT_SUPPORTED:
    D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER = D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER(0i32);
pub const D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER_1: D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER =
    D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER(1i32);
pub const D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER_2: D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER =
    D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER(2i32);
impl ::core::marker::Copy for D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER {}
impl ::core::clone::Clone for D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_PROGRAM_TYPE(pub i32);
pub const D3D12_PROGRAM_TYPE_GENERIC_PIPELINE: D3D12_PROGRAM_TYPE = D3D12_PROGRAM_TYPE(1i32);
pub const D3D12_PROGRAM_TYPE_RAYTRACING_PIPELINE: D3D12_PROGRAM_TYPE = D3D12_PROGRAM_TYPE(4i32);
pub const D3D12_PROGRAM_TYPE_WORK_GRAPH: D3D12_PROGRAM_TYPE = D3D12_PROGRAM_TYPE(5i32);
impl ::core::marker::Copy for D3D12_PROGRAM_TYPE {}
impl ::core::clone::Clone for D3D12_PROGRAM_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_PROGRAM_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_PROGRAM_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_PROGRAM_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_PROGRAM_TYPE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_PROTECTED_RESOURCE_SESSION_FLAGS(pub i32);
pub const D3D12_PROTECTED_RESOURCE_SESSION_FLAG_NONE: D3D12_PROTECTED_RESOURCE_SESSION_FLAGS =
    D3D12_PROTECTED_RESOURCE_SESSION_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {}
impl ::core::clone::Clone for D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_PROTECTED_RESOURCE_SESSION_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_PROTECTED_RESOURCE_SESSION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS(pub i32);
pub const D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAG_NONE:
    D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS =
    D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS(0i32);
pub const D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAG_SUPPORTED:
    D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS =
    D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_PROTECTED_SESSION_STATUS(pub i32);
pub const D3D12_PROTECTED_SESSION_STATUS_OK: D3D12_PROTECTED_SESSION_STATUS =
    D3D12_PROTECTED_SESSION_STATUS(0i32);
pub const D3D12_PROTECTED_SESSION_STATUS_INVALID: D3D12_PROTECTED_SESSION_STATUS =
    D3D12_PROTECTED_SESSION_STATUS(1i32);
impl ::core::marker::Copy for D3D12_PROTECTED_SESSION_STATUS {}
impl ::core::clone::Clone for D3D12_PROTECTED_SESSION_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_PROTECTED_SESSION_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_PROTECTED_SESSION_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_PROTECTED_SESSION_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_PROTECTED_SESSION_STATUS")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_QUERY_HEAP_TYPE(pub i32);
pub const D3D12_QUERY_HEAP_TYPE_OCCLUSION: D3D12_QUERY_HEAP_TYPE = D3D12_QUERY_HEAP_TYPE(0i32);
pub const D3D12_QUERY_HEAP_TYPE_TIMESTAMP: D3D12_QUERY_HEAP_TYPE = D3D12_QUERY_HEAP_TYPE(1i32);
pub const D3D12_QUERY_HEAP_TYPE_PIPELINE_STATISTICS: D3D12_QUERY_HEAP_TYPE =
    D3D12_QUERY_HEAP_TYPE(2i32);
pub const D3D12_QUERY_HEAP_TYPE_SO_STATISTICS: D3D12_QUERY_HEAP_TYPE = D3D12_QUERY_HEAP_TYPE(3i32);
pub const D3D12_QUERY_HEAP_TYPE_VIDEO_DECODE_STATISTICS: D3D12_QUERY_HEAP_TYPE =
    D3D12_QUERY_HEAP_TYPE(4i32);
pub const D3D12_QUERY_HEAP_TYPE_COPY_QUEUE_TIMESTAMP: D3D12_QUERY_HEAP_TYPE =
    D3D12_QUERY_HEAP_TYPE(5i32);
pub const D3D12_QUERY_HEAP_TYPE_PIPELINE_STATISTICS1: D3D12_QUERY_HEAP_TYPE =
    D3D12_QUERY_HEAP_TYPE(7i32);
impl ::core::marker::Copy for D3D12_QUERY_HEAP_TYPE {}
impl ::core::clone::Clone for D3D12_QUERY_HEAP_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_QUERY_HEAP_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_QUERY_HEAP_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_QUERY_HEAP_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_QUERY_HEAP_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_QUERY_TYPE(pub i32);
pub const D3D12_QUERY_TYPE_OCCLUSION: D3D12_QUERY_TYPE = D3D12_QUERY_TYPE(0i32);
pub const D3D12_QUERY_TYPE_BINARY_OCCLUSION: D3D12_QUERY_TYPE = D3D12_QUERY_TYPE(1i32);
pub const D3D12_QUERY_TYPE_TIMESTAMP: D3D12_QUERY_TYPE = D3D12_QUERY_TYPE(2i32);
pub const D3D12_QUERY_TYPE_PIPELINE_STATISTICS: D3D12_QUERY_TYPE = D3D12_QUERY_TYPE(3i32);
pub const D3D12_QUERY_TYPE_SO_STATISTICS_STREAM0: D3D12_QUERY_TYPE = D3D12_QUERY_TYPE(4i32);
pub const D3D12_QUERY_TYPE_SO_STATISTICS_STREAM1: D3D12_QUERY_TYPE = D3D12_QUERY_TYPE(5i32);
pub const D3D12_QUERY_TYPE_SO_STATISTICS_STREAM2: D3D12_QUERY_TYPE = D3D12_QUERY_TYPE(6i32);
pub const D3D12_QUERY_TYPE_SO_STATISTICS_STREAM3: D3D12_QUERY_TYPE = D3D12_QUERY_TYPE(7i32);
pub const D3D12_QUERY_TYPE_VIDEO_DECODE_STATISTICS: D3D12_QUERY_TYPE = D3D12_QUERY_TYPE(8i32);
pub const D3D12_QUERY_TYPE_PIPELINE_STATISTICS1: D3D12_QUERY_TYPE = D3D12_QUERY_TYPE(10i32);
impl ::core::marker::Copy for D3D12_QUERY_TYPE {}
impl ::core::clone::Clone for D3D12_QUERY_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_QUERY_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_QUERY_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_QUERY_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_QUERY_TYPE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS(pub i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_NONE:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS(0i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_UPDATE:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS(1i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_ALLOW_COMPACTION:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS(2i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_TRACE:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS(4i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PREFER_FAST_BUILD:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS(8i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_MINIMIZE_MEMORY:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS(16i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAG_PERFORM_UPDATE:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS(32i32);
impl ::core::marker::Copy for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {}
impl ::core::clone::Clone for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE(pub i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_CLONE:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE(0i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_COMPACT:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE(1i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_VISUALIZATION_DECODE_FOR_TOOLS:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE(2i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_SERIALIZE:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE(3i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE_DESERIALIZE:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE(4i32);
impl ::core::marker::Copy for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE {}
impl ::core::clone::Clone for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE(pub i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE(0i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE(1i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE(2i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE(3i32);
impl ::core::marker::Copy for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE {}
impl ::core::clone::Clone for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE(pub i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE(0i32);
pub const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL:
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE =
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE(1i32);
impl ::core::marker::Copy for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE {}
impl ::core::clone::Clone for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RAYTRACING_GEOMETRY_FLAGS(pub i32);
pub const D3D12_RAYTRACING_GEOMETRY_FLAG_NONE: D3D12_RAYTRACING_GEOMETRY_FLAGS =
    D3D12_RAYTRACING_GEOMETRY_FLAGS(0i32);
pub const D3D12_RAYTRACING_GEOMETRY_FLAG_OPAQUE: D3D12_RAYTRACING_GEOMETRY_FLAGS =
    D3D12_RAYTRACING_GEOMETRY_FLAGS(1i32);
pub const D3D12_RAYTRACING_GEOMETRY_FLAG_NO_DUPLICATE_ANYHIT_INVOCATION:
    D3D12_RAYTRACING_GEOMETRY_FLAGS = D3D12_RAYTRACING_GEOMETRY_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_RAYTRACING_GEOMETRY_FLAGS {}
impl ::core::clone::Clone for D3D12_RAYTRACING_GEOMETRY_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RAYTRACING_GEOMETRY_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_GEOMETRY_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_GEOMETRY_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RAYTRACING_GEOMETRY_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_RAYTRACING_GEOMETRY_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RAYTRACING_GEOMETRY_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RAYTRACING_GEOMETRY_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RAYTRACING_GEOMETRY_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RAYTRACING_GEOMETRY_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RAYTRACING_GEOMETRY_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RAYTRACING_GEOMETRY_TYPE(pub i32);
pub const D3D12_RAYTRACING_GEOMETRY_TYPE_TRIANGLES: D3D12_RAYTRACING_GEOMETRY_TYPE =
    D3D12_RAYTRACING_GEOMETRY_TYPE(0i32);
pub const D3D12_RAYTRACING_GEOMETRY_TYPE_PROCEDURAL_PRIMITIVE_AABBS:
    D3D12_RAYTRACING_GEOMETRY_TYPE = D3D12_RAYTRACING_GEOMETRY_TYPE(1i32);
impl ::core::marker::Copy for D3D12_RAYTRACING_GEOMETRY_TYPE {}
impl ::core::clone::Clone for D3D12_RAYTRACING_GEOMETRY_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RAYTRACING_GEOMETRY_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_GEOMETRY_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_GEOMETRY_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RAYTRACING_GEOMETRY_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RAYTRACING_INSTANCE_FLAGS(pub i32);
pub const D3D12_RAYTRACING_INSTANCE_FLAG_NONE: D3D12_RAYTRACING_INSTANCE_FLAGS =
    D3D12_RAYTRACING_INSTANCE_FLAGS(0i32);
pub const D3D12_RAYTRACING_INSTANCE_FLAG_TRIANGLE_CULL_DISABLE: D3D12_RAYTRACING_INSTANCE_FLAGS =
    D3D12_RAYTRACING_INSTANCE_FLAGS(1i32);
pub const D3D12_RAYTRACING_INSTANCE_FLAG_TRIANGLE_FRONT_COUNTERCLOCKWISE:
    D3D12_RAYTRACING_INSTANCE_FLAGS = D3D12_RAYTRACING_INSTANCE_FLAGS(2i32);
pub const D3D12_RAYTRACING_INSTANCE_FLAG_FORCE_OPAQUE: D3D12_RAYTRACING_INSTANCE_FLAGS =
    D3D12_RAYTRACING_INSTANCE_FLAGS(4i32);
pub const D3D12_RAYTRACING_INSTANCE_FLAG_FORCE_NON_OPAQUE: D3D12_RAYTRACING_INSTANCE_FLAGS =
    D3D12_RAYTRACING_INSTANCE_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_RAYTRACING_INSTANCE_FLAGS {}
impl ::core::clone::Clone for D3D12_RAYTRACING_INSTANCE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RAYTRACING_INSTANCE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_INSTANCE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_INSTANCE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RAYTRACING_INSTANCE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_RAYTRACING_INSTANCE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RAYTRACING_INSTANCE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RAYTRACING_INSTANCE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RAYTRACING_INSTANCE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RAYTRACING_INSTANCE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RAYTRACING_INSTANCE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RAYTRACING_PIPELINE_FLAGS(pub i32);
pub const D3D12_RAYTRACING_PIPELINE_FLAG_NONE: D3D12_RAYTRACING_PIPELINE_FLAGS =
    D3D12_RAYTRACING_PIPELINE_FLAGS(0i32);
pub const D3D12_RAYTRACING_PIPELINE_FLAG_SKIP_TRIANGLES: D3D12_RAYTRACING_PIPELINE_FLAGS =
    D3D12_RAYTRACING_PIPELINE_FLAGS(256i32);
pub const D3D12_RAYTRACING_PIPELINE_FLAG_SKIP_PROCEDURAL_PRIMITIVES:
    D3D12_RAYTRACING_PIPELINE_FLAGS = D3D12_RAYTRACING_PIPELINE_FLAGS(512i32);
impl ::core::marker::Copy for D3D12_RAYTRACING_PIPELINE_FLAGS {}
impl ::core::clone::Clone for D3D12_RAYTRACING_PIPELINE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RAYTRACING_PIPELINE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_PIPELINE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_PIPELINE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RAYTRACING_PIPELINE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_RAYTRACING_PIPELINE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RAYTRACING_PIPELINE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RAYTRACING_PIPELINE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RAYTRACING_PIPELINE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RAYTRACING_PIPELINE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RAYTRACING_PIPELINE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RAYTRACING_TIER(pub i32);
pub const D3D12_RAYTRACING_TIER_NOT_SUPPORTED: D3D12_RAYTRACING_TIER = D3D12_RAYTRACING_TIER(0i32);
pub const D3D12_RAYTRACING_TIER_1_0: D3D12_RAYTRACING_TIER = D3D12_RAYTRACING_TIER(10i32);
pub const D3D12_RAYTRACING_TIER_1_1: D3D12_RAYTRACING_TIER = D3D12_RAYTRACING_TIER(11i32);
impl ::core::marker::Copy for D3D12_RAYTRACING_TIER {}
impl ::core::clone::Clone for D3D12_RAYTRACING_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RAYTRACING_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RAYTRACING_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RAY_FLAGS(pub i32);
pub const D3D12_RAY_FLAG_NONE: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(0i32);
pub const D3D12_RAY_FLAG_FORCE_OPAQUE: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(1i32);
pub const D3D12_RAY_FLAG_FORCE_NON_OPAQUE: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(2i32);
pub const D3D12_RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(4i32);
pub const D3D12_RAY_FLAG_SKIP_CLOSEST_HIT_SHADER: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(8i32);
pub const D3D12_RAY_FLAG_CULL_BACK_FACING_TRIANGLES: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(16i32);
pub const D3D12_RAY_FLAG_CULL_FRONT_FACING_TRIANGLES: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(32i32);
pub const D3D12_RAY_FLAG_CULL_OPAQUE: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(64i32);
pub const D3D12_RAY_FLAG_CULL_NON_OPAQUE: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(128i32);
pub const D3D12_RAY_FLAG_SKIP_TRIANGLES: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(256i32);
pub const D3D12_RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES: D3D12_RAY_FLAGS = D3D12_RAY_FLAGS(512i32);
impl ::core::marker::Copy for D3D12_RAY_FLAGS {}
impl ::core::clone::Clone for D3D12_RAY_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RAY_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RAY_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RAY_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RAY_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_RAY_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RAY_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RAY_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RAY_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RAY_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RAY_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_REFLECT_SHARED_PROPERTY(pub i32);
pub const D3D12_REFLECT_SHARED_PROPERTY_D3D11_RESOURCE_FLAGS: D3D12_REFLECT_SHARED_PROPERTY =
    D3D12_REFLECT_SHARED_PROPERTY(0i32);
pub const D3D12_REFELCT_SHARED_PROPERTY_COMPATIBILITY_SHARED_FLAGS: D3D12_REFLECT_SHARED_PROPERTY =
    D3D12_REFLECT_SHARED_PROPERTY(1i32);
pub const D3D12_REFLECT_SHARED_PROPERTY_NON_NT_SHARED_HANDLE: D3D12_REFLECT_SHARED_PROPERTY =
    D3D12_REFLECT_SHARED_PROPERTY(2i32);
impl ::core::marker::Copy for D3D12_REFLECT_SHARED_PROPERTY {}
impl ::core::clone::Clone for D3D12_REFLECT_SHARED_PROPERTY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_REFLECT_SHARED_PROPERTY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_REFLECT_SHARED_PROPERTY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_REFLECT_SHARED_PROPERTY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_REFLECT_SHARED_PROPERTY")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE(pub i32);
pub const D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_DISCARD: D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE =
    D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE(0i32);
pub const D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_PRESERVE:
    D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE = D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE(1i32);
pub const D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_CLEAR: D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE =
    D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE(2i32);
pub const D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_NO_ACCESS:
    D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE = D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE(3i32);
pub const D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_PRESERVE_LOCAL_RENDER:
    D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE = D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE(4i32);
pub const D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_PRESERVE_LOCAL_SRV:
    D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE = D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE(5i32);
pub const D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE_PRESERVE_LOCAL_UAV:
    D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE = D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE(6i32);
impl ::core::marker::Copy for D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE {}
impl ::core::clone::Clone for D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RENDER_PASS_ENDING_ACCESS_TYPE(pub i32);
pub const D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_DISCARD: D3D12_RENDER_PASS_ENDING_ACCESS_TYPE =
    D3D12_RENDER_PASS_ENDING_ACCESS_TYPE(0i32);
pub const D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE: D3D12_RENDER_PASS_ENDING_ACCESS_TYPE =
    D3D12_RENDER_PASS_ENDING_ACCESS_TYPE(1i32);
pub const D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_RESOLVE: D3D12_RENDER_PASS_ENDING_ACCESS_TYPE =
    D3D12_RENDER_PASS_ENDING_ACCESS_TYPE(2i32);
pub const D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_NO_ACCESS: D3D12_RENDER_PASS_ENDING_ACCESS_TYPE =
    D3D12_RENDER_PASS_ENDING_ACCESS_TYPE(3i32);
pub const D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE_LOCAL_RENDER:
    D3D12_RENDER_PASS_ENDING_ACCESS_TYPE = D3D12_RENDER_PASS_ENDING_ACCESS_TYPE(4i32);
pub const D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE_LOCAL_SRV:
    D3D12_RENDER_PASS_ENDING_ACCESS_TYPE = D3D12_RENDER_PASS_ENDING_ACCESS_TYPE(5i32);
pub const D3D12_RENDER_PASS_ENDING_ACCESS_TYPE_PRESERVE_LOCAL_UAV:
    D3D12_RENDER_PASS_ENDING_ACCESS_TYPE = D3D12_RENDER_PASS_ENDING_ACCESS_TYPE(6i32);
impl ::core::marker::Copy for D3D12_RENDER_PASS_ENDING_ACCESS_TYPE {}
impl ::core::clone::Clone for D3D12_RENDER_PASS_ENDING_ACCESS_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RENDER_PASS_ENDING_ACCESS_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_ENDING_ACCESS_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RENDER_PASS_ENDING_ACCESS_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RENDER_PASS_ENDING_ACCESS_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RENDER_PASS_FLAGS(pub i32);
pub const D3D12_RENDER_PASS_FLAG_NONE: D3D12_RENDER_PASS_FLAGS = D3D12_RENDER_PASS_FLAGS(0i32);
pub const D3D12_RENDER_PASS_FLAG_ALLOW_UAV_WRITES: D3D12_RENDER_PASS_FLAGS =
    D3D12_RENDER_PASS_FLAGS(1i32);
pub const D3D12_RENDER_PASS_FLAG_SUSPENDING_PASS: D3D12_RENDER_PASS_FLAGS =
    D3D12_RENDER_PASS_FLAGS(2i32);
pub const D3D12_RENDER_PASS_FLAG_RESUMING_PASS: D3D12_RENDER_PASS_FLAGS =
    D3D12_RENDER_PASS_FLAGS(4i32);
pub const D3D12_RENDER_PASS_FLAG_BIND_READ_ONLY_DEPTH: D3D12_RENDER_PASS_FLAGS =
    D3D12_RENDER_PASS_FLAGS(8i32);
pub const D3D12_RENDER_PASS_FLAG_BIND_READ_ONLY_STENCIL: D3D12_RENDER_PASS_FLAGS =
    D3D12_RENDER_PASS_FLAGS(16i32);
impl ::core::marker::Copy for D3D12_RENDER_PASS_FLAGS {}
impl ::core::clone::Clone for D3D12_RENDER_PASS_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RENDER_PASS_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RENDER_PASS_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RENDER_PASS_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_RENDER_PASS_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RENDER_PASS_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RENDER_PASS_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RENDER_PASS_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RENDER_PASS_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RENDER_PASS_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RENDER_PASS_TIER(pub i32);
pub const D3D12_RENDER_PASS_TIER_0: D3D12_RENDER_PASS_TIER = D3D12_RENDER_PASS_TIER(0i32);
pub const D3D12_RENDER_PASS_TIER_1: D3D12_RENDER_PASS_TIER = D3D12_RENDER_PASS_TIER(1i32);
pub const D3D12_RENDER_PASS_TIER_2: D3D12_RENDER_PASS_TIER = D3D12_RENDER_PASS_TIER(2i32);
impl ::core::marker::Copy for D3D12_RENDER_PASS_TIER {}
impl ::core::clone::Clone for D3D12_RENDER_PASS_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RENDER_PASS_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RENDER_PASS_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RENDER_PASS_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RESIDENCY_FLAGS(pub i32);
pub const D3D12_RESIDENCY_FLAG_NONE: D3D12_RESIDENCY_FLAGS = D3D12_RESIDENCY_FLAGS(0i32);
pub const D3D12_RESIDENCY_FLAG_DENY_OVERBUDGET: D3D12_RESIDENCY_FLAGS = D3D12_RESIDENCY_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_RESIDENCY_FLAGS {}
impl ::core::clone::Clone for D3D12_RESIDENCY_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RESIDENCY_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RESIDENCY_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RESIDENCY_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RESIDENCY_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_RESIDENCY_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RESIDENCY_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RESIDENCY_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RESIDENCY_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RESIDENCY_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RESIDENCY_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RESIDENCY_PRIORITY(pub i32);
pub const D3D12_RESIDENCY_PRIORITY_MINIMUM: D3D12_RESIDENCY_PRIORITY =
    D3D12_RESIDENCY_PRIORITY(671088640i32);
pub const D3D12_RESIDENCY_PRIORITY_LOW: D3D12_RESIDENCY_PRIORITY =
    D3D12_RESIDENCY_PRIORITY(1342177280i32);
pub const D3D12_RESIDENCY_PRIORITY_NORMAL: D3D12_RESIDENCY_PRIORITY =
    D3D12_RESIDENCY_PRIORITY(2013265920i32);
pub const D3D12_RESIDENCY_PRIORITY_HIGH: D3D12_RESIDENCY_PRIORITY =
    D3D12_RESIDENCY_PRIORITY(-1610547200i32);
pub const D3D12_RESIDENCY_PRIORITY_MAXIMUM: D3D12_RESIDENCY_PRIORITY =
    D3D12_RESIDENCY_PRIORITY(-939524096i32);
impl ::core::marker::Copy for D3D12_RESIDENCY_PRIORITY {}
impl ::core::clone::Clone for D3D12_RESIDENCY_PRIORITY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RESIDENCY_PRIORITY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RESIDENCY_PRIORITY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RESIDENCY_PRIORITY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RESIDENCY_PRIORITY")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RESOLVE_MODE(pub i32);
pub const D3D12_RESOLVE_MODE_DECOMPRESS: D3D12_RESOLVE_MODE = D3D12_RESOLVE_MODE(0i32);
pub const D3D12_RESOLVE_MODE_MIN: D3D12_RESOLVE_MODE = D3D12_RESOLVE_MODE(1i32);
pub const D3D12_RESOLVE_MODE_MAX: D3D12_RESOLVE_MODE = D3D12_RESOLVE_MODE(2i32);
pub const D3D12_RESOLVE_MODE_AVERAGE: D3D12_RESOLVE_MODE = D3D12_RESOLVE_MODE(3i32);
pub const D3D12_RESOLVE_MODE_ENCODE_SAMPLER_FEEDBACK: D3D12_RESOLVE_MODE = D3D12_RESOLVE_MODE(4i32);
pub const D3D12_RESOLVE_MODE_DECODE_SAMPLER_FEEDBACK: D3D12_RESOLVE_MODE = D3D12_RESOLVE_MODE(5i32);
impl ::core::marker::Copy for D3D12_RESOLVE_MODE {}
impl ::core::clone::Clone for D3D12_RESOLVE_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RESOLVE_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RESOLVE_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RESOLVE_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RESOLVE_MODE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RESOURCE_BARRIER_FLAGS(pub i32);
pub const D3D12_RESOURCE_BARRIER_FLAG_NONE: D3D12_RESOURCE_BARRIER_FLAGS =
    D3D12_RESOURCE_BARRIER_FLAGS(0i32);
pub const D3D12_RESOURCE_BARRIER_FLAG_BEGIN_ONLY: D3D12_RESOURCE_BARRIER_FLAGS =
    D3D12_RESOURCE_BARRIER_FLAGS(1i32);
pub const D3D12_RESOURCE_BARRIER_FLAG_END_ONLY: D3D12_RESOURCE_BARRIER_FLAGS =
    D3D12_RESOURCE_BARRIER_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_RESOURCE_BARRIER_FLAGS {}
impl ::core::clone::Clone for D3D12_RESOURCE_BARRIER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RESOURCE_BARRIER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_BARRIER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RESOURCE_BARRIER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RESOURCE_BARRIER_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_RESOURCE_BARRIER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RESOURCE_BARRIER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RESOURCE_BARRIER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RESOURCE_BARRIER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RESOURCE_BARRIER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RESOURCE_BARRIER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RESOURCE_BARRIER_TYPE(pub i32);
pub const D3D12_RESOURCE_BARRIER_TYPE_TRANSITION: D3D12_RESOURCE_BARRIER_TYPE =
    D3D12_RESOURCE_BARRIER_TYPE(0i32);
pub const D3D12_RESOURCE_BARRIER_TYPE_ALIASING: D3D12_RESOURCE_BARRIER_TYPE =
    D3D12_RESOURCE_BARRIER_TYPE(1i32);
pub const D3D12_RESOURCE_BARRIER_TYPE_UAV: D3D12_RESOURCE_BARRIER_TYPE =
    D3D12_RESOURCE_BARRIER_TYPE(2i32);
impl ::core::marker::Copy for D3D12_RESOURCE_BARRIER_TYPE {}
impl ::core::clone::Clone for D3D12_RESOURCE_BARRIER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RESOURCE_BARRIER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_BARRIER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RESOURCE_BARRIER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RESOURCE_BARRIER_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RESOURCE_BINDING_TIER(pub i32);
pub const D3D12_RESOURCE_BINDING_TIER_1: D3D12_RESOURCE_BINDING_TIER =
    D3D12_RESOURCE_BINDING_TIER(1i32);
pub const D3D12_RESOURCE_BINDING_TIER_2: D3D12_RESOURCE_BINDING_TIER =
    D3D12_RESOURCE_BINDING_TIER(2i32);
pub const D3D12_RESOURCE_BINDING_TIER_3: D3D12_RESOURCE_BINDING_TIER =
    D3D12_RESOURCE_BINDING_TIER(3i32);
impl ::core::marker::Copy for D3D12_RESOURCE_BINDING_TIER {}
impl ::core::clone::Clone for D3D12_RESOURCE_BINDING_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RESOURCE_BINDING_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_BINDING_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RESOURCE_BINDING_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RESOURCE_BINDING_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RESOURCE_DIMENSION(pub i32);
pub const D3D12_RESOURCE_DIMENSION_UNKNOWN: D3D12_RESOURCE_DIMENSION =
    D3D12_RESOURCE_DIMENSION(0i32);
pub const D3D12_RESOURCE_DIMENSION_BUFFER: D3D12_RESOURCE_DIMENSION =
    D3D12_RESOURCE_DIMENSION(1i32);
pub const D3D12_RESOURCE_DIMENSION_TEXTURE1D: D3D12_RESOURCE_DIMENSION =
    D3D12_RESOURCE_DIMENSION(2i32);
pub const D3D12_RESOURCE_DIMENSION_TEXTURE2D: D3D12_RESOURCE_DIMENSION =
    D3D12_RESOURCE_DIMENSION(3i32);
pub const D3D12_RESOURCE_DIMENSION_TEXTURE3D: D3D12_RESOURCE_DIMENSION =
    D3D12_RESOURCE_DIMENSION(4i32);
impl ::core::marker::Copy for D3D12_RESOURCE_DIMENSION {}
impl ::core::clone::Clone for D3D12_RESOURCE_DIMENSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RESOURCE_DIMENSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_DIMENSION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RESOURCE_DIMENSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RESOURCE_DIMENSION")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RESOURCE_FLAGS(pub i32);
pub const D3D12_RESOURCE_FLAG_NONE: D3D12_RESOURCE_FLAGS = D3D12_RESOURCE_FLAGS(0i32);
pub const D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET: D3D12_RESOURCE_FLAGS =
    D3D12_RESOURCE_FLAGS(1i32);
pub const D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL: D3D12_RESOURCE_FLAGS =
    D3D12_RESOURCE_FLAGS(2i32);
pub const D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS: D3D12_RESOURCE_FLAGS =
    D3D12_RESOURCE_FLAGS(4i32);
pub const D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE: D3D12_RESOURCE_FLAGS =
    D3D12_RESOURCE_FLAGS(8i32);
pub const D3D12_RESOURCE_FLAG_ALLOW_CROSS_ADAPTER: D3D12_RESOURCE_FLAGS =
    D3D12_RESOURCE_FLAGS(16i32);
pub const D3D12_RESOURCE_FLAG_ALLOW_SIMULTANEOUS_ACCESS: D3D12_RESOURCE_FLAGS =
    D3D12_RESOURCE_FLAGS(32i32);
pub const D3D12_RESOURCE_FLAG_VIDEO_DECODE_REFERENCE_ONLY: D3D12_RESOURCE_FLAGS =
    D3D12_RESOURCE_FLAGS(64i32);
pub const D3D12_RESOURCE_FLAG_VIDEO_ENCODE_REFERENCE_ONLY: D3D12_RESOURCE_FLAGS =
    D3D12_RESOURCE_FLAGS(128i32);
pub const D3D12_RESOURCE_FLAG_RAYTRACING_ACCELERATION_STRUCTURE: D3D12_RESOURCE_FLAGS =
    D3D12_RESOURCE_FLAGS(256i32);
impl ::core::marker::Copy for D3D12_RESOURCE_FLAGS {}
impl ::core::clone::Clone for D3D12_RESOURCE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RESOURCE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RESOURCE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RESOURCE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_RESOURCE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RESOURCE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RESOURCE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RESOURCE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RESOURCE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RESOURCE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RESOURCE_HEAP_TIER(pub i32);
pub const D3D12_RESOURCE_HEAP_TIER_1: D3D12_RESOURCE_HEAP_TIER = D3D12_RESOURCE_HEAP_TIER(1i32);
pub const D3D12_RESOURCE_HEAP_TIER_2: D3D12_RESOURCE_HEAP_TIER = D3D12_RESOURCE_HEAP_TIER(2i32);
impl ::core::marker::Copy for D3D12_RESOURCE_HEAP_TIER {}
impl ::core::clone::Clone for D3D12_RESOURCE_HEAP_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RESOURCE_HEAP_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_HEAP_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RESOURCE_HEAP_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RESOURCE_HEAP_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RESOURCE_STATES(pub i32);
pub const D3D12_RESOURCE_STATE_COMMON: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(0i32);
pub const D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(1i32);
pub const D3D12_RESOURCE_STATE_INDEX_BUFFER: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(2i32);
pub const D3D12_RESOURCE_STATE_RENDER_TARGET: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(4i32);
pub const D3D12_RESOURCE_STATE_UNORDERED_ACCESS: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(8i32);
pub const D3D12_RESOURCE_STATE_DEPTH_WRITE: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(16i32);
pub const D3D12_RESOURCE_STATE_DEPTH_READ: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(32i32);
pub const D3D12_RESOURCE_STATE_NON_PIXEL_SHADER_RESOURCE: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(64i32);
pub const D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(128i32);
pub const D3D12_RESOURCE_STATE_STREAM_OUT: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(256i32);
pub const D3D12_RESOURCE_STATE_INDIRECT_ARGUMENT: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(512i32);
pub const D3D12_RESOURCE_STATE_COPY_DEST: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(1024i32);
pub const D3D12_RESOURCE_STATE_COPY_SOURCE: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(2048i32);
pub const D3D12_RESOURCE_STATE_RESOLVE_DEST: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(4096i32);
pub const D3D12_RESOURCE_STATE_RESOLVE_SOURCE: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(8192i32);
pub const D3D12_RESOURCE_STATE_RAYTRACING_ACCELERATION_STRUCTURE: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(4194304i32);
pub const D3D12_RESOURCE_STATE_SHADING_RATE_SOURCE: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(16777216i32);
pub const D3D12_RESOURCE_STATE_RESERVED_INTERNAL_8000: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(32768i32);
pub const D3D12_RESOURCE_STATE_RESERVED_INTERNAL_4000: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(16384i32);
pub const D3D12_RESOURCE_STATE_RESERVED_INTERNAL_100000: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(1048576i32);
pub const D3D12_RESOURCE_STATE_RESERVED_INTERNAL_40000000: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(1073741824i32);
pub const D3D12_RESOURCE_STATE_RESERVED_INTERNAL_80000000: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(-2147483648i32);
pub const D3D12_RESOURCE_STATE_GENERIC_READ: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(2755i32);
pub const D3D12_RESOURCE_STATE_ALL_SHADER_RESOURCE: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(192i32);
pub const D3D12_RESOURCE_STATE_PRESENT: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(0i32);
pub const D3D12_RESOURCE_STATE_PREDICATION: D3D12_RESOURCE_STATES = D3D12_RESOURCE_STATES(512i32);
pub const D3D12_RESOURCE_STATE_VIDEO_DECODE_READ: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(65536i32);
pub const D3D12_RESOURCE_STATE_VIDEO_DECODE_WRITE: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(131072i32);
pub const D3D12_RESOURCE_STATE_VIDEO_PROCESS_READ: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(262144i32);
pub const D3D12_RESOURCE_STATE_VIDEO_PROCESS_WRITE: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(524288i32);
pub const D3D12_RESOURCE_STATE_VIDEO_ENCODE_READ: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(2097152i32);
pub const D3D12_RESOURCE_STATE_VIDEO_ENCODE_WRITE: D3D12_RESOURCE_STATES =
    D3D12_RESOURCE_STATES(8388608i32);
impl ::core::marker::Copy for D3D12_RESOURCE_STATES {}
impl ::core::clone::Clone for D3D12_RESOURCE_STATES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RESOURCE_STATES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_STATES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RESOURCE_STATES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RESOURCE_STATES")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_RESOURCE_STATES {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RESOURCE_STATES {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RESOURCE_STATES {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RESOURCE_STATES {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RESOURCE_STATES {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RESOURCE_STATES {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RLDO_FLAGS(pub i32);
pub const D3D12_RLDO_NONE: D3D12_RLDO_FLAGS = D3D12_RLDO_FLAGS(0i32);
pub const D3D12_RLDO_SUMMARY: D3D12_RLDO_FLAGS = D3D12_RLDO_FLAGS(1i32);
pub const D3D12_RLDO_DETAIL: D3D12_RLDO_FLAGS = D3D12_RLDO_FLAGS(2i32);
pub const D3D12_RLDO_IGNORE_INTERNAL: D3D12_RLDO_FLAGS = D3D12_RLDO_FLAGS(4i32);
impl ::core::marker::Copy for D3D12_RLDO_FLAGS {}
impl ::core::clone::Clone for D3D12_RLDO_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RLDO_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RLDO_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RLDO_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RLDO_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_RLDO_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_RLDO_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_RLDO_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_RLDO_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_RLDO_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_RLDO_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_ROOT_DESCRIPTOR_FLAGS(pub i32);
pub const D3D12_ROOT_DESCRIPTOR_FLAG_NONE: D3D12_ROOT_DESCRIPTOR_FLAGS =
    D3D12_ROOT_DESCRIPTOR_FLAGS(0i32);
pub const D3D12_ROOT_DESCRIPTOR_FLAG_DATA_VOLATILE: D3D12_ROOT_DESCRIPTOR_FLAGS =
    D3D12_ROOT_DESCRIPTOR_FLAGS(2i32);
pub const D3D12_ROOT_DESCRIPTOR_FLAG_DATA_STATIC_WHILE_SET_AT_EXECUTE: D3D12_ROOT_DESCRIPTOR_FLAGS =
    D3D12_ROOT_DESCRIPTOR_FLAGS(4i32);
pub const D3D12_ROOT_DESCRIPTOR_FLAG_DATA_STATIC: D3D12_ROOT_DESCRIPTOR_FLAGS =
    D3D12_ROOT_DESCRIPTOR_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_ROOT_DESCRIPTOR_FLAGS {}
impl ::core::clone::Clone for D3D12_ROOT_DESCRIPTOR_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_ROOT_DESCRIPTOR_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_DESCRIPTOR_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_ROOT_DESCRIPTOR_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_ROOT_DESCRIPTOR_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_ROOT_DESCRIPTOR_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_ROOT_DESCRIPTOR_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_ROOT_DESCRIPTOR_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_ROOT_DESCRIPTOR_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_ROOT_DESCRIPTOR_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_ROOT_DESCRIPTOR_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_ROOT_PARAMETER_TYPE(pub i32);
pub const D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE: D3D12_ROOT_PARAMETER_TYPE =
    D3D12_ROOT_PARAMETER_TYPE(0i32);
pub const D3D12_ROOT_PARAMETER_TYPE_32BIT_CONSTANTS: D3D12_ROOT_PARAMETER_TYPE =
    D3D12_ROOT_PARAMETER_TYPE(1i32);
pub const D3D12_ROOT_PARAMETER_TYPE_CBV: D3D12_ROOT_PARAMETER_TYPE =
    D3D12_ROOT_PARAMETER_TYPE(2i32);
pub const D3D12_ROOT_PARAMETER_TYPE_SRV: D3D12_ROOT_PARAMETER_TYPE =
    D3D12_ROOT_PARAMETER_TYPE(3i32);
pub const D3D12_ROOT_PARAMETER_TYPE_UAV: D3D12_ROOT_PARAMETER_TYPE =
    D3D12_ROOT_PARAMETER_TYPE(4i32);
impl ::core::marker::Copy for D3D12_ROOT_PARAMETER_TYPE {}
impl ::core::clone::Clone for D3D12_ROOT_PARAMETER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_ROOT_PARAMETER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_PARAMETER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_ROOT_PARAMETER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_ROOT_PARAMETER_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_ROOT_SIGNATURE_FLAGS(pub i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_NONE: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(0i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(1i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_DENY_VERTEX_SHADER_ROOT_ACCESS: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(2i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(4i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(8i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(16i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_DENY_PIXEL_SHADER_ROOT_ACCESS: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(32i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_ALLOW_STREAM_OUTPUT: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(64i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_LOCAL_ROOT_SIGNATURE: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(128i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_DENY_AMPLIFICATION_SHADER_ROOT_ACCESS:
    D3D12_ROOT_SIGNATURE_FLAGS = D3D12_ROOT_SIGNATURE_FLAGS(256i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_DENY_MESH_SHADER_ROOT_ACCESS: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(512i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_CBV_SRV_UAV_HEAP_DIRECTLY_INDEXED: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(1024i32);
pub const D3D12_ROOT_SIGNATURE_FLAG_SAMPLER_HEAP_DIRECTLY_INDEXED: D3D12_ROOT_SIGNATURE_FLAGS =
    D3D12_ROOT_SIGNATURE_FLAGS(2048i32);
impl ::core::marker::Copy for D3D12_ROOT_SIGNATURE_FLAGS {}
impl ::core::clone::Clone for D3D12_ROOT_SIGNATURE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_ROOT_SIGNATURE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_SIGNATURE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_ROOT_SIGNATURE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_ROOT_SIGNATURE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_ROOT_SIGNATURE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_ROOT_SIGNATURE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_ROOT_SIGNATURE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_ROOT_SIGNATURE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_ROOT_SIGNATURE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_ROOT_SIGNATURE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_RTV_DIMENSION(pub i32);
pub const D3D12_RTV_DIMENSION_UNKNOWN: D3D12_RTV_DIMENSION = D3D12_RTV_DIMENSION(0i32);
pub const D3D12_RTV_DIMENSION_BUFFER: D3D12_RTV_DIMENSION = D3D12_RTV_DIMENSION(1i32);
pub const D3D12_RTV_DIMENSION_TEXTURE1D: D3D12_RTV_DIMENSION = D3D12_RTV_DIMENSION(2i32);
pub const D3D12_RTV_DIMENSION_TEXTURE1DARRAY: D3D12_RTV_DIMENSION = D3D12_RTV_DIMENSION(3i32);
pub const D3D12_RTV_DIMENSION_TEXTURE2D: D3D12_RTV_DIMENSION = D3D12_RTV_DIMENSION(4i32);
pub const D3D12_RTV_DIMENSION_TEXTURE2DARRAY: D3D12_RTV_DIMENSION = D3D12_RTV_DIMENSION(5i32);
pub const D3D12_RTV_DIMENSION_TEXTURE2DMS: D3D12_RTV_DIMENSION = D3D12_RTV_DIMENSION(6i32);
pub const D3D12_RTV_DIMENSION_TEXTURE2DMSARRAY: D3D12_RTV_DIMENSION = D3D12_RTV_DIMENSION(7i32);
pub const D3D12_RTV_DIMENSION_TEXTURE3D: D3D12_RTV_DIMENSION = D3D12_RTV_DIMENSION(8i32);
impl ::core::marker::Copy for D3D12_RTV_DIMENSION {}
impl ::core::clone::Clone for D3D12_RTV_DIMENSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_RTV_DIMENSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_RTV_DIMENSION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_RTV_DIMENSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_RTV_DIMENSION").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SAMPLER_FEEDBACK_TIER(pub i32);
pub const D3D12_SAMPLER_FEEDBACK_TIER_NOT_SUPPORTED: D3D12_SAMPLER_FEEDBACK_TIER =
    D3D12_SAMPLER_FEEDBACK_TIER(0i32);
pub const D3D12_SAMPLER_FEEDBACK_TIER_0_9: D3D12_SAMPLER_FEEDBACK_TIER =
    D3D12_SAMPLER_FEEDBACK_TIER(90i32);
pub const D3D12_SAMPLER_FEEDBACK_TIER_1_0: D3D12_SAMPLER_FEEDBACK_TIER =
    D3D12_SAMPLER_FEEDBACK_TIER(100i32);
impl ::core::marker::Copy for D3D12_SAMPLER_FEEDBACK_TIER {}
impl ::core::clone::Clone for D3D12_SAMPLER_FEEDBACK_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SAMPLER_FEEDBACK_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SAMPLER_FEEDBACK_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SAMPLER_FEEDBACK_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SAMPLER_FEEDBACK_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SAMPLER_FLAGS(pub i32);
pub const D3D12_SAMPLER_FLAG_NONE: D3D12_SAMPLER_FLAGS = D3D12_SAMPLER_FLAGS(0i32);
pub const D3D12_SAMPLER_FLAG_UINT_BORDER_COLOR: D3D12_SAMPLER_FLAGS = D3D12_SAMPLER_FLAGS(1i32);
pub const D3D12_SAMPLER_FLAG_NON_NORMALIZED_COORDINATES: D3D12_SAMPLER_FLAGS =
    D3D12_SAMPLER_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_SAMPLER_FLAGS {}
impl ::core::clone::Clone for D3D12_SAMPLER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SAMPLER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SAMPLER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SAMPLER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SAMPLER_FLAGS").field(&self.0).finish()
    }
}
impl D3D12_SAMPLER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_SAMPLER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_SAMPLER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_SAMPLER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_SAMPLER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_SAMPLER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SERIALIZED_DATA_TYPE(pub i32);
pub const D3D12_SERIALIZED_DATA_RAYTRACING_ACCELERATION_STRUCTURE: D3D12_SERIALIZED_DATA_TYPE =
    D3D12_SERIALIZED_DATA_TYPE(0i32);
impl ::core::marker::Copy for D3D12_SERIALIZED_DATA_TYPE {}
impl ::core::clone::Clone for D3D12_SERIALIZED_DATA_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SERIALIZED_DATA_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SERIALIZED_DATA_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SERIALIZED_DATA_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SERIALIZED_DATA_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SET_WORK_GRAPH_FLAGS(pub i32);
pub const D3D12_SET_WORK_GRAPH_FLAG_NONE: D3D12_SET_WORK_GRAPH_FLAGS =
    D3D12_SET_WORK_GRAPH_FLAGS(0i32);
pub const D3D12_SET_WORK_GRAPH_FLAG_INITIALIZE: D3D12_SET_WORK_GRAPH_FLAGS =
    D3D12_SET_WORK_GRAPH_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_SET_WORK_GRAPH_FLAGS {}
impl ::core::clone::Clone for D3D12_SET_WORK_GRAPH_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SET_WORK_GRAPH_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SET_WORK_GRAPH_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SET_WORK_GRAPH_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SET_WORK_GRAPH_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_SET_WORK_GRAPH_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_SET_WORK_GRAPH_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_SET_WORK_GRAPH_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_SET_WORK_GRAPH_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_SET_WORK_GRAPH_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_SET_WORK_GRAPH_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADER_CACHE_CONTROL_FLAGS(pub i32);
pub const D3D12_SHADER_CACHE_CONTROL_FLAG_DISABLE: D3D12_SHADER_CACHE_CONTROL_FLAGS =
    D3D12_SHADER_CACHE_CONTROL_FLAGS(1i32);
pub const D3D12_SHADER_CACHE_CONTROL_FLAG_ENABLE: D3D12_SHADER_CACHE_CONTROL_FLAGS =
    D3D12_SHADER_CACHE_CONTROL_FLAGS(2i32);
pub const D3D12_SHADER_CACHE_CONTROL_FLAG_CLEAR: D3D12_SHADER_CACHE_CONTROL_FLAGS =
    D3D12_SHADER_CACHE_CONTROL_FLAGS(4i32);
impl ::core::marker::Copy for D3D12_SHADER_CACHE_CONTROL_FLAGS {}
impl ::core::clone::Clone for D3D12_SHADER_CACHE_CONTROL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADER_CACHE_CONTROL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_CACHE_CONTROL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADER_CACHE_CONTROL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADER_CACHE_CONTROL_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_SHADER_CACHE_CONTROL_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_SHADER_CACHE_CONTROL_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_SHADER_CACHE_CONTROL_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_SHADER_CACHE_CONTROL_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_SHADER_CACHE_CONTROL_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_SHADER_CACHE_CONTROL_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADER_CACHE_FLAGS(pub i32);
pub const D3D12_SHADER_CACHE_FLAG_NONE: D3D12_SHADER_CACHE_FLAGS = D3D12_SHADER_CACHE_FLAGS(0i32);
pub const D3D12_SHADER_CACHE_FLAG_DRIVER_VERSIONED: D3D12_SHADER_CACHE_FLAGS =
    D3D12_SHADER_CACHE_FLAGS(1i32);
pub const D3D12_SHADER_CACHE_FLAG_USE_WORKING_DIR: D3D12_SHADER_CACHE_FLAGS =
    D3D12_SHADER_CACHE_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_SHADER_CACHE_FLAGS {}
impl ::core::clone::Clone for D3D12_SHADER_CACHE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADER_CACHE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_CACHE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADER_CACHE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADER_CACHE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_SHADER_CACHE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_SHADER_CACHE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_SHADER_CACHE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_SHADER_CACHE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_SHADER_CACHE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_SHADER_CACHE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADER_CACHE_KIND_FLAGS(pub i32);
pub const D3D12_SHADER_CACHE_KIND_FLAG_IMPLICIT_D3D_CACHE_FOR_DRIVER:
    D3D12_SHADER_CACHE_KIND_FLAGS = D3D12_SHADER_CACHE_KIND_FLAGS(1i32);
pub const D3D12_SHADER_CACHE_KIND_FLAG_IMPLICIT_D3D_CONVERSIONS: D3D12_SHADER_CACHE_KIND_FLAGS =
    D3D12_SHADER_CACHE_KIND_FLAGS(2i32);
pub const D3D12_SHADER_CACHE_KIND_FLAG_IMPLICIT_DRIVER_MANAGED: D3D12_SHADER_CACHE_KIND_FLAGS =
    D3D12_SHADER_CACHE_KIND_FLAGS(4i32);
pub const D3D12_SHADER_CACHE_KIND_FLAG_APPLICATION_MANAGED: D3D12_SHADER_CACHE_KIND_FLAGS =
    D3D12_SHADER_CACHE_KIND_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_SHADER_CACHE_KIND_FLAGS {}
impl ::core::clone::Clone for D3D12_SHADER_CACHE_KIND_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADER_CACHE_KIND_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_CACHE_KIND_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADER_CACHE_KIND_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADER_CACHE_KIND_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_SHADER_CACHE_KIND_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_SHADER_CACHE_KIND_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_SHADER_CACHE_KIND_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_SHADER_CACHE_KIND_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_SHADER_CACHE_KIND_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_SHADER_CACHE_KIND_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADER_CACHE_MODE(pub i32);
pub const D3D12_SHADER_CACHE_MODE_MEMORY: D3D12_SHADER_CACHE_MODE = D3D12_SHADER_CACHE_MODE(0i32);
pub const D3D12_SHADER_CACHE_MODE_DISK: D3D12_SHADER_CACHE_MODE = D3D12_SHADER_CACHE_MODE(1i32);
impl ::core::marker::Copy for D3D12_SHADER_CACHE_MODE {}
impl ::core::clone::Clone for D3D12_SHADER_CACHE_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADER_CACHE_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_CACHE_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADER_CACHE_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADER_CACHE_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADER_CACHE_SUPPORT_FLAGS(pub i32);
pub const D3D12_SHADER_CACHE_SUPPORT_NONE: D3D12_SHADER_CACHE_SUPPORT_FLAGS =
    D3D12_SHADER_CACHE_SUPPORT_FLAGS(0i32);
pub const D3D12_SHADER_CACHE_SUPPORT_SINGLE_PSO: D3D12_SHADER_CACHE_SUPPORT_FLAGS =
    D3D12_SHADER_CACHE_SUPPORT_FLAGS(1i32);
pub const D3D12_SHADER_CACHE_SUPPORT_LIBRARY: D3D12_SHADER_CACHE_SUPPORT_FLAGS =
    D3D12_SHADER_CACHE_SUPPORT_FLAGS(2i32);
pub const D3D12_SHADER_CACHE_SUPPORT_AUTOMATIC_INPROC_CACHE: D3D12_SHADER_CACHE_SUPPORT_FLAGS =
    D3D12_SHADER_CACHE_SUPPORT_FLAGS(4i32);
pub const D3D12_SHADER_CACHE_SUPPORT_AUTOMATIC_DISK_CACHE: D3D12_SHADER_CACHE_SUPPORT_FLAGS =
    D3D12_SHADER_CACHE_SUPPORT_FLAGS(8i32);
pub const D3D12_SHADER_CACHE_SUPPORT_DRIVER_MANAGED_CACHE: D3D12_SHADER_CACHE_SUPPORT_FLAGS =
    D3D12_SHADER_CACHE_SUPPORT_FLAGS(16i32);
pub const D3D12_SHADER_CACHE_SUPPORT_SHADER_CONTROL_CLEAR: D3D12_SHADER_CACHE_SUPPORT_FLAGS =
    D3D12_SHADER_CACHE_SUPPORT_FLAGS(32i32);
pub const D3D12_SHADER_CACHE_SUPPORT_SHADER_SESSION_DELETE: D3D12_SHADER_CACHE_SUPPORT_FLAGS =
    D3D12_SHADER_CACHE_SUPPORT_FLAGS(64i32);
impl ::core::marker::Copy for D3D12_SHADER_CACHE_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_SHADER_CACHE_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADER_CACHE_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_CACHE_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADER_CACHE_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADER_CACHE_SUPPORT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_SHADER_CACHE_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_SHADER_CACHE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_SHADER_CACHE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_SHADER_CACHE_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_SHADER_CACHE_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_SHADER_CACHE_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADER_COMPONENT_MAPPING(pub i32);
pub const D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_0: D3D12_SHADER_COMPONENT_MAPPING =
    D3D12_SHADER_COMPONENT_MAPPING(0i32);
pub const D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_1: D3D12_SHADER_COMPONENT_MAPPING =
    D3D12_SHADER_COMPONENT_MAPPING(1i32);
pub const D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_2: D3D12_SHADER_COMPONENT_MAPPING =
    D3D12_SHADER_COMPONENT_MAPPING(2i32);
pub const D3D12_SHADER_COMPONENT_MAPPING_FROM_MEMORY_COMPONENT_3: D3D12_SHADER_COMPONENT_MAPPING =
    D3D12_SHADER_COMPONENT_MAPPING(3i32);
pub const D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_0: D3D12_SHADER_COMPONENT_MAPPING =
    D3D12_SHADER_COMPONENT_MAPPING(4i32);
pub const D3D12_SHADER_COMPONENT_MAPPING_FORCE_VALUE_1: D3D12_SHADER_COMPONENT_MAPPING =
    D3D12_SHADER_COMPONENT_MAPPING(5i32);
impl ::core::marker::Copy for D3D12_SHADER_COMPONENT_MAPPING {}
impl ::core::clone::Clone for D3D12_SHADER_COMPONENT_MAPPING {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADER_COMPONENT_MAPPING {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_COMPONENT_MAPPING {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADER_COMPONENT_MAPPING {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADER_COMPONENT_MAPPING")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADER_MIN_PRECISION_SUPPORT(pub i32);
pub const D3D12_SHADER_MIN_PRECISION_SUPPORT_NONE: D3D12_SHADER_MIN_PRECISION_SUPPORT =
    D3D12_SHADER_MIN_PRECISION_SUPPORT(0i32);
pub const D3D12_SHADER_MIN_PRECISION_SUPPORT_10_BIT: D3D12_SHADER_MIN_PRECISION_SUPPORT =
    D3D12_SHADER_MIN_PRECISION_SUPPORT(1i32);
pub const D3D12_SHADER_MIN_PRECISION_SUPPORT_16_BIT: D3D12_SHADER_MIN_PRECISION_SUPPORT =
    D3D12_SHADER_MIN_PRECISION_SUPPORT(2i32);
impl ::core::marker::Copy for D3D12_SHADER_MIN_PRECISION_SUPPORT {}
impl ::core::clone::Clone for D3D12_SHADER_MIN_PRECISION_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADER_MIN_PRECISION_SUPPORT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_MIN_PRECISION_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADER_MIN_PRECISION_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADER_MIN_PRECISION_SUPPORT")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_SHADER_MIN_PRECISION_SUPPORT {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_SHADER_MIN_PRECISION_SUPPORT {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_SHADER_MIN_PRECISION_SUPPORT {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_SHADER_MIN_PRECISION_SUPPORT {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_SHADER_MIN_PRECISION_SUPPORT {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_SHADER_MIN_PRECISION_SUPPORT {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADER_VERSION_TYPE(pub i32);
pub const D3D12_SHVER_PIXEL_SHADER: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(0i32);
pub const D3D12_SHVER_VERTEX_SHADER: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(1i32);
pub const D3D12_SHVER_GEOMETRY_SHADER: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(2i32);
pub const D3D12_SHVER_HULL_SHADER: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(3i32);
pub const D3D12_SHVER_DOMAIN_SHADER: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(4i32);
pub const D3D12_SHVER_COMPUTE_SHADER: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(5i32);
pub const D3D12_SHVER_LIBRARY: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(6i32);
pub const D3D12_SHVER_RAY_GENERATION_SHADER: D3D12_SHADER_VERSION_TYPE =
    D3D12_SHADER_VERSION_TYPE(7i32);
pub const D3D12_SHVER_INTERSECTION_SHADER: D3D12_SHADER_VERSION_TYPE =
    D3D12_SHADER_VERSION_TYPE(8i32);
pub const D3D12_SHVER_ANY_HIT_SHADER: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(9i32);
pub const D3D12_SHVER_CLOSEST_HIT_SHADER: D3D12_SHADER_VERSION_TYPE =
    D3D12_SHADER_VERSION_TYPE(10i32);
pub const D3D12_SHVER_MISS_SHADER: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(11i32);
pub const D3D12_SHVER_CALLABLE_SHADER: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(12i32);
pub const D3D12_SHVER_MESH_SHADER: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(13i32);
pub const D3D12_SHVER_AMPLIFICATION_SHADER: D3D12_SHADER_VERSION_TYPE =
    D3D12_SHADER_VERSION_TYPE(14i32);
pub const D3D12_SHVER_RESERVED0: D3D12_SHADER_VERSION_TYPE = D3D12_SHADER_VERSION_TYPE(65520i32);
impl ::core::marker::Copy for D3D12_SHADER_VERSION_TYPE {}
impl ::core::clone::Clone for D3D12_SHADER_VERSION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADER_VERSION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_VERSION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADER_VERSION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADER_VERSION_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADER_VISIBILITY(pub i32);
pub const D3D12_SHADER_VISIBILITY_ALL: D3D12_SHADER_VISIBILITY = D3D12_SHADER_VISIBILITY(0i32);
pub const D3D12_SHADER_VISIBILITY_VERTEX: D3D12_SHADER_VISIBILITY = D3D12_SHADER_VISIBILITY(1i32);
pub const D3D12_SHADER_VISIBILITY_HULL: D3D12_SHADER_VISIBILITY = D3D12_SHADER_VISIBILITY(2i32);
pub const D3D12_SHADER_VISIBILITY_DOMAIN: D3D12_SHADER_VISIBILITY = D3D12_SHADER_VISIBILITY(3i32);
pub const D3D12_SHADER_VISIBILITY_GEOMETRY: D3D12_SHADER_VISIBILITY = D3D12_SHADER_VISIBILITY(4i32);
pub const D3D12_SHADER_VISIBILITY_PIXEL: D3D12_SHADER_VISIBILITY = D3D12_SHADER_VISIBILITY(5i32);
pub const D3D12_SHADER_VISIBILITY_AMPLIFICATION: D3D12_SHADER_VISIBILITY =
    D3D12_SHADER_VISIBILITY(6i32);
pub const D3D12_SHADER_VISIBILITY_MESH: D3D12_SHADER_VISIBILITY = D3D12_SHADER_VISIBILITY(7i32);
impl ::core::marker::Copy for D3D12_SHADER_VISIBILITY {}
impl ::core::clone::Clone for D3D12_SHADER_VISIBILITY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADER_VISIBILITY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_VISIBILITY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADER_VISIBILITY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADER_VISIBILITY")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADING_RATE(pub i32);
pub const D3D12_SHADING_RATE_1X1: D3D12_SHADING_RATE = D3D12_SHADING_RATE(0i32);
pub const D3D12_SHADING_RATE_1X2: D3D12_SHADING_RATE = D3D12_SHADING_RATE(1i32);
pub const D3D12_SHADING_RATE_2X1: D3D12_SHADING_RATE = D3D12_SHADING_RATE(4i32);
pub const D3D12_SHADING_RATE_2X2: D3D12_SHADING_RATE = D3D12_SHADING_RATE(5i32);
pub const D3D12_SHADING_RATE_2X4: D3D12_SHADING_RATE = D3D12_SHADING_RATE(6i32);
pub const D3D12_SHADING_RATE_4X2: D3D12_SHADING_RATE = D3D12_SHADING_RATE(9i32);
pub const D3D12_SHADING_RATE_4X4: D3D12_SHADING_RATE = D3D12_SHADING_RATE(10i32);
impl ::core::marker::Copy for D3D12_SHADING_RATE {}
impl ::core::clone::Clone for D3D12_SHADING_RATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADING_RATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADING_RATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADING_RATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADING_RATE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHADING_RATE_COMBINER(pub i32);
pub const D3D12_SHADING_RATE_COMBINER_PASSTHROUGH: D3D12_SHADING_RATE_COMBINER =
    D3D12_SHADING_RATE_COMBINER(0i32);
pub const D3D12_SHADING_RATE_COMBINER_OVERRIDE: D3D12_SHADING_RATE_COMBINER =
    D3D12_SHADING_RATE_COMBINER(1i32);
pub const D3D12_SHADING_RATE_COMBINER_MIN: D3D12_SHADING_RATE_COMBINER =
    D3D12_SHADING_RATE_COMBINER(2i32);
pub const D3D12_SHADING_RATE_COMBINER_MAX: D3D12_SHADING_RATE_COMBINER =
    D3D12_SHADING_RATE_COMBINER(3i32);
pub const D3D12_SHADING_RATE_COMBINER_SUM: D3D12_SHADING_RATE_COMBINER =
    D3D12_SHADING_RATE_COMBINER(4i32);
impl ::core::marker::Copy for D3D12_SHADING_RATE_COMBINER {}
impl ::core::clone::Clone for D3D12_SHADING_RATE_COMBINER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHADING_RATE_COMBINER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHADING_RATE_COMBINER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHADING_RATE_COMBINER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHADING_RATE_COMBINER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER(pub i32);
pub const D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER_0: D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER =
    D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER(0i32);
pub const D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER_1: D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER =
    D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER(1i32);
pub const D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER_2: D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER =
    D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER(2i32);
impl ::core::marker::Copy for D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER {}
impl ::core::clone::Clone for D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_SRV_DIMENSION(pub i32);
pub const D3D12_SRV_DIMENSION_UNKNOWN: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(0i32);
pub const D3D12_SRV_DIMENSION_BUFFER: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(1i32);
pub const D3D12_SRV_DIMENSION_TEXTURE1D: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(2i32);
pub const D3D12_SRV_DIMENSION_TEXTURE1DARRAY: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(3i32);
pub const D3D12_SRV_DIMENSION_TEXTURE2D: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(4i32);
pub const D3D12_SRV_DIMENSION_TEXTURE2DARRAY: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(5i32);
pub const D3D12_SRV_DIMENSION_TEXTURE2DMS: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(6i32);
pub const D3D12_SRV_DIMENSION_TEXTURE2DMSARRAY: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(7i32);
pub const D3D12_SRV_DIMENSION_TEXTURE3D: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(8i32);
pub const D3D12_SRV_DIMENSION_TEXTURECUBE: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(9i32);
pub const D3D12_SRV_DIMENSION_TEXTURECUBEARRAY: D3D12_SRV_DIMENSION = D3D12_SRV_DIMENSION(10i32);
pub const D3D12_SRV_DIMENSION_RAYTRACING_ACCELERATION_STRUCTURE: D3D12_SRV_DIMENSION =
    D3D12_SRV_DIMENSION(11i32);
impl ::core::marker::Copy for D3D12_SRV_DIMENSION {}
impl ::core::clone::Clone for D3D12_SRV_DIMENSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_SRV_DIMENSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_SRV_DIMENSION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_SRV_DIMENSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_SRV_DIMENSION").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_STATE_OBJECT_FLAGS(pub i32);
pub const D3D12_STATE_OBJECT_FLAG_NONE: D3D12_STATE_OBJECT_FLAGS = D3D12_STATE_OBJECT_FLAGS(0i32);
pub const D3D12_STATE_OBJECT_FLAG_ALLOW_LOCAL_DEPENDENCIES_ON_EXTERNAL_DEFINITIONS:
    D3D12_STATE_OBJECT_FLAGS = D3D12_STATE_OBJECT_FLAGS(1i32);
pub const D3D12_STATE_OBJECT_FLAG_ALLOW_EXTERNAL_DEPENDENCIES_ON_LOCAL_DEFINITIONS:
    D3D12_STATE_OBJECT_FLAGS = D3D12_STATE_OBJECT_FLAGS(2i32);
pub const D3D12_STATE_OBJECT_FLAG_ALLOW_STATE_OBJECT_ADDITIONS: D3D12_STATE_OBJECT_FLAGS =
    D3D12_STATE_OBJECT_FLAGS(4i32);
impl ::core::marker::Copy for D3D12_STATE_OBJECT_FLAGS {}
impl ::core::clone::Clone for D3D12_STATE_OBJECT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_STATE_OBJECT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_STATE_OBJECT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_STATE_OBJECT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_STATE_OBJECT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_STATE_OBJECT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_STATE_OBJECT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_STATE_OBJECT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_STATE_OBJECT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_STATE_OBJECT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_STATE_OBJECT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_STATE_OBJECT_TYPE(pub i32);
pub const D3D12_STATE_OBJECT_TYPE_COLLECTION: D3D12_STATE_OBJECT_TYPE =
    D3D12_STATE_OBJECT_TYPE(0i32);
pub const D3D12_STATE_OBJECT_TYPE_RAYTRACING_PIPELINE: D3D12_STATE_OBJECT_TYPE =
    D3D12_STATE_OBJECT_TYPE(3i32);
pub const D3D12_STATE_OBJECT_TYPE_EXECUTABLE: D3D12_STATE_OBJECT_TYPE =
    D3D12_STATE_OBJECT_TYPE(4i32);
impl ::core::marker::Copy for D3D12_STATE_OBJECT_TYPE {}
impl ::core::clone::Clone for D3D12_STATE_OBJECT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_STATE_OBJECT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_STATE_OBJECT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_STATE_OBJECT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_STATE_OBJECT_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_STATE_SUBOBJECT_TYPE(pub i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_STATE_OBJECT_CONFIG: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(0i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_GLOBAL_ROOT_SIGNATURE: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(1i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_LOCAL_ROOT_SIGNATURE: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(2i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_NODE_MASK: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(3i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_DXIL_LIBRARY: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(5i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_EXISTING_COLLECTION: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(6i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_SUBOBJECT_TO_EXPORTS_ASSOCIATION: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(7i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION:
    D3D12_STATE_SUBOBJECT_TYPE = D3D12_STATE_SUBOBJECT_TYPE(8i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_SHADER_CONFIG: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(9i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(10i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_HIT_GROUP: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(11i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_RAYTRACING_PIPELINE_CONFIG1: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(12i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_WORK_GRAPH: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(13i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_STREAM_OUTPUT: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(14i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_BLEND: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(15i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_SAMPLE_MASK: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(16i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_RASTERIZER: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(17i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(18i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_INPUT_LAYOUT: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(19i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_IB_STRIP_CUT_VALUE: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(20i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_PRIMITIVE_TOPOLOGY: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(21i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_RENDER_TARGET_FORMATS: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(22i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL_FORMAT: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(23i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_SAMPLE_DESC: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(24i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_FLAGS: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(26i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL1: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(27i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(28i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_GENERIC_PROGRAM: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(29i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_DEPTH_STENCIL2: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(30i32);
pub const D3D12_STATE_SUBOBJECT_TYPE_MAX_VALID: D3D12_STATE_SUBOBJECT_TYPE =
    D3D12_STATE_SUBOBJECT_TYPE(31i32);
impl ::core::marker::Copy for D3D12_STATE_SUBOBJECT_TYPE {}
impl ::core::clone::Clone for D3D12_STATE_SUBOBJECT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_STATE_SUBOBJECT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_STATE_SUBOBJECT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_STATE_SUBOBJECT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_STATE_SUBOBJECT_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_STATIC_BORDER_COLOR(pub i32);
pub const D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK: D3D12_STATIC_BORDER_COLOR =
    D3D12_STATIC_BORDER_COLOR(0i32);
pub const D3D12_STATIC_BORDER_COLOR_OPAQUE_BLACK: D3D12_STATIC_BORDER_COLOR =
    D3D12_STATIC_BORDER_COLOR(1i32);
pub const D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE: D3D12_STATIC_BORDER_COLOR =
    D3D12_STATIC_BORDER_COLOR(2i32);
pub const D3D12_STATIC_BORDER_COLOR_OPAQUE_BLACK_UINT: D3D12_STATIC_BORDER_COLOR =
    D3D12_STATIC_BORDER_COLOR(3i32);
pub const D3D12_STATIC_BORDER_COLOR_OPAQUE_WHITE_UINT: D3D12_STATIC_BORDER_COLOR =
    D3D12_STATIC_BORDER_COLOR(4i32);
impl ::core::marker::Copy for D3D12_STATIC_BORDER_COLOR {}
impl ::core::clone::Clone for D3D12_STATIC_BORDER_COLOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_STATIC_BORDER_COLOR {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_STATIC_BORDER_COLOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_STATIC_BORDER_COLOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_STATIC_BORDER_COLOR")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_STENCIL_OP(pub i32);
pub const D3D12_STENCIL_OP_KEEP: D3D12_STENCIL_OP = D3D12_STENCIL_OP(1i32);
pub const D3D12_STENCIL_OP_ZERO: D3D12_STENCIL_OP = D3D12_STENCIL_OP(2i32);
pub const D3D12_STENCIL_OP_REPLACE: D3D12_STENCIL_OP = D3D12_STENCIL_OP(3i32);
pub const D3D12_STENCIL_OP_INCR_SAT: D3D12_STENCIL_OP = D3D12_STENCIL_OP(4i32);
pub const D3D12_STENCIL_OP_DECR_SAT: D3D12_STENCIL_OP = D3D12_STENCIL_OP(5i32);
pub const D3D12_STENCIL_OP_INVERT: D3D12_STENCIL_OP = D3D12_STENCIL_OP(6i32);
pub const D3D12_STENCIL_OP_INCR: D3D12_STENCIL_OP = D3D12_STENCIL_OP(7i32);
pub const D3D12_STENCIL_OP_DECR: D3D12_STENCIL_OP = D3D12_STENCIL_OP(8i32);
impl ::core::marker::Copy for D3D12_STENCIL_OP {}
impl ::core::clone::Clone for D3D12_STENCIL_OP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_STENCIL_OP {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_STENCIL_OP {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_STENCIL_OP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_STENCIL_OP").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_TEXTURE_ADDRESS_MODE(pub i32);
pub const D3D12_TEXTURE_ADDRESS_MODE_WRAP: D3D12_TEXTURE_ADDRESS_MODE =
    D3D12_TEXTURE_ADDRESS_MODE(1i32);
pub const D3D12_TEXTURE_ADDRESS_MODE_MIRROR: D3D12_TEXTURE_ADDRESS_MODE =
    D3D12_TEXTURE_ADDRESS_MODE(2i32);
pub const D3D12_TEXTURE_ADDRESS_MODE_CLAMP: D3D12_TEXTURE_ADDRESS_MODE =
    D3D12_TEXTURE_ADDRESS_MODE(3i32);
pub const D3D12_TEXTURE_ADDRESS_MODE_BORDER: D3D12_TEXTURE_ADDRESS_MODE =
    D3D12_TEXTURE_ADDRESS_MODE(4i32);
pub const D3D12_TEXTURE_ADDRESS_MODE_MIRROR_ONCE: D3D12_TEXTURE_ADDRESS_MODE =
    D3D12_TEXTURE_ADDRESS_MODE(5i32);
impl ::core::marker::Copy for D3D12_TEXTURE_ADDRESS_MODE {}
impl ::core::clone::Clone for D3D12_TEXTURE_ADDRESS_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_TEXTURE_ADDRESS_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_TEXTURE_ADDRESS_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_TEXTURE_ADDRESS_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_TEXTURE_ADDRESS_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_TEXTURE_BARRIER_FLAGS(pub i32);
pub const D3D12_TEXTURE_BARRIER_FLAG_NONE: D3D12_TEXTURE_BARRIER_FLAGS =
    D3D12_TEXTURE_BARRIER_FLAGS(0i32);
pub const D3D12_TEXTURE_BARRIER_FLAG_DISCARD: D3D12_TEXTURE_BARRIER_FLAGS =
    D3D12_TEXTURE_BARRIER_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_TEXTURE_BARRIER_FLAGS {}
impl ::core::clone::Clone for D3D12_TEXTURE_BARRIER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_TEXTURE_BARRIER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_TEXTURE_BARRIER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_TEXTURE_BARRIER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_TEXTURE_BARRIER_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_TEXTURE_BARRIER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_TEXTURE_BARRIER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_TEXTURE_BARRIER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_TEXTURE_BARRIER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_TEXTURE_BARRIER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_TEXTURE_BARRIER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_TEXTURE_COPY_TYPE(pub i32);
pub const D3D12_TEXTURE_COPY_TYPE_SUBRESOURCE_INDEX: D3D12_TEXTURE_COPY_TYPE =
    D3D12_TEXTURE_COPY_TYPE(0i32);
pub const D3D12_TEXTURE_COPY_TYPE_PLACED_FOOTPRINT: D3D12_TEXTURE_COPY_TYPE =
    D3D12_TEXTURE_COPY_TYPE(1i32);
impl ::core::marker::Copy for D3D12_TEXTURE_COPY_TYPE {}
impl ::core::clone::Clone for D3D12_TEXTURE_COPY_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_TEXTURE_COPY_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_TEXTURE_COPY_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_TEXTURE_COPY_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_TEXTURE_COPY_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_TEXTURE_LAYOUT(pub i32);
pub const D3D12_TEXTURE_LAYOUT_UNKNOWN: D3D12_TEXTURE_LAYOUT = D3D12_TEXTURE_LAYOUT(0i32);
pub const D3D12_TEXTURE_LAYOUT_ROW_MAJOR: D3D12_TEXTURE_LAYOUT = D3D12_TEXTURE_LAYOUT(1i32);
pub const D3D12_TEXTURE_LAYOUT_64KB_UNDEFINED_SWIZZLE: D3D12_TEXTURE_LAYOUT =
    D3D12_TEXTURE_LAYOUT(2i32);
pub const D3D12_TEXTURE_LAYOUT_64KB_STANDARD_SWIZZLE: D3D12_TEXTURE_LAYOUT =
    D3D12_TEXTURE_LAYOUT(3i32);
impl ::core::marker::Copy for D3D12_TEXTURE_LAYOUT {}
impl ::core::clone::Clone for D3D12_TEXTURE_LAYOUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_TEXTURE_LAYOUT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_TEXTURE_LAYOUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_TEXTURE_LAYOUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_TEXTURE_LAYOUT")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_TILED_RESOURCES_TIER(pub i32);
pub const D3D12_TILED_RESOURCES_TIER_NOT_SUPPORTED: D3D12_TILED_RESOURCES_TIER =
    D3D12_TILED_RESOURCES_TIER(0i32);
pub const D3D12_TILED_RESOURCES_TIER_1: D3D12_TILED_RESOURCES_TIER =
    D3D12_TILED_RESOURCES_TIER(1i32);
pub const D3D12_TILED_RESOURCES_TIER_2: D3D12_TILED_RESOURCES_TIER =
    D3D12_TILED_RESOURCES_TIER(2i32);
pub const D3D12_TILED_RESOURCES_TIER_3: D3D12_TILED_RESOURCES_TIER =
    D3D12_TILED_RESOURCES_TIER(3i32);
pub const D3D12_TILED_RESOURCES_TIER_4: D3D12_TILED_RESOURCES_TIER =
    D3D12_TILED_RESOURCES_TIER(4i32);
impl ::core::marker::Copy for D3D12_TILED_RESOURCES_TIER {}
impl ::core::clone::Clone for D3D12_TILED_RESOURCES_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_TILED_RESOURCES_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_TILED_RESOURCES_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_TILED_RESOURCES_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_TILED_RESOURCES_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_TILE_COPY_FLAGS(pub i32);
pub const D3D12_TILE_COPY_FLAG_NONE: D3D12_TILE_COPY_FLAGS = D3D12_TILE_COPY_FLAGS(0i32);
pub const D3D12_TILE_COPY_FLAG_NO_HAZARD: D3D12_TILE_COPY_FLAGS = D3D12_TILE_COPY_FLAGS(1i32);
pub const D3D12_TILE_COPY_FLAG_LINEAR_BUFFER_TO_SWIZZLED_TILED_RESOURCE: D3D12_TILE_COPY_FLAGS =
    D3D12_TILE_COPY_FLAGS(2i32);
pub const D3D12_TILE_COPY_FLAG_SWIZZLED_TILED_RESOURCE_TO_LINEAR_BUFFER: D3D12_TILE_COPY_FLAGS =
    D3D12_TILE_COPY_FLAGS(4i32);
impl ::core::marker::Copy for D3D12_TILE_COPY_FLAGS {}
impl ::core::clone::Clone for D3D12_TILE_COPY_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_TILE_COPY_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_TILE_COPY_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_TILE_COPY_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_TILE_COPY_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_TILE_COPY_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_TILE_COPY_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_TILE_COPY_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_TILE_COPY_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_TILE_COPY_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_TILE_COPY_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_TILE_MAPPING_FLAGS(pub i32);
pub const D3D12_TILE_MAPPING_FLAG_NONE: D3D12_TILE_MAPPING_FLAGS = D3D12_TILE_MAPPING_FLAGS(0i32);
pub const D3D12_TILE_MAPPING_FLAG_NO_HAZARD: D3D12_TILE_MAPPING_FLAGS =
    D3D12_TILE_MAPPING_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_TILE_MAPPING_FLAGS {}
impl ::core::clone::Clone for D3D12_TILE_MAPPING_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_TILE_MAPPING_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_TILE_MAPPING_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_TILE_MAPPING_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_TILE_MAPPING_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_TILE_MAPPING_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_TILE_MAPPING_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_TILE_MAPPING_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_TILE_MAPPING_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_TILE_MAPPING_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_TILE_MAPPING_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_TILE_RANGE_FLAGS(pub i32);
pub const D3D12_TILE_RANGE_FLAG_NONE: D3D12_TILE_RANGE_FLAGS = D3D12_TILE_RANGE_FLAGS(0i32);
pub const D3D12_TILE_RANGE_FLAG_NULL: D3D12_TILE_RANGE_FLAGS = D3D12_TILE_RANGE_FLAGS(1i32);
pub const D3D12_TILE_RANGE_FLAG_SKIP: D3D12_TILE_RANGE_FLAGS = D3D12_TILE_RANGE_FLAGS(2i32);
pub const D3D12_TILE_RANGE_FLAG_REUSE_SINGLE_TILE: D3D12_TILE_RANGE_FLAGS =
    D3D12_TILE_RANGE_FLAGS(4i32);
impl ::core::marker::Copy for D3D12_TILE_RANGE_FLAGS {}
impl ::core::clone::Clone for D3D12_TILE_RANGE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_TILE_RANGE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_TILE_RANGE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_TILE_RANGE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_TILE_RANGE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_TRI_STATE(pub i32);
pub const D3D12_TRI_STATE_UNKNOWN: D3D12_TRI_STATE = D3D12_TRI_STATE(-1i32);
pub const D3D12_TRI_STATE_FALSE: D3D12_TRI_STATE = D3D12_TRI_STATE(0i32);
pub const D3D12_TRI_STATE_TRUE: D3D12_TRI_STATE = D3D12_TRI_STATE(1i32);
impl ::core::marker::Copy for D3D12_TRI_STATE {}
impl ::core::clone::Clone for D3D12_TRI_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_TRI_STATE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_TRI_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_TRI_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_TRI_STATE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_UAV_DIMENSION(pub i32);
pub const D3D12_UAV_DIMENSION_UNKNOWN: D3D12_UAV_DIMENSION = D3D12_UAV_DIMENSION(0i32);
pub const D3D12_UAV_DIMENSION_BUFFER: D3D12_UAV_DIMENSION = D3D12_UAV_DIMENSION(1i32);
pub const D3D12_UAV_DIMENSION_TEXTURE1D: D3D12_UAV_DIMENSION = D3D12_UAV_DIMENSION(2i32);
pub const D3D12_UAV_DIMENSION_TEXTURE1DARRAY: D3D12_UAV_DIMENSION = D3D12_UAV_DIMENSION(3i32);
pub const D3D12_UAV_DIMENSION_TEXTURE2D: D3D12_UAV_DIMENSION = D3D12_UAV_DIMENSION(4i32);
pub const D3D12_UAV_DIMENSION_TEXTURE2DARRAY: D3D12_UAV_DIMENSION = D3D12_UAV_DIMENSION(5i32);
pub const D3D12_UAV_DIMENSION_TEXTURE2DMS: D3D12_UAV_DIMENSION = D3D12_UAV_DIMENSION(6i32);
pub const D3D12_UAV_DIMENSION_TEXTURE2DMSARRAY: D3D12_UAV_DIMENSION = D3D12_UAV_DIMENSION(7i32);
pub const D3D12_UAV_DIMENSION_TEXTURE3D: D3D12_UAV_DIMENSION = D3D12_UAV_DIMENSION(8i32);
impl ::core::marker::Copy for D3D12_UAV_DIMENSION {}
impl ::core::clone::Clone for D3D12_UAV_DIMENSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_UAV_DIMENSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_UAV_DIMENSION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_UAV_DIMENSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_UAV_DIMENSION").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VARIABLE_SHADING_RATE_TIER(pub i32);
pub const D3D12_VARIABLE_SHADING_RATE_TIER_NOT_SUPPORTED: D3D12_VARIABLE_SHADING_RATE_TIER =
    D3D12_VARIABLE_SHADING_RATE_TIER(0i32);
pub const D3D12_VARIABLE_SHADING_RATE_TIER_1: D3D12_VARIABLE_SHADING_RATE_TIER =
    D3D12_VARIABLE_SHADING_RATE_TIER(1i32);
pub const D3D12_VARIABLE_SHADING_RATE_TIER_2: D3D12_VARIABLE_SHADING_RATE_TIER =
    D3D12_VARIABLE_SHADING_RATE_TIER(2i32);
impl ::core::marker::Copy for D3D12_VARIABLE_SHADING_RATE_TIER {}
impl ::core::clone::Clone for D3D12_VARIABLE_SHADING_RATE_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VARIABLE_SHADING_RATE_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VARIABLE_SHADING_RATE_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VARIABLE_SHADING_RATE_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VARIABLE_SHADING_RATE_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_ARGUMENT_TYPE(pub i32);
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_PICTURE_PARAMETERS: D3D12_VIDEO_DECODE_ARGUMENT_TYPE =
    D3D12_VIDEO_DECODE_ARGUMENT_TYPE(0i32);
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_INVERSE_QUANTIZATION_MATRIX:
    D3D12_VIDEO_DECODE_ARGUMENT_TYPE = D3D12_VIDEO_DECODE_ARGUMENT_TYPE(1i32);
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_SLICE_CONTROL: D3D12_VIDEO_DECODE_ARGUMENT_TYPE =
    D3D12_VIDEO_DECODE_ARGUMENT_TYPE(2i32);
pub const D3D12_VIDEO_DECODE_ARGUMENT_TYPE_MAX_VALID: D3D12_VIDEO_DECODE_ARGUMENT_TYPE =
    D3D12_VIDEO_DECODE_ARGUMENT_TYPE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_ARGUMENT_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_ARGUMENT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_ARGUMENT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_ARGUMENT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_ARGUMENT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_ARGUMENT_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(pub i32);
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_NONE: D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS =
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(0i32);
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_HEIGHT_ALIGNMENT_MULTIPLE_32_REQUIRED:
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(1i32);
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_POST_PROCESSING_SUPPORTED:
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(2i32);
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_REFERENCE_ONLY_ALLOCATIONS_REQUIRED:
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(4i32);
pub const D3D12_VIDEO_DECODE_CONFIGURATION_FLAG_ALLOW_RESOLUTION_CHANGE_ON_NON_KEY_FRAME:
    D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS = D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS(pub i32);
pub const D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_NONE:
    D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS = D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS(0i32);
pub const D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAG_SUPPORTED:
    D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS = D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(pub i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_Y: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(0i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_U: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(1i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_V: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(2i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_R: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(0i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_G: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(1i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_B: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(2i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_A: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(pub i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_NONE:
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(0i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_Y:
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(1i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_U:
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(2i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_V:
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(4i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_R:
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(1i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_G:
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(2i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_B:
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(4i32);
pub const D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAG_A:
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS =
    D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_STATUS(pub i32);
pub const D3D12_VIDEO_DECODE_STATUS_OK: D3D12_VIDEO_DECODE_STATUS = D3D12_VIDEO_DECODE_STATUS(0i32);
pub const D3D12_VIDEO_DECODE_STATUS_CONTINUE: D3D12_VIDEO_DECODE_STATUS =
    D3D12_VIDEO_DECODE_STATUS(1i32);
pub const D3D12_VIDEO_DECODE_STATUS_CONTINUE_SKIP_DISPLAY: D3D12_VIDEO_DECODE_STATUS =
    D3D12_VIDEO_DECODE_STATUS(2i32);
pub const D3D12_VIDEO_DECODE_STATUS_RESTART: D3D12_VIDEO_DECODE_STATUS =
    D3D12_VIDEO_DECODE_STATUS(3i32);
pub const D3D12_VIDEO_DECODE_STATUS_RATE_EXCEEDED: D3D12_VIDEO_DECODE_STATUS =
    D3D12_VIDEO_DECODE_STATUS(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_STATUS {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_STATUS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_STATUS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_STATUS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_STATUS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_STATUS")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_SUPPORT_FLAGS(pub i32);
pub const D3D12_VIDEO_DECODE_SUPPORT_FLAG_NONE: D3D12_VIDEO_DECODE_SUPPORT_FLAGS =
    D3D12_VIDEO_DECODE_SUPPORT_FLAGS(0i32);
pub const D3D12_VIDEO_DECODE_SUPPORT_FLAG_SUPPORTED: D3D12_VIDEO_DECODE_SUPPORT_FLAGS =
    D3D12_VIDEO_DECODE_SUPPORT_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_SUPPORT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_DECODE_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_DECODE_TIER(pub i32);
pub const D3D12_VIDEO_DECODE_TIER_NOT_SUPPORTED: D3D12_VIDEO_DECODE_TIER =
    D3D12_VIDEO_DECODE_TIER(0i32);
pub const D3D12_VIDEO_DECODE_TIER_1: D3D12_VIDEO_DECODE_TIER = D3D12_VIDEO_DECODE_TIER(1i32);
pub const D3D12_VIDEO_DECODE_TIER_2: D3D12_VIDEO_DECODE_TIER = D3D12_VIDEO_DECODE_TIER(2i32);
pub const D3D12_VIDEO_DECODE_TIER_3: D3D12_VIDEO_DECODE_TIER = D3D12_VIDEO_DECODE_TIER(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_TIER {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_DECODE_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_DECODE_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE_SINGLE_REFERENCE:
    D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE =
    D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE_COMPOUND_REFERENCE:
    D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE =
    D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_NONE: D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_128x128_SUPERBLOCK:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_FILTER_INTRA: D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_INTRA_EDGE_FILTER:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_INTERINTRA_COMPOUND:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_MASKED_COMPOUND:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(16i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_WARPED_MOTION:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(32i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_DUAL_FILTER: D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(64i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_JNT_COMP: D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(128i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_FORCED_INTEGER_MOTION_VECTORS:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(256i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_SUPER_RESOLUTION:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(512i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_LOOP_RESTORATION_FILTER:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(1024i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_PALETTE_ENCODING:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(2048i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_CDEF_FILTERING:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(4096i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_INTRA_BLOCK_COPY:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(8192i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_FRAME_REFERENCE_MOTION_VECTORS:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(16384i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_ORDER_HINT_TOOLS:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(32768i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_AUTO_SEGMENTATION:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(65536i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_CUSTOM_SEGMENTATION:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(131072i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_LOOP_FILTER_DELTAS:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(262144i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_QUANTIZATION_DELTAS:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(524288i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_QUANTIZATION_MATRIX:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(1048576i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_REDUCED_TX_SET:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(2097152i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_MOTION_MODE_SWITCHABLE:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(4194304i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_ALLOW_HIGH_PRECISION_MV:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(8388608i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_SKIP_MODE_PRESENT:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(16777216i32);
pub const D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAG_DELTA_LF_PARAMS:
    D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS(33554432i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAG_NONE:
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAG_NOT_SPECIFIED:
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAG_CODEC_CONSTRAINT:
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAG_HARDWARE_CONSTRAINT : D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS ( 4i32 ) ;
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAG_ROWS_COUNT:
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAG_COLS_COUNT:
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS(16i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAG_WIDTH:
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS(32i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAG_AREA:
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS(64i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAG_TOTAL_TILES:
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS(128i32);
impl ::core::marker::Copy
    for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS
{
}
impl ::core::clone::Clone
    for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS
{
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default
    for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS
{
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind
    for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd
    for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS
{
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign
    for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS
{
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign
    for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS
{
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_KEY_FRAME: D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE =
    D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_INTER_FRAME: D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE =
    D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_INTRA_ONLY_FRAME: D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE =
    D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_SWITCH_FRAME: D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE =
    D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAG_NONE: D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAG_KEY_FRAME:
    D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAG_INTER_FRAME:
    D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAG_INTRA_ONLY_FRAME:
    D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAG_SWITCH_FRAME:
    D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS = D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_EIGHTTAP:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_EIGHTTAP_SMOOTH:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_EIGHTTAP_SHARP:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_BILINEAR:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS(3i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_SWITCHABLE:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAG_NONE:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAG_EIGHTTAP:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAG_EIGHTTAP_SMOOTH:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAG_EIGHTTAP_SHARP:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAG_BILINEAR:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAG_SWITCHABLE:
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS(16i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_LEVELS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_2_0: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_2_1: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_2_2: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_2_3: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(3i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_3_0: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(4i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_3_1: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(5i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_3_2: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(6i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_3_3: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(7i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_4_0: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(8i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_4_1: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(9i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_4_2: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(10i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_4_3: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(11i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_5_0: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(12i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_5_1: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(13i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_5_2: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(14i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_5_3: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(15i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_6_0: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(16i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_6_1: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(17i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_6_2: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(18i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_6_3: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(19i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_7_0: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(20i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_7_1: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(21i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_7_2: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(22i32);
pub const D3D12_VIDEO_ENCODER_AV1_LEVELS_7_3: D3D12_VIDEO_ENCODER_AV1_LEVELS =
    D3D12_VIDEO_ENCODER_AV1_LEVELS(23i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_LEVELS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_LEVELS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_LEVELS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_LEVELS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_LEVELS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_LEVELS")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_NONE:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_ENABLE_ERROR_RESILIENT_MODE:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_DISABLE_CDF_UPDATE:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_ENABLE_PALETTE_ENCODING:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_ENABLE_SKIP_MODE:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_FRAME_REFERENCE_MOTION_VECTORS:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(16i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_FORCE_INTEGER_MOTION_VECTORS:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(32i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_ALLOW_INTRA_BLOCK_COPY:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(64i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_USE_SUPER_RESOLUTION:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(128i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_DISABLE_FRAME_END_UPDATE_CDF:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(256i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_ENABLE_FRAME_SEGMENTATION_AUTO:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(512i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_ENABLE_FRAME_SEGMENTATION_CUSTOM:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(1024i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_ENABLE_WARPED_MOTION:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(2048i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_REDUCED_TX_SET:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(4096i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_MOTION_MODE_SWITCHABLE:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(8192i32);
pub const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAG_ALLOW_HIGH_PRECISION_MV:
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS(16384i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAG_NONE:
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAG_QUANTIZATION:
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAG_QUANTIZATION_DELTA:
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAG_LOOP_FILTER:
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAG_LOOP_FILTER_DELTA:
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAG_CDEF_DATA:
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(16i32);
pub const D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAG_CONTEXT_UPDATE_TILE_ID:
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(32i32);
pub const D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAG_COMPOUND_PREDICTION_MODE:
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(64i32);
pub const D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAG_PRIMARY_REF_FRAME:
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(128i32);
pub const D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAG_REFERENCE_INDICES:
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS(256i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_PROFILE(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_PROFILE_MAIN: D3D12_VIDEO_ENCODER_AV1_PROFILE =
    D3D12_VIDEO_ENCODER_AV1_PROFILE(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_PROFILE_HIGH: D3D12_VIDEO_ENCODER_AV1_PROFILE =
    D3D12_VIDEO_ENCODER_AV1_PROFILE(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_PROFILE_PROFESSIONAL: D3D12_VIDEO_ENCODER_AV1_PROFILE =
    D3D12_VIDEO_ENCODER_AV1_PROFILE(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_PROFILE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_PROFILE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_PROFILE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_PROFILE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_PROFILE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_PROFILE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_IDENTITY:
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION =
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_TRANSLATION:
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION =
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_ROTZOOM:
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION =
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_AFFINE:
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION =
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAG_NONE:
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAG_IDENTITY:
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAG_TRANSLATION:
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAG_ROTZOOM:
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAG_AFFINE:
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default
    for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS
{
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind
    for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign
    for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS
{
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign
    for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS
{
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAG_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAG_32x32:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAG_64x64:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAG_128x128:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAG_256x256:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS(8i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE_DISABLED:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE =
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE_32x32:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE =
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE_64x64:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE =
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE_128x128:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE =
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE(3i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE_256x256:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE =
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE_DISABLED:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE = D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE_SWITCHABLE:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE = D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE_WIENER:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE = D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE_SGRPROJ:
    D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE = D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE_4x4:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE_8x8:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE_16x16:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE_32x32:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE(3i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE_64x64:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_DISABLED:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE = D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_ALT_Q:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE = D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_ALT_LF_Y_V:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE = D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_ALT_LF_Y_H:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE = D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE(3i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_ALT_LF_U:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE = D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE(4i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_ALT_LF_V:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE = D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE(5i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_ALT_REF_FRAME:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE = D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE(6i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_ALT_SKIP:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE = D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE(7i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_ALT_GLOBALMV:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE = D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE(8i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAG_NONE:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAG_DISABLED:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAG_ALT_Q:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAG_ALT_LF_Y_V:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAG_ALT_LF_Y_H:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAG_ALT_LF_U:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(16i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAG_ALT_LF_V:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(32i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAG_REF_FRAME:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(64i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAG_ALT_SKIP:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(128i32);
pub const D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAG_ALT_GLOBALMV:
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS(256i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_TIER(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_TIER_MAIN: D3D12_VIDEO_ENCODER_AV1_TIER =
    D3D12_VIDEO_ENCODER_AV1_TIER(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_TIER_HIGH: D3D12_VIDEO_ENCODER_AV1_TIER =
    D3D12_VIDEO_ENCODER_AV1_TIER(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_TIER {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_TX_MODE(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_TX_MODE_ONLY4x4: D3D12_VIDEO_ENCODER_AV1_TX_MODE =
    D3D12_VIDEO_ENCODER_AV1_TX_MODE(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_TX_MODE_LARGEST: D3D12_VIDEO_ENCODER_AV1_TX_MODE =
    D3D12_VIDEO_ENCODER_AV1_TX_MODE(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_TX_MODE_SELECT: D3D12_VIDEO_ENCODER_AV1_TX_MODE =
    D3D12_VIDEO_ENCODER_AV1_TX_MODE(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_TX_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_TX_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_TX_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_TX_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_TX_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_TX_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAG_NONE: D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAG_ONLY4x4: D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAG_LARGEST: D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAG_SELECT: D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC(pub i32);
pub const D3D12_VIDEO_ENCODER_CODEC_H264: D3D12_VIDEO_ENCODER_CODEC =
    D3D12_VIDEO_ENCODER_CODEC(0i32);
pub const D3D12_VIDEO_ENCODER_CODEC_HEVC: D3D12_VIDEO_ENCODER_CODEC =
    D3D12_VIDEO_ENCODER_CODEC(1i32);
pub const D3D12_VIDEO_ENCODER_CODEC_AV1: D3D12_VIDEO_ENCODER_CODEC =
    D3D12_VIDEO_ENCODER_CODEC(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES(pub i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES_DISABLED:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES(0i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES_TEMPORAL:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES(1i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES_SPATIAL:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_NONE:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_USE_CONSTRAINED_INTRAPREDICTION:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_USE_ADAPTIVE_8x8_TRANSFORM:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_ENABLE_CABAC_ENCODING:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAG_ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS ( 8i32 ) ;
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES(pub i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES ( 0i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_1_DISABLE_ALL_SLICE_BLOCK_EDGES : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES ( 1i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_2_DISABLE_SLICE_BOUNDARIES_BLOCKS : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES ( 2i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_3_USE_TWO_STAGE_DEBLOCKING : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES ( 3i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_4_DISABLE_CHROMA_BLOCK_EDGES : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES ( 4i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES ( 5i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES ( 6i32 ) ;
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES
{
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_NONE:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_0_ALL_LUMA_CHROMA_SLICE_BLOCK_EDGES_ALWAYS_FILTERED : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS ( 1i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_1_DISABLE_ALL_SLICE_BLOCK_EDGES : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS ( 2i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_2_DISABLE_SLICE_BOUNDARIES_BLOCKS : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS ( 4i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_3_USE_TWO_STAGE_DEBLOCKING : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS ( 8i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_4_DISABLE_CHROMA_BLOCK_EDGES : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS ( 16i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_5_DISABLE_CHROMA_BLOCK_EDGES_AND_LUMA_BOUNDARIES : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS ( 32i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAG_6_DISABLE_CHROMA_BLOCK_EDGES_AND_USE_LUMA_TWO_STAGE_DEBLOCKING : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS ( 64i32 ) ;
impl ::core::marker::Copy
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS
{
}
impl ::core::clone::Clone
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS
{
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS
{
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS
{
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS
{
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS
{
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS
{
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not
    for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS
{
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE(pub i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_8x8:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE(0i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_16x16:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE(1i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_32x32:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE(2i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE_64x64:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_NONE:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_DISABLE_LOOP_FILTER_ACROSS_SLICES:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ALLOW_REQUEST_INTRA_CONSTRAINED_SLICES : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS ( 2i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ENABLE_SAO_FILTER:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ENABLE_LONG_TERM_REFERENCES:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_USE_ASYMETRIC_MOTION_PARTITION:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(16i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_ENABLE_TRANSFORM_SKIPPING:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(32i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAG_USE_CONSTRAINED_INTRAPREDICTION:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS(64i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE(pub i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_4x4:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE(0i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_8x8:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE(1i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_16x16:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE(2i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE_32x32:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_NONE:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_CABAC_ENCODING_SUPPORT:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS ( 2i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_BFRAME_LTR_COMBINED_SUPPORT:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_ADAPTIVE_8x8_TRANSFORM_ENCODING_SUPPORT : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS ( 8i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_DIRECT_SPATIAL_ENCODING_SUPPORT : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS ( 16i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_DIRECT_TEMPORAL_ENCODING_SUPPORT : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS ( 32i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAG_CONSTRAINED_INTRAPREDICTION_SUPPORT : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS ( 64i32 ) ;
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_NONE:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_BFRAME_LTR_COMBINED_SUPPORT:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_INTRA_SLICE_CONSTRAINED_ENCODING_SUPPORT : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS ( 2i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_CONSTRAINED_INTRAPREDICTION_SUPPORT : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS ( 4i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_SAO_FILTER_SUPPORT:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_ASYMETRIC_MOTION_PARTITION_SUPPORT : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS ( 16i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_ASYMETRIC_MOTION_PARTITION_REQUIRED : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS ( 32i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_TRANSFORM_SKIP_SUPPORT:
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS(64i32);
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_DISABLING_LOOP_FILTER_ACROSS_SLICES_SUPPORT : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS ( 128i32 ) ;
pub const D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAG_P_FRAMES_IMPLEMENTED_AS_LOW_DELAY_B_FRAMES : D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS = D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS ( 256i32 ) ;
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_NO_ERROR: D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS =
    D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_CODEC_PICTURE_CONTROL_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_SUBREGION_LAYOUT_CONFIGURATION_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_INVALID_REFERENCE_PICTURES:
    D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_RECONFIGURATION_REQUEST_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAG_INVALID_METADATA_BUFFER_SOURCE:
    D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS = D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS(16i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_ENCODE_ERROR_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_FLAG_NONE: D3D12_VIDEO_ENCODER_FLAGS =
    D3D12_VIDEO_ENCODER_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(pub i32);
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_FULL_FRAME:
    D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE =
    D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(0i32);
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_BYTES_PER_SUBREGION:
    D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE =
    D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(1i32);
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_SQUARE_UNITS_PER_SUBREGION_ROW_UNALIGNED : D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE ( 2i32 ) ;
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_ROWS_PER_SUBREGION : D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE ( 3i32 ) ;
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_PARTITIONING_SUBREGIONS_PER_FRAME : D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE = D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE ( 4i32 ) ;
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_UNIFORM_GRID_PARTITION:
    D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE =
    D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(5i32);
pub const D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE_CONFIGURABLE_GRID_PARTITION:
    D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE =
    D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE(6i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_FRAME_TYPE_H264(pub i32);
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_I_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 =
    D3D12_VIDEO_ENCODER_FRAME_TYPE_H264(0i32);
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_P_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 =
    D3D12_VIDEO_ENCODER_FRAME_TYPE_H264(1i32);
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_B_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 =
    D3D12_VIDEO_ENCODER_FRAME_TYPE_H264(2i32);
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_H264_IDR_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 =
    D3D12_VIDEO_ENCODER_FRAME_TYPE_H264(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_FRAME_TYPE_H264")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC(pub i32);
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_I_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC =
    D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC(0i32);
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_P_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC =
    D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC(1i32);
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_B_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC =
    D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC(2i32);
pub const D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC_IDR_FRAME: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC =
    D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_HEAP_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_HEAP_FLAG_NONE: D3D12_VIDEO_ENCODER_HEAP_FLAGS =
    D3D12_VIDEO_ENCODER_HEAP_FLAGS(0i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_HEAP_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_HEAP_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_HEAP_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE(pub i32);
pub const D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE_NONE: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE =
    D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE(0i32);
pub const D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE_ROW_BASED: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE =
    D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_LEVELS_H264(pub i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_1: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(0i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_1b: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(1i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_11: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(2i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_12: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(3i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_13: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(4i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_2: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(5i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_21: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(6i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_22: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(7i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_3: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(8i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_31: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(9i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_32: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(10i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_4: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(11i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_41: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(12i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_42: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(13i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_5: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(14i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_51: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(15i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_52: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(16i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_6: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(17i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_61: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(18i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_H264_62: D3D12_VIDEO_ENCODER_LEVELS_H264 =
    D3D12_VIDEO_ENCODER_LEVELS_H264(19i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_LEVELS_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_LEVELS_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_LEVELS_H264 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_LEVELS_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_LEVELS_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_LEVELS_H264")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_LEVELS_HEVC(pub i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_1: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(0i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_2: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(1i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_21: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(2i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_3: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(3i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_31: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(4i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_4: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(5i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_41: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(6i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_5: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(7i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_51: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(8i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_52: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(9i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_6: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(10i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_61: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(11i32);
pub const D3D12_VIDEO_ENCODER_LEVELS_HEVC_62: D3D12_VIDEO_ENCODER_LEVELS_HEVC =
    D3D12_VIDEO_ENCODER_LEVELS_HEVC(12i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_LEVELS_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_LEVELS_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_LEVELS_HEVC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_LEVELS_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_LEVELS_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_LEVELS_HEVC")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(pub i32);
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_MAXIMUM:
    D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE =
    D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(0i32);
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_FULL_PIXEL:
    D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE =
    D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(1i32);
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_HALF_PIXEL:
    D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE =
    D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(2i32);
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_QUARTER_PIXEL:
    D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE =
    D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(3i32);
pub const D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE_EIGHTH_PIXEL:
    D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE =
    D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAG_NONE:
    D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS =
    D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAG_REQUEST_INTRA_CONSTRAINED_SLICES : D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS ( 1i32 ) ;
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAG_NONE:
    D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS =
    D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAG_REQUEST_INTRA_CONSTRAINED_SLICES : D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS ( 1i32 ) ;
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAG_NONE: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAG_USED_AS_REFERENCE_PICTURE:
    D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_PROFILE_H264(pub i32);
pub const D3D12_VIDEO_ENCODER_PROFILE_H264_MAIN: D3D12_VIDEO_ENCODER_PROFILE_H264 =
    D3D12_VIDEO_ENCODER_PROFILE_H264(0i32);
pub const D3D12_VIDEO_ENCODER_PROFILE_H264_HIGH: D3D12_VIDEO_ENCODER_PROFILE_H264 =
    D3D12_VIDEO_ENCODER_PROFILE_H264(1i32);
pub const D3D12_VIDEO_ENCODER_PROFILE_H264_HIGH_10: D3D12_VIDEO_ENCODER_PROFILE_H264 =
    D3D12_VIDEO_ENCODER_PROFILE_H264(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PROFILE_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PROFILE_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PROFILE_H264 {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PROFILE_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PROFILE_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_PROFILE_H264")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_PROFILE_HEVC(pub i32);
pub const D3D12_VIDEO_ENCODER_PROFILE_HEVC_MAIN: D3D12_VIDEO_ENCODER_PROFILE_HEVC =
    D3D12_VIDEO_ENCODER_PROFILE_HEVC(0i32);
pub const D3D12_VIDEO_ENCODER_PROFILE_HEVC_MAIN10: D3D12_VIDEO_ENCODER_PROFILE_HEVC =
    D3D12_VIDEO_ENCODER_PROFILE_HEVC(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PROFILE_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PROFILE_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PROFILE_HEVC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PROFILE_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PROFILE_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_PROFILE_HEVC")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_NONE: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS =
    D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_DELTA_QP:
    D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_FRAME_ANALYSIS:
    D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_QP_RANGE:
    D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_INITIAL_QP:
    D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_MAX_FRAME_SIZE:
    D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(16i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_VBV_SIZES:
    D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(32i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAG_ENABLE_EXTENDED_QVBR1_SUPPORT:
    D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS(64i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(pub i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_ABSOLUTE_QP_MAP:
    D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE = D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(0i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_CQP: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE =
    D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(1i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_CBR: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE =
    D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(2i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_VBR: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE =
    D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(3i32);
pub const D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE_QVBR: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE =
    D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_NONE:
    D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_RESOLUTION_CHANGE:
    D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_RATE_CONTROL_CHANGE:
    D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_SUBREGION_LAYOUT_CHANGE:
    D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_REQUEST_INTRA_REFRESH:
    D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAG_GOP_SEQUENCE_CHANGE:
    D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS = D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS(16i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_NONE: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS =
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_GENERAL_SUPPORT_OK: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS =
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_RECONFIGURATION_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(2i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RESOLUTION_RECONFIGURATION_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(4i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_VBV_SIZE_CONFIG_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_FRAME_ANALYSIS_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(16i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RECONSTRUCTED_FRAMES_REQUIRE_TEXTURE_ARRAYS:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(32i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_DELTA_QP_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(64i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_SUBREGION_LAYOUT_RECONFIGURATION_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(128i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_ADJUSTABLE_QP_RANGE_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(256i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_INITIAL_QP_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(512i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_MAX_FRAME_SIZE_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(1024i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_SEQUENCE_GOP_RECONFIGURATION_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(2048i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_MOTION_ESTIMATION_PRECISION_MODE_LIMIT_AVAILABLE:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(4096i32);
pub const D3D12_VIDEO_ENCODER_SUPPORT_FLAG_RATE_CONTROL_EXTENDED_QVBR1_SUPPORT:
    D3D12_VIDEO_ENCODER_SUPPORT_FLAGS = D3D12_VIDEO_ENCODER_SUPPORT_FLAGS(8192i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_SUPPORT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_TIER_HEVC(pub i32);
pub const D3D12_VIDEO_ENCODER_TIER_HEVC_MAIN: D3D12_VIDEO_ENCODER_TIER_HEVC =
    D3D12_VIDEO_ENCODER_TIER_HEVC(0i32);
pub const D3D12_VIDEO_ENCODER_TIER_HEVC_HIGH: D3D12_VIDEO_ENCODER_TIER_HEVC =
    D3D12_VIDEO_ENCODER_TIER_HEVC(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_TIER_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_TIER_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_TIER_HEVC {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_TIER_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_TIER_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_TIER_HEVC")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(pub i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_NONE: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS =
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(0i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_CODEC_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(1i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_INPUT_FORMAT_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(8i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_CODEC_CONFIGURATION_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(16i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_RATE_CONTROL_MODE_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(32i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_RATE_CONTROL_CONFIGURATION_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(64i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_INTRA_REFRESH_MODE_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(128i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_SUBREGION_LAYOUT_MODE_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(256i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_RESOLUTION_NOT_SUPPORTED_IN_LIST:
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(512i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_GOP_STRUCTURE_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(2048i32);
pub const D3D12_VIDEO_ENCODER_VALIDATION_FLAG_SUBREGION_LAYOUT_DATA_NOT_SUPPORTED:
    D3D12_VIDEO_ENCODER_VALIDATION_FLAGS = D3D12_VIDEO_ENCODER_VALIDATION_FLAGS(4096i32);
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_ENCODER_VALIDATION_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_ENCODER_VALIDATION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS(pub i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_NONE:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS(0i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_READ:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS(1i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAG_WRITE:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(pub i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CREATION:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(0i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_INITIALIZATION:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(1i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_EXECUTION:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(2i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_INPUT:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(3i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_CAPS_OUTPUT:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(4i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_DEVICE_EXECUTE_INPUT:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(5i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE_DEVICE_EXECUTE_OUTPUT:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE(6i32);
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(pub i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT8:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(0i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT16:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(1i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT32:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(2i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_UINT64:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(3i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT8:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(4i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT16:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(5i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT32:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(6i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_SINT64:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(7i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_FLOAT:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(8i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_DOUBLE:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(9i32);
pub const D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE_RESOURCE:
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE =
    D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE(10i32);
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_FIELD_TYPE(pub i32);
pub const D3D12_VIDEO_FIELD_TYPE_NONE: D3D12_VIDEO_FIELD_TYPE = D3D12_VIDEO_FIELD_TYPE(0i32);
pub const D3D12_VIDEO_FIELD_TYPE_INTERLACED_TOP_FIELD_FIRST: D3D12_VIDEO_FIELD_TYPE =
    D3D12_VIDEO_FIELD_TYPE(1i32);
pub const D3D12_VIDEO_FIELD_TYPE_INTERLACED_BOTTOM_FIELD_FIRST: D3D12_VIDEO_FIELD_TYPE =
    D3D12_VIDEO_FIELD_TYPE(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_FIELD_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_FIELD_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_FIELD_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_FIELD_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_FIELD_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_FIELD_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE(pub i32);
pub const D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_NONE: D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE =
    D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE(0i32);
pub const D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE_FIELD_BASED:
    D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE = D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE {}
impl ::core::clone::Clone for D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_FRAME_STEREO_FORMAT(pub i32);
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_NONE: D3D12_VIDEO_FRAME_STEREO_FORMAT =
    D3D12_VIDEO_FRAME_STEREO_FORMAT(0i32);
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_MONO: D3D12_VIDEO_FRAME_STEREO_FORMAT =
    D3D12_VIDEO_FRAME_STEREO_FORMAT(1i32);
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_HORIZONTAL: D3D12_VIDEO_FRAME_STEREO_FORMAT =
    D3D12_VIDEO_FRAME_STEREO_FORMAT(2i32);
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_VERTICAL: D3D12_VIDEO_FRAME_STEREO_FORMAT =
    D3D12_VIDEO_FRAME_STEREO_FORMAT(3i32);
pub const D3D12_VIDEO_FRAME_STEREO_FORMAT_SEPARATE: D3D12_VIDEO_FRAME_STEREO_FORMAT =
    D3D12_VIDEO_FRAME_STEREO_FORMAT(4i32);
impl ::core::marker::Copy for D3D12_VIDEO_FRAME_STEREO_FORMAT {}
impl ::core::clone::Clone for D3D12_VIDEO_FRAME_STEREO_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_FRAME_STEREO_FORMAT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_FRAME_STEREO_FORMAT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_FRAME_STEREO_FORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_FRAME_STEREO_FORMAT")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE(pub i32);
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_8X8:
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE =
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE(0i32);
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_16X16:
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE =
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE {}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS(pub i32);
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_NONE:
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS =
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS(0i32);
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_8X8:
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS =
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS(1i32);
pub const D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_16X16:
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS =
    D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION(pub i32);
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_QUARTER_PEL:
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION =
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION(0i32);
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION {}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS(pub i32);
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_NONE:
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS =
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS(0i32);
pub const D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAG_QUARTER_PEL:
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS =
    D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE(pub i32);
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_OPAQUE: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE =
    D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE(0i32);
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_BACKGROUND: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE =
    D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE(1i32);
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_DESTINATION: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE =
    D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE(2i32);
pub const D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE_SOURCE_STREAM: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE =
    D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE(3i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(pub u32);
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_NONE: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS =
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(0u32);
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DENOISE:
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(1u32);
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_DERINGING:
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(2u32);
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_EDGE_ENHANCEMENT:
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(4u32);
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_COLOR_CORRECTION:
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(8u32);
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_FLESH_TONE_MAPPING:
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(16u32);
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_IMAGE_STABILIZATION:
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(32u32);
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_SUPER_RESOLUTION:
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(64u32);
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_ANAMORPHIC_SCALING:
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS = D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(128u32);
pub const D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAG_CUSTOM:
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS =
    D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS(2147483648u32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS(pub u32);
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_NONE: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS =
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS(0u32);
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_BOB: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS =
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS(1u32);
pub const D3D12_VIDEO_PROCESS_DEINTERLACE_FLAG_CUSTOM: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS =
    D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS(2147483648u32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_FEATURE_FLAGS(pub i32);
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_NONE: D3D12_VIDEO_PROCESS_FEATURE_FLAGS =
    D3D12_VIDEO_PROCESS_FEATURE_FLAGS(0i32);
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_FILL: D3D12_VIDEO_PROCESS_FEATURE_FLAGS =
    D3D12_VIDEO_PROCESS_FEATURE_FLAGS(1i32);
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_LUMA_KEY: D3D12_VIDEO_PROCESS_FEATURE_FLAGS =
    D3D12_VIDEO_PROCESS_FEATURE_FLAGS(2i32);
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_STEREO: D3D12_VIDEO_PROCESS_FEATURE_FLAGS =
    D3D12_VIDEO_PROCESS_FEATURE_FLAGS(4i32);
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ROTATION: D3D12_VIDEO_PROCESS_FEATURE_FLAGS =
    D3D12_VIDEO_PROCESS_FEATURE_FLAGS(8i32);
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_FLIP: D3D12_VIDEO_PROCESS_FEATURE_FLAGS =
    D3D12_VIDEO_PROCESS_FEATURE_FLAGS(16i32);
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_ALPHA_BLENDING: D3D12_VIDEO_PROCESS_FEATURE_FLAGS =
    D3D12_VIDEO_PROCESS_FEATURE_FLAGS(32i32);
pub const D3D12_VIDEO_PROCESS_FEATURE_FLAG_PIXEL_ASPECT_RATIO: D3D12_VIDEO_PROCESS_FEATURE_FLAGS =
    D3D12_VIDEO_PROCESS_FEATURE_FLAGS(64i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_FEATURE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_FEATURE_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_FILTER(pub i32);
pub const D3D12_VIDEO_PROCESS_FILTER_BRIGHTNESS: D3D12_VIDEO_PROCESS_FILTER =
    D3D12_VIDEO_PROCESS_FILTER(0i32);
pub const D3D12_VIDEO_PROCESS_FILTER_CONTRAST: D3D12_VIDEO_PROCESS_FILTER =
    D3D12_VIDEO_PROCESS_FILTER(1i32);
pub const D3D12_VIDEO_PROCESS_FILTER_HUE: D3D12_VIDEO_PROCESS_FILTER =
    D3D12_VIDEO_PROCESS_FILTER(2i32);
pub const D3D12_VIDEO_PROCESS_FILTER_SATURATION: D3D12_VIDEO_PROCESS_FILTER =
    D3D12_VIDEO_PROCESS_FILTER(3i32);
pub const D3D12_VIDEO_PROCESS_FILTER_NOISE_REDUCTION: D3D12_VIDEO_PROCESS_FILTER =
    D3D12_VIDEO_PROCESS_FILTER(4i32);
pub const D3D12_VIDEO_PROCESS_FILTER_EDGE_ENHANCEMENT: D3D12_VIDEO_PROCESS_FILTER =
    D3D12_VIDEO_PROCESS_FILTER(5i32);
pub const D3D12_VIDEO_PROCESS_FILTER_ANAMORPHIC_SCALING: D3D12_VIDEO_PROCESS_FILTER =
    D3D12_VIDEO_PROCESS_FILTER(6i32);
pub const D3D12_VIDEO_PROCESS_FILTER_STEREO_ADJUSTMENT: D3D12_VIDEO_PROCESS_FILTER =
    D3D12_VIDEO_PROCESS_FILTER(7i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_FILTER {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_FILTER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_FILTER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_FILTER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_FILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_FILTER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_FILTER_FLAGS(pub i32);
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_NONE: D3D12_VIDEO_PROCESS_FILTER_FLAGS =
    D3D12_VIDEO_PROCESS_FILTER_FLAGS(0i32);
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_BRIGHTNESS: D3D12_VIDEO_PROCESS_FILTER_FLAGS =
    D3D12_VIDEO_PROCESS_FILTER_FLAGS(1i32);
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_CONTRAST: D3D12_VIDEO_PROCESS_FILTER_FLAGS =
    D3D12_VIDEO_PROCESS_FILTER_FLAGS(2i32);
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_HUE: D3D12_VIDEO_PROCESS_FILTER_FLAGS =
    D3D12_VIDEO_PROCESS_FILTER_FLAGS(4i32);
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_SATURATION: D3D12_VIDEO_PROCESS_FILTER_FLAGS =
    D3D12_VIDEO_PROCESS_FILTER_FLAGS(8i32);
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_NOISE_REDUCTION: D3D12_VIDEO_PROCESS_FILTER_FLAGS =
    D3D12_VIDEO_PROCESS_FILTER_FLAGS(16i32);
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_EDGE_ENHANCEMENT: D3D12_VIDEO_PROCESS_FILTER_FLAGS =
    D3D12_VIDEO_PROCESS_FILTER_FLAGS(32i32);
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_ANAMORPHIC_SCALING: D3D12_VIDEO_PROCESS_FILTER_FLAGS =
    D3D12_VIDEO_PROCESS_FILTER_FLAGS(64i32);
pub const D3D12_VIDEO_PROCESS_FILTER_FLAG_STEREO_ADJUSTMENT: D3D12_VIDEO_PROCESS_FILTER_FLAGS =
    D3D12_VIDEO_PROCESS_FILTER_FLAGS(128i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_FILTER_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_FILTER_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_FILTER_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS(pub i32);
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_NONE: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS =
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS(0i32);
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_DISCONTINUITY:
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS(1i32);
pub const D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAG_FRAME_REPEAT:
    D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS = D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_ORIENTATION(pub i32);
pub const D3D12_VIDEO_PROCESS_ORIENTATION_DEFAULT: D3D12_VIDEO_PROCESS_ORIENTATION =
    D3D12_VIDEO_PROCESS_ORIENTATION(0i32);
pub const D3D12_VIDEO_PROCESS_ORIENTATION_FLIP_HORIZONTAL: D3D12_VIDEO_PROCESS_ORIENTATION =
    D3D12_VIDEO_PROCESS_ORIENTATION(1i32);
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_90: D3D12_VIDEO_PROCESS_ORIENTATION =
    D3D12_VIDEO_PROCESS_ORIENTATION(2i32);
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_90_FLIP_HORIZONTAL:
    D3D12_VIDEO_PROCESS_ORIENTATION = D3D12_VIDEO_PROCESS_ORIENTATION(3i32);
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_180: D3D12_VIDEO_PROCESS_ORIENTATION =
    D3D12_VIDEO_PROCESS_ORIENTATION(4i32);
pub const D3D12_VIDEO_PROCESS_ORIENTATION_FLIP_VERTICAL: D3D12_VIDEO_PROCESS_ORIENTATION =
    D3D12_VIDEO_PROCESS_ORIENTATION(5i32);
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_270: D3D12_VIDEO_PROCESS_ORIENTATION =
    D3D12_VIDEO_PROCESS_ORIENTATION(6i32);
pub const D3D12_VIDEO_PROCESS_ORIENTATION_CLOCKWISE_270_FLIP_HORIZONTAL:
    D3D12_VIDEO_PROCESS_ORIENTATION = D3D12_VIDEO_PROCESS_ORIENTATION(7i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_ORIENTATION {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_ORIENTATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_ORIENTATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_ORIENTATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_ORIENTATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_ORIENTATION")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROCESS_SUPPORT_FLAGS(pub i32);
pub const D3D12_VIDEO_PROCESS_SUPPORT_FLAG_NONE: D3D12_VIDEO_PROCESS_SUPPORT_FLAGS =
    D3D12_VIDEO_PROCESS_SUPPORT_FLAGS(0i32);
pub const D3D12_VIDEO_PROCESS_SUPPORT_FLAG_SUPPORTED: D3D12_VIDEO_PROCESS_SUPPORT_FLAGS =
    D3D12_VIDEO_PROCESS_SUPPORT_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROCESS_SUPPORT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROCESS_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS(pub i32);
pub const D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_NONE:
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS =
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS(0i32);
pub const D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAG_SUPPORTED:
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS =
    D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIDEO_SCALE_SUPPORT_FLAGS(pub i32);
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_NONE: D3D12_VIDEO_SCALE_SUPPORT_FLAGS =
    D3D12_VIDEO_SCALE_SUPPORT_FLAGS(0i32);
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_POW2_ONLY: D3D12_VIDEO_SCALE_SUPPORT_FLAGS =
    D3D12_VIDEO_SCALE_SUPPORT_FLAGS(1i32);
pub const D3D12_VIDEO_SCALE_SUPPORT_FLAG_EVEN_DIMENSIONS_ONLY: D3D12_VIDEO_SCALE_SUPPORT_FLAGS =
    D3D12_VIDEO_SCALE_SUPPORT_FLAGS(2i32);
impl ::core::marker::Copy for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {}
impl ::core::clone::Clone for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIDEO_SCALE_SUPPORT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIDEO_SCALE_SUPPORT_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIEW_INSTANCING_FLAGS(pub i32);
pub const D3D12_VIEW_INSTANCING_FLAG_NONE: D3D12_VIEW_INSTANCING_FLAGS =
    D3D12_VIEW_INSTANCING_FLAGS(0i32);
pub const D3D12_VIEW_INSTANCING_FLAG_ENABLE_VIEW_INSTANCE_MASKING: D3D12_VIEW_INSTANCING_FLAGS =
    D3D12_VIEW_INSTANCING_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_VIEW_INSTANCING_FLAGS {}
impl ::core::clone::Clone for D3D12_VIEW_INSTANCING_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIEW_INSTANCING_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIEW_INSTANCING_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIEW_INSTANCING_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIEW_INSTANCING_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_VIEW_INSTANCING_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_VIEW_INSTANCING_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_VIEW_INSTANCING_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_VIEW_INSTANCING_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_VIEW_INSTANCING_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_VIEW_INSTANCING_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_VIEW_INSTANCING_TIER(pub i32);
pub const D3D12_VIEW_INSTANCING_TIER_NOT_SUPPORTED: D3D12_VIEW_INSTANCING_TIER =
    D3D12_VIEW_INSTANCING_TIER(0i32);
pub const D3D12_VIEW_INSTANCING_TIER_1: D3D12_VIEW_INSTANCING_TIER =
    D3D12_VIEW_INSTANCING_TIER(1i32);
pub const D3D12_VIEW_INSTANCING_TIER_2: D3D12_VIEW_INSTANCING_TIER =
    D3D12_VIEW_INSTANCING_TIER(2i32);
pub const D3D12_VIEW_INSTANCING_TIER_3: D3D12_VIEW_INSTANCING_TIER =
    D3D12_VIEW_INSTANCING_TIER(3i32);
impl ::core::marker::Copy for D3D12_VIEW_INSTANCING_TIER {}
impl ::core::clone::Clone for D3D12_VIEW_INSTANCING_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_VIEW_INSTANCING_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_VIEW_INSTANCING_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_VIEW_INSTANCING_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_VIEW_INSTANCING_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_WAVE_MMA_ACCUM_DATATYPE(pub i32);
pub const D3D12_WAVE_MMA_ACCUM_DATATYPE_NONE: D3D12_WAVE_MMA_ACCUM_DATATYPE =
    D3D12_WAVE_MMA_ACCUM_DATATYPE(0i32);
pub const D3D12_WAVE_MMA_ACCUM_DATATYPE_INT32: D3D12_WAVE_MMA_ACCUM_DATATYPE =
    D3D12_WAVE_MMA_ACCUM_DATATYPE(1i32);
pub const D3D12_WAVE_MMA_ACCUM_DATATYPE_FLOAT16: D3D12_WAVE_MMA_ACCUM_DATATYPE =
    D3D12_WAVE_MMA_ACCUM_DATATYPE(2i32);
pub const D3D12_WAVE_MMA_ACCUM_DATATYPE_FLOAT: D3D12_WAVE_MMA_ACCUM_DATATYPE =
    D3D12_WAVE_MMA_ACCUM_DATATYPE(4i32);
impl ::core::marker::Copy for D3D12_WAVE_MMA_ACCUM_DATATYPE {}
impl ::core::clone::Clone for D3D12_WAVE_MMA_ACCUM_DATATYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_WAVE_MMA_ACCUM_DATATYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_WAVE_MMA_ACCUM_DATATYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_WAVE_MMA_ACCUM_DATATYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_WAVE_MMA_ACCUM_DATATYPE")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_WAVE_MMA_ACCUM_DATATYPE {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_WAVE_MMA_ACCUM_DATATYPE {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_WAVE_MMA_ACCUM_DATATYPE {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_WAVE_MMA_ACCUM_DATATYPE {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_WAVE_MMA_ACCUM_DATATYPE {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_WAVE_MMA_ACCUM_DATATYPE {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_WAVE_MMA_DIMENSION(pub i32);
pub const D3D12_WAVE_MMA_DIMENSION_INVALID: D3D12_WAVE_MMA_DIMENSION =
    D3D12_WAVE_MMA_DIMENSION(0i32);
pub const D3D12_WAVE_MMA_DIMENSION_16: D3D12_WAVE_MMA_DIMENSION = D3D12_WAVE_MMA_DIMENSION(1i32);
pub const D3D12_WAVE_MMA_DIMENSION_64: D3D12_WAVE_MMA_DIMENSION = D3D12_WAVE_MMA_DIMENSION(2i32);
impl ::core::marker::Copy for D3D12_WAVE_MMA_DIMENSION {}
impl ::core::clone::Clone for D3D12_WAVE_MMA_DIMENSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_WAVE_MMA_DIMENSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_WAVE_MMA_DIMENSION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_WAVE_MMA_DIMENSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_WAVE_MMA_DIMENSION")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_WAVE_MMA_INPUT_DATATYPE(pub i32);
pub const D3D12_WAVE_MMA_INPUT_DATATYPE_INVALID: D3D12_WAVE_MMA_INPUT_DATATYPE =
    D3D12_WAVE_MMA_INPUT_DATATYPE(0i32);
pub const D3D12_WAVE_MMA_INPUT_DATATYPE_BYTE: D3D12_WAVE_MMA_INPUT_DATATYPE =
    D3D12_WAVE_MMA_INPUT_DATATYPE(1i32);
pub const D3D12_WAVE_MMA_INPUT_DATATYPE_FLOAT16: D3D12_WAVE_MMA_INPUT_DATATYPE =
    D3D12_WAVE_MMA_INPUT_DATATYPE(2i32);
pub const D3D12_WAVE_MMA_INPUT_DATATYPE_FLOAT: D3D12_WAVE_MMA_INPUT_DATATYPE =
    D3D12_WAVE_MMA_INPUT_DATATYPE(3i32);
impl ::core::marker::Copy for D3D12_WAVE_MMA_INPUT_DATATYPE {}
impl ::core::clone::Clone for D3D12_WAVE_MMA_INPUT_DATATYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_WAVE_MMA_INPUT_DATATYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_WAVE_MMA_INPUT_DATATYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_WAVE_MMA_INPUT_DATATYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_WAVE_MMA_INPUT_DATATYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_WAVE_MMA_TIER(pub i32);
pub const D3D12_WAVE_MMA_TIER_NOT_SUPPORTED: D3D12_WAVE_MMA_TIER = D3D12_WAVE_MMA_TIER(0i32);
pub const D3D12_WAVE_MMA_TIER_1_0: D3D12_WAVE_MMA_TIER = D3D12_WAVE_MMA_TIER(10i32);
impl ::core::marker::Copy for D3D12_WAVE_MMA_TIER {}
impl ::core::clone::Clone for D3D12_WAVE_MMA_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_WAVE_MMA_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_WAVE_MMA_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_WAVE_MMA_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_WAVE_MMA_TIER").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_WORK_GRAPHS_TIER(pub i32);
pub const D3D12_WORK_GRAPHS_TIER_NOT_SUPPORTED: D3D12_WORK_GRAPHS_TIER =
    D3D12_WORK_GRAPHS_TIER(0i32);
pub const D3D12_WORK_GRAPHS_TIER_0_1: D3D12_WORK_GRAPHS_TIER = D3D12_WORK_GRAPHS_TIER(1i32);
impl ::core::marker::Copy for D3D12_WORK_GRAPHS_TIER {}
impl ::core::clone::Clone for D3D12_WORK_GRAPHS_TIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_WORK_GRAPHS_TIER {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_WORK_GRAPHS_TIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_WORK_GRAPHS_TIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_WORK_GRAPHS_TIER")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_WORK_GRAPH_FLAGS(pub i32);
pub const D3D12_WORK_GRAPH_FLAG_NONE: D3D12_WORK_GRAPH_FLAGS = D3D12_WORK_GRAPH_FLAGS(0i32);
pub const D3D12_WORK_GRAPH_FLAG_INCLUDE_ALL_AVAILABLE_NODES: D3D12_WORK_GRAPH_FLAGS =
    D3D12_WORK_GRAPH_FLAGS(1i32);
impl ::core::marker::Copy for D3D12_WORK_GRAPH_FLAGS {}
impl ::core::clone::Clone for D3D12_WORK_GRAPH_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_WORK_GRAPH_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_WORK_GRAPH_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_WORK_GRAPH_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_WORK_GRAPH_FLAGS")
            .field(&self.0)
            .finish()
    }
}
impl D3D12_WORK_GRAPH_FLAGS {
    pub const fn contains(&self, other: Self) -> bool {
        self.0 & other.0 == other.0
    }
}
impl ::core::ops::BitOr for D3D12_WORK_GRAPH_FLAGS {
    type Output = Self;
    fn bitor(self, other: Self) -> Self {
        Self(self.0 | other.0)
    }
}
impl ::core::ops::BitAnd for D3D12_WORK_GRAPH_FLAGS {
    type Output = Self;
    fn bitand(self, other: Self) -> Self {
        Self(self.0 & other.0)
    }
}
impl ::core::ops::BitOrAssign for D3D12_WORK_GRAPH_FLAGS {
    fn bitor_assign(&mut self, other: Self) {
        self.0.bitor_assign(other.0)
    }
}
impl ::core::ops::BitAndAssign for D3D12_WORK_GRAPH_FLAGS {
    fn bitand_assign(&mut self, other: Self) {
        self.0.bitand_assign(other.0)
    }
}
impl ::core::ops::Not for D3D12_WORK_GRAPH_FLAGS {
    type Output = Self;
    fn not(self) -> Self {
        Self(self.0.not())
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D12_WRITEBUFFERIMMEDIATE_MODE(pub i32);
pub const D3D12_WRITEBUFFERIMMEDIATE_MODE_DEFAULT: D3D12_WRITEBUFFERIMMEDIATE_MODE =
    D3D12_WRITEBUFFERIMMEDIATE_MODE(0i32);
pub const D3D12_WRITEBUFFERIMMEDIATE_MODE_MARKER_IN: D3D12_WRITEBUFFERIMMEDIATE_MODE =
    D3D12_WRITEBUFFERIMMEDIATE_MODE(1i32);
pub const D3D12_WRITEBUFFERIMMEDIATE_MODE_MARKER_OUT: D3D12_WRITEBUFFERIMMEDIATE_MODE =
    D3D12_WRITEBUFFERIMMEDIATE_MODE(2i32);
impl ::core::marker::Copy for D3D12_WRITEBUFFERIMMEDIATE_MODE {}
impl ::core::clone::Clone for D3D12_WRITEBUFFERIMMEDIATE_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D12_WRITEBUFFERIMMEDIATE_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D12_WRITEBUFFERIMMEDIATE_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D12_WRITEBUFFERIMMEDIATE_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D12_WRITEBUFFERIMMEDIATE_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_CBUFFER_TYPE(pub i32);
pub const D3D_CT_CBUFFER: D3D_CBUFFER_TYPE = D3D_CBUFFER_TYPE(0i32);
pub const D3D_CT_TBUFFER: D3D_CBUFFER_TYPE = D3D_CBUFFER_TYPE(1i32);
pub const D3D_CT_INTERFACE_POINTERS: D3D_CBUFFER_TYPE = D3D_CBUFFER_TYPE(2i32);
pub const D3D_CT_RESOURCE_BIND_INFO: D3D_CBUFFER_TYPE = D3D_CBUFFER_TYPE(3i32);
pub const D3D10_CT_CBUFFER: D3D_CBUFFER_TYPE = D3D_CBUFFER_TYPE(0i32);
pub const D3D10_CT_TBUFFER: D3D_CBUFFER_TYPE = D3D_CBUFFER_TYPE(1i32);
pub const D3D11_CT_CBUFFER: D3D_CBUFFER_TYPE = D3D_CBUFFER_TYPE(0i32);
pub const D3D11_CT_TBUFFER: D3D_CBUFFER_TYPE = D3D_CBUFFER_TYPE(1i32);
pub const D3D11_CT_INTERFACE_POINTERS: D3D_CBUFFER_TYPE = D3D_CBUFFER_TYPE(2i32);
pub const D3D11_CT_RESOURCE_BIND_INFO: D3D_CBUFFER_TYPE = D3D_CBUFFER_TYPE(3i32);
impl ::core::marker::Copy for D3D_CBUFFER_TYPE {}
impl ::core::clone::Clone for D3D_CBUFFER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_CBUFFER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_CBUFFER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_CBUFFER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_CBUFFER_TYPE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_DRIVER_TYPE(pub i32);
pub const D3D_DRIVER_TYPE_UNKNOWN: D3D_DRIVER_TYPE = D3D_DRIVER_TYPE(0i32);
pub const D3D_DRIVER_TYPE_HARDWARE: D3D_DRIVER_TYPE = D3D_DRIVER_TYPE(1i32);
pub const D3D_DRIVER_TYPE_REFERENCE: D3D_DRIVER_TYPE = D3D_DRIVER_TYPE(2i32);
pub const D3D_DRIVER_TYPE_NULL: D3D_DRIVER_TYPE = D3D_DRIVER_TYPE(3i32);
pub const D3D_DRIVER_TYPE_SOFTWARE: D3D_DRIVER_TYPE = D3D_DRIVER_TYPE(4i32);
pub const D3D_DRIVER_TYPE_WARP: D3D_DRIVER_TYPE = D3D_DRIVER_TYPE(5i32);
impl ::core::marker::Copy for D3D_DRIVER_TYPE {}
impl ::core::clone::Clone for D3D_DRIVER_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_DRIVER_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_DRIVER_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_DRIVER_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_DRIVER_TYPE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_FEATURE_LEVEL(pub i32);
pub const D3D_FEATURE_LEVEL_1_0_CORE: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(4096i32);
pub const D3D_FEATURE_LEVEL_9_1: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(37120i32);
pub const D3D_FEATURE_LEVEL_9_2: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(37376i32);
pub const D3D_FEATURE_LEVEL_9_3: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(37632i32);
pub const D3D_FEATURE_LEVEL_10_0: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(40960i32);
pub const D3D_FEATURE_LEVEL_10_1: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(41216i32);
pub const D3D_FEATURE_LEVEL_11_0: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(45056i32);
pub const D3D_FEATURE_LEVEL_11_1: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(45312i32);
pub const D3D_FEATURE_LEVEL_12_0: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(49152i32);
pub const D3D_FEATURE_LEVEL_12_1: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(49408i32);
pub const D3D_FEATURE_LEVEL_12_2: D3D_FEATURE_LEVEL = D3D_FEATURE_LEVEL(49664i32);
impl ::core::marker::Copy for D3D_FEATURE_LEVEL {}
impl ::core::clone::Clone for D3D_FEATURE_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_FEATURE_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_FEATURE_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_FEATURE_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_FEATURE_LEVEL").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_FORMAT_COMPONENT_INTERPRETATION(pub i32);
pub const D3DFCI_TYPELESS: D3D_FORMAT_COMPONENT_INTERPRETATION =
    D3D_FORMAT_COMPONENT_INTERPRETATION(0i32);
pub const D3DFCI_FLOAT: D3D_FORMAT_COMPONENT_INTERPRETATION =
    D3D_FORMAT_COMPONENT_INTERPRETATION(-4i32);
pub const D3DFCI_SNORM: D3D_FORMAT_COMPONENT_INTERPRETATION =
    D3D_FORMAT_COMPONENT_INTERPRETATION(-3i32);
pub const D3DFCI_UNORM: D3D_FORMAT_COMPONENT_INTERPRETATION =
    D3D_FORMAT_COMPONENT_INTERPRETATION(-2i32);
pub const D3DFCI_SINT: D3D_FORMAT_COMPONENT_INTERPRETATION =
    D3D_FORMAT_COMPONENT_INTERPRETATION(-1i32);
pub const D3DFCI_UINT: D3D_FORMAT_COMPONENT_INTERPRETATION =
    D3D_FORMAT_COMPONENT_INTERPRETATION(1i32);
pub const D3DFCI_UNORM_SRGB: D3D_FORMAT_COMPONENT_INTERPRETATION =
    D3D_FORMAT_COMPONENT_INTERPRETATION(2i32);
pub const D3DFCI_BIASED_FIXED_2_8: D3D_FORMAT_COMPONENT_INTERPRETATION =
    D3D_FORMAT_COMPONENT_INTERPRETATION(3i32);
impl ::core::marker::Copy for D3D_FORMAT_COMPONENT_INTERPRETATION {}
impl ::core::clone::Clone for D3D_FORMAT_COMPONENT_INTERPRETATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_FORMAT_COMPONENT_INTERPRETATION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_FORMAT_COMPONENT_INTERPRETATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_FORMAT_COMPONENT_INTERPRETATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_FORMAT_COMPONENT_INTERPRETATION")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_FORMAT_COMPONENT_NAME(pub i32);
pub const D3DFCN_R: D3D_FORMAT_COMPONENT_NAME = D3D_FORMAT_COMPONENT_NAME(-4i32);
pub const D3DFCN_G: D3D_FORMAT_COMPONENT_NAME = D3D_FORMAT_COMPONENT_NAME(-3i32);
pub const D3DFCN_B: D3D_FORMAT_COMPONENT_NAME = D3D_FORMAT_COMPONENT_NAME(-2i32);
pub const D3DFCN_A: D3D_FORMAT_COMPONENT_NAME = D3D_FORMAT_COMPONENT_NAME(-1i32);
pub const D3DFCN_D: D3D_FORMAT_COMPONENT_NAME = D3D_FORMAT_COMPONENT_NAME(0i32);
pub const D3DFCN_S: D3D_FORMAT_COMPONENT_NAME = D3D_FORMAT_COMPONENT_NAME(1i32);
pub const D3DFCN_X: D3D_FORMAT_COMPONENT_NAME = D3D_FORMAT_COMPONENT_NAME(2i32);
impl ::core::marker::Copy for D3D_FORMAT_COMPONENT_NAME {}
impl ::core::clone::Clone for D3D_FORMAT_COMPONENT_NAME {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_FORMAT_COMPONENT_NAME {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_FORMAT_COMPONENT_NAME {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_FORMAT_COMPONENT_NAME {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_FORMAT_COMPONENT_NAME")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_FORMAT_LAYOUT(pub i32);
pub const D3DFL_STANDARD: D3D_FORMAT_LAYOUT = D3D_FORMAT_LAYOUT(0i32);
pub const D3DFL_CUSTOM: D3D_FORMAT_LAYOUT = D3D_FORMAT_LAYOUT(-1i32);
impl ::core::marker::Copy for D3D_FORMAT_LAYOUT {}
impl ::core::clone::Clone for D3D_FORMAT_LAYOUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_FORMAT_LAYOUT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_FORMAT_LAYOUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_FORMAT_LAYOUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_FORMAT_LAYOUT").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_FORMAT_TYPE_LEVEL(pub i32);
pub const D3DFTL_NO_TYPE: D3D_FORMAT_TYPE_LEVEL = D3D_FORMAT_TYPE_LEVEL(0i32);
pub const D3DFTL_PARTIAL_TYPE: D3D_FORMAT_TYPE_LEVEL = D3D_FORMAT_TYPE_LEVEL(-2i32);
pub const D3DFTL_FULL_TYPE: D3D_FORMAT_TYPE_LEVEL = D3D_FORMAT_TYPE_LEVEL(-1i32);
impl ::core::marker::Copy for D3D_FORMAT_TYPE_LEVEL {}
impl ::core::clone::Clone for D3D_FORMAT_TYPE_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_FORMAT_TYPE_LEVEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_FORMAT_TYPE_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_FORMAT_TYPE_LEVEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_FORMAT_TYPE_LEVEL")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_INCLUDE_TYPE(pub i32);
pub const D3D_INCLUDE_LOCAL: D3D_INCLUDE_TYPE = D3D_INCLUDE_TYPE(0i32);
pub const D3D_INCLUDE_SYSTEM: D3D_INCLUDE_TYPE = D3D_INCLUDE_TYPE(1i32);
pub const D3D10_INCLUDE_LOCAL: D3D_INCLUDE_TYPE = D3D_INCLUDE_TYPE(0i32);
pub const D3D10_INCLUDE_SYSTEM: D3D_INCLUDE_TYPE = D3D_INCLUDE_TYPE(1i32);
impl ::core::marker::Copy for D3D_INCLUDE_TYPE {}
impl ::core::clone::Clone for D3D_INCLUDE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_INCLUDE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_INCLUDE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_INCLUDE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_INCLUDE_TYPE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_INTERPOLATION_MODE(pub i32);
pub const D3D_INTERPOLATION_UNDEFINED: D3D_INTERPOLATION_MODE = D3D_INTERPOLATION_MODE(0i32);
pub const D3D_INTERPOLATION_CONSTANT: D3D_INTERPOLATION_MODE = D3D_INTERPOLATION_MODE(1i32);
pub const D3D_INTERPOLATION_LINEAR: D3D_INTERPOLATION_MODE = D3D_INTERPOLATION_MODE(2i32);
pub const D3D_INTERPOLATION_LINEAR_CENTROID: D3D_INTERPOLATION_MODE = D3D_INTERPOLATION_MODE(3i32);
pub const D3D_INTERPOLATION_LINEAR_NOPERSPECTIVE: D3D_INTERPOLATION_MODE =
    D3D_INTERPOLATION_MODE(4i32);
pub const D3D_INTERPOLATION_LINEAR_NOPERSPECTIVE_CENTROID: D3D_INTERPOLATION_MODE =
    D3D_INTERPOLATION_MODE(5i32);
pub const D3D_INTERPOLATION_LINEAR_SAMPLE: D3D_INTERPOLATION_MODE = D3D_INTERPOLATION_MODE(6i32);
pub const D3D_INTERPOLATION_LINEAR_NOPERSPECTIVE_SAMPLE: D3D_INTERPOLATION_MODE =
    D3D_INTERPOLATION_MODE(7i32);
impl ::core::marker::Copy for D3D_INTERPOLATION_MODE {}
impl ::core::clone::Clone for D3D_INTERPOLATION_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_INTERPOLATION_MODE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_INTERPOLATION_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_INTERPOLATION_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_INTERPOLATION_MODE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_MIN_PRECISION(pub i32);
pub const D3D_MIN_PRECISION_DEFAULT: D3D_MIN_PRECISION = D3D_MIN_PRECISION(0i32);
pub const D3D_MIN_PRECISION_FLOAT_16: D3D_MIN_PRECISION = D3D_MIN_PRECISION(1i32);
pub const D3D_MIN_PRECISION_FLOAT_2_8: D3D_MIN_PRECISION = D3D_MIN_PRECISION(2i32);
pub const D3D_MIN_PRECISION_RESERVED: D3D_MIN_PRECISION = D3D_MIN_PRECISION(3i32);
pub const D3D_MIN_PRECISION_SINT_16: D3D_MIN_PRECISION = D3D_MIN_PRECISION(4i32);
pub const D3D_MIN_PRECISION_UINT_16: D3D_MIN_PRECISION = D3D_MIN_PRECISION(5i32);
pub const D3D_MIN_PRECISION_ANY_16: D3D_MIN_PRECISION = D3D_MIN_PRECISION(240i32);
pub const D3D_MIN_PRECISION_ANY_10: D3D_MIN_PRECISION = D3D_MIN_PRECISION(241i32);
impl ::core::marker::Copy for D3D_MIN_PRECISION {}
impl ::core::clone::Clone for D3D_MIN_PRECISION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_MIN_PRECISION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_MIN_PRECISION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_MIN_PRECISION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_MIN_PRECISION").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_NAME(pub i32);
pub const D3D_NAME_UNDEFINED: D3D_NAME = D3D_NAME(0i32);
pub const D3D_NAME_POSITION: D3D_NAME = D3D_NAME(1i32);
pub const D3D_NAME_CLIP_DISTANCE: D3D_NAME = D3D_NAME(2i32);
pub const D3D_NAME_CULL_DISTANCE: D3D_NAME = D3D_NAME(3i32);
pub const D3D_NAME_RENDER_TARGET_ARRAY_INDEX: D3D_NAME = D3D_NAME(4i32);
pub const D3D_NAME_VIEWPORT_ARRAY_INDEX: D3D_NAME = D3D_NAME(5i32);
pub const D3D_NAME_VERTEX_ID: D3D_NAME = D3D_NAME(6i32);
pub const D3D_NAME_PRIMITIVE_ID: D3D_NAME = D3D_NAME(7i32);
pub const D3D_NAME_INSTANCE_ID: D3D_NAME = D3D_NAME(8i32);
pub const D3D_NAME_IS_FRONT_FACE: D3D_NAME = D3D_NAME(9i32);
pub const D3D_NAME_SAMPLE_INDEX: D3D_NAME = D3D_NAME(10i32);
pub const D3D_NAME_FINAL_QUAD_EDGE_TESSFACTOR: D3D_NAME = D3D_NAME(11i32);
pub const D3D_NAME_FINAL_QUAD_INSIDE_TESSFACTOR: D3D_NAME = D3D_NAME(12i32);
pub const D3D_NAME_FINAL_TRI_EDGE_TESSFACTOR: D3D_NAME = D3D_NAME(13i32);
pub const D3D_NAME_FINAL_TRI_INSIDE_TESSFACTOR: D3D_NAME = D3D_NAME(14i32);
pub const D3D_NAME_FINAL_LINE_DETAIL_TESSFACTOR: D3D_NAME = D3D_NAME(15i32);
pub const D3D_NAME_FINAL_LINE_DENSITY_TESSFACTOR: D3D_NAME = D3D_NAME(16i32);
pub const D3D_NAME_BARYCENTRICS: D3D_NAME = D3D_NAME(23i32);
pub const D3D_NAME_SHADINGRATE: D3D_NAME = D3D_NAME(24i32);
pub const D3D_NAME_CULLPRIMITIVE: D3D_NAME = D3D_NAME(25i32);
pub const D3D_NAME_TARGET: D3D_NAME = D3D_NAME(64i32);
pub const D3D_NAME_DEPTH: D3D_NAME = D3D_NAME(65i32);
pub const D3D_NAME_COVERAGE: D3D_NAME = D3D_NAME(66i32);
pub const D3D_NAME_DEPTH_GREATER_EQUAL: D3D_NAME = D3D_NAME(67i32);
pub const D3D_NAME_DEPTH_LESS_EQUAL: D3D_NAME = D3D_NAME(68i32);
pub const D3D_NAME_STENCIL_REF: D3D_NAME = D3D_NAME(69i32);
pub const D3D_NAME_INNER_COVERAGE: D3D_NAME = D3D_NAME(70i32);
pub const D3D10_NAME_UNDEFINED: D3D_NAME = D3D_NAME(0i32);
pub const D3D10_NAME_POSITION: D3D_NAME = D3D_NAME(1i32);
pub const D3D10_NAME_CLIP_DISTANCE: D3D_NAME = D3D_NAME(2i32);
pub const D3D10_NAME_CULL_DISTANCE: D3D_NAME = D3D_NAME(3i32);
pub const D3D10_NAME_RENDER_TARGET_ARRAY_INDEX: D3D_NAME = D3D_NAME(4i32);
pub const D3D10_NAME_VIEWPORT_ARRAY_INDEX: D3D_NAME = D3D_NAME(5i32);
pub const D3D10_NAME_VERTEX_ID: D3D_NAME = D3D_NAME(6i32);
pub const D3D10_NAME_PRIMITIVE_ID: D3D_NAME = D3D_NAME(7i32);
pub const D3D10_NAME_INSTANCE_ID: D3D_NAME = D3D_NAME(8i32);
pub const D3D10_NAME_IS_FRONT_FACE: D3D_NAME = D3D_NAME(9i32);
pub const D3D10_NAME_SAMPLE_INDEX: D3D_NAME = D3D_NAME(10i32);
pub const D3D10_NAME_TARGET: D3D_NAME = D3D_NAME(64i32);
pub const D3D10_NAME_DEPTH: D3D_NAME = D3D_NAME(65i32);
pub const D3D10_NAME_COVERAGE: D3D_NAME = D3D_NAME(66i32);
pub const D3D11_NAME_FINAL_QUAD_EDGE_TESSFACTOR: D3D_NAME = D3D_NAME(11i32);
pub const D3D11_NAME_FINAL_QUAD_INSIDE_TESSFACTOR: D3D_NAME = D3D_NAME(12i32);
pub const D3D11_NAME_FINAL_TRI_EDGE_TESSFACTOR: D3D_NAME = D3D_NAME(13i32);
pub const D3D11_NAME_FINAL_TRI_INSIDE_TESSFACTOR: D3D_NAME = D3D_NAME(14i32);
pub const D3D11_NAME_FINAL_LINE_DETAIL_TESSFACTOR: D3D_NAME = D3D_NAME(15i32);
pub const D3D11_NAME_FINAL_LINE_DENSITY_TESSFACTOR: D3D_NAME = D3D_NAME(16i32);
pub const D3D11_NAME_DEPTH_GREATER_EQUAL: D3D_NAME = D3D_NAME(67i32);
pub const D3D11_NAME_DEPTH_LESS_EQUAL: D3D_NAME = D3D_NAME(68i32);
pub const D3D11_NAME_STENCIL_REF: D3D_NAME = D3D_NAME(69i32);
pub const D3D11_NAME_INNER_COVERAGE: D3D_NAME = D3D_NAME(70i32);
pub const D3D12_NAME_BARYCENTRICS: D3D_NAME = D3D_NAME(23i32);
pub const D3D12_NAME_SHADINGRATE: D3D_NAME = D3D_NAME(24i32);
pub const D3D12_NAME_CULLPRIMITIVE: D3D_NAME = D3D_NAME(25i32);
impl ::core::marker::Copy for D3D_NAME {}
impl ::core::clone::Clone for D3D_NAME {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_NAME {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_NAME {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_NAME {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_NAME").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_PARAMETER_FLAGS(pub i32);
pub const D3D_PF_NONE: D3D_PARAMETER_FLAGS = D3D_PARAMETER_FLAGS(0i32);
pub const D3D_PF_IN: D3D_PARAMETER_FLAGS = D3D_PARAMETER_FLAGS(1i32);
pub const D3D_PF_OUT: D3D_PARAMETER_FLAGS = D3D_PARAMETER_FLAGS(2i32);
impl ::core::marker::Copy for D3D_PARAMETER_FLAGS {}
impl ::core::clone::Clone for D3D_PARAMETER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_PARAMETER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_PARAMETER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_PARAMETER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_PARAMETER_FLAGS").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_PRIMITIVE(pub i32);
pub const D3D_PRIMITIVE_UNDEFINED: D3D_PRIMITIVE = D3D_PRIMITIVE(0i32);
pub const D3D_PRIMITIVE_POINT: D3D_PRIMITIVE = D3D_PRIMITIVE(1i32);
pub const D3D_PRIMITIVE_LINE: D3D_PRIMITIVE = D3D_PRIMITIVE(2i32);
pub const D3D_PRIMITIVE_TRIANGLE: D3D_PRIMITIVE = D3D_PRIMITIVE(3i32);
pub const D3D_PRIMITIVE_LINE_ADJ: D3D_PRIMITIVE = D3D_PRIMITIVE(6i32);
pub const D3D_PRIMITIVE_TRIANGLE_ADJ: D3D_PRIMITIVE = D3D_PRIMITIVE(7i32);
pub const D3D_PRIMITIVE_1_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(8i32);
pub const D3D_PRIMITIVE_2_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(9i32);
pub const D3D_PRIMITIVE_3_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(10i32);
pub const D3D_PRIMITIVE_4_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(11i32);
pub const D3D_PRIMITIVE_5_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(12i32);
pub const D3D_PRIMITIVE_6_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(13i32);
pub const D3D_PRIMITIVE_7_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(14i32);
pub const D3D_PRIMITIVE_8_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(15i32);
pub const D3D_PRIMITIVE_9_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(16i32);
pub const D3D_PRIMITIVE_10_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(17i32);
pub const D3D_PRIMITIVE_11_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(18i32);
pub const D3D_PRIMITIVE_12_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(19i32);
pub const D3D_PRIMITIVE_13_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(20i32);
pub const D3D_PRIMITIVE_14_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(21i32);
pub const D3D_PRIMITIVE_15_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(22i32);
pub const D3D_PRIMITIVE_16_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(23i32);
pub const D3D_PRIMITIVE_17_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(24i32);
pub const D3D_PRIMITIVE_18_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(25i32);
pub const D3D_PRIMITIVE_19_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(26i32);
pub const D3D_PRIMITIVE_20_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(27i32);
pub const D3D_PRIMITIVE_21_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(28i32);
pub const D3D_PRIMITIVE_22_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(29i32);
pub const D3D_PRIMITIVE_23_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(30i32);
pub const D3D_PRIMITIVE_24_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(31i32);
pub const D3D_PRIMITIVE_25_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(32i32);
pub const D3D_PRIMITIVE_26_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(33i32);
pub const D3D_PRIMITIVE_27_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(34i32);
pub const D3D_PRIMITIVE_28_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(35i32);
pub const D3D_PRIMITIVE_29_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(36i32);
pub const D3D_PRIMITIVE_30_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(37i32);
pub const D3D_PRIMITIVE_31_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(38i32);
pub const D3D_PRIMITIVE_32_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(39i32);
pub const D3D10_PRIMITIVE_UNDEFINED: D3D_PRIMITIVE = D3D_PRIMITIVE(0i32);
pub const D3D10_PRIMITIVE_POINT: D3D_PRIMITIVE = D3D_PRIMITIVE(1i32);
pub const D3D10_PRIMITIVE_LINE: D3D_PRIMITIVE = D3D_PRIMITIVE(2i32);
pub const D3D10_PRIMITIVE_TRIANGLE: D3D_PRIMITIVE = D3D_PRIMITIVE(3i32);
pub const D3D10_PRIMITIVE_LINE_ADJ: D3D_PRIMITIVE = D3D_PRIMITIVE(6i32);
pub const D3D10_PRIMITIVE_TRIANGLE_ADJ: D3D_PRIMITIVE = D3D_PRIMITIVE(7i32);
pub const D3D11_PRIMITIVE_UNDEFINED: D3D_PRIMITIVE = D3D_PRIMITIVE(0i32);
pub const D3D11_PRIMITIVE_POINT: D3D_PRIMITIVE = D3D_PRIMITIVE(1i32);
pub const D3D11_PRIMITIVE_LINE: D3D_PRIMITIVE = D3D_PRIMITIVE(2i32);
pub const D3D11_PRIMITIVE_TRIANGLE: D3D_PRIMITIVE = D3D_PRIMITIVE(3i32);
pub const D3D11_PRIMITIVE_LINE_ADJ: D3D_PRIMITIVE = D3D_PRIMITIVE(6i32);
pub const D3D11_PRIMITIVE_TRIANGLE_ADJ: D3D_PRIMITIVE = D3D_PRIMITIVE(7i32);
pub const D3D11_PRIMITIVE_1_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(8i32);
pub const D3D11_PRIMITIVE_2_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(9i32);
pub const D3D11_PRIMITIVE_3_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(10i32);
pub const D3D11_PRIMITIVE_4_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(11i32);
pub const D3D11_PRIMITIVE_5_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(12i32);
pub const D3D11_PRIMITIVE_6_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(13i32);
pub const D3D11_PRIMITIVE_7_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(14i32);
pub const D3D11_PRIMITIVE_8_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(15i32);
pub const D3D11_PRIMITIVE_9_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(16i32);
pub const D3D11_PRIMITIVE_10_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(17i32);
pub const D3D11_PRIMITIVE_11_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(18i32);
pub const D3D11_PRIMITIVE_12_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(19i32);
pub const D3D11_PRIMITIVE_13_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(20i32);
pub const D3D11_PRIMITIVE_14_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(21i32);
pub const D3D11_PRIMITIVE_15_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(22i32);
pub const D3D11_PRIMITIVE_16_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(23i32);
pub const D3D11_PRIMITIVE_17_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(24i32);
pub const D3D11_PRIMITIVE_18_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(25i32);
pub const D3D11_PRIMITIVE_19_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(26i32);
pub const D3D11_PRIMITIVE_20_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(27i32);
pub const D3D11_PRIMITIVE_21_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(28i32);
pub const D3D11_PRIMITIVE_22_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(29i32);
pub const D3D11_PRIMITIVE_23_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(30i32);
pub const D3D11_PRIMITIVE_24_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(31i32);
pub const D3D11_PRIMITIVE_25_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(32i32);
pub const D3D11_PRIMITIVE_26_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(33i32);
pub const D3D11_PRIMITIVE_27_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(34i32);
pub const D3D11_PRIMITIVE_28_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(35i32);
pub const D3D11_PRIMITIVE_29_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(36i32);
pub const D3D11_PRIMITIVE_30_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(37i32);
pub const D3D11_PRIMITIVE_31_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(38i32);
pub const D3D11_PRIMITIVE_32_CONTROL_POINT_PATCH: D3D_PRIMITIVE = D3D_PRIMITIVE(39i32);
impl ::core::marker::Copy for D3D_PRIMITIVE {}
impl ::core::clone::Clone for D3D_PRIMITIVE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_PRIMITIVE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_PRIMITIVE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_PRIMITIVE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_PRIMITIVE").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_PRIMITIVE_TOPOLOGY(pub i32);
pub const D3D_PRIMITIVE_TOPOLOGY_UNDEFINED: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(0i32);
pub const D3D_PRIMITIVE_TOPOLOGY_POINTLIST: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(1i32);
pub const D3D_PRIMITIVE_TOPOLOGY_LINELIST: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(2i32);
pub const D3D_PRIMITIVE_TOPOLOGY_LINESTRIP: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(3i32);
pub const D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(4i32);
pub const D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(5i32);
pub const D3D_PRIMITIVE_TOPOLOGY_TRIANGLEFAN: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(6i32);
pub const D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(10i32);
pub const D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(11i32);
pub const D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(12i32);
pub const D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(13i32);
pub const D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(33i32);
pub const D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(34i32);
pub const D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(35i32);
pub const D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(36i32);
pub const D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(37i32);
pub const D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(38i32);
pub const D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(39i32);
pub const D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(40i32);
pub const D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(41i32);
pub const D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(42i32);
pub const D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(43i32);
pub const D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(44i32);
pub const D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(45i32);
pub const D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(46i32);
pub const D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(47i32);
pub const D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(48i32);
pub const D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(49i32);
pub const D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(50i32);
pub const D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(51i32);
pub const D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(52i32);
pub const D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(53i32);
pub const D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(54i32);
pub const D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(55i32);
pub const D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(56i32);
pub const D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(57i32);
pub const D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(58i32);
pub const D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(59i32);
pub const D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(60i32);
pub const D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(61i32);
pub const D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(62i32);
pub const D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(63i32);
pub const D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(64i32);
pub const D3D10_PRIMITIVE_TOPOLOGY_UNDEFINED: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(0i32);
pub const D3D10_PRIMITIVE_TOPOLOGY_POINTLIST: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(1i32);
pub const D3D10_PRIMITIVE_TOPOLOGY_LINELIST: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(2i32);
pub const D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(3i32);
pub const D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(4i32);
pub const D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(5i32);
pub const D3D10_PRIMITIVE_TOPOLOGY_LINELIST_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(10i32);
pub const D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(11i32);
pub const D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(12i32);
pub const D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(13i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(0i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_POINTLIST: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(1i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_LINELIST: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(2i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP: D3D_PRIMITIVE_TOPOLOGY = D3D_PRIMITIVE_TOPOLOGY(3i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(4i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(5i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_LINELIST_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(10i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(11i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(12i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(13i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(33i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(34i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(35i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(36i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(37i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(38i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(39i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(40i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(41i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(42i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(43i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(44i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(45i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(46i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(47i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(48i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(49i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(50i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(51i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(52i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(53i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(54i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(55i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(56i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(57i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(58i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(59i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(60i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(61i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(62i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(63i32);
pub const D3D11_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST: D3D_PRIMITIVE_TOPOLOGY =
    D3D_PRIMITIVE_TOPOLOGY(64i32);
impl ::core::marker::Copy for D3D_PRIMITIVE_TOPOLOGY {}
impl ::core::clone::Clone for D3D_PRIMITIVE_TOPOLOGY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_PRIMITIVE_TOPOLOGY {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_PRIMITIVE_TOPOLOGY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_PRIMITIVE_TOPOLOGY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_PRIMITIVE_TOPOLOGY")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_REGISTER_COMPONENT_TYPE(pub i32);
pub const D3D_REGISTER_COMPONENT_UNKNOWN: D3D_REGISTER_COMPONENT_TYPE =
    D3D_REGISTER_COMPONENT_TYPE(0i32);
pub const D3D_REGISTER_COMPONENT_UINT32: D3D_REGISTER_COMPONENT_TYPE =
    D3D_REGISTER_COMPONENT_TYPE(1i32);
pub const D3D_REGISTER_COMPONENT_SINT32: D3D_REGISTER_COMPONENT_TYPE =
    D3D_REGISTER_COMPONENT_TYPE(2i32);
pub const D3D_REGISTER_COMPONENT_FLOAT32: D3D_REGISTER_COMPONENT_TYPE =
    D3D_REGISTER_COMPONENT_TYPE(3i32);
pub const D3D10_REGISTER_COMPONENT_UNKNOWN: D3D_REGISTER_COMPONENT_TYPE =
    D3D_REGISTER_COMPONENT_TYPE(0i32);
pub const D3D10_REGISTER_COMPONENT_UINT32: D3D_REGISTER_COMPONENT_TYPE =
    D3D_REGISTER_COMPONENT_TYPE(1i32);
pub const D3D10_REGISTER_COMPONENT_SINT32: D3D_REGISTER_COMPONENT_TYPE =
    D3D_REGISTER_COMPONENT_TYPE(2i32);
pub const D3D10_REGISTER_COMPONENT_FLOAT32: D3D_REGISTER_COMPONENT_TYPE =
    D3D_REGISTER_COMPONENT_TYPE(3i32);
impl ::core::marker::Copy for D3D_REGISTER_COMPONENT_TYPE {}
impl ::core::clone::Clone for D3D_REGISTER_COMPONENT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_REGISTER_COMPONENT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_REGISTER_COMPONENT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_REGISTER_COMPONENT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_REGISTER_COMPONENT_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_RESOURCE_RETURN_TYPE(pub i32);
pub const D3D_RETURN_TYPE_UNORM: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(1i32);
pub const D3D_RETURN_TYPE_SNORM: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(2i32);
pub const D3D_RETURN_TYPE_SINT: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(3i32);
pub const D3D_RETURN_TYPE_UINT: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(4i32);
pub const D3D_RETURN_TYPE_FLOAT: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(5i32);
pub const D3D_RETURN_TYPE_MIXED: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(6i32);
pub const D3D_RETURN_TYPE_DOUBLE: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(7i32);
pub const D3D_RETURN_TYPE_CONTINUED: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(8i32);
pub const D3D10_RETURN_TYPE_UNORM: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(1i32);
pub const D3D10_RETURN_TYPE_SNORM: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(2i32);
pub const D3D10_RETURN_TYPE_SINT: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(3i32);
pub const D3D10_RETURN_TYPE_UINT: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(4i32);
pub const D3D10_RETURN_TYPE_FLOAT: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(5i32);
pub const D3D10_RETURN_TYPE_MIXED: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(6i32);
pub const D3D11_RETURN_TYPE_UNORM: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(1i32);
pub const D3D11_RETURN_TYPE_SNORM: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(2i32);
pub const D3D11_RETURN_TYPE_SINT: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(3i32);
pub const D3D11_RETURN_TYPE_UINT: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(4i32);
pub const D3D11_RETURN_TYPE_FLOAT: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(5i32);
pub const D3D11_RETURN_TYPE_MIXED: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(6i32);
pub const D3D11_RETURN_TYPE_DOUBLE: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(7i32);
pub const D3D11_RETURN_TYPE_CONTINUED: D3D_RESOURCE_RETURN_TYPE = D3D_RESOURCE_RETURN_TYPE(8i32);
impl ::core::marker::Copy for D3D_RESOURCE_RETURN_TYPE {}
impl ::core::clone::Clone for D3D_RESOURCE_RETURN_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_RESOURCE_RETURN_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_RESOURCE_RETURN_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_RESOURCE_RETURN_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_RESOURCE_RETURN_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_ROOT_SIGNATURE_VERSION(pub i32);
pub const D3D_ROOT_SIGNATURE_VERSION_1: D3D_ROOT_SIGNATURE_VERSION =
    D3D_ROOT_SIGNATURE_VERSION(1i32);
pub const D3D_ROOT_SIGNATURE_VERSION_1_0: D3D_ROOT_SIGNATURE_VERSION =
    D3D_ROOT_SIGNATURE_VERSION(1i32);
pub const D3D_ROOT_SIGNATURE_VERSION_1_1: D3D_ROOT_SIGNATURE_VERSION =
    D3D_ROOT_SIGNATURE_VERSION(2i32);
pub const D3D_ROOT_SIGNATURE_VERSION_1_2: D3D_ROOT_SIGNATURE_VERSION =
    D3D_ROOT_SIGNATURE_VERSION(3i32);
impl ::core::marker::Copy for D3D_ROOT_SIGNATURE_VERSION {}
impl ::core::clone::Clone for D3D_ROOT_SIGNATURE_VERSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_ROOT_SIGNATURE_VERSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_ROOT_SIGNATURE_VERSION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_ROOT_SIGNATURE_VERSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_ROOT_SIGNATURE_VERSION")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_SHADER_CBUFFER_FLAGS(pub i32);
pub const D3D_CBF_USERPACKED: D3D_SHADER_CBUFFER_FLAGS = D3D_SHADER_CBUFFER_FLAGS(1i32);
pub const D3D10_CBF_USERPACKED: D3D_SHADER_CBUFFER_FLAGS = D3D_SHADER_CBUFFER_FLAGS(1i32);
impl ::core::marker::Copy for D3D_SHADER_CBUFFER_FLAGS {}
impl ::core::clone::Clone for D3D_SHADER_CBUFFER_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_SHADER_CBUFFER_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_SHADER_CBUFFER_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_SHADER_CBUFFER_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_SHADER_CBUFFER_FLAGS")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_SHADER_INPUT_FLAGS(pub i32);
pub const D3D_SIF_USERPACKED: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(1i32);
pub const D3D_SIF_COMPARISON_SAMPLER: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(2i32);
pub const D3D_SIF_TEXTURE_COMPONENT_0: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(4i32);
pub const D3D_SIF_TEXTURE_COMPONENT_1: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(8i32);
pub const D3D_SIF_TEXTURE_COMPONENTS: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(12i32);
pub const D3D_SIF_UNUSED: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(16i32);
pub const D3D10_SIF_USERPACKED: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(1i32);
pub const D3D10_SIF_COMPARISON_SAMPLER: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(2i32);
pub const D3D10_SIF_TEXTURE_COMPONENT_0: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(4i32);
pub const D3D10_SIF_TEXTURE_COMPONENT_1: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(8i32);
pub const D3D10_SIF_TEXTURE_COMPONENTS: D3D_SHADER_INPUT_FLAGS = D3D_SHADER_INPUT_FLAGS(12i32);
impl ::core::marker::Copy for D3D_SHADER_INPUT_FLAGS {}
impl ::core::clone::Clone for D3D_SHADER_INPUT_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_SHADER_INPUT_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_SHADER_INPUT_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_SHADER_INPUT_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_SHADER_INPUT_FLAGS")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_SHADER_INPUT_TYPE(pub i32);
pub const D3D_SIT_CBUFFER: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(0i32);
pub const D3D_SIT_TBUFFER: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(1i32);
pub const D3D_SIT_TEXTURE: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(2i32);
pub const D3D_SIT_SAMPLER: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(3i32);
pub const D3D_SIT_UAV_RWTYPED: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(4i32);
pub const D3D_SIT_STRUCTURED: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(5i32);
pub const D3D_SIT_UAV_RWSTRUCTURED: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(6i32);
pub const D3D_SIT_BYTEADDRESS: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(7i32);
pub const D3D_SIT_UAV_RWBYTEADDRESS: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(8i32);
pub const D3D_SIT_UAV_APPEND_STRUCTURED: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(9i32);
pub const D3D_SIT_UAV_CONSUME_STRUCTURED: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(10i32);
pub const D3D_SIT_UAV_RWSTRUCTURED_WITH_COUNTER: D3D_SHADER_INPUT_TYPE =
    D3D_SHADER_INPUT_TYPE(11i32);
pub const D3D_SIT_RTACCELERATIONSTRUCTURE: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(12i32);
pub const D3D_SIT_UAV_FEEDBACKTEXTURE: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(13i32);
pub const D3D10_SIT_CBUFFER: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(0i32);
pub const D3D10_SIT_TBUFFER: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(1i32);
pub const D3D10_SIT_TEXTURE: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(2i32);
pub const D3D10_SIT_SAMPLER: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(3i32);
pub const D3D11_SIT_UAV_RWTYPED: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(4i32);
pub const D3D11_SIT_STRUCTURED: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(5i32);
pub const D3D11_SIT_UAV_RWSTRUCTURED: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(6i32);
pub const D3D11_SIT_BYTEADDRESS: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(7i32);
pub const D3D11_SIT_UAV_RWBYTEADDRESS: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(8i32);
pub const D3D11_SIT_UAV_APPEND_STRUCTURED: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(9i32);
pub const D3D11_SIT_UAV_CONSUME_STRUCTURED: D3D_SHADER_INPUT_TYPE = D3D_SHADER_INPUT_TYPE(10i32);
pub const D3D11_SIT_UAV_RWSTRUCTURED_WITH_COUNTER: D3D_SHADER_INPUT_TYPE =
    D3D_SHADER_INPUT_TYPE(11i32);
impl ::core::marker::Copy for D3D_SHADER_INPUT_TYPE {}
impl ::core::clone::Clone for D3D_SHADER_INPUT_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_SHADER_INPUT_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_SHADER_INPUT_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_SHADER_INPUT_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_SHADER_INPUT_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_SHADER_MODEL(pub i32);
pub const D3D_SHADER_MODEL_5_1: D3D_SHADER_MODEL = D3D_SHADER_MODEL(81i32);
pub const D3D_SHADER_MODEL_6_0: D3D_SHADER_MODEL = D3D_SHADER_MODEL(96i32);
pub const D3D_SHADER_MODEL_6_1: D3D_SHADER_MODEL = D3D_SHADER_MODEL(97i32);
pub const D3D_SHADER_MODEL_6_2: D3D_SHADER_MODEL = D3D_SHADER_MODEL(98i32);
pub const D3D_SHADER_MODEL_6_3: D3D_SHADER_MODEL = D3D_SHADER_MODEL(99i32);
pub const D3D_SHADER_MODEL_6_4: D3D_SHADER_MODEL = D3D_SHADER_MODEL(100i32);
pub const D3D_SHADER_MODEL_6_5: D3D_SHADER_MODEL = D3D_SHADER_MODEL(101i32);
pub const D3D_SHADER_MODEL_6_6: D3D_SHADER_MODEL = D3D_SHADER_MODEL(102i32);
pub const D3D_SHADER_MODEL_6_7: D3D_SHADER_MODEL = D3D_SHADER_MODEL(103i32);
pub const D3D_SHADER_MODEL_6_8: D3D_SHADER_MODEL = D3D_SHADER_MODEL(104i32);
pub const D3D_HIGHEST_SHADER_MODEL: D3D_SHADER_MODEL = D3D_SHADER_MODEL(104i32);
impl ::core::marker::Copy for D3D_SHADER_MODEL {}
impl ::core::clone::Clone for D3D_SHADER_MODEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_SHADER_MODEL {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_SHADER_MODEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_SHADER_MODEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_SHADER_MODEL").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_SHADER_VARIABLE_CLASS(pub i32);
pub const D3D_SVC_SCALAR: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(0i32);
pub const D3D_SVC_VECTOR: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(1i32);
pub const D3D_SVC_MATRIX_ROWS: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(2i32);
pub const D3D_SVC_MATRIX_COLUMNS: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(3i32);
pub const D3D_SVC_OBJECT: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(4i32);
pub const D3D_SVC_STRUCT: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(5i32);
pub const D3D_SVC_INTERFACE_CLASS: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(6i32);
pub const D3D_SVC_INTERFACE_POINTER: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(7i32);
pub const D3D10_SVC_SCALAR: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(0i32);
pub const D3D10_SVC_VECTOR: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(1i32);
pub const D3D10_SVC_MATRIX_ROWS: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(2i32);
pub const D3D10_SVC_MATRIX_COLUMNS: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(3i32);
pub const D3D10_SVC_OBJECT: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(4i32);
pub const D3D10_SVC_STRUCT: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(5i32);
pub const D3D11_SVC_INTERFACE_CLASS: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(6i32);
pub const D3D11_SVC_INTERFACE_POINTER: D3D_SHADER_VARIABLE_CLASS = D3D_SHADER_VARIABLE_CLASS(7i32);
impl ::core::marker::Copy for D3D_SHADER_VARIABLE_CLASS {}
impl ::core::clone::Clone for D3D_SHADER_VARIABLE_CLASS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_SHADER_VARIABLE_CLASS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_SHADER_VARIABLE_CLASS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_SHADER_VARIABLE_CLASS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_SHADER_VARIABLE_CLASS")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_SHADER_VARIABLE_FLAGS(pub i32);
pub const D3D_SVF_USERPACKED: D3D_SHADER_VARIABLE_FLAGS = D3D_SHADER_VARIABLE_FLAGS(1i32);
pub const D3D_SVF_USED: D3D_SHADER_VARIABLE_FLAGS = D3D_SHADER_VARIABLE_FLAGS(2i32);
pub const D3D_SVF_INTERFACE_POINTER: D3D_SHADER_VARIABLE_FLAGS = D3D_SHADER_VARIABLE_FLAGS(4i32);
pub const D3D_SVF_INTERFACE_PARAMETER: D3D_SHADER_VARIABLE_FLAGS = D3D_SHADER_VARIABLE_FLAGS(8i32);
pub const D3D10_SVF_USERPACKED: D3D_SHADER_VARIABLE_FLAGS = D3D_SHADER_VARIABLE_FLAGS(1i32);
pub const D3D10_SVF_USED: D3D_SHADER_VARIABLE_FLAGS = D3D_SHADER_VARIABLE_FLAGS(2i32);
pub const D3D11_SVF_INTERFACE_POINTER: D3D_SHADER_VARIABLE_FLAGS = D3D_SHADER_VARIABLE_FLAGS(4i32);
pub const D3D11_SVF_INTERFACE_PARAMETER: D3D_SHADER_VARIABLE_FLAGS =
    D3D_SHADER_VARIABLE_FLAGS(8i32);
impl ::core::marker::Copy for D3D_SHADER_VARIABLE_FLAGS {}
impl ::core::clone::Clone for D3D_SHADER_VARIABLE_FLAGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_SHADER_VARIABLE_FLAGS {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_SHADER_VARIABLE_FLAGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_SHADER_VARIABLE_FLAGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_SHADER_VARIABLE_FLAGS")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_SHADER_VARIABLE_TYPE(pub i32);
pub const D3D_SVT_VOID: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(0i32);
pub const D3D_SVT_BOOL: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(1i32);
pub const D3D_SVT_INT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(2i32);
pub const D3D_SVT_FLOAT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(3i32);
pub const D3D_SVT_STRING: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(4i32);
pub const D3D_SVT_TEXTURE: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(5i32);
pub const D3D_SVT_TEXTURE1D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(6i32);
pub const D3D_SVT_TEXTURE2D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(7i32);
pub const D3D_SVT_TEXTURE3D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(8i32);
pub const D3D_SVT_TEXTURECUBE: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(9i32);
pub const D3D_SVT_SAMPLER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(10i32);
pub const D3D_SVT_SAMPLER1D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(11i32);
pub const D3D_SVT_SAMPLER2D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(12i32);
pub const D3D_SVT_SAMPLER3D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(13i32);
pub const D3D_SVT_SAMPLERCUBE: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(14i32);
pub const D3D_SVT_PIXELSHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(15i32);
pub const D3D_SVT_VERTEXSHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(16i32);
pub const D3D_SVT_PIXELFRAGMENT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(17i32);
pub const D3D_SVT_VERTEXFRAGMENT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(18i32);
pub const D3D_SVT_UINT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(19i32);
pub const D3D_SVT_UINT8: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(20i32);
pub const D3D_SVT_GEOMETRYSHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(21i32);
pub const D3D_SVT_RASTERIZER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(22i32);
pub const D3D_SVT_DEPTHSTENCIL: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(23i32);
pub const D3D_SVT_BLEND: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(24i32);
pub const D3D_SVT_BUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(25i32);
pub const D3D_SVT_CBUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(26i32);
pub const D3D_SVT_TBUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(27i32);
pub const D3D_SVT_TEXTURE1DARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(28i32);
pub const D3D_SVT_TEXTURE2DARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(29i32);
pub const D3D_SVT_RENDERTARGETVIEW: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(30i32);
pub const D3D_SVT_DEPTHSTENCILVIEW: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(31i32);
pub const D3D_SVT_TEXTURE2DMS: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(32i32);
pub const D3D_SVT_TEXTURE2DMSARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(33i32);
pub const D3D_SVT_TEXTURECUBEARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(34i32);
pub const D3D_SVT_HULLSHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(35i32);
pub const D3D_SVT_DOMAINSHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(36i32);
pub const D3D_SVT_INTERFACE_POINTER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(37i32);
pub const D3D_SVT_COMPUTESHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(38i32);
pub const D3D_SVT_DOUBLE: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(39i32);
pub const D3D_SVT_RWTEXTURE1D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(40i32);
pub const D3D_SVT_RWTEXTURE1DARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(41i32);
pub const D3D_SVT_RWTEXTURE2D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(42i32);
pub const D3D_SVT_RWTEXTURE2DARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(43i32);
pub const D3D_SVT_RWTEXTURE3D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(44i32);
pub const D3D_SVT_RWBUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(45i32);
pub const D3D_SVT_BYTEADDRESS_BUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(46i32);
pub const D3D_SVT_RWBYTEADDRESS_BUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(47i32);
pub const D3D_SVT_STRUCTURED_BUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(48i32);
pub const D3D_SVT_RWSTRUCTURED_BUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(49i32);
pub const D3D_SVT_APPEND_STRUCTURED_BUFFER: D3D_SHADER_VARIABLE_TYPE =
    D3D_SHADER_VARIABLE_TYPE(50i32);
pub const D3D_SVT_CONSUME_STRUCTURED_BUFFER: D3D_SHADER_VARIABLE_TYPE =
    D3D_SHADER_VARIABLE_TYPE(51i32);
pub const D3D_SVT_MIN8FLOAT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(52i32);
pub const D3D_SVT_MIN10FLOAT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(53i32);
pub const D3D_SVT_MIN16FLOAT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(54i32);
pub const D3D_SVT_MIN12INT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(55i32);
pub const D3D_SVT_MIN16INT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(56i32);
pub const D3D_SVT_MIN16UINT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(57i32);
pub const D3D_SVT_INT16: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(58i32);
pub const D3D_SVT_UINT16: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(59i32);
pub const D3D_SVT_FLOAT16: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(60i32);
pub const D3D_SVT_INT64: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(61i32);
pub const D3D_SVT_UINT64: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(62i32);
pub const D3D10_SVT_VOID: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(0i32);
pub const D3D10_SVT_BOOL: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(1i32);
pub const D3D10_SVT_INT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(2i32);
pub const D3D10_SVT_FLOAT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(3i32);
pub const D3D10_SVT_STRING: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(4i32);
pub const D3D10_SVT_TEXTURE: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(5i32);
pub const D3D10_SVT_TEXTURE1D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(6i32);
pub const D3D10_SVT_TEXTURE2D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(7i32);
pub const D3D10_SVT_TEXTURE3D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(8i32);
pub const D3D10_SVT_TEXTURECUBE: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(9i32);
pub const D3D10_SVT_SAMPLER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(10i32);
pub const D3D10_SVT_SAMPLER1D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(11i32);
pub const D3D10_SVT_SAMPLER2D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(12i32);
pub const D3D10_SVT_SAMPLER3D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(13i32);
pub const D3D10_SVT_SAMPLERCUBE: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(14i32);
pub const D3D10_SVT_PIXELSHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(15i32);
pub const D3D10_SVT_VERTEXSHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(16i32);
pub const D3D10_SVT_PIXELFRAGMENT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(17i32);
pub const D3D10_SVT_VERTEXFRAGMENT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(18i32);
pub const D3D10_SVT_UINT: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(19i32);
pub const D3D10_SVT_UINT8: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(20i32);
pub const D3D10_SVT_GEOMETRYSHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(21i32);
pub const D3D10_SVT_RASTERIZER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(22i32);
pub const D3D10_SVT_DEPTHSTENCIL: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(23i32);
pub const D3D10_SVT_BLEND: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(24i32);
pub const D3D10_SVT_BUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(25i32);
pub const D3D10_SVT_CBUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(26i32);
pub const D3D10_SVT_TBUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(27i32);
pub const D3D10_SVT_TEXTURE1DARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(28i32);
pub const D3D10_SVT_TEXTURE2DARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(29i32);
pub const D3D10_SVT_RENDERTARGETVIEW: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(30i32);
pub const D3D10_SVT_DEPTHSTENCILVIEW: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(31i32);
pub const D3D10_SVT_TEXTURE2DMS: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(32i32);
pub const D3D10_SVT_TEXTURE2DMSARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(33i32);
pub const D3D10_SVT_TEXTURECUBEARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(34i32);
pub const D3D11_SVT_HULLSHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(35i32);
pub const D3D11_SVT_DOMAINSHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(36i32);
pub const D3D11_SVT_INTERFACE_POINTER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(37i32);
pub const D3D11_SVT_COMPUTESHADER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(38i32);
pub const D3D11_SVT_DOUBLE: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(39i32);
pub const D3D11_SVT_RWTEXTURE1D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(40i32);
pub const D3D11_SVT_RWTEXTURE1DARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(41i32);
pub const D3D11_SVT_RWTEXTURE2D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(42i32);
pub const D3D11_SVT_RWTEXTURE2DARRAY: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(43i32);
pub const D3D11_SVT_RWTEXTURE3D: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(44i32);
pub const D3D11_SVT_RWBUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(45i32);
pub const D3D11_SVT_BYTEADDRESS_BUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(46i32);
pub const D3D11_SVT_RWBYTEADDRESS_BUFFER: D3D_SHADER_VARIABLE_TYPE =
    D3D_SHADER_VARIABLE_TYPE(47i32);
pub const D3D11_SVT_STRUCTURED_BUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(48i32);
pub const D3D11_SVT_RWSTRUCTURED_BUFFER: D3D_SHADER_VARIABLE_TYPE = D3D_SHADER_VARIABLE_TYPE(49i32);
pub const D3D11_SVT_APPEND_STRUCTURED_BUFFER: D3D_SHADER_VARIABLE_TYPE =
    D3D_SHADER_VARIABLE_TYPE(50i32);
pub const D3D11_SVT_CONSUME_STRUCTURED_BUFFER: D3D_SHADER_VARIABLE_TYPE =
    D3D_SHADER_VARIABLE_TYPE(51i32);
impl ::core::marker::Copy for D3D_SHADER_VARIABLE_TYPE {}
impl ::core::clone::Clone for D3D_SHADER_VARIABLE_TYPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_SHADER_VARIABLE_TYPE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_SHADER_VARIABLE_TYPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_SHADER_VARIABLE_TYPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_SHADER_VARIABLE_TYPE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_SRV_DIMENSION(pub i32);
pub const D3D_SRV_DIMENSION_UNKNOWN: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(0i32);
pub const D3D_SRV_DIMENSION_BUFFER: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(1i32);
pub const D3D_SRV_DIMENSION_TEXTURE1D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(2i32);
pub const D3D_SRV_DIMENSION_TEXTURE1DARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(3i32);
pub const D3D_SRV_DIMENSION_TEXTURE2D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(4i32);
pub const D3D_SRV_DIMENSION_TEXTURE2DARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(5i32);
pub const D3D_SRV_DIMENSION_TEXTURE2DMS: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(6i32);
pub const D3D_SRV_DIMENSION_TEXTURE2DMSARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(7i32);
pub const D3D_SRV_DIMENSION_TEXTURE3D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(8i32);
pub const D3D_SRV_DIMENSION_TEXTURECUBE: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(9i32);
pub const D3D_SRV_DIMENSION_TEXTURECUBEARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(10i32);
pub const D3D_SRV_DIMENSION_BUFFEREX: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(11i32);
pub const D3D10_SRV_DIMENSION_UNKNOWN: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(0i32);
pub const D3D10_SRV_DIMENSION_BUFFER: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(1i32);
pub const D3D10_SRV_DIMENSION_TEXTURE1D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(2i32);
pub const D3D10_SRV_DIMENSION_TEXTURE1DARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(3i32);
pub const D3D10_SRV_DIMENSION_TEXTURE2D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(4i32);
pub const D3D10_SRV_DIMENSION_TEXTURE2DARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(5i32);
pub const D3D10_SRV_DIMENSION_TEXTURE2DMS: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(6i32);
pub const D3D10_SRV_DIMENSION_TEXTURE2DMSARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(7i32);
pub const D3D10_SRV_DIMENSION_TEXTURE3D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(8i32);
pub const D3D10_SRV_DIMENSION_TEXTURECUBE: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(9i32);
pub const D3D10_1_SRV_DIMENSION_UNKNOWN: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(0i32);
pub const D3D10_1_SRV_DIMENSION_BUFFER: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(1i32);
pub const D3D10_1_SRV_DIMENSION_TEXTURE1D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(2i32);
pub const D3D10_1_SRV_DIMENSION_TEXTURE1DARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(3i32);
pub const D3D10_1_SRV_DIMENSION_TEXTURE2D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(4i32);
pub const D3D10_1_SRV_DIMENSION_TEXTURE2DARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(5i32);
pub const D3D10_1_SRV_DIMENSION_TEXTURE2DMS: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(6i32);
pub const D3D10_1_SRV_DIMENSION_TEXTURE2DMSARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(7i32);
pub const D3D10_1_SRV_DIMENSION_TEXTURE3D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(8i32);
pub const D3D10_1_SRV_DIMENSION_TEXTURECUBE: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(9i32);
pub const D3D10_1_SRV_DIMENSION_TEXTURECUBEARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(10i32);
pub const D3D11_SRV_DIMENSION_UNKNOWN: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(0i32);
pub const D3D11_SRV_DIMENSION_BUFFER: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(1i32);
pub const D3D11_SRV_DIMENSION_TEXTURE1D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(2i32);
pub const D3D11_SRV_DIMENSION_TEXTURE1DARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(3i32);
pub const D3D11_SRV_DIMENSION_TEXTURE2D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(4i32);
pub const D3D11_SRV_DIMENSION_TEXTURE2DARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(5i32);
pub const D3D11_SRV_DIMENSION_TEXTURE2DMS: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(6i32);
pub const D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(7i32);
pub const D3D11_SRV_DIMENSION_TEXTURE3D: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(8i32);
pub const D3D11_SRV_DIMENSION_TEXTURECUBE: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(9i32);
pub const D3D11_SRV_DIMENSION_TEXTURECUBEARRAY: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(10i32);
pub const D3D11_SRV_DIMENSION_BUFFEREX: D3D_SRV_DIMENSION = D3D_SRV_DIMENSION(11i32);
impl ::core::marker::Copy for D3D_SRV_DIMENSION {}
impl ::core::clone::Clone for D3D_SRV_DIMENSION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_SRV_DIMENSION {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_SRV_DIMENSION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_SRV_DIMENSION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_SRV_DIMENSION").field(&self.0).finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_TESSELLATOR_DOMAIN(pub i32);
pub const D3D_TESSELLATOR_DOMAIN_UNDEFINED: D3D_TESSELLATOR_DOMAIN = D3D_TESSELLATOR_DOMAIN(0i32);
pub const D3D_TESSELLATOR_DOMAIN_ISOLINE: D3D_TESSELLATOR_DOMAIN = D3D_TESSELLATOR_DOMAIN(1i32);
pub const D3D_TESSELLATOR_DOMAIN_TRI: D3D_TESSELLATOR_DOMAIN = D3D_TESSELLATOR_DOMAIN(2i32);
pub const D3D_TESSELLATOR_DOMAIN_QUAD: D3D_TESSELLATOR_DOMAIN = D3D_TESSELLATOR_DOMAIN(3i32);
pub const D3D11_TESSELLATOR_DOMAIN_UNDEFINED: D3D_TESSELLATOR_DOMAIN = D3D_TESSELLATOR_DOMAIN(0i32);
pub const D3D11_TESSELLATOR_DOMAIN_ISOLINE: D3D_TESSELLATOR_DOMAIN = D3D_TESSELLATOR_DOMAIN(1i32);
pub const D3D11_TESSELLATOR_DOMAIN_TRI: D3D_TESSELLATOR_DOMAIN = D3D_TESSELLATOR_DOMAIN(2i32);
pub const D3D11_TESSELLATOR_DOMAIN_QUAD: D3D_TESSELLATOR_DOMAIN = D3D_TESSELLATOR_DOMAIN(3i32);
impl ::core::marker::Copy for D3D_TESSELLATOR_DOMAIN {}
impl ::core::clone::Clone for D3D_TESSELLATOR_DOMAIN {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_TESSELLATOR_DOMAIN {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_TESSELLATOR_DOMAIN {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_TESSELLATOR_DOMAIN {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_TESSELLATOR_DOMAIN")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_TESSELLATOR_OUTPUT_PRIMITIVE(pub i32);
pub const D3D_TESSELLATOR_OUTPUT_UNDEFINED: D3D_TESSELLATOR_OUTPUT_PRIMITIVE =
    D3D_TESSELLATOR_OUTPUT_PRIMITIVE(0i32);
pub const D3D_TESSELLATOR_OUTPUT_POINT: D3D_TESSELLATOR_OUTPUT_PRIMITIVE =
    D3D_TESSELLATOR_OUTPUT_PRIMITIVE(1i32);
pub const D3D_TESSELLATOR_OUTPUT_LINE: D3D_TESSELLATOR_OUTPUT_PRIMITIVE =
    D3D_TESSELLATOR_OUTPUT_PRIMITIVE(2i32);
pub const D3D_TESSELLATOR_OUTPUT_TRIANGLE_CW: D3D_TESSELLATOR_OUTPUT_PRIMITIVE =
    D3D_TESSELLATOR_OUTPUT_PRIMITIVE(3i32);
pub const D3D_TESSELLATOR_OUTPUT_TRIANGLE_CCW: D3D_TESSELLATOR_OUTPUT_PRIMITIVE =
    D3D_TESSELLATOR_OUTPUT_PRIMITIVE(4i32);
pub const D3D11_TESSELLATOR_OUTPUT_UNDEFINED: D3D_TESSELLATOR_OUTPUT_PRIMITIVE =
    D3D_TESSELLATOR_OUTPUT_PRIMITIVE(0i32);
pub const D3D11_TESSELLATOR_OUTPUT_POINT: D3D_TESSELLATOR_OUTPUT_PRIMITIVE =
    D3D_TESSELLATOR_OUTPUT_PRIMITIVE(1i32);
pub const D3D11_TESSELLATOR_OUTPUT_LINE: D3D_TESSELLATOR_OUTPUT_PRIMITIVE =
    D3D_TESSELLATOR_OUTPUT_PRIMITIVE(2i32);
pub const D3D11_TESSELLATOR_OUTPUT_TRIANGLE_CW: D3D_TESSELLATOR_OUTPUT_PRIMITIVE =
    D3D_TESSELLATOR_OUTPUT_PRIMITIVE(3i32);
pub const D3D11_TESSELLATOR_OUTPUT_TRIANGLE_CCW: D3D_TESSELLATOR_OUTPUT_PRIMITIVE =
    D3D_TESSELLATOR_OUTPUT_PRIMITIVE(4i32);
impl ::core::marker::Copy for D3D_TESSELLATOR_OUTPUT_PRIMITIVE {}
impl ::core::clone::Clone for D3D_TESSELLATOR_OUTPUT_PRIMITIVE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_TESSELLATOR_OUTPUT_PRIMITIVE {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_TESSELLATOR_OUTPUT_PRIMITIVE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_TESSELLATOR_OUTPUT_PRIMITIVE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_TESSELLATOR_OUTPUT_PRIMITIVE")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct D3D_TESSELLATOR_PARTITIONING(pub i32);
pub const D3D_TESSELLATOR_PARTITIONING_UNDEFINED: D3D_TESSELLATOR_PARTITIONING =
    D3D_TESSELLATOR_PARTITIONING(0i32);
pub const D3D_TESSELLATOR_PARTITIONING_INTEGER: D3D_TESSELLATOR_PARTITIONING =
    D3D_TESSELLATOR_PARTITIONING(1i32);
pub const D3D_TESSELLATOR_PARTITIONING_POW2: D3D_TESSELLATOR_PARTITIONING =
    D3D_TESSELLATOR_PARTITIONING(2i32);
pub const D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD: D3D_TESSELLATOR_PARTITIONING =
    D3D_TESSELLATOR_PARTITIONING(3i32);
pub const D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN: D3D_TESSELLATOR_PARTITIONING =
    D3D_TESSELLATOR_PARTITIONING(4i32);
pub const D3D11_TESSELLATOR_PARTITIONING_UNDEFINED: D3D_TESSELLATOR_PARTITIONING =
    D3D_TESSELLATOR_PARTITIONING(0i32);
pub const D3D11_TESSELLATOR_PARTITIONING_INTEGER: D3D_TESSELLATOR_PARTITIONING =
    D3D_TESSELLATOR_PARTITIONING(1i32);
pub const D3D11_TESSELLATOR_PARTITIONING_POW2: D3D_TESSELLATOR_PARTITIONING =
    D3D_TESSELLATOR_PARTITIONING(2i32);
pub const D3D11_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD: D3D_TESSELLATOR_PARTITIONING =
    D3D_TESSELLATOR_PARTITIONING(3i32);
pub const D3D11_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN: D3D_TESSELLATOR_PARTITIONING =
    D3D_TESSELLATOR_PARTITIONING(4i32);
impl ::core::marker::Copy for D3D_TESSELLATOR_PARTITIONING {}
impl ::core::clone::Clone for D3D_TESSELLATOR_PARTITIONING {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for D3D_TESSELLATOR_PARTITIONING {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for D3D_TESSELLATOR_PARTITIONING {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for D3D_TESSELLATOR_PARTITIONING {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("D3D_TESSELLATOR_PARTITIONING")
            .field(&self.0)
            .finish()
    }
}
#[repr(transparent)]
#[derive(::core::cmp::PartialEq, ::core::cmp::Eq)]
pub struct DXGI_FORMAT(pub u32);
pub const DXGI_FORMAT_UNKNOWN: DXGI_FORMAT = DXGI_FORMAT(0u32);
pub const DXGI_FORMAT_R32G32B32A32_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(1u32);
pub const DXGI_FORMAT_R32G32B32A32_FLOAT: DXGI_FORMAT = DXGI_FORMAT(2u32);
pub const DXGI_FORMAT_R32G32B32A32_UINT: DXGI_FORMAT = DXGI_FORMAT(3u32);
pub const DXGI_FORMAT_R32G32B32A32_SINT: DXGI_FORMAT = DXGI_FORMAT(4u32);
pub const DXGI_FORMAT_R32G32B32_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(5u32);
pub const DXGI_FORMAT_R32G32B32_FLOAT: DXGI_FORMAT = DXGI_FORMAT(6u32);
pub const DXGI_FORMAT_R32G32B32_UINT: DXGI_FORMAT = DXGI_FORMAT(7u32);
pub const DXGI_FORMAT_R32G32B32_SINT: DXGI_FORMAT = DXGI_FORMAT(8u32);
pub const DXGI_FORMAT_R16G16B16A16_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(9u32);
pub const DXGI_FORMAT_R16G16B16A16_FLOAT: DXGI_FORMAT = DXGI_FORMAT(10u32);
pub const DXGI_FORMAT_R16G16B16A16_UNORM: DXGI_FORMAT = DXGI_FORMAT(11u32);
pub const DXGI_FORMAT_R16G16B16A16_UINT: DXGI_FORMAT = DXGI_FORMAT(12u32);
pub const DXGI_FORMAT_R16G16B16A16_SNORM: DXGI_FORMAT = DXGI_FORMAT(13u32);
pub const DXGI_FORMAT_R16G16B16A16_SINT: DXGI_FORMAT = DXGI_FORMAT(14u32);
pub const DXGI_FORMAT_R32G32_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(15u32);
pub const DXGI_FORMAT_R32G32_FLOAT: DXGI_FORMAT = DXGI_FORMAT(16u32);
pub const DXGI_FORMAT_R32G32_UINT: DXGI_FORMAT = DXGI_FORMAT(17u32);
pub const DXGI_FORMAT_R32G32_SINT: DXGI_FORMAT = DXGI_FORMAT(18u32);
pub const DXGI_FORMAT_R32G8X24_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(19u32);
pub const DXGI_FORMAT_D32_FLOAT_S8X24_UINT: DXGI_FORMAT = DXGI_FORMAT(20u32);
pub const DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(21u32);
pub const DXGI_FORMAT_X32_TYPELESS_G8X24_UINT: DXGI_FORMAT = DXGI_FORMAT(22u32);
pub const DXGI_FORMAT_R10G10B10A2_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(23u32);
pub const DXGI_FORMAT_R10G10B10A2_UNORM: DXGI_FORMAT = DXGI_FORMAT(24u32);
pub const DXGI_FORMAT_R10G10B10A2_UINT: DXGI_FORMAT = DXGI_FORMAT(25u32);
pub const DXGI_FORMAT_R11G11B10_FLOAT: DXGI_FORMAT = DXGI_FORMAT(26u32);
pub const DXGI_FORMAT_R8G8B8A8_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(27u32);
pub const DXGI_FORMAT_R8G8B8A8_UNORM: DXGI_FORMAT = DXGI_FORMAT(28u32);
pub const DXGI_FORMAT_R8G8B8A8_UNORM_SRGB: DXGI_FORMAT = DXGI_FORMAT(29u32);
pub const DXGI_FORMAT_R8G8B8A8_UINT: DXGI_FORMAT = DXGI_FORMAT(30u32);
pub const DXGI_FORMAT_R8G8B8A8_SNORM: DXGI_FORMAT = DXGI_FORMAT(31u32);
pub const DXGI_FORMAT_R8G8B8A8_SINT: DXGI_FORMAT = DXGI_FORMAT(32u32);
pub const DXGI_FORMAT_R16G16_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(33u32);
pub const DXGI_FORMAT_R16G16_FLOAT: DXGI_FORMAT = DXGI_FORMAT(34u32);
pub const DXGI_FORMAT_R16G16_UNORM: DXGI_FORMAT = DXGI_FORMAT(35u32);
pub const DXGI_FORMAT_R16G16_UINT: DXGI_FORMAT = DXGI_FORMAT(36u32);
pub const DXGI_FORMAT_R16G16_SNORM: DXGI_FORMAT = DXGI_FORMAT(37u32);
pub const DXGI_FORMAT_R16G16_SINT: DXGI_FORMAT = DXGI_FORMAT(38u32);
pub const DXGI_FORMAT_R32_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(39u32);
pub const DXGI_FORMAT_D32_FLOAT: DXGI_FORMAT = DXGI_FORMAT(40u32);
pub const DXGI_FORMAT_R32_FLOAT: DXGI_FORMAT = DXGI_FORMAT(41u32);
pub const DXGI_FORMAT_R32_UINT: DXGI_FORMAT = DXGI_FORMAT(42u32);
pub const DXGI_FORMAT_R32_SINT: DXGI_FORMAT = DXGI_FORMAT(43u32);
pub const DXGI_FORMAT_R24G8_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(44u32);
pub const DXGI_FORMAT_D24_UNORM_S8_UINT: DXGI_FORMAT = DXGI_FORMAT(45u32);
pub const DXGI_FORMAT_R24_UNORM_X8_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(46u32);
pub const DXGI_FORMAT_X24_TYPELESS_G8_UINT: DXGI_FORMAT = DXGI_FORMAT(47u32);
pub const DXGI_FORMAT_R8G8_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(48u32);
pub const DXGI_FORMAT_R8G8_UNORM: DXGI_FORMAT = DXGI_FORMAT(49u32);
pub const DXGI_FORMAT_R8G8_UINT: DXGI_FORMAT = DXGI_FORMAT(50u32);
pub const DXGI_FORMAT_R8G8_SNORM: DXGI_FORMAT = DXGI_FORMAT(51u32);
pub const DXGI_FORMAT_R8G8_SINT: DXGI_FORMAT = DXGI_FORMAT(52u32);
pub const DXGI_FORMAT_R16_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(53u32);
pub const DXGI_FORMAT_R16_FLOAT: DXGI_FORMAT = DXGI_FORMAT(54u32);
pub const DXGI_FORMAT_D16_UNORM: DXGI_FORMAT = DXGI_FORMAT(55u32);
pub const DXGI_FORMAT_R16_UNORM: DXGI_FORMAT = DXGI_FORMAT(56u32);
pub const DXGI_FORMAT_R16_UINT: DXGI_FORMAT = DXGI_FORMAT(57u32);
pub const DXGI_FORMAT_R16_SNORM: DXGI_FORMAT = DXGI_FORMAT(58u32);
pub const DXGI_FORMAT_R16_SINT: DXGI_FORMAT = DXGI_FORMAT(59u32);
pub const DXGI_FORMAT_R8_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(60u32);
pub const DXGI_FORMAT_R8_UNORM: DXGI_FORMAT = DXGI_FORMAT(61u32);
pub const DXGI_FORMAT_R8_UINT: DXGI_FORMAT = DXGI_FORMAT(62u32);
pub const DXGI_FORMAT_R8_SNORM: DXGI_FORMAT = DXGI_FORMAT(63u32);
pub const DXGI_FORMAT_R8_SINT: DXGI_FORMAT = DXGI_FORMAT(64u32);
pub const DXGI_FORMAT_A8_UNORM: DXGI_FORMAT = DXGI_FORMAT(65u32);
pub const DXGI_FORMAT_R1_UNORM: DXGI_FORMAT = DXGI_FORMAT(66u32);
pub const DXGI_FORMAT_R9G9B9E5_SHAREDEXP: DXGI_FORMAT = DXGI_FORMAT(67u32);
pub const DXGI_FORMAT_R8G8_B8G8_UNORM: DXGI_FORMAT = DXGI_FORMAT(68u32);
pub const DXGI_FORMAT_G8R8_G8B8_UNORM: DXGI_FORMAT = DXGI_FORMAT(69u32);
pub const DXGI_FORMAT_BC1_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(70u32);
pub const DXGI_FORMAT_BC1_UNORM: DXGI_FORMAT = DXGI_FORMAT(71u32);
pub const DXGI_FORMAT_BC1_UNORM_SRGB: DXGI_FORMAT = DXGI_FORMAT(72u32);
pub const DXGI_FORMAT_BC2_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(73u32);
pub const DXGI_FORMAT_BC2_UNORM: DXGI_FORMAT = DXGI_FORMAT(74u32);
pub const DXGI_FORMAT_BC2_UNORM_SRGB: DXGI_FORMAT = DXGI_FORMAT(75u32);
pub const DXGI_FORMAT_BC3_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(76u32);
pub const DXGI_FORMAT_BC3_UNORM: DXGI_FORMAT = DXGI_FORMAT(77u32);
pub const DXGI_FORMAT_BC3_UNORM_SRGB: DXGI_FORMAT = DXGI_FORMAT(78u32);
pub const DXGI_FORMAT_BC4_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(79u32);
pub const DXGI_FORMAT_BC4_UNORM: DXGI_FORMAT = DXGI_FORMAT(80u32);
pub const DXGI_FORMAT_BC4_SNORM: DXGI_FORMAT = DXGI_FORMAT(81u32);
pub const DXGI_FORMAT_BC5_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(82u32);
pub const DXGI_FORMAT_BC5_UNORM: DXGI_FORMAT = DXGI_FORMAT(83u32);
pub const DXGI_FORMAT_BC5_SNORM: DXGI_FORMAT = DXGI_FORMAT(84u32);
pub const DXGI_FORMAT_B5G6R5_UNORM: DXGI_FORMAT = DXGI_FORMAT(85u32);
pub const DXGI_FORMAT_B5G5R5A1_UNORM: DXGI_FORMAT = DXGI_FORMAT(86u32);
pub const DXGI_FORMAT_B8G8R8A8_UNORM: DXGI_FORMAT = DXGI_FORMAT(87u32);
pub const DXGI_FORMAT_B8G8R8X8_UNORM: DXGI_FORMAT = DXGI_FORMAT(88u32);
pub const DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM: DXGI_FORMAT = DXGI_FORMAT(89u32);
pub const DXGI_FORMAT_B8G8R8A8_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(90u32);
pub const DXGI_FORMAT_B8G8R8A8_UNORM_SRGB: DXGI_FORMAT = DXGI_FORMAT(91u32);
pub const DXGI_FORMAT_B8G8R8X8_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(92u32);
pub const DXGI_FORMAT_B8G8R8X8_UNORM_SRGB: DXGI_FORMAT = DXGI_FORMAT(93u32);
pub const DXGI_FORMAT_BC6H_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(94u32);
pub const DXGI_FORMAT_BC6H_UF16: DXGI_FORMAT = DXGI_FORMAT(95u32);
pub const DXGI_FORMAT_BC6H_SF16: DXGI_FORMAT = DXGI_FORMAT(96u32);
pub const DXGI_FORMAT_BC7_TYPELESS: DXGI_FORMAT = DXGI_FORMAT(97u32);
pub const DXGI_FORMAT_BC7_UNORM: DXGI_FORMAT = DXGI_FORMAT(98u32);
pub const DXGI_FORMAT_BC7_UNORM_SRGB: DXGI_FORMAT = DXGI_FORMAT(99u32);
pub const DXGI_FORMAT_AYUV: DXGI_FORMAT = DXGI_FORMAT(100u32);
pub const DXGI_FORMAT_Y410: DXGI_FORMAT = DXGI_FORMAT(101u32);
pub const DXGI_FORMAT_Y416: DXGI_FORMAT = DXGI_FORMAT(102u32);
pub const DXGI_FORMAT_NV12: DXGI_FORMAT = DXGI_FORMAT(103u32);
pub const DXGI_FORMAT_P010: DXGI_FORMAT = DXGI_FORMAT(104u32);
pub const DXGI_FORMAT_P016: DXGI_FORMAT = DXGI_FORMAT(105u32);
pub const DXGI_FORMAT_420_OPAQUE: DXGI_FORMAT = DXGI_FORMAT(106u32);
pub const DXGI_FORMAT_YUY2: DXGI_FORMAT = DXGI_FORMAT(107u32);
pub const DXGI_FORMAT_Y210: DXGI_FORMAT = DXGI_FORMAT(108u32);
pub const DXGI_FORMAT_Y216: DXGI_FORMAT = DXGI_FORMAT(109u32);
pub const DXGI_FORMAT_NV11: DXGI_FORMAT = DXGI_FORMAT(110u32);
pub const DXGI_FORMAT_AI44: DXGI_FORMAT = DXGI_FORMAT(111u32);
pub const DXGI_FORMAT_IA44: DXGI_FORMAT = DXGI_FORMAT(112u32);
pub const DXGI_FORMAT_P8: DXGI_FORMAT = DXGI_FORMAT(113u32);
pub const DXGI_FORMAT_A8P8: DXGI_FORMAT = DXGI_FORMAT(114u32);
pub const DXGI_FORMAT_B4G4R4A4_UNORM: DXGI_FORMAT = DXGI_FORMAT(115u32);
pub const DXGI_FORMAT_P208: DXGI_FORMAT = DXGI_FORMAT(130u32);
pub const DXGI_FORMAT_V208: DXGI_FORMAT = DXGI_FORMAT(131u32);
pub const DXGI_FORMAT_V408: DXGI_FORMAT = DXGI_FORMAT(132u32);
pub const DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE: DXGI_FORMAT = DXGI_FORMAT(189u32);
pub const DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE: DXGI_FORMAT = DXGI_FORMAT(190u32);
pub const DXGI_FORMAT_A4B4G4R4_UNORM: DXGI_FORMAT = DXGI_FORMAT(191u32);
impl ::core::marker::Copy for DXGI_FORMAT {}
impl ::core::clone::Clone for DXGI_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::default::Default for DXGI_FORMAT {
    fn default() -> Self {
        Self(0)
    }
}
impl ::windows::core::TypeKind for DXGI_FORMAT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::fmt::Debug for DXGI_FORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_tuple("DXGI_FORMAT").field(&self.0).finish()
    }
}
#[repr(C)]
pub struct D3D12_AUTO_BREADCRUMB_NODE {
    pub pCommandListDebugNameA: ::windows::core::PCSTR,
    pub pCommandListDebugNameW: ::windows::core::PCWSTR,
    pub pCommandQueueDebugNameA: ::windows::core::PCSTR,
    pub pCommandQueueDebugNameW: ::windows::core::PCWSTR,
    pub pCommandList: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12GraphicsCommandList>>,
    pub pCommandQueue: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12CommandQueue>>,
    pub BreadcrumbCount: u32,
    pub pLastBreadcrumbValue: *const u32,
    pub pCommandHistory: *const D3D12_AUTO_BREADCRUMB_OP,
    pub pNext: *const D3D12_AUTO_BREADCRUMB_NODE,
}
impl ::core::clone::Clone for D3D12_AUTO_BREADCRUMB_NODE {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_AUTO_BREADCRUMB_NODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_AUTO_BREADCRUMB_NODE")
            .field("pCommandListDebugNameA", &self.pCommandListDebugNameA)
            .field("pCommandListDebugNameW", &self.pCommandListDebugNameW)
            .field("pCommandQueueDebugNameA", &self.pCommandQueueDebugNameA)
            .field("pCommandQueueDebugNameW", &self.pCommandQueueDebugNameW)
            .field("pCommandList", &self.pCommandList)
            .field("pCommandQueue", &self.pCommandQueue)
            .field("BreadcrumbCount", &self.BreadcrumbCount)
            .field("pLastBreadcrumbValue", &self.pLastBreadcrumbValue)
            .field("pCommandHistory", &self.pCommandHistory)
            .field("pNext", &self.pNext)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_AUTO_BREADCRUMB_NODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_AUTO_BREADCRUMB_NODE {
    fn eq(&self, other: &Self) -> bool {
        self.pCommandListDebugNameA == other.pCommandListDebugNameA
            && self.pCommandListDebugNameW == other.pCommandListDebugNameW
            && self.pCommandQueueDebugNameA == other.pCommandQueueDebugNameA
            && self.pCommandQueueDebugNameW == other.pCommandQueueDebugNameW
            && self.pCommandList == other.pCommandList
            && self.pCommandQueue == other.pCommandQueue
            && self.BreadcrumbCount == other.BreadcrumbCount
            && self.pLastBreadcrumbValue == other.pLastBreadcrumbValue
            && self.pCommandHistory == other.pCommandHistory
            && self.pNext == other.pNext
    }
}
impl ::core::cmp::Eq for D3D12_AUTO_BREADCRUMB_NODE {}
impl ::core::default::Default for D3D12_AUTO_BREADCRUMB_NODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_AUTO_BREADCRUMB_NODE1 {
    pub pCommandListDebugNameA: ::windows::core::PCSTR,
    pub pCommandListDebugNameW: ::windows::core::PCWSTR,
    pub pCommandQueueDebugNameA: ::windows::core::PCSTR,
    pub pCommandQueueDebugNameW: ::windows::core::PCWSTR,
    pub pCommandList: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12GraphicsCommandList>>,
    pub pCommandQueue: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12CommandQueue>>,
    pub BreadcrumbCount: u32,
    pub pLastBreadcrumbValue: *const u32,
    pub pCommandHistory: *const D3D12_AUTO_BREADCRUMB_OP,
    pub pNext: *const D3D12_AUTO_BREADCRUMB_NODE1,
    pub BreadcrumbContextsCount: u32,
    pub pBreadcrumbContexts: *mut D3D12_DRED_BREADCRUMB_CONTEXT,
}
impl ::core::clone::Clone for D3D12_AUTO_BREADCRUMB_NODE1 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_AUTO_BREADCRUMB_NODE1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_AUTO_BREADCRUMB_NODE1")
            .field("pCommandListDebugNameA", &self.pCommandListDebugNameA)
            .field("pCommandListDebugNameW", &self.pCommandListDebugNameW)
            .field("pCommandQueueDebugNameA", &self.pCommandQueueDebugNameA)
            .field("pCommandQueueDebugNameW", &self.pCommandQueueDebugNameW)
            .field("pCommandList", &self.pCommandList)
            .field("pCommandQueue", &self.pCommandQueue)
            .field("BreadcrumbCount", &self.BreadcrumbCount)
            .field("pLastBreadcrumbValue", &self.pLastBreadcrumbValue)
            .field("pCommandHistory", &self.pCommandHistory)
            .field("pNext", &self.pNext)
            .field("BreadcrumbContextsCount", &self.BreadcrumbContextsCount)
            .field("pBreadcrumbContexts", &self.pBreadcrumbContexts)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_AUTO_BREADCRUMB_NODE1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_AUTO_BREADCRUMB_NODE1 {
    fn eq(&self, other: &Self) -> bool {
        self.pCommandListDebugNameA == other.pCommandListDebugNameA
            && self.pCommandListDebugNameW == other.pCommandListDebugNameW
            && self.pCommandQueueDebugNameA == other.pCommandQueueDebugNameA
            && self.pCommandQueueDebugNameW == other.pCommandQueueDebugNameW
            && self.pCommandList == other.pCommandList
            && self.pCommandQueue == other.pCommandQueue
            && self.BreadcrumbCount == other.BreadcrumbCount
            && self.pLastBreadcrumbValue == other.pLastBreadcrumbValue
            && self.pCommandHistory == other.pCommandHistory
            && self.pNext == other.pNext
            && self.BreadcrumbContextsCount == other.BreadcrumbContextsCount
            && self.pBreadcrumbContexts == other.pBreadcrumbContexts
    }
}
impl ::core::cmp::Eq for D3D12_AUTO_BREADCRUMB_NODE1 {}
impl ::core::default::Default for D3D12_AUTO_BREADCRUMB_NODE1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BARRIER_GROUP {
    pub Type: D3D12_BARRIER_TYPE,
    pub NumBarriers: u32,
    pub Anonymous: D3D12_BARRIER_GROUP_0,
}
impl ::core::marker::Copy for D3D12_BARRIER_GROUP {}
impl ::core::clone::Clone for D3D12_BARRIER_GROUP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_BARRIER_GROUP {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_BARRIER_GROUP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_BARRIER_GROUP_0 {
    pub pGlobalBarriers: *const D3D12_GLOBAL_BARRIER,
    pub pTextureBarriers: *const D3D12_TEXTURE_BARRIER,
    pub pBufferBarriers: *const D3D12_BUFFER_BARRIER,
}
impl ::core::marker::Copy for D3D12_BARRIER_GROUP_0 {}
impl ::core::clone::Clone for D3D12_BARRIER_GROUP_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_BARRIER_GROUP_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_BARRIER_GROUP_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BARRIER_SUBRESOURCE_RANGE {
    pub IndexOrFirstMipLevel: u32,
    pub NumMipLevels: u32,
    pub FirstArraySlice: u32,
    pub NumArraySlices: u32,
    pub FirstPlane: u32,
    pub NumPlanes: u32,
}
impl ::core::marker::Copy for D3D12_BARRIER_SUBRESOURCE_RANGE {}
impl ::core::clone::Clone for D3D12_BARRIER_SUBRESOURCE_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_BARRIER_SUBRESOURCE_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_BARRIER_SUBRESOURCE_RANGE")
            .field("IndexOrFirstMipLevel", &self.IndexOrFirstMipLevel)
            .field("NumMipLevels", &self.NumMipLevels)
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("NumArraySlices", &self.NumArraySlices)
            .field("FirstPlane", &self.FirstPlane)
            .field("NumPlanes", &self.NumPlanes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_BARRIER_SUBRESOURCE_RANGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_BARRIER_SUBRESOURCE_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.IndexOrFirstMipLevel == other.IndexOrFirstMipLevel
            && self.NumMipLevels == other.NumMipLevels
            && self.FirstArraySlice == other.FirstArraySlice
            && self.NumArraySlices == other.NumArraySlices
            && self.FirstPlane == other.FirstPlane
            && self.NumPlanes == other.NumPlanes
    }
}
impl ::core::cmp::Eq for D3D12_BARRIER_SUBRESOURCE_RANGE {}
impl ::core::default::Default for D3D12_BARRIER_SUBRESOURCE_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BLEND_DESC {
    pub AlphaToCoverageEnable: ::windows::Win32::Foundation::BOOL,
    pub IndependentBlendEnable: ::windows::Win32::Foundation::BOOL,
    pub RenderTarget: [D3D12_RENDER_TARGET_BLEND_DESC; 8],
}
impl ::core::marker::Copy for D3D12_BLEND_DESC {}
impl ::core::clone::Clone for D3D12_BLEND_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_BLEND_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_BLEND_DESC")
            .field("AlphaToCoverageEnable", &self.AlphaToCoverageEnable)
            .field("IndependentBlendEnable", &self.IndependentBlendEnable)
            .field("RenderTarget", &self.RenderTarget)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_BLEND_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_BLEND_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.AlphaToCoverageEnable == other.AlphaToCoverageEnable
            && self.IndependentBlendEnable == other.IndependentBlendEnable
            && self.RenderTarget == other.RenderTarget
    }
}
impl ::core::cmp::Eq for D3D12_BLEND_DESC {}
impl ::core::default::Default for D3D12_BLEND_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BOX {
    pub left: u32,
    pub top: u32,
    pub front: u32,
    pub right: u32,
    pub bottom: u32,
    pub back: u32,
}
impl ::core::marker::Copy for D3D12_BOX {}
impl ::core::clone::Clone for D3D12_BOX {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_BOX {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_BOX")
            .field("left", &self.left)
            .field("top", &self.top)
            .field("front", &self.front)
            .field("right", &self.right)
            .field("bottom", &self.bottom)
            .field("back", &self.back)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_BOX {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_BOX {
    fn eq(&self, other: &Self) -> bool {
        self.left == other.left
            && self.top == other.top
            && self.front == other.front
            && self.right == other.right
            && self.bottom == other.bottom
            && self.back == other.back
    }
}
impl ::core::cmp::Eq for D3D12_BOX {}
impl ::core::default::Default for D3D12_BOX {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BROADCASTING_LAUNCH_OVERRIDES {
    pub pLocalRootArgumentsTableIndex: *const u32,
    pub pProgramEntry: *const ::windows::Win32::Foundation::BOOL,
    pub pNewName: *const D3D12_NODE_ID,
    pub pShareInputOf: *const D3D12_NODE_ID,
    pub pDispatchGrid: *const u32,
    pub pMaxDispatchGrid: *const u32,
    pub NumOutputOverrides: u32,
    pub pOutputOverrides: *const D3D12_NODE_OUTPUT_OVERRIDES,
}
impl ::core::marker::Copy for D3D12_BROADCASTING_LAUNCH_OVERRIDES {}
impl ::core::clone::Clone for D3D12_BROADCASTING_LAUNCH_OVERRIDES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_BROADCASTING_LAUNCH_OVERRIDES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_BROADCASTING_LAUNCH_OVERRIDES")
            .field(
                "pLocalRootArgumentsTableIndex",
                &self.pLocalRootArgumentsTableIndex,
            )
            .field("pProgramEntry", &self.pProgramEntry)
            .field("pNewName", &self.pNewName)
            .field("pShareInputOf", &self.pShareInputOf)
            .field("pDispatchGrid", &self.pDispatchGrid)
            .field("pMaxDispatchGrid", &self.pMaxDispatchGrid)
            .field("NumOutputOverrides", &self.NumOutputOverrides)
            .field("pOutputOverrides", &self.pOutputOverrides)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_BROADCASTING_LAUNCH_OVERRIDES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_BROADCASTING_LAUNCH_OVERRIDES {
    fn eq(&self, other: &Self) -> bool {
        self.pLocalRootArgumentsTableIndex == other.pLocalRootArgumentsTableIndex
            && self.pProgramEntry == other.pProgramEntry
            && self.pNewName == other.pNewName
            && self.pShareInputOf == other.pShareInputOf
            && self.pDispatchGrid == other.pDispatchGrid
            && self.pMaxDispatchGrid == other.pMaxDispatchGrid
            && self.NumOutputOverrides == other.NumOutputOverrides
            && self.pOutputOverrides == other.pOutputOverrides
    }
}
impl ::core::cmp::Eq for D3D12_BROADCASTING_LAUNCH_OVERRIDES {}
impl ::core::default::Default for D3D12_BROADCASTING_LAUNCH_OVERRIDES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BUFFER_BARRIER {
    pub SyncBefore: D3D12_BARRIER_SYNC,
    pub SyncAfter: D3D12_BARRIER_SYNC,
    pub AccessBefore: D3D12_BARRIER_ACCESS,
    pub AccessAfter: D3D12_BARRIER_ACCESS,
    pub pResource: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub Offset: u64,
    pub Size: u64,
}
impl ::core::clone::Clone for D3D12_BUFFER_BARRIER {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_BUFFER_BARRIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_BUFFER_BARRIER")
            .field("SyncBefore", &self.SyncBefore)
            .field("SyncAfter", &self.SyncAfter)
            .field("AccessBefore", &self.AccessBefore)
            .field("AccessAfter", &self.AccessAfter)
            .field("pResource", &self.pResource)
            .field("Offset", &self.Offset)
            .field("Size", &self.Size)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_BUFFER_BARRIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_BUFFER_BARRIER {
    fn eq(&self, other: &Self) -> bool {
        self.SyncBefore == other.SyncBefore
            && self.SyncAfter == other.SyncAfter
            && self.AccessBefore == other.AccessBefore
            && self.AccessAfter == other.AccessAfter
            && self.pResource == other.pResource
            && self.Offset == other.Offset
            && self.Size == other.Size
    }
}
impl ::core::cmp::Eq for D3D12_BUFFER_BARRIER {}
impl ::core::default::Default for D3D12_BUFFER_BARRIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BUFFER_RTV {
    pub FirstElement: u64,
    pub NumElements: u32,
}
impl ::core::marker::Copy for D3D12_BUFFER_RTV {}
impl ::core::clone::Clone for D3D12_BUFFER_RTV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_BUFFER_RTV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_BUFFER_RTV")
            .field("FirstElement", &self.FirstElement)
            .field("NumElements", &self.NumElements)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_BUFFER_RTV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_BUFFER_RTV {
    fn eq(&self, other: &Self) -> bool {
        self.FirstElement == other.FirstElement && self.NumElements == other.NumElements
    }
}
impl ::core::cmp::Eq for D3D12_BUFFER_RTV {}
impl ::core::default::Default for D3D12_BUFFER_RTV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BUFFER_SRV {
    pub FirstElement: u64,
    pub NumElements: u32,
    pub StructureByteStride: u32,
    pub Flags: D3D12_BUFFER_SRV_FLAGS,
}
impl ::core::marker::Copy for D3D12_BUFFER_SRV {}
impl ::core::clone::Clone for D3D12_BUFFER_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_BUFFER_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_BUFFER_SRV")
            .field("FirstElement", &self.FirstElement)
            .field("NumElements", &self.NumElements)
            .field("StructureByteStride", &self.StructureByteStride)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_BUFFER_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_BUFFER_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.FirstElement == other.FirstElement
            && self.NumElements == other.NumElements
            && self.StructureByteStride == other.StructureByteStride
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_BUFFER_SRV {}
impl ::core::default::Default for D3D12_BUFFER_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BUFFER_UAV {
    pub FirstElement: u64,
    pub NumElements: u32,
    pub StructureByteStride: u32,
    pub CounterOffsetInBytes: u64,
    pub Flags: D3D12_BUFFER_UAV_FLAGS,
}
impl ::core::marker::Copy for D3D12_BUFFER_UAV {}
impl ::core::clone::Clone for D3D12_BUFFER_UAV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_BUFFER_UAV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_BUFFER_UAV")
            .field("FirstElement", &self.FirstElement)
            .field("NumElements", &self.NumElements)
            .field("StructureByteStride", &self.StructureByteStride)
            .field("CounterOffsetInBytes", &self.CounterOffsetInBytes)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_BUFFER_UAV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_BUFFER_UAV {
    fn eq(&self, other: &Self) -> bool {
        self.FirstElement == other.FirstElement
            && self.NumElements == other.NumElements
            && self.StructureByteStride == other.StructureByteStride
            && self.CounterOffsetInBytes == other.CounterOffsetInBytes
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_BUFFER_UAV {}
impl ::core::default::Default for D3D12_BUFFER_UAV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC {
    pub DestAccelerationStructureData: u64,
    pub Inputs: D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
    pub SourceAccelerationStructureData: u64,
    pub ScratchAccelerationStructureData: u64,
}
impl ::core::marker::Copy for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC {}
impl ::core::clone::Clone for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {
    pub Type: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE,
    pub Flags: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_BUILD_FLAGS,
    pub NumDescs: u32,
    pub DescsLayout: D3D12_ELEMENTS_LAYOUT,
    pub Anonymous: D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0,
}
impl ::core::marker::Copy for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {}
impl ::core::clone::Clone for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0 {
    pub InstanceDescs: u64,
    pub pGeometryDescs: *const D3D12_RAYTRACING_GEOMETRY_DESC,
    pub ppGeometryDescs: *const *const D3D12_RAYTRACING_GEOMETRY_DESC,
}
impl ::core::marker::Copy for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0 {}
impl ::core::clone::Clone for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER {
    pub Type: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_TYPE,
    pub NumDescs: u32,
}
impl ::core::marker::Copy
    for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER
{
}
impl ::core::clone::Clone
    for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER
{
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug
    for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER")
            .field("Type", &self.Type)
            .field("NumDescs", &self.NumDescs)
            .finish()
    }
}
impl ::windows::core::TypeKind
    for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq
    for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER
{
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.NumDescs == other.NumDescs
    }
}
impl ::core::cmp::Eq for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER {}
impl ::core::default::Default
    for D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_TOOLS_VISUALIZATION_HEADER
{
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_CACHED_PIPELINE_STATE {
    pub pCachedBlob: *const ::core::ffi::c_void,
    pub CachedBlobSizeInBytes: usize,
}
impl ::core::marker::Copy for D3D12_CACHED_PIPELINE_STATE {}
impl ::core::clone::Clone for D3D12_CACHED_PIPELINE_STATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_CACHED_PIPELINE_STATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_CACHED_PIPELINE_STATE")
            .field("pCachedBlob", &self.pCachedBlob)
            .field("CachedBlobSizeInBytes", &self.CachedBlobSizeInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_CACHED_PIPELINE_STATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_CACHED_PIPELINE_STATE {
    fn eq(&self, other: &Self) -> bool {
        self.pCachedBlob == other.pCachedBlob
            && self.CachedBlobSizeInBytes == other.CachedBlobSizeInBytes
    }
}
impl ::core::cmp::Eq for D3D12_CACHED_PIPELINE_STATE {}
impl ::core::default::Default for D3D12_CACHED_PIPELINE_STATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_CLEAR_VALUE {
    pub Format: DXGI_FORMAT,
    pub Anonymous: D3D12_CLEAR_VALUE_0,
}
impl ::core::marker::Copy for D3D12_CLEAR_VALUE {}
impl ::core::clone::Clone for D3D12_CLEAR_VALUE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_CLEAR_VALUE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_CLEAR_VALUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_CLEAR_VALUE_0 {
    pub Color: [f32; 4],
    pub DepthStencil: D3D12_DEPTH_STENCIL_VALUE,
}
impl ::core::marker::Copy for D3D12_CLEAR_VALUE_0 {}
impl ::core::clone::Clone for D3D12_CLEAR_VALUE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_CLEAR_VALUE_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_CLEAR_VALUE_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_COALESCING_LAUNCH_OVERRIDES {
    pub pLocalRootArgumentsTableIndex: *const u32,
    pub pProgramEntry: *const ::windows::Win32::Foundation::BOOL,
    pub pNewName: *const D3D12_NODE_ID,
    pub pShareInputOf: *const D3D12_NODE_ID,
    pub NumOutputOverrides: u32,
    pub pOutputOverrides: *const D3D12_NODE_OUTPUT_OVERRIDES,
}
impl ::core::marker::Copy for D3D12_COALESCING_LAUNCH_OVERRIDES {}
impl ::core::clone::Clone for D3D12_COALESCING_LAUNCH_OVERRIDES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_COALESCING_LAUNCH_OVERRIDES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_COALESCING_LAUNCH_OVERRIDES")
            .field(
                "pLocalRootArgumentsTableIndex",
                &self.pLocalRootArgumentsTableIndex,
            )
            .field("pProgramEntry", &self.pProgramEntry)
            .field("pNewName", &self.pNewName)
            .field("pShareInputOf", &self.pShareInputOf)
            .field("NumOutputOverrides", &self.NumOutputOverrides)
            .field("pOutputOverrides", &self.pOutputOverrides)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_COALESCING_LAUNCH_OVERRIDES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_COALESCING_LAUNCH_OVERRIDES {
    fn eq(&self, other: &Self) -> bool {
        self.pLocalRootArgumentsTableIndex == other.pLocalRootArgumentsTableIndex
            && self.pProgramEntry == other.pProgramEntry
            && self.pNewName == other.pNewName
            && self.pShareInputOf == other.pShareInputOf
            && self.NumOutputOverrides == other.NumOutputOverrides
            && self.pOutputOverrides == other.pOutputOverrides
    }
}
impl ::core::cmp::Eq for D3D12_COALESCING_LAUNCH_OVERRIDES {}
impl ::core::default::Default for D3D12_COALESCING_LAUNCH_OVERRIDES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_COMMAND_QUEUE_DESC {
    pub Type: D3D12_COMMAND_LIST_TYPE,
    pub Priority: i32,
    pub Flags: D3D12_COMMAND_QUEUE_FLAGS,
    pub NodeMask: u32,
}
impl ::core::marker::Copy for D3D12_COMMAND_QUEUE_DESC {}
impl ::core::clone::Clone for D3D12_COMMAND_QUEUE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_COMMAND_QUEUE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_COMMAND_QUEUE_DESC")
            .field("Type", &self.Type)
            .field("Priority", &self.Priority)
            .field("Flags", &self.Flags)
            .field("NodeMask", &self.NodeMask)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_COMMAND_QUEUE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_COMMAND_QUEUE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type
            && self.Priority == other.Priority
            && self.Flags == other.Flags
            && self.NodeMask == other.NodeMask
    }
}
impl ::core::cmp::Eq for D3D12_COMMAND_QUEUE_DESC {}
impl ::core::default::Default for D3D12_COMMAND_QUEUE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_COMMAND_SIGNATURE_DESC {
    pub ByteStride: u32,
    pub NumArgumentDescs: u32,
    pub pArgumentDescs: *const D3D12_INDIRECT_ARGUMENT_DESC,
    pub NodeMask: u32,
}
impl ::core::marker::Copy for D3D12_COMMAND_SIGNATURE_DESC {}
impl ::core::clone::Clone for D3D12_COMMAND_SIGNATURE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_COMMAND_SIGNATURE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_COMMAND_SIGNATURE_DESC")
            .field("ByteStride", &self.ByteStride)
            .field("NumArgumentDescs", &self.NumArgumentDescs)
            .field("pArgumentDescs", &self.pArgumentDescs)
            .field("NodeMask", &self.NodeMask)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_COMMAND_SIGNATURE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_COMMAND_SIGNATURE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.ByteStride == other.ByteStride
            && self.NumArgumentDescs == other.NumArgumentDescs
            && self.pArgumentDescs == other.pArgumentDescs
            && self.NodeMask == other.NodeMask
    }
}
impl ::core::cmp::Eq for D3D12_COMMAND_SIGNATURE_DESC {}
impl ::core::default::Default for D3D12_COMMAND_SIGNATURE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_COMPUTE_PIPELINE_STATE_DESC {
    pub pRootSignature: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12RootSignature>>,
    pub CS: D3D12_SHADER_BYTECODE,
    pub NodeMask: u32,
    pub CachedPSO: D3D12_CACHED_PIPELINE_STATE,
    pub Flags: D3D12_PIPELINE_STATE_FLAGS,
}
impl ::core::clone::Clone for D3D12_COMPUTE_PIPELINE_STATE_DESC {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_COMPUTE_PIPELINE_STATE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_COMPUTE_PIPELINE_STATE_DESC")
            .field("pRootSignature", &self.pRootSignature)
            .field("CS", &self.CS)
            .field("NodeMask", &self.NodeMask)
            .field("CachedPSO", &self.CachedPSO)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_COMPUTE_PIPELINE_STATE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_COMPUTE_PIPELINE_STATE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.pRootSignature == other.pRootSignature
            && self.CS == other.CS
            && self.NodeMask == other.NodeMask
            && self.CachedPSO == other.CachedPSO
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_COMPUTE_PIPELINE_STATE_DESC {}
impl ::core::default::Default for D3D12_COMPUTE_PIPELINE_STATE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_CONSTANT_BUFFER_VIEW_DESC {
    pub BufferLocation: u64,
    pub SizeInBytes: u32,
}
impl ::core::marker::Copy for D3D12_CONSTANT_BUFFER_VIEW_DESC {}
impl ::core::clone::Clone for D3D12_CONSTANT_BUFFER_VIEW_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_CONSTANT_BUFFER_VIEW_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_CONSTANT_BUFFER_VIEW_DESC")
            .field("BufferLocation", &self.BufferLocation)
            .field("SizeInBytes", &self.SizeInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_CONSTANT_BUFFER_VIEW_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_CONSTANT_BUFFER_VIEW_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.BufferLocation == other.BufferLocation && self.SizeInBytes == other.SizeInBytes
    }
}
impl ::core::cmp::Eq for D3D12_CONSTANT_BUFFER_VIEW_DESC {}
impl ::core::default::Default for D3D12_CONSTANT_BUFFER_VIEW_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_CPU_DESCRIPTOR_HANDLE {
    pub ptr: usize,
}
impl ::core::marker::Copy for D3D12_CPU_DESCRIPTOR_HANDLE {}
impl ::core::clone::Clone for D3D12_CPU_DESCRIPTOR_HANDLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_CPU_DESCRIPTOR_HANDLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_CPU_DESCRIPTOR_HANDLE")
            .field("ptr", &self.ptr)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_CPU_DESCRIPTOR_HANDLE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_CPU_DESCRIPTOR_HANDLE {
    fn eq(&self, other: &Self) -> bool {
        self.ptr == other.ptr
    }
}
impl ::core::cmp::Eq for D3D12_CPU_DESCRIPTOR_HANDLE {}
impl ::core::default::Default for D3D12_CPU_DESCRIPTOR_HANDLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS {
    pub ShaderPatchMode: D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE,
}
impl ::core::marker::Copy for D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS {}
impl ::core::clone::Clone for D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS")
            .field("ShaderPatchMode", &self.ShaderPatchMode)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS {
    fn eq(&self, other: &Self) -> bool {
        self.ShaderPatchMode == other.ShaderPatchMode
    }
}
impl ::core::cmp::Eq for D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS {}
impl ::core::default::Default for D3D12_DEBUG_COMMAND_LIST_GPU_BASED_VALIDATION_SETTINGS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS {
    pub MaxMessagesPerCommandList: u32,
    pub DefaultShaderPatchMode: D3D12_GPU_BASED_VALIDATION_SHADER_PATCH_MODE,
    pub PipelineStateCreateFlags: D3D12_GPU_BASED_VALIDATION_PIPELINE_STATE_CREATE_FLAGS,
}
impl ::core::marker::Copy for D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS {}
impl ::core::clone::Clone for D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS")
            .field("MaxMessagesPerCommandList", &self.MaxMessagesPerCommandList)
            .field("DefaultShaderPatchMode", &self.DefaultShaderPatchMode)
            .field("PipelineStateCreateFlags", &self.PipelineStateCreateFlags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS {
    fn eq(&self, other: &Self) -> bool {
        self.MaxMessagesPerCommandList == other.MaxMessagesPerCommandList
            && self.DefaultShaderPatchMode == other.DefaultShaderPatchMode
            && self.PipelineStateCreateFlags == other.PipelineStateCreateFlags
    }
}
impl ::core::cmp::Eq for D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS {}
impl ::core::default::Default for D3D12_DEBUG_DEVICE_GPU_BASED_VALIDATION_SETTINGS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR {
    pub SlowdownFactor: f32,
}
impl ::core::marker::Copy for D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR {}
impl ::core::clone::Clone for D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR")
            .field("SlowdownFactor", &self.SlowdownFactor)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR {
    fn eq(&self, other: &Self) -> bool {
        self.SlowdownFactor == other.SlowdownFactor
    }
}
impl ::core::cmp::Eq for D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR {}
impl ::core::default::Default for D3D12_DEBUG_DEVICE_GPU_SLOWDOWN_PERFORMANCE_FACTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEPTH_STENCILOP_DESC {
    pub StencilFailOp: D3D12_STENCIL_OP,
    pub StencilDepthFailOp: D3D12_STENCIL_OP,
    pub StencilPassOp: D3D12_STENCIL_OP,
    pub StencilFunc: D3D12_COMPARISON_FUNC,
}
impl ::core::marker::Copy for D3D12_DEPTH_STENCILOP_DESC {}
impl ::core::clone::Clone for D3D12_DEPTH_STENCILOP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEPTH_STENCILOP_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEPTH_STENCILOP_DESC")
            .field("StencilFailOp", &self.StencilFailOp)
            .field("StencilDepthFailOp", &self.StencilDepthFailOp)
            .field("StencilPassOp", &self.StencilPassOp)
            .field("StencilFunc", &self.StencilFunc)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEPTH_STENCILOP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEPTH_STENCILOP_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.StencilFailOp == other.StencilFailOp
            && self.StencilDepthFailOp == other.StencilDepthFailOp
            && self.StencilPassOp == other.StencilPassOp
            && self.StencilFunc == other.StencilFunc
    }
}
impl ::core::cmp::Eq for D3D12_DEPTH_STENCILOP_DESC {}
impl ::core::default::Default for D3D12_DEPTH_STENCILOP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEPTH_STENCILOP_DESC1 {
    pub StencilFailOp: D3D12_STENCIL_OP,
    pub StencilDepthFailOp: D3D12_STENCIL_OP,
    pub StencilPassOp: D3D12_STENCIL_OP,
    pub StencilFunc: D3D12_COMPARISON_FUNC,
    pub StencilReadMask: u8,
    pub StencilWriteMask: u8,
}
impl ::core::marker::Copy for D3D12_DEPTH_STENCILOP_DESC1 {}
impl ::core::clone::Clone for D3D12_DEPTH_STENCILOP_DESC1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEPTH_STENCILOP_DESC1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEPTH_STENCILOP_DESC1")
            .field("StencilFailOp", &self.StencilFailOp)
            .field("StencilDepthFailOp", &self.StencilDepthFailOp)
            .field("StencilPassOp", &self.StencilPassOp)
            .field("StencilFunc", &self.StencilFunc)
            .field("StencilReadMask", &self.StencilReadMask)
            .field("StencilWriteMask", &self.StencilWriteMask)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEPTH_STENCILOP_DESC1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEPTH_STENCILOP_DESC1 {
    fn eq(&self, other: &Self) -> bool {
        self.StencilFailOp == other.StencilFailOp
            && self.StencilDepthFailOp == other.StencilDepthFailOp
            && self.StencilPassOp == other.StencilPassOp
            && self.StencilFunc == other.StencilFunc
            && self.StencilReadMask == other.StencilReadMask
            && self.StencilWriteMask == other.StencilWriteMask
    }
}
impl ::core::cmp::Eq for D3D12_DEPTH_STENCILOP_DESC1 {}
impl ::core::default::Default for D3D12_DEPTH_STENCILOP_DESC1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEPTH_STENCIL_DESC {
    pub DepthEnable: ::windows::Win32::Foundation::BOOL,
    pub DepthWriteMask: D3D12_DEPTH_WRITE_MASK,
    pub DepthFunc: D3D12_COMPARISON_FUNC,
    pub StencilEnable: ::windows::Win32::Foundation::BOOL,
    pub StencilReadMask: u8,
    pub StencilWriteMask: u8,
    pub FrontFace: D3D12_DEPTH_STENCILOP_DESC,
    pub BackFace: D3D12_DEPTH_STENCILOP_DESC,
}
impl ::core::marker::Copy for D3D12_DEPTH_STENCIL_DESC {}
impl ::core::clone::Clone for D3D12_DEPTH_STENCIL_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEPTH_STENCIL_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEPTH_STENCIL_DESC")
            .field("DepthEnable", &self.DepthEnable)
            .field("DepthWriteMask", &self.DepthWriteMask)
            .field("DepthFunc", &self.DepthFunc)
            .field("StencilEnable", &self.StencilEnable)
            .field("StencilReadMask", &self.StencilReadMask)
            .field("StencilWriteMask", &self.StencilWriteMask)
            .field("FrontFace", &self.FrontFace)
            .field("BackFace", &self.BackFace)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEPTH_STENCIL_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEPTH_STENCIL_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.DepthEnable == other.DepthEnable
            && self.DepthWriteMask == other.DepthWriteMask
            && self.DepthFunc == other.DepthFunc
            && self.StencilEnable == other.StencilEnable
            && self.StencilReadMask == other.StencilReadMask
            && self.StencilWriteMask == other.StencilWriteMask
            && self.FrontFace == other.FrontFace
            && self.BackFace == other.BackFace
    }
}
impl ::core::cmp::Eq for D3D12_DEPTH_STENCIL_DESC {}
impl ::core::default::Default for D3D12_DEPTH_STENCIL_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEPTH_STENCIL_DESC1 {
    pub DepthEnable: ::windows::Win32::Foundation::BOOL,
    pub DepthWriteMask: D3D12_DEPTH_WRITE_MASK,
    pub DepthFunc: D3D12_COMPARISON_FUNC,
    pub StencilEnable: ::windows::Win32::Foundation::BOOL,
    pub StencilReadMask: u8,
    pub StencilWriteMask: u8,
    pub FrontFace: D3D12_DEPTH_STENCILOP_DESC,
    pub BackFace: D3D12_DEPTH_STENCILOP_DESC,
    pub DepthBoundsTestEnable: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_DEPTH_STENCIL_DESC1 {}
impl ::core::clone::Clone for D3D12_DEPTH_STENCIL_DESC1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEPTH_STENCIL_DESC1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEPTH_STENCIL_DESC1")
            .field("DepthEnable", &self.DepthEnable)
            .field("DepthWriteMask", &self.DepthWriteMask)
            .field("DepthFunc", &self.DepthFunc)
            .field("StencilEnable", &self.StencilEnable)
            .field("StencilReadMask", &self.StencilReadMask)
            .field("StencilWriteMask", &self.StencilWriteMask)
            .field("FrontFace", &self.FrontFace)
            .field("BackFace", &self.BackFace)
            .field("DepthBoundsTestEnable", &self.DepthBoundsTestEnable)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEPTH_STENCIL_DESC1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEPTH_STENCIL_DESC1 {
    fn eq(&self, other: &Self) -> bool {
        self.DepthEnable == other.DepthEnable
            && self.DepthWriteMask == other.DepthWriteMask
            && self.DepthFunc == other.DepthFunc
            && self.StencilEnable == other.StencilEnable
            && self.StencilReadMask == other.StencilReadMask
            && self.StencilWriteMask == other.StencilWriteMask
            && self.FrontFace == other.FrontFace
            && self.BackFace == other.BackFace
            && self.DepthBoundsTestEnable == other.DepthBoundsTestEnable
    }
}
impl ::core::cmp::Eq for D3D12_DEPTH_STENCIL_DESC1 {}
impl ::core::default::Default for D3D12_DEPTH_STENCIL_DESC1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEPTH_STENCIL_DESC2 {
    pub DepthEnable: ::windows::Win32::Foundation::BOOL,
    pub DepthWriteMask: D3D12_DEPTH_WRITE_MASK,
    pub DepthFunc: D3D12_COMPARISON_FUNC,
    pub StencilEnable: ::windows::Win32::Foundation::BOOL,
    pub FrontFace: D3D12_DEPTH_STENCILOP_DESC1,
    pub BackFace: D3D12_DEPTH_STENCILOP_DESC1,
    pub DepthBoundsTestEnable: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_DEPTH_STENCIL_DESC2 {}
impl ::core::clone::Clone for D3D12_DEPTH_STENCIL_DESC2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEPTH_STENCIL_DESC2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEPTH_STENCIL_DESC2")
            .field("DepthEnable", &self.DepthEnable)
            .field("DepthWriteMask", &self.DepthWriteMask)
            .field("DepthFunc", &self.DepthFunc)
            .field("StencilEnable", &self.StencilEnable)
            .field("FrontFace", &self.FrontFace)
            .field("BackFace", &self.BackFace)
            .field("DepthBoundsTestEnable", &self.DepthBoundsTestEnable)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEPTH_STENCIL_DESC2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEPTH_STENCIL_DESC2 {
    fn eq(&self, other: &Self) -> bool {
        self.DepthEnable == other.DepthEnable
            && self.DepthWriteMask == other.DepthWriteMask
            && self.DepthFunc == other.DepthFunc
            && self.StencilEnable == other.StencilEnable
            && self.FrontFace == other.FrontFace
            && self.BackFace == other.BackFace
            && self.DepthBoundsTestEnable == other.DepthBoundsTestEnable
    }
}
impl ::core::cmp::Eq for D3D12_DEPTH_STENCIL_DESC2 {}
impl ::core::default::Default for D3D12_DEPTH_STENCIL_DESC2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEPTH_STENCIL_FORMAT {
    pub DepthStencilFormat: DXGI_FORMAT,
}
impl ::core::marker::Copy for D3D12_DEPTH_STENCIL_FORMAT {}
impl ::core::clone::Clone for D3D12_DEPTH_STENCIL_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEPTH_STENCIL_FORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEPTH_STENCIL_FORMAT")
            .field("DepthStencilFormat", &self.DepthStencilFormat)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEPTH_STENCIL_FORMAT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEPTH_STENCIL_FORMAT {
    fn eq(&self, other: &Self) -> bool {
        self.DepthStencilFormat == other.DepthStencilFormat
    }
}
impl ::core::cmp::Eq for D3D12_DEPTH_STENCIL_FORMAT {}
impl ::core::default::Default for D3D12_DEPTH_STENCIL_FORMAT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEPTH_STENCIL_VALUE {
    pub Depth: f32,
    pub Stencil: u8,
}
impl ::core::marker::Copy for D3D12_DEPTH_STENCIL_VALUE {}
impl ::core::clone::Clone for D3D12_DEPTH_STENCIL_VALUE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEPTH_STENCIL_VALUE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEPTH_STENCIL_VALUE")
            .field("Depth", &self.Depth)
            .field("Stencil", &self.Stencil)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEPTH_STENCIL_VALUE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEPTH_STENCIL_VALUE {
    fn eq(&self, other: &Self) -> bool {
        self.Depth == other.Depth && self.Stencil == other.Stencil
    }
}
impl ::core::cmp::Eq for D3D12_DEPTH_STENCIL_VALUE {}
impl ::core::default::Default for D3D12_DEPTH_STENCIL_VALUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEPTH_STENCIL_VIEW_DESC {
    pub Format: DXGI_FORMAT,
    pub ViewDimension: D3D12_DSV_DIMENSION,
    pub Flags: D3D12_DSV_FLAGS,
    pub Anonymous: D3D12_DEPTH_STENCIL_VIEW_DESC_0,
}
impl ::core::marker::Copy for D3D12_DEPTH_STENCIL_VIEW_DESC {}
impl ::core::clone::Clone for D3D12_DEPTH_STENCIL_VIEW_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_DEPTH_STENCIL_VIEW_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_DEPTH_STENCIL_VIEW_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_DEPTH_STENCIL_VIEW_DESC_0 {
    pub Texture1D: D3D12_TEX1D_DSV,
    pub Texture1DArray: D3D12_TEX1D_ARRAY_DSV,
    pub Texture2D: D3D12_TEX2D_DSV,
    pub Texture2DArray: D3D12_TEX2D_ARRAY_DSV,
    pub Texture2DMS: D3D12_TEX2DMS_DSV,
    pub Texture2DMSArray: D3D12_TEX2DMS_ARRAY_DSV,
}
impl ::core::marker::Copy for D3D12_DEPTH_STENCIL_VIEW_DESC_0 {}
impl ::core::clone::Clone for D3D12_DEPTH_STENCIL_VIEW_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_DEPTH_STENCIL_VIEW_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_DEPTH_STENCIL_VIEW_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DESCRIPTOR_HEAP_DESC {
    pub Type: D3D12_DESCRIPTOR_HEAP_TYPE,
    pub NumDescriptors: u32,
    pub Flags: D3D12_DESCRIPTOR_HEAP_FLAGS,
    pub NodeMask: u32,
}
impl ::core::marker::Copy for D3D12_DESCRIPTOR_HEAP_DESC {}
impl ::core::clone::Clone for D3D12_DESCRIPTOR_HEAP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DESCRIPTOR_HEAP_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DESCRIPTOR_HEAP_DESC")
            .field("Type", &self.Type)
            .field("NumDescriptors", &self.NumDescriptors)
            .field("Flags", &self.Flags)
            .field("NodeMask", &self.NodeMask)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DESCRIPTOR_HEAP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DESCRIPTOR_HEAP_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type
            && self.NumDescriptors == other.NumDescriptors
            && self.Flags == other.Flags
            && self.NodeMask == other.NodeMask
    }
}
impl ::core::cmp::Eq for D3D12_DESCRIPTOR_HEAP_DESC {}
impl ::core::default::Default for D3D12_DESCRIPTOR_HEAP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DESCRIPTOR_RANGE {
    pub RangeType: D3D12_DESCRIPTOR_RANGE_TYPE,
    pub NumDescriptors: u32,
    pub BaseShaderRegister: u32,
    pub RegisterSpace: u32,
    pub OffsetInDescriptorsFromTableStart: u32,
}
impl ::core::marker::Copy for D3D12_DESCRIPTOR_RANGE {}
impl ::core::clone::Clone for D3D12_DESCRIPTOR_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DESCRIPTOR_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DESCRIPTOR_RANGE")
            .field("RangeType", &self.RangeType)
            .field("NumDescriptors", &self.NumDescriptors)
            .field("BaseShaderRegister", &self.BaseShaderRegister)
            .field("RegisterSpace", &self.RegisterSpace)
            .field(
                "OffsetInDescriptorsFromTableStart",
                &self.OffsetInDescriptorsFromTableStart,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DESCRIPTOR_RANGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DESCRIPTOR_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.RangeType == other.RangeType
            && self.NumDescriptors == other.NumDescriptors
            && self.BaseShaderRegister == other.BaseShaderRegister
            && self.RegisterSpace == other.RegisterSpace
            && self.OffsetInDescriptorsFromTableStart == other.OffsetInDescriptorsFromTableStart
    }
}
impl ::core::cmp::Eq for D3D12_DESCRIPTOR_RANGE {}
impl ::core::default::Default for D3D12_DESCRIPTOR_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DESCRIPTOR_RANGE1 {
    pub RangeType: D3D12_DESCRIPTOR_RANGE_TYPE,
    pub NumDescriptors: u32,
    pub BaseShaderRegister: u32,
    pub RegisterSpace: u32,
    pub Flags: D3D12_DESCRIPTOR_RANGE_FLAGS,
    pub OffsetInDescriptorsFromTableStart: u32,
}
impl ::core::marker::Copy for D3D12_DESCRIPTOR_RANGE1 {}
impl ::core::clone::Clone for D3D12_DESCRIPTOR_RANGE1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DESCRIPTOR_RANGE1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DESCRIPTOR_RANGE1")
            .field("RangeType", &self.RangeType)
            .field("NumDescriptors", &self.NumDescriptors)
            .field("BaseShaderRegister", &self.BaseShaderRegister)
            .field("RegisterSpace", &self.RegisterSpace)
            .field("Flags", &self.Flags)
            .field(
                "OffsetInDescriptorsFromTableStart",
                &self.OffsetInDescriptorsFromTableStart,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DESCRIPTOR_RANGE1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DESCRIPTOR_RANGE1 {
    fn eq(&self, other: &Self) -> bool {
        self.RangeType == other.RangeType
            && self.NumDescriptors == other.NumDescriptors
            && self.BaseShaderRegister == other.BaseShaderRegister
            && self.RegisterSpace == other.RegisterSpace
            && self.Flags == other.Flags
            && self.OffsetInDescriptorsFromTableStart == other.OffsetInDescriptorsFromTableStart
    }
}
impl ::core::cmp::Eq for D3D12_DESCRIPTOR_RANGE1 {}
impl ::core::default::Default for D3D12_DESCRIPTOR_RANGE1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEVICE_CONFIGURATION_DESC {
    pub Flags: D3D12_DEVICE_FLAGS,
    pub GpuBasedValidationFlags: u32,
    pub SDKVersion: u32,
    pub NumEnabledExperimentalFeatures: u32,
}
impl ::core::marker::Copy for D3D12_DEVICE_CONFIGURATION_DESC {}
impl ::core::clone::Clone for D3D12_DEVICE_CONFIGURATION_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEVICE_CONFIGURATION_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEVICE_CONFIGURATION_DESC")
            .field("Flags", &self.Flags)
            .field("GpuBasedValidationFlags", &self.GpuBasedValidationFlags)
            .field("SDKVersion", &self.SDKVersion)
            .field(
                "NumEnabledExperimentalFeatures",
                &self.NumEnabledExperimentalFeatures,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEVICE_CONFIGURATION_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEVICE_CONFIGURATION_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.GpuBasedValidationFlags == other.GpuBasedValidationFlags
            && self.SDKVersion == other.SDKVersion
            && self.NumEnabledExperimentalFeatures == other.NumEnabledExperimentalFeatures
    }
}
impl ::core::cmp::Eq for D3D12_DEVICE_CONFIGURATION_DESC {}
impl ::core::default::Default for D3D12_DEVICE_CONFIGURATION_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEVICE_REMOVED_EXTENDED_DATA {
    pub Flags: D3D12_DRED_FLAGS,
    pub pHeadAutoBreadcrumbNode: *mut D3D12_AUTO_BREADCRUMB_NODE,
}
impl ::core::marker::Copy for D3D12_DEVICE_REMOVED_EXTENDED_DATA {}
impl ::core::clone::Clone for D3D12_DEVICE_REMOVED_EXTENDED_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEVICE_REMOVED_EXTENDED_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEVICE_REMOVED_EXTENDED_DATA")
            .field("Flags", &self.Flags)
            .field("pHeadAutoBreadcrumbNode", &self.pHeadAutoBreadcrumbNode)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEVICE_REMOVED_EXTENDED_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEVICE_REMOVED_EXTENDED_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags && self.pHeadAutoBreadcrumbNode == other.pHeadAutoBreadcrumbNode
    }
}
impl ::core::cmp::Eq for D3D12_DEVICE_REMOVED_EXTENDED_DATA {}
impl ::core::default::Default for D3D12_DEVICE_REMOVED_EXTENDED_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEVICE_REMOVED_EXTENDED_DATA1 {
    pub DeviceRemovedReason: ::windows::core::HRESULT,
    pub AutoBreadcrumbsOutput: D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT,
    pub PageFaultOutput: D3D12_DRED_PAGE_FAULT_OUTPUT,
}
impl ::core::marker::Copy for D3D12_DEVICE_REMOVED_EXTENDED_DATA1 {}
impl ::core::clone::Clone for D3D12_DEVICE_REMOVED_EXTENDED_DATA1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEVICE_REMOVED_EXTENDED_DATA1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEVICE_REMOVED_EXTENDED_DATA1")
            .field("DeviceRemovedReason", &self.DeviceRemovedReason)
            .field("AutoBreadcrumbsOutput", &self.AutoBreadcrumbsOutput)
            .field("PageFaultOutput", &self.PageFaultOutput)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEVICE_REMOVED_EXTENDED_DATA1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEVICE_REMOVED_EXTENDED_DATA1 {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceRemovedReason == other.DeviceRemovedReason
            && self.AutoBreadcrumbsOutput == other.AutoBreadcrumbsOutput
            && self.PageFaultOutput == other.PageFaultOutput
    }
}
impl ::core::cmp::Eq for D3D12_DEVICE_REMOVED_EXTENDED_DATA1 {}
impl ::core::default::Default for D3D12_DEVICE_REMOVED_EXTENDED_DATA1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEVICE_REMOVED_EXTENDED_DATA2 {
    pub DeviceRemovedReason: ::windows::core::HRESULT,
    pub AutoBreadcrumbsOutput: D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1,
    pub PageFaultOutput: D3D12_DRED_PAGE_FAULT_OUTPUT1,
}
impl ::core::marker::Copy for D3D12_DEVICE_REMOVED_EXTENDED_DATA2 {}
impl ::core::clone::Clone for D3D12_DEVICE_REMOVED_EXTENDED_DATA2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEVICE_REMOVED_EXTENDED_DATA2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEVICE_REMOVED_EXTENDED_DATA2")
            .field("DeviceRemovedReason", &self.DeviceRemovedReason)
            .field("AutoBreadcrumbsOutput", &self.AutoBreadcrumbsOutput)
            .field("PageFaultOutput", &self.PageFaultOutput)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEVICE_REMOVED_EXTENDED_DATA2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEVICE_REMOVED_EXTENDED_DATA2 {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceRemovedReason == other.DeviceRemovedReason
            && self.AutoBreadcrumbsOutput == other.AutoBreadcrumbsOutput
            && self.PageFaultOutput == other.PageFaultOutput
    }
}
impl ::core::cmp::Eq for D3D12_DEVICE_REMOVED_EXTENDED_DATA2 {}
impl ::core::default::Default for D3D12_DEVICE_REMOVED_EXTENDED_DATA2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DEVICE_REMOVED_EXTENDED_DATA3 {
    pub DeviceRemovedReason: ::windows::core::HRESULT,
    pub AutoBreadcrumbsOutput: D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1,
    pub PageFaultOutput: D3D12_DRED_PAGE_FAULT_OUTPUT2,
    pub DeviceState: D3D12_DRED_DEVICE_STATE,
}
impl ::core::marker::Copy for D3D12_DEVICE_REMOVED_EXTENDED_DATA3 {}
impl ::core::clone::Clone for D3D12_DEVICE_REMOVED_EXTENDED_DATA3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DEVICE_REMOVED_EXTENDED_DATA3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DEVICE_REMOVED_EXTENDED_DATA3")
            .field("DeviceRemovedReason", &self.DeviceRemovedReason)
            .field("AutoBreadcrumbsOutput", &self.AutoBreadcrumbsOutput)
            .field("PageFaultOutput", &self.PageFaultOutput)
            .field("DeviceState", &self.DeviceState)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DEVICE_REMOVED_EXTENDED_DATA3 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DEVICE_REMOVED_EXTENDED_DATA3 {
    fn eq(&self, other: &Self) -> bool {
        self.DeviceRemovedReason == other.DeviceRemovedReason
            && self.AutoBreadcrumbsOutput == other.AutoBreadcrumbsOutput
            && self.PageFaultOutput == other.PageFaultOutput
            && self.DeviceState == other.DeviceState
    }
}
impl ::core::cmp::Eq for D3D12_DEVICE_REMOVED_EXTENDED_DATA3 {}
impl ::core::default::Default for D3D12_DEVICE_REMOVED_EXTENDED_DATA3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DISCARD_REGION {
    pub NumRects: u32,
    pub pRects: *const ::windows::Win32::Foundation::RECT,
    pub FirstSubresource: u32,
    pub NumSubresources: u32,
}
impl ::core::marker::Copy for D3D12_DISCARD_REGION {}
impl ::core::clone::Clone for D3D12_DISCARD_REGION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DISCARD_REGION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DISCARD_REGION")
            .field("NumRects", &self.NumRects)
            .field("pRects", &self.pRects)
            .field("FirstSubresource", &self.FirstSubresource)
            .field("NumSubresources", &self.NumSubresources)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DISCARD_REGION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DISCARD_REGION {
    fn eq(&self, other: &Self) -> bool {
        self.NumRects == other.NumRects
            && self.pRects == other.pRects
            && self.FirstSubresource == other.FirstSubresource
            && self.NumSubresources == other.NumSubresources
    }
}
impl ::core::cmp::Eq for D3D12_DISCARD_REGION {}
impl ::core::default::Default for D3D12_DISCARD_REGION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DISPATCH_ARGUMENTS {
    pub ThreadGroupCountX: u32,
    pub ThreadGroupCountY: u32,
    pub ThreadGroupCountZ: u32,
}
impl ::core::marker::Copy for D3D12_DISPATCH_ARGUMENTS {}
impl ::core::clone::Clone for D3D12_DISPATCH_ARGUMENTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DISPATCH_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DISPATCH_ARGUMENTS")
            .field("ThreadGroupCountX", &self.ThreadGroupCountX)
            .field("ThreadGroupCountY", &self.ThreadGroupCountY)
            .field("ThreadGroupCountZ", &self.ThreadGroupCountZ)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DISPATCH_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DISPATCH_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.ThreadGroupCountX == other.ThreadGroupCountX
            && self.ThreadGroupCountY == other.ThreadGroupCountY
            && self.ThreadGroupCountZ == other.ThreadGroupCountZ
    }
}
impl ::core::cmp::Eq for D3D12_DISPATCH_ARGUMENTS {}
impl ::core::default::Default for D3D12_DISPATCH_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DISPATCH_GRAPH_DESC {
    pub Mode: D3D12_DISPATCH_MODE,
    pub Anonymous: D3D12_DISPATCH_GRAPH_DESC_0,
}
impl ::core::marker::Copy for D3D12_DISPATCH_GRAPH_DESC {}
impl ::core::clone::Clone for D3D12_DISPATCH_GRAPH_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_DISPATCH_GRAPH_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_DISPATCH_GRAPH_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_DISPATCH_GRAPH_DESC_0 {
    pub NodeCPUInput: D3D12_NODE_CPU_INPUT,
    pub NodeGPUInput: u64,
    pub MultiNodeCPUInput: D3D12_MULTI_NODE_CPU_INPUT,
    pub MultiNodeGPUInput: u64,
}
impl ::core::marker::Copy for D3D12_DISPATCH_GRAPH_DESC_0 {}
impl ::core::clone::Clone for D3D12_DISPATCH_GRAPH_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_DISPATCH_GRAPH_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_DISPATCH_GRAPH_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DISPATCH_MESH_ARGUMENTS {
    pub ThreadGroupCountX: u32,
    pub ThreadGroupCountY: u32,
    pub ThreadGroupCountZ: u32,
}
impl ::core::marker::Copy for D3D12_DISPATCH_MESH_ARGUMENTS {}
impl ::core::clone::Clone for D3D12_DISPATCH_MESH_ARGUMENTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DISPATCH_MESH_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DISPATCH_MESH_ARGUMENTS")
            .field("ThreadGroupCountX", &self.ThreadGroupCountX)
            .field("ThreadGroupCountY", &self.ThreadGroupCountY)
            .field("ThreadGroupCountZ", &self.ThreadGroupCountZ)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DISPATCH_MESH_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DISPATCH_MESH_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.ThreadGroupCountX == other.ThreadGroupCountX
            && self.ThreadGroupCountY == other.ThreadGroupCountY
            && self.ThreadGroupCountZ == other.ThreadGroupCountZ
    }
}
impl ::core::cmp::Eq for D3D12_DISPATCH_MESH_ARGUMENTS {}
impl ::core::default::Default for D3D12_DISPATCH_MESH_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DISPATCH_RAYS_DESC {
    pub RayGenerationShaderRecord: D3D12_GPU_VIRTUAL_ADDRESS_RANGE,
    pub MissShaderTable: D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE,
    pub HitGroupTable: D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE,
    pub CallableShaderTable: D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE,
    pub Width: u32,
    pub Height: u32,
    pub Depth: u32,
}
impl ::core::marker::Copy for D3D12_DISPATCH_RAYS_DESC {}
impl ::core::clone::Clone for D3D12_DISPATCH_RAYS_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DISPATCH_RAYS_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DISPATCH_RAYS_DESC")
            .field("RayGenerationShaderRecord", &self.RayGenerationShaderRecord)
            .field("MissShaderTable", &self.MissShaderTable)
            .field("HitGroupTable", &self.HitGroupTable)
            .field("CallableShaderTable", &self.CallableShaderTable)
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .field("Depth", &self.Depth)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DISPATCH_RAYS_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DISPATCH_RAYS_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.RayGenerationShaderRecord == other.RayGenerationShaderRecord
            && self.MissShaderTable == other.MissShaderTable
            && self.HitGroupTable == other.HitGroupTable
            && self.CallableShaderTable == other.CallableShaderTable
            && self.Width == other.Width
            && self.Height == other.Height
            && self.Depth == other.Depth
    }
}
impl ::core::cmp::Eq for D3D12_DISPATCH_RAYS_DESC {}
impl ::core::default::Default for D3D12_DISPATCH_RAYS_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DRAW_ARGUMENTS {
    pub VertexCountPerInstance: u32,
    pub InstanceCount: u32,
    pub StartVertexLocation: u32,
    pub StartInstanceLocation: u32,
}
impl ::core::marker::Copy for D3D12_DRAW_ARGUMENTS {}
impl ::core::clone::Clone for D3D12_DRAW_ARGUMENTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DRAW_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DRAW_ARGUMENTS")
            .field("VertexCountPerInstance", &self.VertexCountPerInstance)
            .field("InstanceCount", &self.InstanceCount)
            .field("StartVertexLocation", &self.StartVertexLocation)
            .field("StartInstanceLocation", &self.StartInstanceLocation)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DRAW_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DRAW_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.VertexCountPerInstance == other.VertexCountPerInstance
            && self.InstanceCount == other.InstanceCount
            && self.StartVertexLocation == other.StartVertexLocation
            && self.StartInstanceLocation == other.StartInstanceLocation
    }
}
impl ::core::cmp::Eq for D3D12_DRAW_ARGUMENTS {}
impl ::core::default::Default for D3D12_DRAW_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DRAW_INDEXED_ARGUMENTS {
    pub IndexCountPerInstance: u32,
    pub InstanceCount: u32,
    pub StartIndexLocation: u32,
    pub BaseVertexLocation: i32,
    pub StartInstanceLocation: u32,
}
impl ::core::marker::Copy for D3D12_DRAW_INDEXED_ARGUMENTS {}
impl ::core::clone::Clone for D3D12_DRAW_INDEXED_ARGUMENTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DRAW_INDEXED_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DRAW_INDEXED_ARGUMENTS")
            .field("IndexCountPerInstance", &self.IndexCountPerInstance)
            .field("InstanceCount", &self.InstanceCount)
            .field("StartIndexLocation", &self.StartIndexLocation)
            .field("BaseVertexLocation", &self.BaseVertexLocation)
            .field("StartInstanceLocation", &self.StartInstanceLocation)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DRAW_INDEXED_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DRAW_INDEXED_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.IndexCountPerInstance == other.IndexCountPerInstance
            && self.InstanceCount == other.InstanceCount
            && self.StartIndexLocation == other.StartIndexLocation
            && self.BaseVertexLocation == other.BaseVertexLocation
            && self.StartInstanceLocation == other.StartInstanceLocation
    }
}
impl ::core::cmp::Eq for D3D12_DRAW_INDEXED_ARGUMENTS {}
impl ::core::default::Default for D3D12_DRAW_INDEXED_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DRED_ALLOCATION_NODE {
    pub ObjectNameA: ::windows::core::PCSTR,
    pub ObjectNameW: ::windows::core::PCWSTR,
    pub AllocationType: D3D12_DRED_ALLOCATION_TYPE,
    pub pNext: *const D3D12_DRED_ALLOCATION_NODE,
}
impl ::core::marker::Copy for D3D12_DRED_ALLOCATION_NODE {}
impl ::core::clone::Clone for D3D12_DRED_ALLOCATION_NODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DRED_ALLOCATION_NODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DRED_ALLOCATION_NODE")
            .field("ObjectNameA", &self.ObjectNameA)
            .field("ObjectNameW", &self.ObjectNameW)
            .field("AllocationType", &self.AllocationType)
            .field("pNext", &self.pNext)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_ALLOCATION_NODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DRED_ALLOCATION_NODE {
    fn eq(&self, other: &Self) -> bool {
        self.ObjectNameA == other.ObjectNameA
            && self.ObjectNameW == other.ObjectNameW
            && self.AllocationType == other.AllocationType
            && self.pNext == other.pNext
    }
}
impl ::core::cmp::Eq for D3D12_DRED_ALLOCATION_NODE {}
impl ::core::default::Default for D3D12_DRED_ALLOCATION_NODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DRED_ALLOCATION_NODE1 {
    pub ObjectNameA: ::windows::core::PCSTR,
    pub ObjectNameW: ::windows::core::PCWSTR,
    pub AllocationType: D3D12_DRED_ALLOCATION_TYPE,
    pub pNext: *const D3D12_DRED_ALLOCATION_NODE1,
    pub pObject: ::std::mem::ManuallyDrop<::core::option::Option<::windows::core::IUnknown>>,
}
impl ::core::clone::Clone for D3D12_DRED_ALLOCATION_NODE1 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_DRED_ALLOCATION_NODE1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DRED_ALLOCATION_NODE1")
            .field("ObjectNameA", &self.ObjectNameA)
            .field("ObjectNameW", &self.ObjectNameW)
            .field("AllocationType", &self.AllocationType)
            .field("pNext", &self.pNext)
            .field("pObject", &self.pObject)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_ALLOCATION_NODE1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DRED_ALLOCATION_NODE1 {
    fn eq(&self, other: &Self) -> bool {
        self.ObjectNameA == other.ObjectNameA
            && self.ObjectNameW == other.ObjectNameW
            && self.AllocationType == other.AllocationType
            && self.pNext == other.pNext
            && self.pObject == other.pObject
    }
}
impl ::core::cmp::Eq for D3D12_DRED_ALLOCATION_NODE1 {}
impl ::core::default::Default for D3D12_DRED_ALLOCATION_NODE1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT {
    pub pHeadAutoBreadcrumbNode: *const D3D12_AUTO_BREADCRUMB_NODE,
}
impl ::core::marker::Copy for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT {}
impl ::core::clone::Clone for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT")
            .field("pHeadAutoBreadcrumbNode", &self.pHeadAutoBreadcrumbNode)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.pHeadAutoBreadcrumbNode == other.pHeadAutoBreadcrumbNode
    }
}
impl ::core::cmp::Eq for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT {}
impl ::core::default::Default for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1 {
    pub pHeadAutoBreadcrumbNode: *const D3D12_AUTO_BREADCRUMB_NODE1,
}
impl ::core::marker::Copy for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1 {}
impl ::core::clone::Clone for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1")
            .field("pHeadAutoBreadcrumbNode", &self.pHeadAutoBreadcrumbNode)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1 {
    fn eq(&self, other: &Self) -> bool {
        self.pHeadAutoBreadcrumbNode == other.pHeadAutoBreadcrumbNode
    }
}
impl ::core::cmp::Eq for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1 {}
impl ::core::default::Default for D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DRED_BREADCRUMB_CONTEXT {
    pub BreadcrumbIndex: u32,
    pub pContextString: ::windows::core::PCWSTR,
}
impl ::core::marker::Copy for D3D12_DRED_BREADCRUMB_CONTEXT {}
impl ::core::clone::Clone for D3D12_DRED_BREADCRUMB_CONTEXT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DRED_BREADCRUMB_CONTEXT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DRED_BREADCRUMB_CONTEXT")
            .field("BreadcrumbIndex", &self.BreadcrumbIndex)
            .field("pContextString", &self.pContextString)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_BREADCRUMB_CONTEXT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DRED_BREADCRUMB_CONTEXT {
    fn eq(&self, other: &Self) -> bool {
        self.BreadcrumbIndex == other.BreadcrumbIndex && self.pContextString == other.pContextString
    }
}
impl ::core::cmp::Eq for D3D12_DRED_BREADCRUMB_CONTEXT {}
impl ::core::default::Default for D3D12_DRED_BREADCRUMB_CONTEXT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DRED_PAGE_FAULT_OUTPUT {
    pub PageFaultVA: u64,
    pub pHeadExistingAllocationNode: *const D3D12_DRED_ALLOCATION_NODE,
    pub pHeadRecentFreedAllocationNode: *const D3D12_DRED_ALLOCATION_NODE,
}
impl ::core::marker::Copy for D3D12_DRED_PAGE_FAULT_OUTPUT {}
impl ::core::clone::Clone for D3D12_DRED_PAGE_FAULT_OUTPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DRED_PAGE_FAULT_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DRED_PAGE_FAULT_OUTPUT")
            .field("PageFaultVA", &self.PageFaultVA)
            .field(
                "pHeadExistingAllocationNode",
                &self.pHeadExistingAllocationNode,
            )
            .field(
                "pHeadRecentFreedAllocationNode",
                &self.pHeadRecentFreedAllocationNode,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_PAGE_FAULT_OUTPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DRED_PAGE_FAULT_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.PageFaultVA == other.PageFaultVA
            && self.pHeadExistingAllocationNode == other.pHeadExistingAllocationNode
            && self.pHeadRecentFreedAllocationNode == other.pHeadRecentFreedAllocationNode
    }
}
impl ::core::cmp::Eq for D3D12_DRED_PAGE_FAULT_OUTPUT {}
impl ::core::default::Default for D3D12_DRED_PAGE_FAULT_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DRED_PAGE_FAULT_OUTPUT1 {
    pub PageFaultVA: u64,
    pub pHeadExistingAllocationNode: *const D3D12_DRED_ALLOCATION_NODE1,
    pub pHeadRecentFreedAllocationNode: *const D3D12_DRED_ALLOCATION_NODE1,
}
impl ::core::marker::Copy for D3D12_DRED_PAGE_FAULT_OUTPUT1 {}
impl ::core::clone::Clone for D3D12_DRED_PAGE_FAULT_OUTPUT1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DRED_PAGE_FAULT_OUTPUT1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DRED_PAGE_FAULT_OUTPUT1")
            .field("PageFaultVA", &self.PageFaultVA)
            .field(
                "pHeadExistingAllocationNode",
                &self.pHeadExistingAllocationNode,
            )
            .field(
                "pHeadRecentFreedAllocationNode",
                &self.pHeadRecentFreedAllocationNode,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_PAGE_FAULT_OUTPUT1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DRED_PAGE_FAULT_OUTPUT1 {
    fn eq(&self, other: &Self) -> bool {
        self.PageFaultVA == other.PageFaultVA
            && self.pHeadExistingAllocationNode == other.pHeadExistingAllocationNode
            && self.pHeadRecentFreedAllocationNode == other.pHeadRecentFreedAllocationNode
    }
}
impl ::core::cmp::Eq for D3D12_DRED_PAGE_FAULT_OUTPUT1 {}
impl ::core::default::Default for D3D12_DRED_PAGE_FAULT_OUTPUT1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DRED_PAGE_FAULT_OUTPUT2 {
    pub PageFaultVA: u64,
    pub pHeadExistingAllocationNode: *const D3D12_DRED_ALLOCATION_NODE1,
    pub pHeadRecentFreedAllocationNode: *const D3D12_DRED_ALLOCATION_NODE1,
    pub PageFaultFlags: D3D12_DRED_PAGE_FAULT_FLAGS,
}
impl ::core::marker::Copy for D3D12_DRED_PAGE_FAULT_OUTPUT2 {}
impl ::core::clone::Clone for D3D12_DRED_PAGE_FAULT_OUTPUT2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DRED_PAGE_FAULT_OUTPUT2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DRED_PAGE_FAULT_OUTPUT2")
            .field("PageFaultVA", &self.PageFaultVA)
            .field(
                "pHeadExistingAllocationNode",
                &self.pHeadExistingAllocationNode,
            )
            .field(
                "pHeadRecentFreedAllocationNode",
                &self.pHeadRecentFreedAllocationNode,
            )
            .field("PageFaultFlags", &self.PageFaultFlags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DRED_PAGE_FAULT_OUTPUT2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DRED_PAGE_FAULT_OUTPUT2 {
    fn eq(&self, other: &Self) -> bool {
        self.PageFaultVA == other.PageFaultVA
            && self.pHeadExistingAllocationNode == other.pHeadExistingAllocationNode
            && self.pHeadRecentFreedAllocationNode == other.pHeadRecentFreedAllocationNode
            && self.PageFaultFlags == other.PageFaultFlags
    }
}
impl ::core::cmp::Eq for D3D12_DRED_PAGE_FAULT_OUTPUT2 {}
impl ::core::default::Default for D3D12_DRED_PAGE_FAULT_OUTPUT2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DXIL_LIBRARY_DESC {
    pub DXILLibrary: D3D12_SHADER_BYTECODE,
    pub NumExports: u32,
    pub pExports: *mut D3D12_EXPORT_DESC,
}
impl ::core::marker::Copy for D3D12_DXIL_LIBRARY_DESC {}
impl ::core::clone::Clone for D3D12_DXIL_LIBRARY_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DXIL_LIBRARY_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DXIL_LIBRARY_DESC")
            .field("DXILLibrary", &self.DXILLibrary)
            .field("NumExports", &self.NumExports)
            .field("pExports", &self.pExports)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DXIL_LIBRARY_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DXIL_LIBRARY_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.DXILLibrary == other.DXILLibrary
            && self.NumExports == other.NumExports
            && self.pExports == other.pExports
    }
}
impl ::core::cmp::Eq for D3D12_DXIL_LIBRARY_DESC {}
impl ::core::default::Default for D3D12_DXIL_LIBRARY_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    pub SubobjectToAssociate: ::windows::core::PCWSTR,
    pub NumExports: u32,
    pub pExports: *const ::windows::core::PCWSTR,
}
impl ::core::marker::Copy for D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION {}
impl ::core::clone::Clone for D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION")
            .field("SubobjectToAssociate", &self.SubobjectToAssociate)
            .field("NumExports", &self.NumExports)
            .field("pExports", &self.pExports)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    fn eq(&self, other: &Self) -> bool {
        self.SubobjectToAssociate == other.SubobjectToAssociate
            && self.NumExports == other.NumExports
            && self.pExports == other.pExports
    }
}
impl ::core::cmp::Eq for D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION {}
impl ::core::default::Default for D3D12_DXIL_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_EXISTING_COLLECTION_DESC {
    pub pExistingCollection: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12StateObject>>,
    pub NumExports: u32,
    pub pExports: *mut D3D12_EXPORT_DESC,
}
impl ::core::clone::Clone for D3D12_EXISTING_COLLECTION_DESC {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_EXISTING_COLLECTION_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_EXISTING_COLLECTION_DESC")
            .field("pExistingCollection", &self.pExistingCollection)
            .field("NumExports", &self.NumExports)
            .field("pExports", &self.pExports)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_EXISTING_COLLECTION_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_EXISTING_COLLECTION_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.pExistingCollection == other.pExistingCollection
            && self.NumExports == other.NumExports
            && self.pExports == other.pExports
    }
}
impl ::core::cmp::Eq for D3D12_EXISTING_COLLECTION_DESC {}
impl ::core::default::Default for D3D12_EXISTING_COLLECTION_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_EXPORT_DESC {
    pub Name: ::windows::core::PCWSTR,
    pub ExportToRename: ::windows::core::PCWSTR,
    pub Flags: D3D12_EXPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_EXPORT_DESC {}
impl ::core::clone::Clone for D3D12_EXPORT_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_EXPORT_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_EXPORT_DESC")
            .field("Name", &self.Name)
            .field("ExportToRename", &self.ExportToRename)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_EXPORT_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_EXPORT_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name
            && self.ExportToRename == other.ExportToRename
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_EXPORT_DESC {}
impl ::core::default::Default for D3D12_EXPORT_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_ARCHITECTURE {
    pub NodeIndex: u32,
    pub TileBasedRenderer: ::windows::Win32::Foundation::BOOL,
    pub UMA: ::windows::Win32::Foundation::BOOL,
    pub CacheCoherentUMA: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_ARCHITECTURE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_ARCHITECTURE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_ARCHITECTURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_ARCHITECTURE")
            .field("NodeIndex", &self.NodeIndex)
            .field("TileBasedRenderer", &self.TileBasedRenderer)
            .field("UMA", &self.UMA)
            .field("CacheCoherentUMA", &self.CacheCoherentUMA)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_ARCHITECTURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_ARCHITECTURE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.TileBasedRenderer == other.TileBasedRenderer
            && self.UMA == other.UMA
            && self.CacheCoherentUMA == other.CacheCoherentUMA
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_ARCHITECTURE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_ARCHITECTURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_ARCHITECTURE1 {
    pub NodeIndex: u32,
    pub TileBasedRenderer: ::windows::Win32::Foundation::BOOL,
    pub UMA: ::windows::Win32::Foundation::BOOL,
    pub CacheCoherentUMA: ::windows::Win32::Foundation::BOOL,
    pub IsolatedMMU: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_ARCHITECTURE1 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_ARCHITECTURE1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_ARCHITECTURE1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_ARCHITECTURE1")
            .field("NodeIndex", &self.NodeIndex)
            .field("TileBasedRenderer", &self.TileBasedRenderer)
            .field("UMA", &self.UMA)
            .field("CacheCoherentUMA", &self.CacheCoherentUMA)
            .field("IsolatedMMU", &self.IsolatedMMU)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_ARCHITECTURE1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_ARCHITECTURE1 {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.TileBasedRenderer == other.TileBasedRenderer
            && self.UMA == other.UMA
            && self.CacheCoherentUMA == other.CacheCoherentUMA
            && self.IsolatedMMU == other.IsolatedMMU
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_ARCHITECTURE1 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_ARCHITECTURE1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY {
    pub CommandListType: D3D12_COMMAND_LIST_TYPE,
    pub Priority: u32,
    pub PriorityForTypeIsSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY")
            .field("CommandListType", &self.CommandListType)
            .field("Priority", &self.Priority)
            .field(
                "PriorityForTypeIsSupported",
                &self.PriorityForTypeIsSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY {
    fn eq(&self, other: &Self) -> bool {
        self.CommandListType == other.CommandListType
            && self.Priority == other.Priority
            && self.PriorityForTypeIsSupported == other.PriorityForTypeIsSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY {}
impl ::core::default::Default for D3D12_FEATURE_DATA_COMMAND_QUEUE_PRIORITY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_CROSS_NODE {
    pub SharingTier: D3D12_CROSS_NODE_SHARING_TIER,
    pub AtomicShaderInstructions: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_CROSS_NODE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_CROSS_NODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_CROSS_NODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_CROSS_NODE")
            .field("SharingTier", &self.SharingTier)
            .field("AtomicShaderInstructions", &self.AtomicShaderInstructions)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_CROSS_NODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_CROSS_NODE {
    fn eq(&self, other: &Self) -> bool {
        self.SharingTier == other.SharingTier
            && self.AtomicShaderInstructions == other.AtomicShaderInstructions
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_CROSS_NODE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_CROSS_NODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS {
    pub DoublePrecisionFloatShaderOps: ::windows::Win32::Foundation::BOOL,
    pub OutputMergerLogicOp: ::windows::Win32::Foundation::BOOL,
    pub MinPrecisionSupport: D3D12_SHADER_MIN_PRECISION_SUPPORT,
    pub TiledResourcesTier: D3D12_TILED_RESOURCES_TIER,
    pub ResourceBindingTier: D3D12_RESOURCE_BINDING_TIER,
    pub PSSpecifiedStencilRefSupported: ::windows::Win32::Foundation::BOOL,
    pub TypedUAVLoadAdditionalFormats: ::windows::Win32::Foundation::BOOL,
    pub ROVsSupported: ::windows::Win32::Foundation::BOOL,
    pub ConservativeRasterizationTier: D3D12_CONSERVATIVE_RASTERIZATION_TIER,
    pub MaxGPUVirtualAddressBitsPerResource: u32,
    pub StandardSwizzle64KBSupported: ::windows::Win32::Foundation::BOOL,
    pub CrossNodeSharingTier: D3D12_CROSS_NODE_SHARING_TIER,
    pub CrossAdapterRowMajorTextureSupported: ::windows::Win32::Foundation::BOOL,
    pub VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation:
        ::windows::Win32::Foundation::BOOL,
    pub ResourceHeapTier: D3D12_RESOURCE_HEAP_TIER,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS")
            .field(
                "DoublePrecisionFloatShaderOps",
                &self.DoublePrecisionFloatShaderOps,
            )
            .field("OutputMergerLogicOp", &self.OutputMergerLogicOp)
            .field("MinPrecisionSupport", &self.MinPrecisionSupport)
            .field("TiledResourcesTier", &self.TiledResourcesTier)
            .field("ResourceBindingTier", &self.ResourceBindingTier)
            .field(
                "PSSpecifiedStencilRefSupported",
                &self.PSSpecifiedStencilRefSupported,
            )
            .field(
                "TypedUAVLoadAdditionalFormats",
                &self.TypedUAVLoadAdditionalFormats,
            )
            .field("ROVsSupported", &self.ROVsSupported)
            .field(
                "ConservativeRasterizationTier",
                &self.ConservativeRasterizationTier,
            )
            .field(
                "MaxGPUVirtualAddressBitsPerResource",
                &self.MaxGPUVirtualAddressBitsPerResource,
            )
            .field(
                "StandardSwizzle64KBSupported",
                &self.StandardSwizzle64KBSupported,
            )
            .field("CrossNodeSharingTier", &self.CrossNodeSharingTier)
            .field(
                "CrossAdapterRowMajorTextureSupported",
                &self.CrossAdapterRowMajorTextureSupported,
            )
            .field(
                "VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation",
                &self.VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation,
            )
            .field("ResourceHeapTier", &self.ResourceHeapTier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS {
    fn eq(&self, other: &Self) -> bool {
        self.DoublePrecisionFloatShaderOps == other.DoublePrecisionFloatShaderOps
            && self.OutputMergerLogicOp == other.OutputMergerLogicOp
            && self.MinPrecisionSupport == other.MinPrecisionSupport
            && self.TiledResourcesTier == other.TiledResourcesTier
            && self.ResourceBindingTier == other.ResourceBindingTier
            && self.PSSpecifiedStencilRefSupported == other.PSSpecifiedStencilRefSupported
            && self.TypedUAVLoadAdditionalFormats == other.TypedUAVLoadAdditionalFormats
            && self.ROVsSupported == other.ROVsSupported
            && self.ConservativeRasterizationTier == other.ConservativeRasterizationTier
            && self.MaxGPUVirtualAddressBitsPerResource == other.MaxGPUVirtualAddressBitsPerResource
            && self.StandardSwizzle64KBSupported == other.StandardSwizzle64KBSupported
            && self.CrossNodeSharingTier == other.CrossNodeSharingTier
            && self.CrossAdapterRowMajorTextureSupported
                == other.CrossAdapterRowMajorTextureSupported
            && self.VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation
                == other.VPAndRTArrayIndexFromAnyShaderFeedingRasterizerSupportedWithoutGSEmulation
            && self.ResourceHeapTier == other.ResourceHeapTier
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS1 {
    pub WaveOps: ::windows::Win32::Foundation::BOOL,
    pub WaveLaneCountMin: u32,
    pub WaveLaneCountMax: u32,
    pub TotalLaneCount: u32,
    pub ExpandedComputeResourceStates: ::windows::Win32::Foundation::BOOL,
    pub Int64ShaderOps: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS1 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS1")
            .field("WaveOps", &self.WaveOps)
            .field("WaveLaneCountMin", &self.WaveLaneCountMin)
            .field("WaveLaneCountMax", &self.WaveLaneCountMax)
            .field("TotalLaneCount", &self.TotalLaneCount)
            .field(
                "ExpandedComputeResourceStates",
                &self.ExpandedComputeResourceStates,
            )
            .field("Int64ShaderOps", &self.Int64ShaderOps)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS1 {
    fn eq(&self, other: &Self) -> bool {
        self.WaveOps == other.WaveOps
            && self.WaveLaneCountMin == other.WaveLaneCountMin
            && self.WaveLaneCountMax == other.WaveLaneCountMax
            && self.TotalLaneCount == other.TotalLaneCount
            && self.ExpandedComputeResourceStates == other.ExpandedComputeResourceStates
            && self.Int64ShaderOps == other.Int64ShaderOps
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS1 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS10 {
    pub VariableRateShadingSumCombinerSupported: ::windows::Win32::Foundation::BOOL,
    pub MeshShaderPerPrimitiveShadingRateSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS10 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS10 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS10 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS10")
            .field(
                "VariableRateShadingSumCombinerSupported",
                &self.VariableRateShadingSumCombinerSupported,
            )
            .field(
                "MeshShaderPerPrimitiveShadingRateSupported",
                &self.MeshShaderPerPrimitiveShadingRateSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS10 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS10 {
    fn eq(&self, other: &Self) -> bool {
        self.VariableRateShadingSumCombinerSupported
            == other.VariableRateShadingSumCombinerSupported
            && self.MeshShaderPerPrimitiveShadingRateSupported
                == other.MeshShaderPerPrimitiveShadingRateSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS10 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS10 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS11 {
    pub AtomicInt64OnDescriptorHeapResourceSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS11 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS11 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS11 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS11")
            .field(
                "AtomicInt64OnDescriptorHeapResourceSupported",
                &self.AtomicInt64OnDescriptorHeapResourceSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS11 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS11 {
    fn eq(&self, other: &Self) -> bool {
        self.AtomicInt64OnDescriptorHeapResourceSupported
            == other.AtomicInt64OnDescriptorHeapResourceSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS11 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS11 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS12 {
    pub MSPrimitivesPipelineStatisticIncludesCulledPrimitives: D3D12_TRI_STATE,
    pub EnhancedBarriersSupported: ::windows::Win32::Foundation::BOOL,
    pub RelaxedFormatCastingSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS12 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS12 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS12 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS12")
            .field(
                "MSPrimitivesPipelineStatisticIncludesCulledPrimitives",
                &self.MSPrimitivesPipelineStatisticIncludesCulledPrimitives,
            )
            .field("EnhancedBarriersSupported", &self.EnhancedBarriersSupported)
            .field(
                "RelaxedFormatCastingSupported",
                &self.RelaxedFormatCastingSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS12 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS12 {
    fn eq(&self, other: &Self) -> bool {
        self.MSPrimitivesPipelineStatisticIncludesCulledPrimitives
            == other.MSPrimitivesPipelineStatisticIncludesCulledPrimitives
            && self.EnhancedBarriersSupported == other.EnhancedBarriersSupported
            && self.RelaxedFormatCastingSupported == other.RelaxedFormatCastingSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS12 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS12 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS13 {
    pub UnrestrictedBufferTextureCopyPitchSupported: ::windows::Win32::Foundation::BOOL,
    pub UnrestrictedVertexElementAlignmentSupported: ::windows::Win32::Foundation::BOOL,
    pub InvertedViewportHeightFlipsYSupported: ::windows::Win32::Foundation::BOOL,
    pub InvertedViewportDepthFlipsZSupported: ::windows::Win32::Foundation::BOOL,
    pub TextureCopyBetweenDimensionsSupported: ::windows::Win32::Foundation::BOOL,
    pub AlphaBlendFactorSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS13 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS13 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS13 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS13")
            .field(
                "UnrestrictedBufferTextureCopyPitchSupported",
                &self.UnrestrictedBufferTextureCopyPitchSupported,
            )
            .field(
                "UnrestrictedVertexElementAlignmentSupported",
                &self.UnrestrictedVertexElementAlignmentSupported,
            )
            .field(
                "InvertedViewportHeightFlipsYSupported",
                &self.InvertedViewportHeightFlipsYSupported,
            )
            .field(
                "InvertedViewportDepthFlipsZSupported",
                &self.InvertedViewportDepthFlipsZSupported,
            )
            .field(
                "TextureCopyBetweenDimensionsSupported",
                &self.TextureCopyBetweenDimensionsSupported,
            )
            .field("AlphaBlendFactorSupported", &self.AlphaBlendFactorSupported)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS13 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS13 {
    fn eq(&self, other: &Self) -> bool {
        self.UnrestrictedBufferTextureCopyPitchSupported
            == other.UnrestrictedBufferTextureCopyPitchSupported
            && self.UnrestrictedVertexElementAlignmentSupported
                == other.UnrestrictedVertexElementAlignmentSupported
            && self.InvertedViewportHeightFlipsYSupported
                == other.InvertedViewportHeightFlipsYSupported
            && self.InvertedViewportDepthFlipsZSupported
                == other.InvertedViewportDepthFlipsZSupported
            && self.TextureCopyBetweenDimensionsSupported
                == other.TextureCopyBetweenDimensionsSupported
            && self.AlphaBlendFactorSupported == other.AlphaBlendFactorSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS13 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS13 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS14 {
    pub AdvancedTextureOpsSupported: ::windows::Win32::Foundation::BOOL,
    pub WriteableMSAATexturesSupported: ::windows::Win32::Foundation::BOOL,
    pub IndependentFrontAndBackStencilRefMaskSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS14 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS14 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS14 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS14")
            .field(
                "AdvancedTextureOpsSupported",
                &self.AdvancedTextureOpsSupported,
            )
            .field(
                "WriteableMSAATexturesSupported",
                &self.WriteableMSAATexturesSupported,
            )
            .field(
                "IndependentFrontAndBackStencilRefMaskSupported",
                &self.IndependentFrontAndBackStencilRefMaskSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS14 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS14 {
    fn eq(&self, other: &Self) -> bool {
        self.AdvancedTextureOpsSupported == other.AdvancedTextureOpsSupported
            && self.WriteableMSAATexturesSupported == other.WriteableMSAATexturesSupported
            && self.IndependentFrontAndBackStencilRefMaskSupported
                == other.IndependentFrontAndBackStencilRefMaskSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS14 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS14 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS15 {
    pub TriangleFanSupported: ::windows::Win32::Foundation::BOOL,
    pub DynamicIndexBufferStripCutSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS15 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS15 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS15 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS15")
            .field("TriangleFanSupported", &self.TriangleFanSupported)
            .field(
                "DynamicIndexBufferStripCutSupported",
                &self.DynamicIndexBufferStripCutSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS15 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS15 {
    fn eq(&self, other: &Self) -> bool {
        self.TriangleFanSupported == other.TriangleFanSupported
            && self.DynamicIndexBufferStripCutSupported == other.DynamicIndexBufferStripCutSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS15 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS15 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS16 {
    pub DynamicDepthBiasSupported: ::windows::Win32::Foundation::BOOL,
    pub GPUUploadHeapSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS16 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS16 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS16 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS16")
            .field("DynamicDepthBiasSupported", &self.DynamicDepthBiasSupported)
            .field("GPUUploadHeapSupported", &self.GPUUploadHeapSupported)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS16 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS16 {
    fn eq(&self, other: &Self) -> bool {
        self.DynamicDepthBiasSupported == other.DynamicDepthBiasSupported
            && self.GPUUploadHeapSupported == other.GPUUploadHeapSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS16 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS16 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS17 {
    pub NonNormalizedCoordinateSamplersSupported: ::windows::Win32::Foundation::BOOL,
    pub ManualWriteTrackingResourceSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS17 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS17 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS17 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS17")
            .field(
                "NonNormalizedCoordinateSamplersSupported",
                &self.NonNormalizedCoordinateSamplersSupported,
            )
            .field(
                "ManualWriteTrackingResourceSupported",
                &self.ManualWriteTrackingResourceSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS17 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS17 {
    fn eq(&self, other: &Self) -> bool {
        self.NonNormalizedCoordinateSamplersSupported
            == other.NonNormalizedCoordinateSamplersSupported
            && self.ManualWriteTrackingResourceSupported
                == other.ManualWriteTrackingResourceSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS17 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS17 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS18 {
    pub RenderPassesValid: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS18 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS18 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS18 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS18")
            .field("RenderPassesValid", &self.RenderPassesValid)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS18 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS18 {
    fn eq(&self, other: &Self) -> bool {
        self.RenderPassesValid == other.RenderPassesValid
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS18 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS18 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS19 {
    pub MismatchingOutputDimensionsSupported: ::windows::Win32::Foundation::BOOL,
    pub SupportedSampleCountsWithNoOutputs: u32,
    pub PointSamplingAddressesNeverRoundUp: ::windows::Win32::Foundation::BOOL,
    pub RasterizerDesc2Supported: ::windows::Win32::Foundation::BOOL,
    pub NarrowQuadrilateralLinesSupported: ::windows::Win32::Foundation::BOOL,
    pub AnisoFilterWithPointMipSupported: ::windows::Win32::Foundation::BOOL,
    pub MaxSamplerDescriptorHeapSize: u32,
    pub MaxSamplerDescriptorHeapSizeWithStaticSamplers: u32,
    pub MaxViewDescriptorHeapSize: u32,
    pub ComputeOnlyCustomHeapSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS19 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS19 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS19 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS19")
            .field(
                "MismatchingOutputDimensionsSupported",
                &self.MismatchingOutputDimensionsSupported,
            )
            .field(
                "SupportedSampleCountsWithNoOutputs",
                &self.SupportedSampleCountsWithNoOutputs,
            )
            .field(
                "PointSamplingAddressesNeverRoundUp",
                &self.PointSamplingAddressesNeverRoundUp,
            )
            .field("RasterizerDesc2Supported", &self.RasterizerDesc2Supported)
            .field(
                "NarrowQuadrilateralLinesSupported",
                &self.NarrowQuadrilateralLinesSupported,
            )
            .field(
                "AnisoFilterWithPointMipSupported",
                &self.AnisoFilterWithPointMipSupported,
            )
            .field(
                "MaxSamplerDescriptorHeapSize",
                &self.MaxSamplerDescriptorHeapSize,
            )
            .field(
                "MaxSamplerDescriptorHeapSizeWithStaticSamplers",
                &self.MaxSamplerDescriptorHeapSizeWithStaticSamplers,
            )
            .field("MaxViewDescriptorHeapSize", &self.MaxViewDescriptorHeapSize)
            .field(
                "ComputeOnlyCustomHeapSupported",
                &self.ComputeOnlyCustomHeapSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS19 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS19 {
    fn eq(&self, other: &Self) -> bool {
        self.MismatchingOutputDimensionsSupported == other.MismatchingOutputDimensionsSupported
            && self.SupportedSampleCountsWithNoOutputs == other.SupportedSampleCountsWithNoOutputs
            && self.PointSamplingAddressesNeverRoundUp == other.PointSamplingAddressesNeverRoundUp
            && self.RasterizerDesc2Supported == other.RasterizerDesc2Supported
            && self.NarrowQuadrilateralLinesSupported == other.NarrowQuadrilateralLinesSupported
            && self.AnisoFilterWithPointMipSupported == other.AnisoFilterWithPointMipSupported
            && self.MaxSamplerDescriptorHeapSize == other.MaxSamplerDescriptorHeapSize
            && self.MaxSamplerDescriptorHeapSizeWithStaticSamplers
                == other.MaxSamplerDescriptorHeapSizeWithStaticSamplers
            && self.MaxViewDescriptorHeapSize == other.MaxViewDescriptorHeapSize
            && self.ComputeOnlyCustomHeapSupported == other.ComputeOnlyCustomHeapSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS19 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS19 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS2 {
    pub DepthBoundsTestSupported: ::windows::Win32::Foundation::BOOL,
    pub ProgrammableSamplePositionsTier: D3D12_PROGRAMMABLE_SAMPLE_POSITIONS_TIER,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS2 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS2")
            .field("DepthBoundsTestSupported", &self.DepthBoundsTestSupported)
            .field(
                "ProgrammableSamplePositionsTier",
                &self.ProgrammableSamplePositionsTier,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS2 {
    fn eq(&self, other: &Self) -> bool {
        self.DepthBoundsTestSupported == other.DepthBoundsTestSupported
            && self.ProgrammableSamplePositionsTier == other.ProgrammableSamplePositionsTier
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS2 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS20 {
    pub ComputeOnlyWriteWatchSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS20 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS20 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS20 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS20")
            .field(
                "ComputeOnlyWriteWatchSupported",
                &self.ComputeOnlyWriteWatchSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS20 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS20 {
    fn eq(&self, other: &Self) -> bool {
        self.ComputeOnlyWriteWatchSupported == other.ComputeOnlyWriteWatchSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS20 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS20 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS3 {
    pub CopyQueueTimestampQueriesSupported: ::windows::Win32::Foundation::BOOL,
    pub CastingFullyTypedFormatSupported: ::windows::Win32::Foundation::BOOL,
    pub WriteBufferImmediateSupportFlags: D3D12_COMMAND_LIST_SUPPORT_FLAGS,
    pub ViewInstancingTier: D3D12_VIEW_INSTANCING_TIER,
    pub BarycentricsSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS3 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS3")
            .field(
                "CopyQueueTimestampQueriesSupported",
                &self.CopyQueueTimestampQueriesSupported,
            )
            .field(
                "CastingFullyTypedFormatSupported",
                &self.CastingFullyTypedFormatSupported,
            )
            .field(
                "WriteBufferImmediateSupportFlags",
                &self.WriteBufferImmediateSupportFlags,
            )
            .field("ViewInstancingTier", &self.ViewInstancingTier)
            .field("BarycentricsSupported", &self.BarycentricsSupported)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS3 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS3 {
    fn eq(&self, other: &Self) -> bool {
        self.CopyQueueTimestampQueriesSupported == other.CopyQueueTimestampQueriesSupported
            && self.CastingFullyTypedFormatSupported == other.CastingFullyTypedFormatSupported
            && self.WriteBufferImmediateSupportFlags == other.WriteBufferImmediateSupportFlags
            && self.ViewInstancingTier == other.ViewInstancingTier
            && self.BarycentricsSupported == other.BarycentricsSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS3 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS4 {
    pub MSAA64KBAlignedTextureSupported: ::windows::Win32::Foundation::BOOL,
    pub SharedResourceCompatibilityTier: D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER,
    pub Native16BitShaderOpsSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS4 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS4")
            .field(
                "MSAA64KBAlignedTextureSupported",
                &self.MSAA64KBAlignedTextureSupported,
            )
            .field(
                "SharedResourceCompatibilityTier",
                &self.SharedResourceCompatibilityTier,
            )
            .field(
                "Native16BitShaderOpsSupported",
                &self.Native16BitShaderOpsSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS4 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS4 {
    fn eq(&self, other: &Self) -> bool {
        self.MSAA64KBAlignedTextureSupported == other.MSAA64KBAlignedTextureSupported
            && self.SharedResourceCompatibilityTier == other.SharedResourceCompatibilityTier
            && self.Native16BitShaderOpsSupported == other.Native16BitShaderOpsSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS4 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS5 {
    pub SRVOnlyTiledResourceTier3: ::windows::Win32::Foundation::BOOL,
    pub RenderPassesTier: D3D12_RENDER_PASS_TIER,
    pub RaytracingTier: D3D12_RAYTRACING_TIER,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS5 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS5 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS5 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS5")
            .field("SRVOnlyTiledResourceTier3", &self.SRVOnlyTiledResourceTier3)
            .field("RenderPassesTier", &self.RenderPassesTier)
            .field("RaytracingTier", &self.RaytracingTier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS5 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS5 {
    fn eq(&self, other: &Self) -> bool {
        self.SRVOnlyTiledResourceTier3 == other.SRVOnlyTiledResourceTier3
            && self.RenderPassesTier == other.RenderPassesTier
            && self.RaytracingTier == other.RaytracingTier
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS5 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS6 {
    pub AdditionalShadingRatesSupported: ::windows::Win32::Foundation::BOOL,
    pub PerPrimitiveShadingRateSupportedWithViewportIndexing: ::windows::Win32::Foundation::BOOL,
    pub VariableShadingRateTier: D3D12_VARIABLE_SHADING_RATE_TIER,
    pub ShadingRateImageTileSize: u32,
    pub BackgroundProcessingSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS6 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS6 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS6 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS6")
            .field(
                "AdditionalShadingRatesSupported",
                &self.AdditionalShadingRatesSupported,
            )
            .field(
                "PerPrimitiveShadingRateSupportedWithViewportIndexing",
                &self.PerPrimitiveShadingRateSupportedWithViewportIndexing,
            )
            .field("VariableShadingRateTier", &self.VariableShadingRateTier)
            .field("ShadingRateImageTileSize", &self.ShadingRateImageTileSize)
            .field(
                "BackgroundProcessingSupported",
                &self.BackgroundProcessingSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS6 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS6 {
    fn eq(&self, other: &Self) -> bool {
        self.AdditionalShadingRatesSupported == other.AdditionalShadingRatesSupported
            && self.PerPrimitiveShadingRateSupportedWithViewportIndexing
                == other.PerPrimitiveShadingRateSupportedWithViewportIndexing
            && self.VariableShadingRateTier == other.VariableShadingRateTier
            && self.ShadingRateImageTileSize == other.ShadingRateImageTileSize
            && self.BackgroundProcessingSupported == other.BackgroundProcessingSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS6 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS7 {
    pub MeshShaderTier: D3D12_MESH_SHADER_TIER,
    pub SamplerFeedbackTier: D3D12_SAMPLER_FEEDBACK_TIER,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS7 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS7 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS7 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS7")
            .field("MeshShaderTier", &self.MeshShaderTier)
            .field("SamplerFeedbackTier", &self.SamplerFeedbackTier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS7 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS7 {
    fn eq(&self, other: &Self) -> bool {
        self.MeshShaderTier == other.MeshShaderTier
            && self.SamplerFeedbackTier == other.SamplerFeedbackTier
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS7 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS8 {
    pub UnalignedBlockTexturesSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS8 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS8 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS8 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS8")
            .field(
                "UnalignedBlockTexturesSupported",
                &self.UnalignedBlockTexturesSupported,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS8 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS8 {
    fn eq(&self, other: &Self) -> bool {
        self.UnalignedBlockTexturesSupported == other.UnalignedBlockTexturesSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS8 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS9 {
    pub MeshShaderPipelineStatsSupported: ::windows::Win32::Foundation::BOOL,
    pub MeshShaderSupportsFullRangeRenderTargetArrayIndex: ::windows::Win32::Foundation::BOOL,
    pub AtomicInt64OnTypedResourceSupported: ::windows::Win32::Foundation::BOOL,
    pub AtomicInt64OnGroupSharedSupported: ::windows::Win32::Foundation::BOOL,
    pub DerivativesInMeshAndAmplificationShadersSupported: ::windows::Win32::Foundation::BOOL,
    pub WaveMMATier: D3D12_WAVE_MMA_TIER,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS9 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS9 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS9 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS9")
            .field(
                "MeshShaderPipelineStatsSupported",
                &self.MeshShaderPipelineStatsSupported,
            )
            .field(
                "MeshShaderSupportsFullRangeRenderTargetArrayIndex",
                &self.MeshShaderSupportsFullRangeRenderTargetArrayIndex,
            )
            .field(
                "AtomicInt64OnTypedResourceSupported",
                &self.AtomicInt64OnTypedResourceSupported,
            )
            .field(
                "AtomicInt64OnGroupSharedSupported",
                &self.AtomicInt64OnGroupSharedSupported,
            )
            .field(
                "DerivativesInMeshAndAmplificationShadersSupported",
                &self.DerivativesInMeshAndAmplificationShadersSupported,
            )
            .field("WaveMMATier", &self.WaveMMATier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS9 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS9 {
    fn eq(&self, other: &Self) -> bool {
        self.MeshShaderPipelineStatsSupported == other.MeshShaderPipelineStatsSupported
            && self.MeshShaderSupportsFullRangeRenderTargetArrayIndex
                == other.MeshShaderSupportsFullRangeRenderTargetArrayIndex
            && self.AtomicInt64OnTypedResourceSupported == other.AtomicInt64OnTypedResourceSupported
            && self.AtomicInt64OnGroupSharedSupported == other.AtomicInt64OnGroupSharedSupported
            && self.DerivativesInMeshAndAmplificationShadersSupported
                == other.DerivativesInMeshAndAmplificationShadersSupported
            && self.WaveMMATier == other.WaveMMATier
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS9 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS9 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_D3D12_OPTIONS_EXPERIMENTAL {
    pub WorkGraphsTier: D3D12_WORK_GRAPHS_TIER,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_D3D12_OPTIONS_EXPERIMENTAL {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_D3D12_OPTIONS_EXPERIMENTAL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_D3D12_OPTIONS_EXPERIMENTAL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_D3D12_OPTIONS_EXPERIMENTAL")
            .field("WorkGraphsTier", &self.WorkGraphsTier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_D3D12_OPTIONS_EXPERIMENTAL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_D3D12_OPTIONS_EXPERIMENTAL {
    fn eq(&self, other: &Self) -> bool {
        self.WorkGraphsTier == other.WorkGraphsTier
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_D3D12_OPTIONS_EXPERIMENTAL {}
impl ::core::default::Default for D3D12_FEATURE_DATA_D3D12_OPTIONS_EXPERIMENTAL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_DISPLAYABLE {
    pub DisplayableTexture: ::windows::Win32::Foundation::BOOL,
    pub SharedResourceCompatibilityTier: D3D12_SHARED_RESOURCE_COMPATIBILITY_TIER,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_DISPLAYABLE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_DISPLAYABLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_DISPLAYABLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_DISPLAYABLE")
            .field("DisplayableTexture", &self.DisplayableTexture)
            .field(
                "SharedResourceCompatibilityTier",
                &self.SharedResourceCompatibilityTier,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_DISPLAYABLE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_DISPLAYABLE {
    fn eq(&self, other: &Self) -> bool {
        self.DisplayableTexture == other.DisplayableTexture
            && self.SharedResourceCompatibilityTier == other.SharedResourceCompatibilityTier
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_DISPLAYABLE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_DISPLAYABLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_EXISTING_HEAPS {
    pub Supported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_EXISTING_HEAPS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_EXISTING_HEAPS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_EXISTING_HEAPS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_EXISTING_HEAPS")
            .field("Supported", &self.Supported)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_EXISTING_HEAPS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_EXISTING_HEAPS {
    fn eq(&self, other: &Self) -> bool {
        self.Supported == other.Supported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_EXISTING_HEAPS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_EXISTING_HEAPS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_FEATURE_LEVELS {
    pub NumFeatureLevels: u32,
    pub pFeatureLevelsRequested: *const D3D_FEATURE_LEVEL,
    pub MaxSupportedFeatureLevel: D3D_FEATURE_LEVEL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_FEATURE_LEVELS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_FEATURE_LEVELS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_FEATURE_LEVELS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_FEATURE_LEVELS")
            .field("NumFeatureLevels", &self.NumFeatureLevels)
            .field("pFeatureLevelsRequested", &self.pFeatureLevelsRequested)
            .field("MaxSupportedFeatureLevel", &self.MaxSupportedFeatureLevel)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_FEATURE_LEVELS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_FEATURE_LEVELS {
    fn eq(&self, other: &Self) -> bool {
        self.NumFeatureLevels == other.NumFeatureLevels
            && self.pFeatureLevelsRequested == other.pFeatureLevelsRequested
            && self.MaxSupportedFeatureLevel == other.MaxSupportedFeatureLevel
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_FEATURE_LEVELS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_FEATURE_LEVELS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_FORMAT_INFO {
    pub Format: DXGI_FORMAT,
    pub PlaneCount: u8,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_FORMAT_INFO {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_FORMAT_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_FORMAT_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_FORMAT_INFO")
            .field("Format", &self.Format)
            .field("PlaneCount", &self.PlaneCount)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_FORMAT_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_FORMAT_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format && self.PlaneCount == other.PlaneCount
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_FORMAT_INFO {}
impl ::core::default::Default for D3D12_FEATURE_DATA_FORMAT_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_FORMAT_SUPPORT {
    pub Format: DXGI_FORMAT,
    pub Support1: D3D12_FORMAT_SUPPORT1,
    pub Support2: D3D12_FORMAT_SUPPORT2,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_FORMAT_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_FORMAT_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_FORMAT_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_FORMAT_SUPPORT")
            .field("Format", &self.Format)
            .field("Support1", &self.Support1)
            .field("Support2", &self.Support2)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_FORMAT_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_FORMAT_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format
            && self.Support1 == other.Support1
            && self.Support2 == other.Support2
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_FORMAT_SUPPORT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_FORMAT_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {
    pub MaxGPUVirtualAddressBitsPerResource: u32,
    pub MaxGPUVirtualAddressBitsPerProcess: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT")
            .field(
                "MaxGPUVirtualAddressBitsPerResource",
                &self.MaxGPUVirtualAddressBitsPerResource,
            )
            .field(
                "MaxGPUVirtualAddressBitsPerProcess",
                &self.MaxGPUVirtualAddressBitsPerProcess,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.MaxGPUVirtualAddressBitsPerResource == other.MaxGPUVirtualAddressBitsPerResource
            && self.MaxGPUVirtualAddressBitsPerProcess == other.MaxGPUVirtualAddressBitsPerProcess
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_GPU_VIRTUAL_ADDRESS_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS {
    pub Format: DXGI_FORMAT,
    pub SampleCount: u32,
    pub Flags: D3D12_MULTISAMPLE_QUALITY_LEVEL_FLAGS,
    pub NumQualityLevels: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS")
            .field("Format", &self.Format)
            .field("SampleCount", &self.SampleCount)
            .field("Flags", &self.Flags)
            .field("NumQualityLevels", &self.NumQualityLevels)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format
            && self.SampleCount == other.SampleCount
            && self.Flags == other.Flags
            && self.NumQualityLevels == other.NumQualityLevels
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_MULTISAMPLE_QUALITY_LEVELS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT {
    pub NodeIndex: u32,
    pub Support: D3D12_PROTECTED_RESOURCE_SESSION_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT")
            .field("NodeIndex", &self.NodeIndex)
            .field("Support", &self.Support)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Support == other.Support
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPES {
    pub NodeIndex: u32,
    pub Count: u32,
    pub pTypes: *mut ::windows::core::GUID,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPES {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPES")
            .field("NodeIndex", &self.NodeIndex)
            .field("Count", &self.Count)
            .field("pTypes", &self.pTypes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPES {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.Count == other.Count
            && self.pTypes == other.pTypes
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPES {}
impl ::core::default::Default for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPE_COUNT {
    pub NodeIndex: u32,
    pub Count: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPE_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPE_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPE_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPE_COUNT")
            .field("NodeIndex", &self.NodeIndex)
            .field("Count", &self.Count)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPE_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPE_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.Count == other.Count
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPE_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_PROTECTED_RESOURCE_SESSION_TYPE_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_QUERY_META_COMMAND {
    pub CommandId: ::windows::core::GUID,
    pub NodeMask: u32,
    pub pQueryInputData: *const ::core::ffi::c_void,
    pub QueryInputDataSizeInBytes: usize,
    pub pQueryOutputData: *mut ::core::ffi::c_void,
    pub QueryOutputDataSizeInBytes: usize,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_QUERY_META_COMMAND {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_QUERY_META_COMMAND {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_QUERY_META_COMMAND {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_QUERY_META_COMMAND")
            .field("CommandId", &self.CommandId)
            .field("NodeMask", &self.NodeMask)
            .field("pQueryInputData", &self.pQueryInputData)
            .field("QueryInputDataSizeInBytes", &self.QueryInputDataSizeInBytes)
            .field("pQueryOutputData", &self.pQueryOutputData)
            .field(
                "QueryOutputDataSizeInBytes",
                &self.QueryOutputDataSizeInBytes,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_QUERY_META_COMMAND {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_QUERY_META_COMMAND {
    fn eq(&self, other: &Self) -> bool {
        self.CommandId == other.CommandId
            && self.NodeMask == other.NodeMask
            && self.pQueryInputData == other.pQueryInputData
            && self.QueryInputDataSizeInBytes == other.QueryInputDataSizeInBytes
            && self.pQueryOutputData == other.pQueryOutputData
            && self.QueryOutputDataSizeInBytes == other.QueryOutputDataSizeInBytes
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_QUERY_META_COMMAND {}
impl ::core::default::Default for D3D12_FEATURE_DATA_QUERY_META_COMMAND {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_ROOT_SIGNATURE {
    pub HighestVersion: D3D_ROOT_SIGNATURE_VERSION,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_ROOT_SIGNATURE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_ROOT_SIGNATURE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_ROOT_SIGNATURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_ROOT_SIGNATURE")
            .field("HighestVersion", &self.HighestVersion)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_ROOT_SIGNATURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_ROOT_SIGNATURE {
    fn eq(&self, other: &Self) -> bool {
        self.HighestVersion == other.HighestVersion
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_ROOT_SIGNATURE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_ROOT_SIGNATURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_SERIALIZATION {
    pub NodeIndex: u32,
    pub HeapSerializationTier: D3D12_HEAP_SERIALIZATION_TIER,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_SERIALIZATION {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_SERIALIZATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_SERIALIZATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_SERIALIZATION")
            .field("NodeIndex", &self.NodeIndex)
            .field("HeapSerializationTier", &self.HeapSerializationTier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_SERIALIZATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_SERIALIZATION {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.HeapSerializationTier == other.HeapSerializationTier
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_SERIALIZATION {}
impl ::core::default::Default for D3D12_FEATURE_DATA_SERIALIZATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_SHADER_CACHE {
    pub SupportFlags: D3D12_SHADER_CACHE_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_SHADER_CACHE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_SHADER_CACHE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_SHADER_CACHE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_SHADER_CACHE")
            .field("SupportFlags", &self.SupportFlags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_SHADER_CACHE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_SHADER_CACHE {
    fn eq(&self, other: &Self) -> bool {
        self.SupportFlags == other.SupportFlags
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_SHADER_CACHE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_SHADER_CACHE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_SHADER_MODEL {
    pub HighestShaderModel: D3D_SHADER_MODEL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_SHADER_MODEL {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_SHADER_MODEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_SHADER_MODEL {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_SHADER_MODEL")
            .field("HighestShaderModel", &self.HighestShaderModel)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_SHADER_MODEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_SHADER_MODEL {
    fn eq(&self, other: &Self) -> bool {
        self.HighestShaderModel == other.HighestShaderModel
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_SHADER_MODEL {}
impl ::core::default::Default for D3D12_FEATURE_DATA_SHADER_MODEL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    pub IOCoherent: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE")
            .field("IOCoherent", &self.IOCoherent)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    fn eq(&self, other: &Self) -> bool {
        self.IOCoherent == other.IOCoherent
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ARCHITECTURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    pub VideoDecoderHeapDesc: D3D12_VIDEO_DECODER_HEAP_DESC,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE")
            .field("VideoDecoderHeapDesc", &self.VideoDecoderHeapDesc)
            .field("MemoryPoolL0Size", &self.MemoryPoolL0Size)
            .field("MemoryPoolL1Size", &self.MemoryPoolL1Size)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    fn eq(&self, other: &Self) -> bool {
        self.VideoDecoderHeapDesc == other.VideoDecoderHeapDesc
            && self.MemoryPoolL0Size == other.MemoryPoolL0Size
            && self.MemoryPoolL1Size == other.MemoryPoolL1Size
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    pub VideoDecoderHeapDesc: D3D12_VIDEO_DECODER_HEAP_DESC,
    pub Protected: ::windows::Win32::Foundation::BOOL,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1")
            .field("VideoDecoderHeapDesc", &self.VideoDecoderHeapDesc)
            .field("Protected", &self.Protected)
            .field("MemoryPoolL0Size", &self.MemoryPoolL0Size)
            .field("MemoryPoolL1Size", &self.MemoryPoolL1Size)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    fn eq(&self, other: &Self) -> bool {
        self.VideoDecoderHeapDesc == other.VideoDecoderHeapDesc
            && self.Protected == other.Protected
            && self.MemoryPoolL0Size == other.MemoryPoolL0Size
            && self.MemoryPoolL1Size == other.MemoryPoolL1Size
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODER_HEAP_SIZE1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    pub NodeIndex: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub DecodeSample: D3D12_VIDEO_SAMPLE,
    pub OutputFormat: D3D12_VIDEO_FORMAT,
    pub FrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub BitRate: u32,
    pub SupportFlags: D3D12_VIDEO_DECODE_CONVERSION_SUPPORT_FLAGS,
    pub ScaleSupport: D3D12_VIDEO_SCALE_SUPPORT,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT")
            .field("NodeIndex", &self.NodeIndex)
            .field("Configuration", &self.Configuration)
            .field("DecodeSample", &self.DecodeSample)
            .field("OutputFormat", &self.OutputFormat)
            .field("FrameRate", &self.FrameRate)
            .field("BitRate", &self.BitRate)
            .field("SupportFlags", &self.SupportFlags)
            .field("ScaleSupport", &self.ScaleSupport)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.Configuration == other.Configuration
            && self.DecodeSample == other.DecodeSample
            && self.OutputFormat == other.OutputFormat
            && self.FrameRate == other.FrameRate
            && self.BitRate == other.BitRate
            && self.SupportFlags == other.SupportFlags
            && self.ScaleSupport == other.ScaleSupport
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_CONVERSION_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    pub NodeIndex: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub FormatCount: u32,
    pub pOutputFormats: *mut DXGI_FORMAT,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS")
            .field("NodeIndex", &self.NodeIndex)
            .field("Configuration", &self.Configuration)
            .field("FormatCount", &self.FormatCount)
            .field("pOutputFormats", &self.pOutputFormats)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.Configuration == other.Configuration
            && self.FormatCount == other.FormatCount
            && self.pOutputFormats == other.pOutputFormats
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMATS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    pub NodeIndex: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub FormatCount: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT")
            .field("NodeIndex", &self.NodeIndex)
            .field("Configuration", &self.Configuration)
            .field("FormatCount", &self.FormatCount)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.Configuration == other.Configuration
            && self.FormatCount == other.FormatCount
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_FORMAT_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    pub NodeIndex: u32,
    pub DecodeProfile: ::windows::core::GUID,
    pub Width: u32,
    pub Height: u32,
    pub DecodeFormat: DXGI_FORMAT,
    pub Components: D3D12_VIDEO_DECODE_HISTOGRAM_COMPONENT_FLAGS,
    pub BinCount: u32,
    pub CounterBitDepth: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM")
            .field("NodeIndex", &self.NodeIndex)
            .field("DecodeProfile", &self.DecodeProfile)
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .field("DecodeFormat", &self.DecodeFormat)
            .field("Components", &self.Components)
            .field("BinCount", &self.BinCount)
            .field("CounterBitDepth", &self.CounterBitDepth)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.DecodeProfile == other.DecodeProfile
            && self.Width == other.Width
            && self.Height == other.Height
            && self.DecodeFormat == other.DecodeFormat
            && self.Components == other.Components
            && self.BinCount == other.BinCount
            && self.CounterBitDepth == other.CounterBitDepth
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_HISTOGRAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    pub NodeIndex: u32,
    pub ProfileCount: u32,
    pub pProfiles: *mut ::windows::core::GUID,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES")
            .field("NodeIndex", &self.NodeIndex)
            .field("ProfileCount", &self.ProfileCount)
            .field("pProfiles", &self.pProfiles)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.ProfileCount == other.ProfileCount
            && self.pProfiles == other.pProfiles
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    pub NodeIndex: u32,
    pub ProfileCount: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT")
            .field("NodeIndex", &self.NodeIndex)
            .field("ProfileCount", &self.ProfileCount)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.ProfileCount == other.ProfileCount
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_PROFILE_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    pub NodeIndex: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES")
            .field("NodeIndex", &self.NodeIndex)
            .field("Configuration", &self.Configuration)
            .field("SupportFlags", &self.SupportFlags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.Configuration == other.Configuration
            && self.SupportFlags == other.SupportFlags
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_PROTECTED_RESOURCES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    pub NodeIndex: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub Width: u32,
    pub Height: u32,
    pub DecodeFormat: DXGI_FORMAT,
    pub FrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub BitRate: u32,
    pub SupportFlags: D3D12_VIDEO_DECODE_SUPPORT_FLAGS,
    pub ConfigurationFlags: D3D12_VIDEO_DECODE_CONFIGURATION_FLAGS,
    pub DecodeTier: D3D12_VIDEO_DECODE_TIER,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT")
            .field("NodeIndex", &self.NodeIndex)
            .field("Configuration", &self.Configuration)
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .field("DecodeFormat", &self.DecodeFormat)
            .field("FrameRate", &self.FrameRate)
            .field("BitRate", &self.BitRate)
            .field("SupportFlags", &self.SupportFlags)
            .field("ConfigurationFlags", &self.ConfigurationFlags)
            .field("DecodeTier", &self.DecodeTier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.Configuration == other.Configuration
            && self.Width == other.Width
            && self.Height == other.Height
            && self.DecodeFormat == other.DecodeFormat
            && self.FrameRate == other.FrameRate
            && self.BitRate == other.BitRate
            && self.SupportFlags == other.SupportFlags
            && self.ConfigurationFlags == other.ConfigurationFlags
            && self.DecodeTier == other.DecodeTier
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_DECODE_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC")
            .field("NodeIndex", &self.NodeIndex)
            .field("Codec", &self.Codec)
            .field("IsSupported", &self.IsSupported)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.Codec == other.Codec
            && self.IsSupported == other.IsSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
    pub CodecSupportLimits: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
    pub PictureSupport: D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub Level: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub SubregionMode: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    pub FrameResolution: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub CodecSupport: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub Level: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub SubregionMode: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE {
    pub HeapDesc: D3D12_VIDEO_ENCODER_HEAP_DESC,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_HEAP_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub Format: DXGI_FORMAT,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_INPUT_FORMAT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub Level: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub IntraRefreshMode: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_INTRA_REFRESH_MODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub ResolutionRatiosCount: u32,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
    pub MinResolutionSupported: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub MaxResolutionSupported: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub ResolutionWidthMultipleRequirement: u32,
    pub ResolutionHeightMultipleRequirement: u32,
    pub pResolutionRatios: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION")
            .field("NodeIndex", &self.NodeIndex)
            .field("Codec", &self.Codec)
            .field("ResolutionRatiosCount", &self.ResolutionRatiosCount)
            .field("IsSupported", &self.IsSupported)
            .field("MinResolutionSupported", &self.MinResolutionSupported)
            .field("MaxResolutionSupported", &self.MaxResolutionSupported)
            .field(
                "ResolutionWidthMultipleRequirement",
                &self.ResolutionWidthMultipleRequirement,
            )
            .field(
                "ResolutionHeightMultipleRequirement",
                &self.ResolutionHeightMultipleRequirement,
            )
            .field("pResolutionRatios", &self.pResolutionRatios)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.Codec == other.Codec
            && self.ResolutionRatiosCount == other.ResolutionRatiosCount
            && self.IsSupported == other.IsSupported
            && self.MinResolutionSupported == other.MinResolutionSupported
            && self.MaxResolutionSupported == other.MaxResolutionSupported
            && self.ResolutionWidthMultipleRequirement == other.ResolutionWidthMultipleRequirement
            && self.ResolutionHeightMultipleRequirement == other.ResolutionHeightMultipleRequirement
            && self.pResolutionRatios == other.pResolutionRatios
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub ResolutionRatiosCount: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT")
            .field("NodeIndex", &self.NodeIndex)
            .field("Codec", &self.Codec)
            .field("ResolutionRatiosCount", &self.ResolutionRatiosCount)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.Codec == other.Codec
            && self.ResolutionRatiosCount == other.ResolutionRatiosCount
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_OUTPUT_RESOLUTION_RATIOS_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
    pub MinSupportedLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub MaxSupportedLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_PROFILE_LEVEL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub RateControlMode: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE")
            .field("NodeIndex", &self.NodeIndex)
            .field("Codec", &self.Codec)
            .field("RateControlMode", &self.RateControlMode)
            .field("IsSupported", &self.IsSupported)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.Codec == other.Codec
            && self.RateControlMode == other.RateControlMode
            && self.IsSupported == other.IsSupported
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_RATE_CONTROL_MODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    pub MaxSubregionsNumber: u32,
    pub MaxIntraRefreshFrameDuration: u32,
    pub SubregionBlockPixelsSize: u32,
    pub QPMapRegionPixelsSize: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS")
            .field("MaxSubregionsNumber", &self.MaxSubregionsNumber)
            .field(
                "MaxIntraRefreshFrameDuration",
                &self.MaxIntraRefreshFrameDuration,
            )
            .field("SubregionBlockPixelsSize", &self.SubregionBlockPixelsSize)
            .field("QPMapRegionPixelsSize", &self.QPMapRegionPixelsSize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    fn eq(&self, other: &Self) -> bool {
        self.MaxSubregionsNumber == other.MaxSubregionsNumber
            && self.MaxIntraRefreshFrameDuration == other.MaxIntraRefreshFrameDuration
            && self.SubregionBlockPixelsSize == other.SubregionBlockPixelsSize
            && self.QPMapRegionPixelsSize == other.QPMapRegionPixelsSize
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub Profile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub InputFormat: DXGI_FORMAT,
    pub PictureTargetResolution: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub IsSupported: ::windows::Win32::Foundation::BOOL,
    pub CompressedBitstreamBufferAccessAlignment: u32,
    pub EncoderMetadataBufferAccessAlignment: u32,
    pub MaxEncoderOutputMetadataBufferSize: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOURCE_REQUIREMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub InputFormat: DXGI_FORMAT,
    pub CodecConfiguration: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
    pub CodecGopSequence: D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE,
    pub RateControl: D3D12_VIDEO_ENCODER_RATE_CONTROL,
    pub IntraRefresh: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE,
    pub SubregionFrameEncoding: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    pub ResolutionsListCount: u32,
    pub pResolutionList: *const D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub MaxReferenceFramesInDPB: u32,
    pub ValidationFlags: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS,
    pub SupportFlags: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS,
    pub SuggestedProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub SuggestedLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub pResolutionDependentSupport:
        *mut D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT1 {
    pub NodeIndex: u32,
    pub Codec: D3D12_VIDEO_ENCODER_CODEC,
    pub InputFormat: DXGI_FORMAT,
    pub CodecConfiguration: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
    pub CodecGopSequence: D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE,
    pub RateControl: D3D12_VIDEO_ENCODER_RATE_CONTROL,
    pub IntraRefresh: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE,
    pub SubregionFrameEncoding: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    pub ResolutionsListCount: u32,
    pub pResolutionList: *const D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub MaxReferenceFramesInDPB: u32,
    pub ValidationFlags: D3D12_VIDEO_ENCODER_VALIDATION_FLAGS,
    pub SupportFlags: D3D12_VIDEO_ENCODER_SUPPORT_FLAGS,
    pub SuggestedProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub SuggestedLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub pResolutionDependentSupport:
        *mut D3D12_FEATURE_DATA_VIDEO_ENCODER_RESOLUTION_SUPPORT_LIMITS,
    pub SubregionFrameEncodingData: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT1 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_ENCODER_SUPPORT1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    pub NodeIndex: u32,
    pub CommandCount: u32,
    pub pCommandInfos: *mut D3D12_VIDEO_EXTENSION_COMMAND_INFO,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS")
            .field("NodeIndex", &self.NodeIndex)
            .field("CommandCount", &self.CommandCount)
            .field("pCommandInfos", &self.pCommandInfos)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.CommandCount == other.CommandCount
            && self.pCommandInfos == other.pCommandInfos
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMANDS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    pub NodeIndex: u32,
    pub CommandCount: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT")
            .field("NodeIndex", &self.NodeIndex)
            .field("CommandCount", &self.CommandCount)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.CommandCount == other.CommandCount
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    pub CommandId: ::windows::core::GUID,
    pub Stage: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE,
    pub ParameterCount: u32,
    pub pParameterInfos: *mut D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS")
            .field("CommandId", &self.CommandId)
            .field("Stage", &self.Stage)
            .field("ParameterCount", &self.ParameterCount)
            .field("pParameterInfos", &self.pParameterInfos)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.CommandId == other.CommandId
            && self.Stage == other.Stage
            && self.ParameterCount == other.ParameterCount
            && self.pParameterInfos == other.pParameterInfos
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    pub CommandId: ::windows::core::GUID,
    pub Stage: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_STAGE,
    pub ParameterCount: u32,
    pub ParameterPacking: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT")
            .field("CommandId", &self.CommandId)
            .field("Stage", &self.Stage)
            .field("ParameterCount", &self.ParameterCount)
            .field("ParameterPacking", &self.ParameterPacking)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    fn eq(&self, other: &Self) -> bool {
        self.CommandId == other.CommandId
            && self.Stage == other.Stage
            && self.ParameterCount == other.ParameterCount
            && self.ParameterPacking == other.ParameterPacking
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_PARAMETER_COUNT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    pub NodeIndex: u32,
    pub CommandId: ::windows::core::GUID,
    pub pCreationParameters: *const ::core::ffi::c_void,
    pub CreationParametersSizeInBytes: usize,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE")
            .field("NodeIndex", &self.NodeIndex)
            .field("CommandId", &self.CommandId)
            .field("pCreationParameters", &self.pCreationParameters)
            .field(
                "CreationParametersSizeInBytes",
                &self.CreationParametersSizeInBytes,
            )
            .field("MemoryPoolL0Size", &self.MemoryPoolL0Size)
            .field("MemoryPoolL1Size", &self.MemoryPoolL1Size)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.CommandId == other.CommandId
            && self.pCreationParameters == other.pCreationParameters
            && self.CreationParametersSizeInBytes == other.CreationParametersSizeInBytes
            && self.MemoryPoolL0Size == other.MemoryPoolL0Size
            && self.MemoryPoolL1Size == other.MemoryPoolL1Size
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    pub NodeIndex: u32,
    pub CommandId: ::windows::core::GUID,
    pub pInputData: *const ::core::ffi::c_void,
    pub InputDataSizeInBytes: usize,
    pub pOutputData: *mut ::core::ffi::c_void,
    pub OutputDataSizeInBytes: usize,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT")
            .field("NodeIndex", &self.NodeIndex)
            .field("CommandId", &self.CommandId)
            .field("pInputData", &self.pInputData)
            .field("InputDataSizeInBytes", &self.InputDataSizeInBytes)
            .field("pOutputData", &self.pOutputData)
            .field("OutputDataSizeInBytes", &self.OutputDataSizeInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.CommandId == other.CommandId
            && self.pInputData == other.pInputData
            && self.InputDataSizeInBytes == other.InputDataSizeInBytes
            && self.pOutputData == other.pOutputData
            && self.OutputDataSizeInBytes == other.OutputDataSizeInBytes
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_EXTENSION_COMMAND_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    pub NodeIndex: u32,
    pub VideoDecodeSupport: ::windows::Win32::Foundation::BOOL,
    pub VideoProcessSupport: ::windows::Win32::Foundation::BOOL,
    pub VideoEncodeSupport: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT")
            .field("NodeIndex", &self.NodeIndex)
            .field("VideoDecodeSupport", &self.VideoDecodeSupport)
            .field("VideoProcessSupport", &self.VideoProcessSupport)
            .field("VideoEncodeSupport", &self.VideoEncodeSupport)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.VideoDecodeSupport == other.VideoDecodeSupport
            && self.VideoProcessSupport == other.VideoProcessSupport
            && self.VideoEncodeSupport == other.VideoEncodeSupport
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_FEATURE_AREA_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    pub NodeIndex: u32,
    pub InputFormat: DXGI_FORMAT,
    pub BlockSizeFlags: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAGS,
    pub PrecisionFlags: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_FLAGS,
    pub SizeRange: D3D12_VIDEO_SIZE_RANGE,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR")
            .field("NodeIndex", &self.NodeIndex)
            .field("InputFormat", &self.InputFormat)
            .field("BlockSizeFlags", &self.BlockSizeFlags)
            .field("PrecisionFlags", &self.PrecisionFlags)
            .field("SizeRange", &self.SizeRange)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.InputFormat == other.InputFormat
            && self.BlockSizeFlags == other.BlockSizeFlags
            && self.PrecisionFlags == other.PrecisionFlags
            && self.SizeRange == other.SizeRange
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    pub NodeIndex: u32,
    pub SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES")
            .field("NodeIndex", &self.NodeIndex)
            .field("SupportFlags", &self.SupportFlags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.SupportFlags == other.SupportFlags
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_PROTECTED_RESOURCES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    pub NodeIndex: u32,
    pub InputFormat: DXGI_FORMAT,
    pub BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    pub Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    pub SizeRange: D3D12_VIDEO_SIZE_RANGE,
    pub Protected: ::windows::Win32::Foundation::BOOL,
    pub MotionVectorHeapMemoryPoolL0Size: u64,
    pub MotionVectorHeapMemoryPoolL1Size: u64,
    pub MotionEstimatorMemoryPoolL0Size: u64,
    pub MotionEstimatorMemoryPoolL1Size: u64,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE")
            .field("NodeIndex", &self.NodeIndex)
            .field("InputFormat", &self.InputFormat)
            .field("BlockSize", &self.BlockSize)
            .field("Precision", &self.Precision)
            .field("SizeRange", &self.SizeRange)
            .field("Protected", &self.Protected)
            .field(
                "MotionVectorHeapMemoryPoolL0Size",
                &self.MotionVectorHeapMemoryPoolL0Size,
            )
            .field(
                "MotionVectorHeapMemoryPoolL1Size",
                &self.MotionVectorHeapMemoryPoolL1Size,
            )
            .field(
                "MotionEstimatorMemoryPoolL0Size",
                &self.MotionEstimatorMemoryPoolL0Size,
            )
            .field(
                "MotionEstimatorMemoryPoolL1Size",
                &self.MotionEstimatorMemoryPoolL1Size,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.InputFormat == other.InputFormat
            && self.BlockSize == other.BlockSize
            && self.Precision == other.Precision
            && self.SizeRange == other.SizeRange
            && self.Protected == other.Protected
            && self.MotionVectorHeapMemoryPoolL0Size == other.MotionVectorHeapMemoryPoolL0Size
            && self.MotionVectorHeapMemoryPoolL1Size == other.MotionVectorHeapMemoryPoolL1Size
            && self.MotionEstimatorMemoryPoolL0Size == other.MotionEstimatorMemoryPoolL0Size
            && self.MotionEstimatorMemoryPoolL1Size == other.MotionEstimatorMemoryPoolL1Size
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    pub NodeMask: u32,
    pub pOutputStreamDesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
    pub NumInputStreamDescs: u32,
    pub pInputStreamDescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE")
            .field("NodeMask", &self.NodeMask)
            .field("pOutputStreamDesc", &self.pOutputStreamDesc)
            .field("NumInputStreamDescs", &self.NumInputStreamDescs)
            .field("pInputStreamDescs", &self.pInputStreamDescs)
            .field("MemoryPoolL0Size", &self.MemoryPoolL0Size)
            .field("MemoryPoolL1Size", &self.MemoryPoolL1Size)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask
            && self.pOutputStreamDesc == other.pOutputStreamDesc
            && self.NumInputStreamDescs == other.NumInputStreamDescs
            && self.pInputStreamDescs == other.pInputStreamDescs
            && self.MemoryPoolL0Size == other.MemoryPoolL0Size
            && self.MemoryPoolL1Size == other.MemoryPoolL1Size
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    pub NodeMask: u32,
    pub pOutputStreamDesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
    pub NumInputStreamDescs: u32,
    pub pInputStreamDescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
    pub Protected: ::windows::Win32::Foundation::BOOL,
    pub MemoryPoolL0Size: u64,
    pub MemoryPoolL1Size: u64,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1")
            .field("NodeMask", &self.NodeMask)
            .field("pOutputStreamDesc", &self.pOutputStreamDesc)
            .field("NumInputStreamDescs", &self.NumInputStreamDescs)
            .field("pInputStreamDescs", &self.pInputStreamDescs)
            .field("Protected", &self.Protected)
            .field("MemoryPoolL0Size", &self.MemoryPoolL0Size)
            .field("MemoryPoolL1Size", &self.MemoryPoolL1Size)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask
            && self.pOutputStreamDesc == other.pOutputStreamDesc
            && self.NumInputStreamDescs == other.NumInputStreamDescs
            && self.pInputStreamDescs == other.pInputStreamDescs
            && self.Protected == other.Protected
            && self.MemoryPoolL0Size == other.MemoryPoolL0Size
            && self.MemoryPoolL1Size == other.MemoryPoolL1Size
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESSOR_SIZE1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    pub NodeIndex: u32,
    pub MaxInputStreams: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS")
            .field("NodeIndex", &self.NodeIndex)
            .field("MaxInputStreams", &self.MaxInputStreams)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.MaxInputStreams == other.MaxInputStreams
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESS_MAX_INPUT_STREAMS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    pub NodeIndex: u32,
    pub SupportFlags: D3D12_VIDEO_PROTECTED_RESOURCE_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES")
            .field("NodeIndex", &self.NodeIndex)
            .field("SupportFlags", &self.SupportFlags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex && self.SupportFlags == other.SupportFlags
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESS_PROTECTED_RESOURCES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    pub NodeIndex: u32,
    pub DeinterlaceMode: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    pub Filters: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    pub FeatureSupport: D3D12_VIDEO_PROCESS_FEATURE_FLAGS,
    pub InputFrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub OutputFrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub EnableAutoProcessing: ::windows::Win32::Foundation::BOOL,
    pub PastFrames: u32,
    pub FutureFrames: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO")
            .field("NodeIndex", &self.NodeIndex)
            .field("DeinterlaceMode", &self.DeinterlaceMode)
            .field("Filters", &self.Filters)
            .field("FeatureSupport", &self.FeatureSupport)
            .field("InputFrameRate", &self.InputFrameRate)
            .field("OutputFrameRate", &self.OutputFrameRate)
            .field("EnableAutoProcessing", &self.EnableAutoProcessing)
            .field("PastFrames", &self.PastFrames)
            .field("FutureFrames", &self.FutureFrames)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.DeinterlaceMode == other.DeinterlaceMode
            && self.Filters == other.Filters
            && self.FeatureSupport == other.FeatureSupport
            && self.InputFrameRate == other.InputFrameRate
            && self.OutputFrameRate == other.OutputFrameRate
            && self.EnableAutoProcessing == other.EnableAutoProcessing
            && self.PastFrames == other.PastFrames
            && self.FutureFrames == other.FutureFrames
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESS_REFERENCE_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    pub NodeIndex: u32,
    pub InputSample: D3D12_VIDEO_SAMPLE,
    pub InputFieldType: D3D12_VIDEO_FIELD_TYPE,
    pub InputStereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    pub InputFrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub OutputFormat: D3D12_VIDEO_FORMAT,
    pub OutputStereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    pub OutputFrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub SupportFlags: D3D12_VIDEO_PROCESS_SUPPORT_FLAGS,
    pub ScaleSupport: D3D12_VIDEO_SCALE_SUPPORT,
    pub FeatureSupport: D3D12_VIDEO_PROCESS_FEATURE_FLAGS,
    pub DeinterlaceSupport: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    pub AutoProcessingSupport: D3D12_VIDEO_PROCESS_AUTO_PROCESSING_FLAGS,
    pub FilterSupport: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    pub FilterRangeSupport: [D3D12_VIDEO_PROCESS_FILTER_RANGE; 32],
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT")
            .field("NodeIndex", &self.NodeIndex)
            .field("InputSample", &self.InputSample)
            .field("InputFieldType", &self.InputFieldType)
            .field("InputStereoFormat", &self.InputStereoFormat)
            .field("InputFrameRate", &self.InputFrameRate)
            .field("OutputFormat", &self.OutputFormat)
            .field("OutputStereoFormat", &self.OutputStereoFormat)
            .field("OutputFrameRate", &self.OutputFrameRate)
            .field("SupportFlags", &self.SupportFlags)
            .field("ScaleSupport", &self.ScaleSupport)
            .field("FeatureSupport", &self.FeatureSupport)
            .field("DeinterlaceSupport", &self.DeinterlaceSupport)
            .field("AutoProcessingSupport", &self.AutoProcessingSupport)
            .field("FilterSupport", &self.FilterSupport)
            .field("FilterRangeSupport", &self.FilterRangeSupport)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.NodeIndex == other.NodeIndex
            && self.InputSample == other.InputSample
            && self.InputFieldType == other.InputFieldType
            && self.InputStereoFormat == other.InputStereoFormat
            && self.InputFrameRate == other.InputFrameRate
            && self.OutputFormat == other.OutputFormat
            && self.OutputStereoFormat == other.OutputStereoFormat
            && self.OutputFrameRate == other.OutputFrameRate
            && self.SupportFlags == other.SupportFlags
            && self.ScaleSupport == other.ScaleSupport
            && self.FeatureSupport == other.FeatureSupport
            && self.DeinterlaceSupport == other.DeinterlaceSupport
            && self.AutoProcessingSupport == other.AutoProcessingSupport
            && self.FilterSupport == other.FilterSupport
            && self.FilterRangeSupport == other.FilterRangeSupport
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {}
impl ::core::default::Default for D3D12_FEATURE_DATA_VIDEO_PROCESS_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FEATURE_DATA_WAVE_MMA {
    pub InputDataType: D3D12_WAVE_MMA_INPUT_DATATYPE,
    pub M: D3D12_WAVE_MMA_DIMENSION,
    pub N: D3D12_WAVE_MMA_DIMENSION,
    pub Supported: ::windows::Win32::Foundation::BOOL,
    pub K: u32,
    pub AccumDataTypes: D3D12_WAVE_MMA_ACCUM_DATATYPE,
    pub RequiredWaveLaneCountMin: u32,
    pub RequiredWaveLaneCountMax: u32,
}
impl ::core::marker::Copy for D3D12_FEATURE_DATA_WAVE_MMA {}
impl ::core::clone::Clone for D3D12_FEATURE_DATA_WAVE_MMA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FEATURE_DATA_WAVE_MMA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FEATURE_DATA_WAVE_MMA")
            .field("InputDataType", &self.InputDataType)
            .field("M", &self.M)
            .field("N", &self.N)
            .field("Supported", &self.Supported)
            .field("K", &self.K)
            .field("AccumDataTypes", &self.AccumDataTypes)
            .field("RequiredWaveLaneCountMin", &self.RequiredWaveLaneCountMin)
            .field("RequiredWaveLaneCountMax", &self.RequiredWaveLaneCountMax)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FEATURE_DATA_WAVE_MMA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FEATURE_DATA_WAVE_MMA {
    fn eq(&self, other: &Self) -> bool {
        self.InputDataType == other.InputDataType
            && self.M == other.M
            && self.N == other.N
            && self.Supported == other.Supported
            && self.K == other.K
            && self.AccumDataTypes == other.AccumDataTypes
            && self.RequiredWaveLaneCountMin == other.RequiredWaveLaneCountMin
            && self.RequiredWaveLaneCountMax == other.RequiredWaveLaneCountMax
    }
}
impl ::core::cmp::Eq for D3D12_FEATURE_DATA_WAVE_MMA {}
impl ::core::default::Default for D3D12_FEATURE_DATA_WAVE_MMA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_FUNCTION_DESC {
    pub Version: u32,
    pub Creator: ::windows::core::PCSTR,
    pub Flags: u32,
    pub ConstantBuffers: u32,
    pub BoundResources: u32,
    pub InstructionCount: u32,
    pub TempRegisterCount: u32,
    pub TempArrayCount: u32,
    pub DefCount: u32,
    pub DclCount: u32,
    pub TextureNormalInstructions: u32,
    pub TextureLoadInstructions: u32,
    pub TextureCompInstructions: u32,
    pub TextureBiasInstructions: u32,
    pub TextureGradientInstructions: u32,
    pub FloatInstructionCount: u32,
    pub IntInstructionCount: u32,
    pub UintInstructionCount: u32,
    pub StaticFlowControlCount: u32,
    pub DynamicFlowControlCount: u32,
    pub MacroInstructionCount: u32,
    pub ArrayInstructionCount: u32,
    pub MovInstructionCount: u32,
    pub MovcInstructionCount: u32,
    pub ConversionInstructionCount: u32,
    pub BitwiseInstructionCount: u32,
    pub MinFeatureLevel: D3D_FEATURE_LEVEL,
    pub RequiredFeatureFlags: u64,
    pub Name: ::windows::core::PCSTR,
    pub FunctionParameterCount: i32,
    pub HasReturn: ::windows::Win32::Foundation::BOOL,
    pub Has10Level9VertexShader: ::windows::Win32::Foundation::BOOL,
    pub Has10Level9PixelShader: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_FUNCTION_DESC {}
impl ::core::clone::Clone for D3D12_FUNCTION_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_FUNCTION_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_FUNCTION_DESC")
            .field("Version", &self.Version)
            .field("Creator", &self.Creator)
            .field("Flags", &self.Flags)
            .field("ConstantBuffers", &self.ConstantBuffers)
            .field("BoundResources", &self.BoundResources)
            .field("InstructionCount", &self.InstructionCount)
            .field("TempRegisterCount", &self.TempRegisterCount)
            .field("TempArrayCount", &self.TempArrayCount)
            .field("DefCount", &self.DefCount)
            .field("DclCount", &self.DclCount)
            .field("TextureNormalInstructions", &self.TextureNormalInstructions)
            .field("TextureLoadInstructions", &self.TextureLoadInstructions)
            .field("TextureCompInstructions", &self.TextureCompInstructions)
            .field("TextureBiasInstructions", &self.TextureBiasInstructions)
            .field(
                "TextureGradientInstructions",
                &self.TextureGradientInstructions,
            )
            .field("FloatInstructionCount", &self.FloatInstructionCount)
            .field("IntInstructionCount", &self.IntInstructionCount)
            .field("UintInstructionCount", &self.UintInstructionCount)
            .field("StaticFlowControlCount", &self.StaticFlowControlCount)
            .field("DynamicFlowControlCount", &self.DynamicFlowControlCount)
            .field("MacroInstructionCount", &self.MacroInstructionCount)
            .field("ArrayInstructionCount", &self.ArrayInstructionCount)
            .field("MovInstructionCount", &self.MovInstructionCount)
            .field("MovcInstructionCount", &self.MovcInstructionCount)
            .field(
                "ConversionInstructionCount",
                &self.ConversionInstructionCount,
            )
            .field("BitwiseInstructionCount", &self.BitwiseInstructionCount)
            .field("MinFeatureLevel", &self.MinFeatureLevel)
            .field("RequiredFeatureFlags", &self.RequiredFeatureFlags)
            .field("Name", &self.Name)
            .field("FunctionParameterCount", &self.FunctionParameterCount)
            .field("HasReturn", &self.HasReturn)
            .field("Has10Level9VertexShader", &self.Has10Level9VertexShader)
            .field("Has10Level9PixelShader", &self.Has10Level9PixelShader)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_FUNCTION_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_FUNCTION_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Creator == other.Creator
            && self.Flags == other.Flags
            && self.ConstantBuffers == other.ConstantBuffers
            && self.BoundResources == other.BoundResources
            && self.InstructionCount == other.InstructionCount
            && self.TempRegisterCount == other.TempRegisterCount
            && self.TempArrayCount == other.TempArrayCount
            && self.DefCount == other.DefCount
            && self.DclCount == other.DclCount
            && self.TextureNormalInstructions == other.TextureNormalInstructions
            && self.TextureLoadInstructions == other.TextureLoadInstructions
            && self.TextureCompInstructions == other.TextureCompInstructions
            && self.TextureBiasInstructions == other.TextureBiasInstructions
            && self.TextureGradientInstructions == other.TextureGradientInstructions
            && self.FloatInstructionCount == other.FloatInstructionCount
            && self.IntInstructionCount == other.IntInstructionCount
            && self.UintInstructionCount == other.UintInstructionCount
            && self.StaticFlowControlCount == other.StaticFlowControlCount
            && self.DynamicFlowControlCount == other.DynamicFlowControlCount
            && self.MacroInstructionCount == other.MacroInstructionCount
            && self.ArrayInstructionCount == other.ArrayInstructionCount
            && self.MovInstructionCount == other.MovInstructionCount
            && self.MovcInstructionCount == other.MovcInstructionCount
            && self.ConversionInstructionCount == other.ConversionInstructionCount
            && self.BitwiseInstructionCount == other.BitwiseInstructionCount
            && self.MinFeatureLevel == other.MinFeatureLevel
            && self.RequiredFeatureFlags == other.RequiredFeatureFlags
            && self.Name == other.Name
            && self.FunctionParameterCount == other.FunctionParameterCount
            && self.HasReturn == other.HasReturn
            && self.Has10Level9VertexShader == other.Has10Level9VertexShader
            && self.Has10Level9PixelShader == other.Has10Level9PixelShader
    }
}
impl ::core::cmp::Eq for D3D12_FUNCTION_DESC {}
impl ::core::default::Default for D3D12_FUNCTION_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_GENERIC_PROGRAM_DESC {
    pub ProgramName: ::windows::core::PCWSTR,
    pub NumExports: u32,
    pub pExports: *const ::windows::core::PCWSTR,
    pub NumSubobjects: u32,
    pub ppSubobjects: *const *const D3D12_STATE_SUBOBJECT,
}
impl ::core::marker::Copy for D3D12_GENERIC_PROGRAM_DESC {}
impl ::core::clone::Clone for D3D12_GENERIC_PROGRAM_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_GENERIC_PROGRAM_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_GENERIC_PROGRAM_DESC")
            .field("ProgramName", &self.ProgramName)
            .field("NumExports", &self.NumExports)
            .field("pExports", &self.pExports)
            .field("NumSubobjects", &self.NumSubobjects)
            .field("ppSubobjects", &self.ppSubobjects)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_GENERIC_PROGRAM_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_GENERIC_PROGRAM_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.ProgramName == other.ProgramName
            && self.NumExports == other.NumExports
            && self.pExports == other.pExports
            && self.NumSubobjects == other.NumSubobjects
            && self.ppSubobjects == other.ppSubobjects
    }
}
impl ::core::cmp::Eq for D3D12_GENERIC_PROGRAM_DESC {}
impl ::core::default::Default for D3D12_GENERIC_PROGRAM_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_GLOBAL_BARRIER {
    pub SyncBefore: D3D12_BARRIER_SYNC,
    pub SyncAfter: D3D12_BARRIER_SYNC,
    pub AccessBefore: D3D12_BARRIER_ACCESS,
    pub AccessAfter: D3D12_BARRIER_ACCESS,
}
impl ::core::marker::Copy for D3D12_GLOBAL_BARRIER {}
impl ::core::clone::Clone for D3D12_GLOBAL_BARRIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_GLOBAL_BARRIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_GLOBAL_BARRIER")
            .field("SyncBefore", &self.SyncBefore)
            .field("SyncAfter", &self.SyncAfter)
            .field("AccessBefore", &self.AccessBefore)
            .field("AccessAfter", &self.AccessAfter)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_GLOBAL_BARRIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_GLOBAL_BARRIER {
    fn eq(&self, other: &Self) -> bool {
        self.SyncBefore == other.SyncBefore
            && self.SyncAfter == other.SyncAfter
            && self.AccessBefore == other.AccessBefore
            && self.AccessAfter == other.AccessAfter
    }
}
impl ::core::cmp::Eq for D3D12_GLOBAL_BARRIER {}
impl ::core::default::Default for D3D12_GLOBAL_BARRIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_GLOBAL_ROOT_SIGNATURE {
    pub pGlobalRootSignature: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12RootSignature>>,
}
impl ::core::clone::Clone for D3D12_GLOBAL_ROOT_SIGNATURE {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_GLOBAL_ROOT_SIGNATURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_GLOBAL_ROOT_SIGNATURE")
            .field("pGlobalRootSignature", &self.pGlobalRootSignature)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_GLOBAL_ROOT_SIGNATURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_GLOBAL_ROOT_SIGNATURE {
    fn eq(&self, other: &Self) -> bool {
        self.pGlobalRootSignature == other.pGlobalRootSignature
    }
}
impl ::core::cmp::Eq for D3D12_GLOBAL_ROOT_SIGNATURE {}
impl ::core::default::Default for D3D12_GLOBAL_ROOT_SIGNATURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_GPU_DESCRIPTOR_HANDLE {
    pub ptr: u64,
}
impl ::core::marker::Copy for D3D12_GPU_DESCRIPTOR_HANDLE {}
impl ::core::clone::Clone for D3D12_GPU_DESCRIPTOR_HANDLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_GPU_DESCRIPTOR_HANDLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_GPU_DESCRIPTOR_HANDLE")
            .field("ptr", &self.ptr)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_GPU_DESCRIPTOR_HANDLE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_GPU_DESCRIPTOR_HANDLE {
    fn eq(&self, other: &Self) -> bool {
        self.ptr == other.ptr
    }
}
impl ::core::cmp::Eq for D3D12_GPU_DESCRIPTOR_HANDLE {}
impl ::core::default::Default for D3D12_GPU_DESCRIPTOR_HANDLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE {
    pub StartAddress: u64,
    pub StrideInBytes: u64,
}
impl ::core::marker::Copy for D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE {}
impl ::core::clone::Clone for D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE")
            .field("StartAddress", &self.StartAddress)
            .field("StrideInBytes", &self.StrideInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE {
    fn eq(&self, other: &Self) -> bool {
        self.StartAddress == other.StartAddress && self.StrideInBytes == other.StrideInBytes
    }
}
impl ::core::cmp::Eq for D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE {}
impl ::core::default::Default for D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_GPU_VIRTUAL_ADDRESS_RANGE {
    pub StartAddress: u64,
    pub SizeInBytes: u64,
}
impl ::core::marker::Copy for D3D12_GPU_VIRTUAL_ADDRESS_RANGE {}
impl ::core::clone::Clone for D3D12_GPU_VIRTUAL_ADDRESS_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_GPU_VIRTUAL_ADDRESS_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_GPU_VIRTUAL_ADDRESS_RANGE")
            .field("StartAddress", &self.StartAddress)
            .field("SizeInBytes", &self.SizeInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_GPU_VIRTUAL_ADDRESS_RANGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_GPU_VIRTUAL_ADDRESS_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.StartAddress == other.StartAddress && self.SizeInBytes == other.SizeInBytes
    }
}
impl ::core::cmp::Eq for D3D12_GPU_VIRTUAL_ADDRESS_RANGE {}
impl ::core::default::Default for D3D12_GPU_VIRTUAL_ADDRESS_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {
    pub StartAddress: u64,
    pub SizeInBytes: u64,
    pub StrideInBytes: u64,
}
impl ::core::marker::Copy for D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {}
impl ::core::clone::Clone for D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE")
            .field("StartAddress", &self.StartAddress)
            .field("SizeInBytes", &self.SizeInBytes)
            .field("StrideInBytes", &self.StrideInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {
    fn eq(&self, other: &Self) -> bool {
        self.StartAddress == other.StartAddress
            && self.SizeInBytes == other.SizeInBytes
            && self.StrideInBytes == other.StrideInBytes
    }
}
impl ::core::cmp::Eq for D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {}
impl ::core::default::Default for D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_GRAPHICS_PIPELINE_STATE_DESC {
    pub pRootSignature: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12RootSignature>>,
    pub VS: D3D12_SHADER_BYTECODE,
    pub PS: D3D12_SHADER_BYTECODE,
    pub DS: D3D12_SHADER_BYTECODE,
    pub HS: D3D12_SHADER_BYTECODE,
    pub GS: D3D12_SHADER_BYTECODE,
    pub StreamOutput: D3D12_STREAM_OUTPUT_DESC,
    pub BlendState: D3D12_BLEND_DESC,
    pub SampleMask: u32,
    pub RasterizerState: D3D12_RASTERIZER_DESC,
    pub DepthStencilState: D3D12_DEPTH_STENCIL_DESC,
    pub InputLayout: D3D12_INPUT_LAYOUT_DESC,
    pub IBStripCutValue: D3D12_INDEX_BUFFER_STRIP_CUT_VALUE,
    pub PrimitiveTopologyType: D3D12_PRIMITIVE_TOPOLOGY_TYPE,
    pub NumRenderTargets: u32,
    pub RTVFormats: [DXGI_FORMAT; 8],
    pub DSVFormat: DXGI_FORMAT,
    pub SampleDesc: ::windows::Win32::Graphics::Dxgi::Common::DXGI_SAMPLE_DESC,
    pub NodeMask: u32,
    pub CachedPSO: D3D12_CACHED_PIPELINE_STATE,
    pub Flags: D3D12_PIPELINE_STATE_FLAGS,
}
impl ::core::clone::Clone for D3D12_GRAPHICS_PIPELINE_STATE_DESC {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_GRAPHICS_PIPELINE_STATE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_GRAPHICS_PIPELINE_STATE_DESC")
            .field("pRootSignature", &self.pRootSignature)
            .field("VS", &self.VS)
            .field("PS", &self.PS)
            .field("DS", &self.DS)
            .field("HS", &self.HS)
            .field("GS", &self.GS)
            .field("StreamOutput", &self.StreamOutput)
            .field("BlendState", &self.BlendState)
            .field("SampleMask", &self.SampleMask)
            .field("RasterizerState", &self.RasterizerState)
            .field("DepthStencilState", &self.DepthStencilState)
            .field("InputLayout", &self.InputLayout)
            .field("IBStripCutValue", &self.IBStripCutValue)
            .field("PrimitiveTopologyType", &self.PrimitiveTopologyType)
            .field("NumRenderTargets", &self.NumRenderTargets)
            .field("RTVFormats", &self.RTVFormats)
            .field("DSVFormat", &self.DSVFormat)
            .field("SampleDesc", &self.SampleDesc)
            .field("NodeMask", &self.NodeMask)
            .field("CachedPSO", &self.CachedPSO)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_GRAPHICS_PIPELINE_STATE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_GRAPHICS_PIPELINE_STATE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.pRootSignature == other.pRootSignature
            && self.VS == other.VS
            && self.PS == other.PS
            && self.DS == other.DS
            && self.HS == other.HS
            && self.GS == other.GS
            && self.StreamOutput == other.StreamOutput
            && self.BlendState == other.BlendState
            && self.SampleMask == other.SampleMask
            && self.RasterizerState == other.RasterizerState
            && self.DepthStencilState == other.DepthStencilState
            && self.InputLayout == other.InputLayout
            && self.IBStripCutValue == other.IBStripCutValue
            && self.PrimitiveTopologyType == other.PrimitiveTopologyType
            && self.NumRenderTargets == other.NumRenderTargets
            && self.RTVFormats == other.RTVFormats
            && self.DSVFormat == other.DSVFormat
            && self.SampleDesc == other.SampleDesc
            && self.NodeMask == other.NodeMask
            && self.CachedPSO == other.CachedPSO
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_GRAPHICS_PIPELINE_STATE_DESC {}
impl ::core::default::Default for D3D12_GRAPHICS_PIPELINE_STATE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_HEAP_DESC {
    pub SizeInBytes: u64,
    pub Properties: D3D12_HEAP_PROPERTIES,
    pub Alignment: u64,
    pub Flags: D3D12_HEAP_FLAGS,
}
impl ::core::marker::Copy for D3D12_HEAP_DESC {}
impl ::core::clone::Clone for D3D12_HEAP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_HEAP_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_HEAP_DESC")
            .field("SizeInBytes", &self.SizeInBytes)
            .field("Properties", &self.Properties)
            .field("Alignment", &self.Alignment)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_HEAP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_HEAP_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.SizeInBytes == other.SizeInBytes
            && self.Properties == other.Properties
            && self.Alignment == other.Alignment
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_HEAP_DESC {}
impl ::core::default::Default for D3D12_HEAP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_HEAP_PROPERTIES {
    pub Type: D3D12_HEAP_TYPE,
    pub CPUPageProperty: D3D12_CPU_PAGE_PROPERTY,
    pub MemoryPoolPreference: D3D12_MEMORY_POOL,
    pub CreationNodeMask: u32,
    pub VisibleNodeMask: u32,
}
impl ::core::marker::Copy for D3D12_HEAP_PROPERTIES {}
impl ::core::clone::Clone for D3D12_HEAP_PROPERTIES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_HEAP_PROPERTIES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_HEAP_PROPERTIES")
            .field("Type", &self.Type)
            .field("CPUPageProperty", &self.CPUPageProperty)
            .field("MemoryPoolPreference", &self.MemoryPoolPreference)
            .field("CreationNodeMask", &self.CreationNodeMask)
            .field("VisibleNodeMask", &self.VisibleNodeMask)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_HEAP_PROPERTIES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_HEAP_PROPERTIES {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type
            && self.CPUPageProperty == other.CPUPageProperty
            && self.MemoryPoolPreference == other.MemoryPoolPreference
            && self.CreationNodeMask == other.CreationNodeMask
            && self.VisibleNodeMask == other.VisibleNodeMask
    }
}
impl ::core::cmp::Eq for D3D12_HEAP_PROPERTIES {}
impl ::core::default::Default for D3D12_HEAP_PROPERTIES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_HIT_GROUP_DESC {
    pub HitGroupExport: ::windows::core::PCWSTR,
    pub Type: D3D12_HIT_GROUP_TYPE,
    pub AnyHitShaderImport: ::windows::core::PCWSTR,
    pub ClosestHitShaderImport: ::windows::core::PCWSTR,
    pub IntersectionShaderImport: ::windows::core::PCWSTR,
}
impl ::core::marker::Copy for D3D12_HIT_GROUP_DESC {}
impl ::core::clone::Clone for D3D12_HIT_GROUP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_HIT_GROUP_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_HIT_GROUP_DESC")
            .field("HitGroupExport", &self.HitGroupExport)
            .field("Type", &self.Type)
            .field("AnyHitShaderImport", &self.AnyHitShaderImport)
            .field("ClosestHitShaderImport", &self.ClosestHitShaderImport)
            .field("IntersectionShaderImport", &self.IntersectionShaderImport)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_HIT_GROUP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_HIT_GROUP_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.HitGroupExport == other.HitGroupExport
            && self.Type == other.Type
            && self.AnyHitShaderImport == other.AnyHitShaderImport
            && self.ClosestHitShaderImport == other.ClosestHitShaderImport
            && self.IntersectionShaderImport == other.IntersectionShaderImport
    }
}
impl ::core::cmp::Eq for D3D12_HIT_GROUP_DESC {}
impl ::core::default::Default for D3D12_HIT_GROUP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_IB_STRIP_CUT_VALUE {
    pub IndexBufferStripCutValue: D3D12_INDEX_BUFFER_STRIP_CUT_VALUE,
}
impl ::core::marker::Copy for D3D12_IB_STRIP_CUT_VALUE {}
impl ::core::clone::Clone for D3D12_IB_STRIP_CUT_VALUE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_IB_STRIP_CUT_VALUE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_IB_STRIP_CUT_VALUE")
            .field("IndexBufferStripCutValue", &self.IndexBufferStripCutValue)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_IB_STRIP_CUT_VALUE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_IB_STRIP_CUT_VALUE {
    fn eq(&self, other: &Self) -> bool {
        self.IndexBufferStripCutValue == other.IndexBufferStripCutValue
    }
}
impl ::core::cmp::Eq for D3D12_IB_STRIP_CUT_VALUE {}
impl ::core::default::Default for D3D12_IB_STRIP_CUT_VALUE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INDEX_BUFFER_VIEW {
    pub BufferLocation: u64,
    pub SizeInBytes: u32,
    pub Format: DXGI_FORMAT,
}
impl ::core::marker::Copy for D3D12_INDEX_BUFFER_VIEW {}
impl ::core::clone::Clone for D3D12_INDEX_BUFFER_VIEW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_INDEX_BUFFER_VIEW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_INDEX_BUFFER_VIEW")
            .field("BufferLocation", &self.BufferLocation)
            .field("SizeInBytes", &self.SizeInBytes)
            .field("Format", &self.Format)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_INDEX_BUFFER_VIEW {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_INDEX_BUFFER_VIEW {
    fn eq(&self, other: &Self) -> bool {
        self.BufferLocation == other.BufferLocation
            && self.SizeInBytes == other.SizeInBytes
            && self.Format == other.Format
    }
}
impl ::core::cmp::Eq for D3D12_INDEX_BUFFER_VIEW {}
impl ::core::default::Default for D3D12_INDEX_BUFFER_VIEW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INDIRECT_ARGUMENT_DESC {
    pub Type: D3D12_INDIRECT_ARGUMENT_TYPE,
    pub Anonymous: D3D12_INDIRECT_ARGUMENT_DESC_0,
}
impl ::core::marker::Copy for D3D12_INDIRECT_ARGUMENT_DESC {}
impl ::core::clone::Clone for D3D12_INDIRECT_ARGUMENT_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_INDIRECT_ARGUMENT_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_INDIRECT_ARGUMENT_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_INDIRECT_ARGUMENT_DESC_0 {
    pub VertexBuffer: D3D12_INDIRECT_ARGUMENT_DESC_0_4,
    pub Constant: D3D12_INDIRECT_ARGUMENT_DESC_0_1,
    pub ConstantBufferView: D3D12_INDIRECT_ARGUMENT_DESC_0_0,
    pub ShaderResourceView: D3D12_INDIRECT_ARGUMENT_DESC_0_2,
    pub UnorderedAccessView: D3D12_INDIRECT_ARGUMENT_DESC_0_3,
}
impl ::core::marker::Copy for D3D12_INDIRECT_ARGUMENT_DESC_0 {}
impl ::core::clone::Clone for D3D12_INDIRECT_ARGUMENT_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_INDIRECT_ARGUMENT_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_INDIRECT_ARGUMENT_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INDIRECT_ARGUMENT_DESC_0_0 {
    pub RootParameterIndex: u32,
}
impl ::core::marker::Copy for D3D12_INDIRECT_ARGUMENT_DESC_0_0 {}
impl ::core::clone::Clone for D3D12_INDIRECT_ARGUMENT_DESC_0_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_INDIRECT_ARGUMENT_DESC_0_0 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_INDIRECT_ARGUMENT_DESC_0_0")
            .field("RootParameterIndex", &self.RootParameterIndex)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_INDIRECT_ARGUMENT_DESC_0_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_INDIRECT_ARGUMENT_DESC_0_0 {
    fn eq(&self, other: &Self) -> bool {
        self.RootParameterIndex == other.RootParameterIndex
    }
}
impl ::core::cmp::Eq for D3D12_INDIRECT_ARGUMENT_DESC_0_0 {}
impl ::core::default::Default for D3D12_INDIRECT_ARGUMENT_DESC_0_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INDIRECT_ARGUMENT_DESC_0_1 {
    pub RootParameterIndex: u32,
    pub DestOffsetIn32BitValues: u32,
    pub Num32BitValuesToSet: u32,
}
impl ::core::marker::Copy for D3D12_INDIRECT_ARGUMENT_DESC_0_1 {}
impl ::core::clone::Clone for D3D12_INDIRECT_ARGUMENT_DESC_0_1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_INDIRECT_ARGUMENT_DESC_0_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_INDIRECT_ARGUMENT_DESC_0_1")
            .field("RootParameterIndex", &self.RootParameterIndex)
            .field("DestOffsetIn32BitValues", &self.DestOffsetIn32BitValues)
            .field("Num32BitValuesToSet", &self.Num32BitValuesToSet)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_INDIRECT_ARGUMENT_DESC_0_1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_INDIRECT_ARGUMENT_DESC_0_1 {
    fn eq(&self, other: &Self) -> bool {
        self.RootParameterIndex == other.RootParameterIndex
            && self.DestOffsetIn32BitValues == other.DestOffsetIn32BitValues
            && self.Num32BitValuesToSet == other.Num32BitValuesToSet
    }
}
impl ::core::cmp::Eq for D3D12_INDIRECT_ARGUMENT_DESC_0_1 {}
impl ::core::default::Default for D3D12_INDIRECT_ARGUMENT_DESC_0_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INDIRECT_ARGUMENT_DESC_0_2 {
    pub RootParameterIndex: u32,
}
impl ::core::marker::Copy for D3D12_INDIRECT_ARGUMENT_DESC_0_2 {}
impl ::core::clone::Clone for D3D12_INDIRECT_ARGUMENT_DESC_0_2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_INDIRECT_ARGUMENT_DESC_0_2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_INDIRECT_ARGUMENT_DESC_0_2")
            .field("RootParameterIndex", &self.RootParameterIndex)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_INDIRECT_ARGUMENT_DESC_0_2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_INDIRECT_ARGUMENT_DESC_0_2 {
    fn eq(&self, other: &Self) -> bool {
        self.RootParameterIndex == other.RootParameterIndex
    }
}
impl ::core::cmp::Eq for D3D12_INDIRECT_ARGUMENT_DESC_0_2 {}
impl ::core::default::Default for D3D12_INDIRECT_ARGUMENT_DESC_0_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INDIRECT_ARGUMENT_DESC_0_3 {
    pub RootParameterIndex: u32,
}
impl ::core::marker::Copy for D3D12_INDIRECT_ARGUMENT_DESC_0_3 {}
impl ::core::clone::Clone for D3D12_INDIRECT_ARGUMENT_DESC_0_3 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_INDIRECT_ARGUMENT_DESC_0_3 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_INDIRECT_ARGUMENT_DESC_0_3")
            .field("RootParameterIndex", &self.RootParameterIndex)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_INDIRECT_ARGUMENT_DESC_0_3 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_INDIRECT_ARGUMENT_DESC_0_3 {
    fn eq(&self, other: &Self) -> bool {
        self.RootParameterIndex == other.RootParameterIndex
    }
}
impl ::core::cmp::Eq for D3D12_INDIRECT_ARGUMENT_DESC_0_3 {}
impl ::core::default::Default for D3D12_INDIRECT_ARGUMENT_DESC_0_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INDIRECT_ARGUMENT_DESC_0_4 {
    pub Slot: u32,
}
impl ::core::marker::Copy for D3D12_INDIRECT_ARGUMENT_DESC_0_4 {}
impl ::core::clone::Clone for D3D12_INDIRECT_ARGUMENT_DESC_0_4 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_INDIRECT_ARGUMENT_DESC_0_4 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_INDIRECT_ARGUMENT_DESC_0_4")
            .field("Slot", &self.Slot)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_INDIRECT_ARGUMENT_DESC_0_4 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_INDIRECT_ARGUMENT_DESC_0_4 {
    fn eq(&self, other: &Self) -> bool {
        self.Slot == other.Slot
    }
}
impl ::core::cmp::Eq for D3D12_INDIRECT_ARGUMENT_DESC_0_4 {}
impl ::core::default::Default for D3D12_INDIRECT_ARGUMENT_DESC_0_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INFO_QUEUE_FILTER {
    pub AllowList: D3D12_INFO_QUEUE_FILTER_DESC,
    pub DenyList: D3D12_INFO_QUEUE_FILTER_DESC,
}
impl ::core::marker::Copy for D3D12_INFO_QUEUE_FILTER {}
impl ::core::clone::Clone for D3D12_INFO_QUEUE_FILTER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_INFO_QUEUE_FILTER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_INFO_QUEUE_FILTER")
            .field("AllowList", &self.AllowList)
            .field("DenyList", &self.DenyList)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_INFO_QUEUE_FILTER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_INFO_QUEUE_FILTER {
    fn eq(&self, other: &Self) -> bool {
        self.AllowList == other.AllowList && self.DenyList == other.DenyList
    }
}
impl ::core::cmp::Eq for D3D12_INFO_QUEUE_FILTER {}
impl ::core::default::Default for D3D12_INFO_QUEUE_FILTER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INFO_QUEUE_FILTER_DESC {
    pub NumCategories: u32,
    pub pCategoryList: *mut D3D12_MESSAGE_CATEGORY,
    pub NumSeverities: u32,
    pub pSeverityList: *mut D3D12_MESSAGE_SEVERITY,
    pub NumIDs: u32,
    pub pIDList: *mut D3D12_MESSAGE_ID,
}
impl ::core::marker::Copy for D3D12_INFO_QUEUE_FILTER_DESC {}
impl ::core::clone::Clone for D3D12_INFO_QUEUE_FILTER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_INFO_QUEUE_FILTER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_INFO_QUEUE_FILTER_DESC")
            .field("NumCategories", &self.NumCategories)
            .field("pCategoryList", &self.pCategoryList)
            .field("NumSeverities", &self.NumSeverities)
            .field("pSeverityList", &self.pSeverityList)
            .field("NumIDs", &self.NumIDs)
            .field("pIDList", &self.pIDList)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_INFO_QUEUE_FILTER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_INFO_QUEUE_FILTER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NumCategories == other.NumCategories
            && self.pCategoryList == other.pCategoryList
            && self.NumSeverities == other.NumSeverities
            && self.pSeverityList == other.pSeverityList
            && self.NumIDs == other.NumIDs
            && self.pIDList == other.pIDList
    }
}
impl ::core::cmp::Eq for D3D12_INFO_QUEUE_FILTER_DESC {}
impl ::core::default::Default for D3D12_INFO_QUEUE_FILTER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INPUT_ELEMENT_DESC {
    pub SemanticName: ::windows::core::PCSTR,
    pub SemanticIndex: u32,
    pub Format: DXGI_FORMAT,
    pub InputSlot: u32,
    pub AlignedByteOffset: u32,
    pub InputSlotClass: D3D12_INPUT_CLASSIFICATION,
    pub InstanceDataStepRate: u32,
}
impl ::core::marker::Copy for D3D12_INPUT_ELEMENT_DESC {}
impl ::core::clone::Clone for D3D12_INPUT_ELEMENT_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_INPUT_ELEMENT_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_INPUT_ELEMENT_DESC")
            .field("SemanticName", &self.SemanticName)
            .field("SemanticIndex", &self.SemanticIndex)
            .field("Format", &self.Format)
            .field("InputSlot", &self.InputSlot)
            .field("AlignedByteOffset", &self.AlignedByteOffset)
            .field("InputSlotClass", &self.InputSlotClass)
            .field("InstanceDataStepRate", &self.InstanceDataStepRate)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_INPUT_ELEMENT_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_INPUT_ELEMENT_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.SemanticName == other.SemanticName
            && self.SemanticIndex == other.SemanticIndex
            && self.Format == other.Format
            && self.InputSlot == other.InputSlot
            && self.AlignedByteOffset == other.AlignedByteOffset
            && self.InputSlotClass == other.InputSlotClass
            && self.InstanceDataStepRate == other.InstanceDataStepRate
    }
}
impl ::core::cmp::Eq for D3D12_INPUT_ELEMENT_DESC {}
impl ::core::default::Default for D3D12_INPUT_ELEMENT_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_INPUT_LAYOUT_DESC {
    pub pInputElementDescs: *const D3D12_INPUT_ELEMENT_DESC,
    pub NumElements: u32,
}
impl ::core::marker::Copy for D3D12_INPUT_LAYOUT_DESC {}
impl ::core::clone::Clone for D3D12_INPUT_LAYOUT_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_INPUT_LAYOUT_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_INPUT_LAYOUT_DESC")
            .field("pInputElementDescs", &self.pInputElementDescs)
            .field("NumElements", &self.NumElements)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_INPUT_LAYOUT_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_INPUT_LAYOUT_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.pInputElementDescs == other.pInputElementDescs && self.NumElements == other.NumElements
    }
}
impl ::core::cmp::Eq for D3D12_INPUT_LAYOUT_DESC {}
impl ::core::default::Default for D3D12_INPUT_LAYOUT_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_LIBRARY_DESC {
    pub Creator: ::windows::core::PCSTR,
    pub Flags: u32,
    pub FunctionCount: u32,
}
impl ::core::marker::Copy for D3D12_LIBRARY_DESC {}
impl ::core::clone::Clone for D3D12_LIBRARY_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_LIBRARY_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_LIBRARY_DESC")
            .field("Creator", &self.Creator)
            .field("Flags", &self.Flags)
            .field("FunctionCount", &self.FunctionCount)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_LIBRARY_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_LIBRARY_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Creator == other.Creator
            && self.Flags == other.Flags
            && self.FunctionCount == other.FunctionCount
    }
}
impl ::core::cmp::Eq for D3D12_LIBRARY_DESC {}
impl ::core::default::Default for D3D12_LIBRARY_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_LOCAL_ROOT_SIGNATURE {
    pub pLocalRootSignature: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12RootSignature>>,
}
impl ::core::clone::Clone for D3D12_LOCAL_ROOT_SIGNATURE {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_LOCAL_ROOT_SIGNATURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_LOCAL_ROOT_SIGNATURE")
            .field("pLocalRootSignature", &self.pLocalRootSignature)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_LOCAL_ROOT_SIGNATURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_LOCAL_ROOT_SIGNATURE {
    fn eq(&self, other: &Self) -> bool {
        self.pLocalRootSignature == other.pLocalRootSignature
    }
}
impl ::core::cmp::Eq for D3D12_LOCAL_ROOT_SIGNATURE {}
impl ::core::default::Default for D3D12_LOCAL_ROOT_SIGNATURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_MEMCPY_DEST {
    pub pData: *mut ::core::ffi::c_void,
    pub RowPitch: usize,
    pub SlicePitch: usize,
}
impl ::core::marker::Copy for D3D12_MEMCPY_DEST {}
impl ::core::clone::Clone for D3D12_MEMCPY_DEST {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_MEMCPY_DEST {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_MEMCPY_DEST")
            .field("pData", &self.pData)
            .field("RowPitch", &self.RowPitch)
            .field("SlicePitch", &self.SlicePitch)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_MEMCPY_DEST {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_MEMCPY_DEST {
    fn eq(&self, other: &Self) -> bool {
        self.pData == other.pData
            && self.RowPitch == other.RowPitch
            && self.SlicePitch == other.SlicePitch
    }
}
impl ::core::cmp::Eq for D3D12_MEMCPY_DEST {}
impl ::core::default::Default for D3D12_MEMCPY_DEST {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_MESSAGE {
    pub Category: D3D12_MESSAGE_CATEGORY,
    pub Severity: D3D12_MESSAGE_SEVERITY,
    pub ID: D3D12_MESSAGE_ID,
    pub pDescription: ::windows::core::PCSTR,
    pub DescriptionByteLength: usize,
}
impl ::core::marker::Copy for D3D12_MESSAGE {}
impl ::core::clone::Clone for D3D12_MESSAGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_MESSAGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_MESSAGE")
            .field("Category", &self.Category)
            .field("Severity", &self.Severity)
            .field("ID", &self.ID)
            .field("pDescription", &self.pDescription)
            .field("DescriptionByteLength", &self.DescriptionByteLength)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_MESSAGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_MESSAGE {
    fn eq(&self, other: &Self) -> bool {
        self.Category == other.Category
            && self.Severity == other.Severity
            && self.ID == other.ID
            && self.pDescription == other.pDescription
            && self.DescriptionByteLength == other.DescriptionByteLength
    }
}
impl ::core::cmp::Eq for D3D12_MESSAGE {}
impl ::core::default::Default for D3D12_MESSAGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_META_COMMAND_DESC {
    pub Id: ::windows::core::GUID,
    pub Name: ::windows::core::PCWSTR,
    pub InitializationDirtyState: D3D12_GRAPHICS_STATES,
    pub ExecutionDirtyState: D3D12_GRAPHICS_STATES,
}
impl ::core::marker::Copy for D3D12_META_COMMAND_DESC {}
impl ::core::clone::Clone for D3D12_META_COMMAND_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_META_COMMAND_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_META_COMMAND_DESC")
            .field("Id", &self.Id)
            .field("Name", &self.Name)
            .field("InitializationDirtyState", &self.InitializationDirtyState)
            .field("ExecutionDirtyState", &self.ExecutionDirtyState)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_META_COMMAND_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_META_COMMAND_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Id == other.Id
            && self.Name == other.Name
            && self.InitializationDirtyState == other.InitializationDirtyState
            && self.ExecutionDirtyState == other.ExecutionDirtyState
    }
}
impl ::core::cmp::Eq for D3D12_META_COMMAND_DESC {}
impl ::core::default::Default for D3D12_META_COMMAND_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_META_COMMAND_PARAMETER_DESC {
    pub Name: ::windows::core::PCWSTR,
    pub Type: D3D12_META_COMMAND_PARAMETER_TYPE,
    pub Flags: D3D12_META_COMMAND_PARAMETER_FLAGS,
    pub RequiredResourceState: D3D12_RESOURCE_STATES,
    pub StructureOffset: u32,
}
impl ::core::marker::Copy for D3D12_META_COMMAND_PARAMETER_DESC {}
impl ::core::clone::Clone for D3D12_META_COMMAND_PARAMETER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_META_COMMAND_PARAMETER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_META_COMMAND_PARAMETER_DESC")
            .field("Name", &self.Name)
            .field("Type", &self.Type)
            .field("Flags", &self.Flags)
            .field("RequiredResourceState", &self.RequiredResourceState)
            .field("StructureOffset", &self.StructureOffset)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_META_COMMAND_PARAMETER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_META_COMMAND_PARAMETER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name
            && self.Type == other.Type
            && self.Flags == other.Flags
            && self.RequiredResourceState == other.RequiredResourceState
            && self.StructureOffset == other.StructureOffset
    }
}
impl ::core::cmp::Eq for D3D12_META_COMMAND_PARAMETER_DESC {}
impl ::core::default::Default for D3D12_META_COMMAND_PARAMETER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_MIP_REGION {
    pub Width: u32,
    pub Height: u32,
    pub Depth: u32,
}
impl ::core::marker::Copy for D3D12_MIP_REGION {}
impl ::core::clone::Clone for D3D12_MIP_REGION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_MIP_REGION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_MIP_REGION")
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .field("Depth", &self.Depth)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_MIP_REGION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_MIP_REGION {
    fn eq(&self, other: &Self) -> bool {
        self.Width == other.Width && self.Height == other.Height && self.Depth == other.Depth
    }
}
impl ::core::cmp::Eq for D3D12_MIP_REGION {}
impl ::core::default::Default for D3D12_MIP_REGION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_MULTI_NODE_CPU_INPUT {
    pub NumNodeInputs: u32,
    pub pNodeInputs: *mut D3D12_NODE_CPU_INPUT,
    pub NodeInputStrideInBytes: u64,
}
impl ::core::marker::Copy for D3D12_MULTI_NODE_CPU_INPUT {}
impl ::core::clone::Clone for D3D12_MULTI_NODE_CPU_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_MULTI_NODE_CPU_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_MULTI_NODE_CPU_INPUT")
            .field("NumNodeInputs", &self.NumNodeInputs)
            .field("pNodeInputs", &self.pNodeInputs)
            .field("NodeInputStrideInBytes", &self.NodeInputStrideInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_MULTI_NODE_CPU_INPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_MULTI_NODE_CPU_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NumNodeInputs == other.NumNodeInputs
            && self.pNodeInputs == other.pNodeInputs
            && self.NodeInputStrideInBytes == other.NodeInputStrideInBytes
    }
}
impl ::core::cmp::Eq for D3D12_MULTI_NODE_CPU_INPUT {}
impl ::core::default::Default for D3D12_MULTI_NODE_CPU_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_MULTI_NODE_GPU_INPUT {
    pub NumNodeInputs: u32,
    pub NodeInputs: D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE,
}
impl ::core::marker::Copy for D3D12_MULTI_NODE_GPU_INPUT {}
impl ::core::clone::Clone for D3D12_MULTI_NODE_GPU_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_MULTI_NODE_GPU_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_MULTI_NODE_GPU_INPUT")
            .field("NumNodeInputs", &self.NumNodeInputs)
            .field("NodeInputs", &self.NodeInputs)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_MULTI_NODE_GPU_INPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_MULTI_NODE_GPU_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.NumNodeInputs == other.NumNodeInputs && self.NodeInputs == other.NodeInputs
    }
}
impl ::core::cmp::Eq for D3D12_MULTI_NODE_GPU_INPUT {}
impl ::core::default::Default for D3D12_MULTI_NODE_GPU_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_NODE {
    pub NodeType: D3D12_NODE_TYPE,
    pub Anonymous: D3D12_NODE_0,
}
impl ::core::marker::Copy for D3D12_NODE {}
impl ::core::clone::Clone for D3D12_NODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_NODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_NODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_NODE_0 {
    pub Shader: D3D12_SHADER_NODE,
}
impl ::core::marker::Copy for D3D12_NODE_0 {}
impl ::core::clone::Clone for D3D12_NODE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_NODE_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_NODE_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_NODE_CPU_INPUT {
    pub EntrypointIndex: u32,
    pub NumRecords: u32,
    pub pRecords: *mut ::core::ffi::c_void,
    pub RecordStrideInBytes: u64,
}
impl ::core::marker::Copy for D3D12_NODE_CPU_INPUT {}
impl ::core::clone::Clone for D3D12_NODE_CPU_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_NODE_CPU_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_NODE_CPU_INPUT")
            .field("EntrypointIndex", &self.EntrypointIndex)
            .field("NumRecords", &self.NumRecords)
            .field("pRecords", &self.pRecords)
            .field("RecordStrideInBytes", &self.RecordStrideInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_NODE_CPU_INPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_NODE_CPU_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.EntrypointIndex == other.EntrypointIndex
            && self.NumRecords == other.NumRecords
            && self.pRecords == other.pRecords
            && self.RecordStrideInBytes == other.RecordStrideInBytes
    }
}
impl ::core::cmp::Eq for D3D12_NODE_CPU_INPUT {}
impl ::core::default::Default for D3D12_NODE_CPU_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_NODE_GPU_INPUT {
    pub EntrypointIndex: u32,
    pub NumRecords: u32,
    pub Records: D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE,
}
impl ::core::marker::Copy for D3D12_NODE_GPU_INPUT {}
impl ::core::clone::Clone for D3D12_NODE_GPU_INPUT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_NODE_GPU_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_NODE_GPU_INPUT")
            .field("EntrypointIndex", &self.EntrypointIndex)
            .field("NumRecords", &self.NumRecords)
            .field("Records", &self.Records)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_NODE_GPU_INPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_NODE_GPU_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.EntrypointIndex == other.EntrypointIndex
            && self.NumRecords == other.NumRecords
            && self.Records == other.Records
    }
}
impl ::core::cmp::Eq for D3D12_NODE_GPU_INPUT {}
impl ::core::default::Default for D3D12_NODE_GPU_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_NODE_ID {
    pub Name: ::windows::core::PCWSTR,
    pub ArrayIndex: u32,
}
impl ::core::marker::Copy for D3D12_NODE_ID {}
impl ::core::clone::Clone for D3D12_NODE_ID {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_NODE_ID {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_NODE_ID")
            .field("Name", &self.Name)
            .field("ArrayIndex", &self.ArrayIndex)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_NODE_ID {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_NODE_ID {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name && self.ArrayIndex == other.ArrayIndex
    }
}
impl ::core::cmp::Eq for D3D12_NODE_ID {}
impl ::core::default::Default for D3D12_NODE_ID {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_NODE_MASK {
    pub NodeMask: u32,
}
impl ::core::marker::Copy for D3D12_NODE_MASK {}
impl ::core::clone::Clone for D3D12_NODE_MASK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_NODE_MASK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_NODE_MASK")
            .field("NodeMask", &self.NodeMask)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_NODE_MASK {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_NODE_MASK {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask
    }
}
impl ::core::cmp::Eq for D3D12_NODE_MASK {}
impl ::core::default::Default for D3D12_NODE_MASK {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_NODE_OUTPUT_OVERRIDES {
    pub OutputIndex: u32,
    pub pNewName: *const D3D12_NODE_ID,
    pub pAllowSparseNodes: *const ::windows::Win32::Foundation::BOOL,
    pub pMaxRecords: *const u32,
    pub pMaxRecordsSharedWithOutputIndex: *const u32,
}
impl ::core::marker::Copy for D3D12_NODE_OUTPUT_OVERRIDES {}
impl ::core::clone::Clone for D3D12_NODE_OUTPUT_OVERRIDES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_NODE_OUTPUT_OVERRIDES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_NODE_OUTPUT_OVERRIDES")
            .field("OutputIndex", &self.OutputIndex)
            .field("pNewName", &self.pNewName)
            .field("pAllowSparseNodes", &self.pAllowSparseNodes)
            .field("pMaxRecords", &self.pMaxRecords)
            .field(
                "pMaxRecordsSharedWithOutputIndex",
                &self.pMaxRecordsSharedWithOutputIndex,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_NODE_OUTPUT_OVERRIDES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_NODE_OUTPUT_OVERRIDES {
    fn eq(&self, other: &Self) -> bool {
        self.OutputIndex == other.OutputIndex
            && self.pNewName == other.pNewName
            && self.pAllowSparseNodes == other.pAllowSparseNodes
            && self.pMaxRecords == other.pMaxRecords
            && self.pMaxRecordsSharedWithOutputIndex == other.pMaxRecordsSharedWithOutputIndex
    }
}
impl ::core::cmp::Eq for D3D12_NODE_OUTPUT_OVERRIDES {}
impl ::core::default::Default for D3D12_NODE_OUTPUT_OVERRIDES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_PACKED_MIP_INFO {
    pub NumStandardMips: u8,
    pub NumPackedMips: u8,
    pub NumTilesForPackedMips: u32,
    pub StartTileIndexInOverallResource: u32,
}
impl ::core::marker::Copy for D3D12_PACKED_MIP_INFO {}
impl ::core::clone::Clone for D3D12_PACKED_MIP_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_PACKED_MIP_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_PACKED_MIP_INFO")
            .field("NumStandardMips", &self.NumStandardMips)
            .field("NumPackedMips", &self.NumPackedMips)
            .field("NumTilesForPackedMips", &self.NumTilesForPackedMips)
            .field(
                "StartTileIndexInOverallResource",
                &self.StartTileIndexInOverallResource,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_PACKED_MIP_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_PACKED_MIP_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.NumStandardMips == other.NumStandardMips
            && self.NumPackedMips == other.NumPackedMips
            && self.NumTilesForPackedMips == other.NumTilesForPackedMips
            && self.StartTileIndexInOverallResource == other.StartTileIndexInOverallResource
    }
}
impl ::core::cmp::Eq for D3D12_PACKED_MIP_INFO {}
impl ::core::default::Default for D3D12_PACKED_MIP_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_PARAMETER_DESC {
    pub Name: ::windows::core::PCSTR,
    pub SemanticName: ::windows::core::PCSTR,
    pub Type: D3D_SHADER_VARIABLE_TYPE,
    pub Class: D3D_SHADER_VARIABLE_CLASS,
    pub Rows: u32,
    pub Columns: u32,
    pub InterpolationMode: D3D_INTERPOLATION_MODE,
    pub Flags: D3D_PARAMETER_FLAGS,
    pub FirstInRegister: u32,
    pub FirstInComponent: u32,
    pub FirstOutRegister: u32,
    pub FirstOutComponent: u32,
}
impl ::core::marker::Copy for D3D12_PARAMETER_DESC {}
impl ::core::clone::Clone for D3D12_PARAMETER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_PARAMETER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_PARAMETER_DESC")
            .field("Name", &self.Name)
            .field("SemanticName", &self.SemanticName)
            .field("Type", &self.Type)
            .field("Class", &self.Class)
            .field("Rows", &self.Rows)
            .field("Columns", &self.Columns)
            .field("InterpolationMode", &self.InterpolationMode)
            .field("Flags", &self.Flags)
            .field("FirstInRegister", &self.FirstInRegister)
            .field("FirstInComponent", &self.FirstInComponent)
            .field("FirstOutRegister", &self.FirstOutRegister)
            .field("FirstOutComponent", &self.FirstOutComponent)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_PARAMETER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_PARAMETER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name
            && self.SemanticName == other.SemanticName
            && self.Type == other.Type
            && self.Class == other.Class
            && self.Rows == other.Rows
            && self.Columns == other.Columns
            && self.InterpolationMode == other.InterpolationMode
            && self.Flags == other.Flags
            && self.FirstInRegister == other.FirstInRegister
            && self.FirstInComponent == other.FirstInComponent
            && self.FirstOutRegister == other.FirstOutRegister
            && self.FirstOutComponent == other.FirstOutComponent
    }
}
impl ::core::cmp::Eq for D3D12_PARAMETER_DESC {}
impl ::core::default::Default for D3D12_PARAMETER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_PIPELINE_STATE_STREAM_DESC {
    pub SizeInBytes: usize,
    pub pPipelineStateSubobjectStream: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for D3D12_PIPELINE_STATE_STREAM_DESC {}
impl ::core::clone::Clone for D3D12_PIPELINE_STATE_STREAM_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_PIPELINE_STATE_STREAM_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_PIPELINE_STATE_STREAM_DESC")
            .field("SizeInBytes", &self.SizeInBytes)
            .field(
                "pPipelineStateSubobjectStream",
                &self.pPipelineStateSubobjectStream,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_PIPELINE_STATE_STREAM_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_PIPELINE_STATE_STREAM_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.SizeInBytes == other.SizeInBytes
            && self.pPipelineStateSubobjectStream == other.pPipelineStateSubobjectStream
    }
}
impl ::core::cmp::Eq for D3D12_PIPELINE_STATE_STREAM_DESC {}
impl ::core::default::Default for D3D12_PIPELINE_STATE_STREAM_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_PLACED_SUBRESOURCE_FOOTPRINT {
    pub Offset: u64,
    pub Footprint: D3D12_SUBRESOURCE_FOOTPRINT,
}
impl ::core::marker::Copy for D3D12_PLACED_SUBRESOURCE_FOOTPRINT {}
impl ::core::clone::Clone for D3D12_PLACED_SUBRESOURCE_FOOTPRINT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_PLACED_SUBRESOURCE_FOOTPRINT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_PLACED_SUBRESOURCE_FOOTPRINT")
            .field("Offset", &self.Offset)
            .field("Footprint", &self.Footprint)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_PLACED_SUBRESOURCE_FOOTPRINT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_PLACED_SUBRESOURCE_FOOTPRINT {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.Footprint == other.Footprint
    }
}
impl ::core::cmp::Eq for D3D12_PLACED_SUBRESOURCE_FOOTPRINT {}
impl ::core::default::Default for D3D12_PLACED_SUBRESOURCE_FOOTPRINT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_PRIMITIVE_TOPOLOGY_DESC {
    pub PrimitiveTopology: D3D12_PRIMITIVE_TOPOLOGY_TYPE,
}
impl ::core::marker::Copy for D3D12_PRIMITIVE_TOPOLOGY_DESC {}
impl ::core::clone::Clone for D3D12_PRIMITIVE_TOPOLOGY_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_PRIMITIVE_TOPOLOGY_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_PRIMITIVE_TOPOLOGY_DESC")
            .field("PrimitiveTopology", &self.PrimitiveTopology)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_PRIMITIVE_TOPOLOGY_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_PRIMITIVE_TOPOLOGY_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.PrimitiveTopology == other.PrimitiveTopology
    }
}
impl ::core::cmp::Eq for D3D12_PRIMITIVE_TOPOLOGY_DESC {}
impl ::core::default::Default for D3D12_PRIMITIVE_TOPOLOGY_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_PROGRAM_IDENTIFIER {
    pub OpaqueData: [u64; 4],
}
impl ::core::marker::Copy for D3D12_PROGRAM_IDENTIFIER {}
impl ::core::clone::Clone for D3D12_PROGRAM_IDENTIFIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_PROGRAM_IDENTIFIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_PROGRAM_IDENTIFIER")
            .field("OpaqueData", &self.OpaqueData)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_PROGRAM_IDENTIFIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_PROGRAM_IDENTIFIER {
    fn eq(&self, other: &Self) -> bool {
        self.OpaqueData == other.OpaqueData
    }
}
impl ::core::cmp::Eq for D3D12_PROGRAM_IDENTIFIER {}
impl ::core::default::Default for D3D12_PROGRAM_IDENTIFIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_PROTECTED_RESOURCE_SESSION_DESC {
    pub NodeMask: u32,
    pub Flags: D3D12_PROTECTED_RESOURCE_SESSION_FLAGS,
}
impl ::core::marker::Copy for D3D12_PROTECTED_RESOURCE_SESSION_DESC {}
impl ::core::clone::Clone for D3D12_PROTECTED_RESOURCE_SESSION_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_PROTECTED_RESOURCE_SESSION_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_PROTECTED_RESOURCE_SESSION_DESC")
            .field("NodeMask", &self.NodeMask)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_PROTECTED_RESOURCE_SESSION_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_PROTECTED_RESOURCE_SESSION_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_PROTECTED_RESOURCE_SESSION_DESC {}
impl ::core::default::Default for D3D12_PROTECTED_RESOURCE_SESSION_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_PROTECTED_RESOURCE_SESSION_DESC1 {
    pub NodeMask: u32,
    pub Flags: D3D12_PROTECTED_RESOURCE_SESSION_FLAGS,
    pub ProtectionType: ::windows::core::GUID,
}
impl ::core::marker::Copy for D3D12_PROTECTED_RESOURCE_SESSION_DESC1 {}
impl ::core::clone::Clone for D3D12_PROTECTED_RESOURCE_SESSION_DESC1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_PROTECTED_RESOURCE_SESSION_DESC1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_PROTECTED_RESOURCE_SESSION_DESC1")
            .field("NodeMask", &self.NodeMask)
            .field("Flags", &self.Flags)
            .field("ProtectionType", &self.ProtectionType)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_PROTECTED_RESOURCE_SESSION_DESC1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_PROTECTED_RESOURCE_SESSION_DESC1 {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask
            && self.Flags == other.Flags
            && self.ProtectionType == other.ProtectionType
    }
}
impl ::core::cmp::Eq for D3D12_PROTECTED_RESOURCE_SESSION_DESC1 {}
impl ::core::default::Default for D3D12_PROTECTED_RESOURCE_SESSION_DESC1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_QUERY_DATA_PIPELINE_STATISTICS {
    pub IAVertices: u64,
    pub IAPrimitives: u64,
    pub VSInvocations: u64,
    pub GSInvocations: u64,
    pub GSPrimitives: u64,
    pub CInvocations: u64,
    pub CPrimitives: u64,
    pub PSInvocations: u64,
    pub HSInvocations: u64,
    pub DSInvocations: u64,
    pub CSInvocations: u64,
}
impl ::core::marker::Copy for D3D12_QUERY_DATA_PIPELINE_STATISTICS {}
impl ::core::clone::Clone for D3D12_QUERY_DATA_PIPELINE_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_QUERY_DATA_PIPELINE_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_QUERY_DATA_PIPELINE_STATISTICS")
            .field("IAVertices", &self.IAVertices)
            .field("IAPrimitives", &self.IAPrimitives)
            .field("VSInvocations", &self.VSInvocations)
            .field("GSInvocations", &self.GSInvocations)
            .field("GSPrimitives", &self.GSPrimitives)
            .field("CInvocations", &self.CInvocations)
            .field("CPrimitives", &self.CPrimitives)
            .field("PSInvocations", &self.PSInvocations)
            .field("HSInvocations", &self.HSInvocations)
            .field("DSInvocations", &self.DSInvocations)
            .field("CSInvocations", &self.CSInvocations)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_QUERY_DATA_PIPELINE_STATISTICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_QUERY_DATA_PIPELINE_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.IAVertices == other.IAVertices
            && self.IAPrimitives == other.IAPrimitives
            && self.VSInvocations == other.VSInvocations
            && self.GSInvocations == other.GSInvocations
            && self.GSPrimitives == other.GSPrimitives
            && self.CInvocations == other.CInvocations
            && self.CPrimitives == other.CPrimitives
            && self.PSInvocations == other.PSInvocations
            && self.HSInvocations == other.HSInvocations
            && self.DSInvocations == other.DSInvocations
            && self.CSInvocations == other.CSInvocations
    }
}
impl ::core::cmp::Eq for D3D12_QUERY_DATA_PIPELINE_STATISTICS {}
impl ::core::default::Default for D3D12_QUERY_DATA_PIPELINE_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_QUERY_DATA_PIPELINE_STATISTICS1 {
    pub IAVertices: u64,
    pub IAPrimitives: u64,
    pub VSInvocations: u64,
    pub GSInvocations: u64,
    pub GSPrimitives: u64,
    pub CInvocations: u64,
    pub CPrimitives: u64,
    pub PSInvocations: u64,
    pub HSInvocations: u64,
    pub DSInvocations: u64,
    pub CSInvocations: u64,
    pub ASInvocations: u64,
    pub MSInvocations: u64,
    pub MSPrimitives: u64,
}
impl ::core::marker::Copy for D3D12_QUERY_DATA_PIPELINE_STATISTICS1 {}
impl ::core::clone::Clone for D3D12_QUERY_DATA_PIPELINE_STATISTICS1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_QUERY_DATA_PIPELINE_STATISTICS1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_QUERY_DATA_PIPELINE_STATISTICS1")
            .field("IAVertices", &self.IAVertices)
            .field("IAPrimitives", &self.IAPrimitives)
            .field("VSInvocations", &self.VSInvocations)
            .field("GSInvocations", &self.GSInvocations)
            .field("GSPrimitives", &self.GSPrimitives)
            .field("CInvocations", &self.CInvocations)
            .field("CPrimitives", &self.CPrimitives)
            .field("PSInvocations", &self.PSInvocations)
            .field("HSInvocations", &self.HSInvocations)
            .field("DSInvocations", &self.DSInvocations)
            .field("CSInvocations", &self.CSInvocations)
            .field("ASInvocations", &self.ASInvocations)
            .field("MSInvocations", &self.MSInvocations)
            .field("MSPrimitives", &self.MSPrimitives)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_QUERY_DATA_PIPELINE_STATISTICS1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_QUERY_DATA_PIPELINE_STATISTICS1 {
    fn eq(&self, other: &Self) -> bool {
        self.IAVertices == other.IAVertices
            && self.IAPrimitives == other.IAPrimitives
            && self.VSInvocations == other.VSInvocations
            && self.GSInvocations == other.GSInvocations
            && self.GSPrimitives == other.GSPrimitives
            && self.CInvocations == other.CInvocations
            && self.CPrimitives == other.CPrimitives
            && self.PSInvocations == other.PSInvocations
            && self.HSInvocations == other.HSInvocations
            && self.DSInvocations == other.DSInvocations
            && self.CSInvocations == other.CSInvocations
            && self.ASInvocations == other.ASInvocations
            && self.MSInvocations == other.MSInvocations
            && self.MSPrimitives == other.MSPrimitives
    }
}
impl ::core::cmp::Eq for D3D12_QUERY_DATA_PIPELINE_STATISTICS1 {}
impl ::core::default::Default for D3D12_QUERY_DATA_PIPELINE_STATISTICS1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_QUERY_DATA_SO_STATISTICS {
    pub NumPrimitivesWritten: u64,
    pub PrimitivesStorageNeeded: u64,
}
impl ::core::marker::Copy for D3D12_QUERY_DATA_SO_STATISTICS {}
impl ::core::clone::Clone for D3D12_QUERY_DATA_SO_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_QUERY_DATA_SO_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_QUERY_DATA_SO_STATISTICS")
            .field("NumPrimitivesWritten", &self.NumPrimitivesWritten)
            .field("PrimitivesStorageNeeded", &self.PrimitivesStorageNeeded)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_QUERY_DATA_SO_STATISTICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_QUERY_DATA_SO_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.NumPrimitivesWritten == other.NumPrimitivesWritten
            && self.PrimitivesStorageNeeded == other.PrimitivesStorageNeeded
    }
}
impl ::core::cmp::Eq for D3D12_QUERY_DATA_SO_STATISTICS {}
impl ::core::default::Default for D3D12_QUERY_DATA_SO_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    pub Status: u64,
    pub NumMacroblocksAffected: u64,
    pub FrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub BitRate: u32,
}
impl ::core::marker::Copy for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {}
impl ::core::clone::Clone for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS")
            .field("Status", &self.Status)
            .field("NumMacroblocksAffected", &self.NumMacroblocksAffected)
            .field("FrameRate", &self.FrameRate)
            .field("BitRate", &self.BitRate)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.Status == other.Status
            && self.NumMacroblocksAffected == other.NumMacroblocksAffected
            && self.FrameRate == other.FrameRate
            && self.BitRate == other.BitRate
    }
}
impl ::core::cmp::Eq for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {}
impl ::core::default::Default for D3D12_QUERY_DATA_VIDEO_DECODE_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_QUERY_HEAP_DESC {
    pub Type: D3D12_QUERY_HEAP_TYPE,
    pub Count: u32,
    pub NodeMask: u32,
}
impl ::core::marker::Copy for D3D12_QUERY_HEAP_DESC {}
impl ::core::clone::Clone for D3D12_QUERY_HEAP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_QUERY_HEAP_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_QUERY_HEAP_DESC")
            .field("Type", &self.Type)
            .field("Count", &self.Count)
            .field("NodeMask", &self.NodeMask)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_QUERY_HEAP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_QUERY_HEAP_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Count == other.Count && self.NodeMask == other.NodeMask
    }
}
impl ::core::cmp::Eq for D3D12_QUERY_HEAP_DESC {}
impl ::core::default::Default for D3D12_QUERY_HEAP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RANGE {
    pub Begin: usize,
    pub End: usize,
}
impl ::core::marker::Copy for D3D12_RANGE {}
impl ::core::clone::Clone for D3D12_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RANGE")
            .field("Begin", &self.Begin)
            .field("End", &self.End)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RANGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.Begin == other.Begin && self.End == other.End
    }
}
impl ::core::cmp::Eq for D3D12_RANGE {}
impl ::core::default::Default for D3D12_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RANGE_UINT64 {
    pub Begin: u64,
    pub End: u64,
}
impl ::core::marker::Copy for D3D12_RANGE_UINT64 {}
impl ::core::clone::Clone for D3D12_RANGE_UINT64 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RANGE_UINT64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RANGE_UINT64")
            .field("Begin", &self.Begin)
            .field("End", &self.End)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RANGE_UINT64 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RANGE_UINT64 {
    fn eq(&self, other: &Self) -> bool {
        self.Begin == other.Begin && self.End == other.End
    }
}
impl ::core::cmp::Eq for D3D12_RANGE_UINT64 {}
impl ::core::default::Default for D3D12_RANGE_UINT64 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RASTERIZER_DESC {
    pub FillMode: D3D12_FILL_MODE,
    pub CullMode: D3D12_CULL_MODE,
    pub FrontCounterClockwise: ::windows::Win32::Foundation::BOOL,
    pub DepthBias: i32,
    pub DepthBiasClamp: f32,
    pub SlopeScaledDepthBias: f32,
    pub DepthClipEnable: ::windows::Win32::Foundation::BOOL,
    pub MultisampleEnable: ::windows::Win32::Foundation::BOOL,
    pub AntialiasedLineEnable: ::windows::Win32::Foundation::BOOL,
    pub ForcedSampleCount: u32,
    pub ConservativeRaster: D3D12_CONSERVATIVE_RASTERIZATION_MODE,
}
impl ::core::marker::Copy for D3D12_RASTERIZER_DESC {}
impl ::core::clone::Clone for D3D12_RASTERIZER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RASTERIZER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RASTERIZER_DESC")
            .field("FillMode", &self.FillMode)
            .field("CullMode", &self.CullMode)
            .field("FrontCounterClockwise", &self.FrontCounterClockwise)
            .field("DepthBias", &self.DepthBias)
            .field("DepthBiasClamp", &self.DepthBiasClamp)
            .field("SlopeScaledDepthBias", &self.SlopeScaledDepthBias)
            .field("DepthClipEnable", &self.DepthClipEnable)
            .field("MultisampleEnable", &self.MultisampleEnable)
            .field("AntialiasedLineEnable", &self.AntialiasedLineEnable)
            .field("ForcedSampleCount", &self.ForcedSampleCount)
            .field("ConservativeRaster", &self.ConservativeRaster)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RASTERIZER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RASTERIZER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.FillMode == other.FillMode
            && self.CullMode == other.CullMode
            && self.FrontCounterClockwise == other.FrontCounterClockwise
            && self.DepthBias == other.DepthBias
            && self.DepthBiasClamp == other.DepthBiasClamp
            && self.SlopeScaledDepthBias == other.SlopeScaledDepthBias
            && self.DepthClipEnable == other.DepthClipEnable
            && self.MultisampleEnable == other.MultisampleEnable
            && self.AntialiasedLineEnable == other.AntialiasedLineEnable
            && self.ForcedSampleCount == other.ForcedSampleCount
            && self.ConservativeRaster == other.ConservativeRaster
    }
}
impl ::core::cmp::Eq for D3D12_RASTERIZER_DESC {}
impl ::core::default::Default for D3D12_RASTERIZER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RASTERIZER_DESC1 {
    pub FillMode: D3D12_FILL_MODE,
    pub CullMode: D3D12_CULL_MODE,
    pub FrontCounterClockwise: ::windows::Win32::Foundation::BOOL,
    pub DepthBias: f32,
    pub DepthBiasClamp: f32,
    pub SlopeScaledDepthBias: f32,
    pub DepthClipEnable: ::windows::Win32::Foundation::BOOL,
    pub MultisampleEnable: ::windows::Win32::Foundation::BOOL,
    pub AntialiasedLineEnable: ::windows::Win32::Foundation::BOOL,
    pub ForcedSampleCount: u32,
    pub ConservativeRaster: D3D12_CONSERVATIVE_RASTERIZATION_MODE,
}
impl ::core::marker::Copy for D3D12_RASTERIZER_DESC1 {}
impl ::core::clone::Clone for D3D12_RASTERIZER_DESC1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RASTERIZER_DESC1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RASTERIZER_DESC1")
            .field("FillMode", &self.FillMode)
            .field("CullMode", &self.CullMode)
            .field("FrontCounterClockwise", &self.FrontCounterClockwise)
            .field("DepthBias", &self.DepthBias)
            .field("DepthBiasClamp", &self.DepthBiasClamp)
            .field("SlopeScaledDepthBias", &self.SlopeScaledDepthBias)
            .field("DepthClipEnable", &self.DepthClipEnable)
            .field("MultisampleEnable", &self.MultisampleEnable)
            .field("AntialiasedLineEnable", &self.AntialiasedLineEnable)
            .field("ForcedSampleCount", &self.ForcedSampleCount)
            .field("ConservativeRaster", &self.ConservativeRaster)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RASTERIZER_DESC1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RASTERIZER_DESC1 {
    fn eq(&self, other: &Self) -> bool {
        self.FillMode == other.FillMode
            && self.CullMode == other.CullMode
            && self.FrontCounterClockwise == other.FrontCounterClockwise
            && self.DepthBias == other.DepthBias
            && self.DepthBiasClamp == other.DepthBiasClamp
            && self.SlopeScaledDepthBias == other.SlopeScaledDepthBias
            && self.DepthClipEnable == other.DepthClipEnable
            && self.MultisampleEnable == other.MultisampleEnable
            && self.AntialiasedLineEnable == other.AntialiasedLineEnable
            && self.ForcedSampleCount == other.ForcedSampleCount
            && self.ConservativeRaster == other.ConservativeRaster
    }
}
impl ::core::cmp::Eq for D3D12_RASTERIZER_DESC1 {}
impl ::core::default::Default for D3D12_RASTERIZER_DESC1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RASTERIZER_DESC2 {
    pub FillMode: D3D12_FILL_MODE,
    pub CullMode: D3D12_CULL_MODE,
    pub FrontCounterClockwise: ::windows::Win32::Foundation::BOOL,
    pub DepthBias: f32,
    pub DepthBiasClamp: f32,
    pub SlopeScaledDepthBias: f32,
    pub DepthClipEnable: ::windows::Win32::Foundation::BOOL,
    pub LineRasterizationMode: D3D12_LINE_RASTERIZATION_MODE,
    pub ForcedSampleCount: u32,
    pub ConservativeRaster: D3D12_CONSERVATIVE_RASTERIZATION_MODE,
}
impl ::core::marker::Copy for D3D12_RASTERIZER_DESC2 {}
impl ::core::clone::Clone for D3D12_RASTERIZER_DESC2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RASTERIZER_DESC2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RASTERIZER_DESC2")
            .field("FillMode", &self.FillMode)
            .field("CullMode", &self.CullMode)
            .field("FrontCounterClockwise", &self.FrontCounterClockwise)
            .field("DepthBias", &self.DepthBias)
            .field("DepthBiasClamp", &self.DepthBiasClamp)
            .field("SlopeScaledDepthBias", &self.SlopeScaledDepthBias)
            .field("DepthClipEnable", &self.DepthClipEnable)
            .field("LineRasterizationMode", &self.LineRasterizationMode)
            .field("ForcedSampleCount", &self.ForcedSampleCount)
            .field("ConservativeRaster", &self.ConservativeRaster)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RASTERIZER_DESC2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RASTERIZER_DESC2 {
    fn eq(&self, other: &Self) -> bool {
        self.FillMode == other.FillMode
            && self.CullMode == other.CullMode
            && self.FrontCounterClockwise == other.FrontCounterClockwise
            && self.DepthBias == other.DepthBias
            && self.DepthBiasClamp == other.DepthBiasClamp
            && self.SlopeScaledDepthBias == other.SlopeScaledDepthBias
            && self.DepthClipEnable == other.DepthClipEnable
            && self.LineRasterizationMode == other.LineRasterizationMode
            && self.ForcedSampleCount == other.ForcedSampleCount
            && self.ConservativeRaster == other.ConservativeRaster
    }
}
impl ::core::cmp::Eq for D3D12_RASTERIZER_DESC2 {}
impl ::core::default::Default for D3D12_RASTERIZER_DESC2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_AABB {
    pub MinX: f32,
    pub MinY: f32,
    pub MinZ: f32,
    pub MaxX: f32,
    pub MaxY: f32,
    pub MaxZ: f32,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_AABB {}
impl ::core::clone::Clone for D3D12_RAYTRACING_AABB {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_AABB {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_AABB")
            .field("MinX", &self.MinX)
            .field("MinY", &self.MinY)
            .field("MinZ", &self.MinZ)
            .field("MaxX", &self.MaxX)
            .field("MaxY", &self.MaxY)
            .field("MaxZ", &self.MaxZ)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_AABB {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RAYTRACING_AABB {
    fn eq(&self, other: &Self) -> bool {
        self.MinX == other.MinX
            && self.MinY == other.MinY
            && self.MinZ == other.MinZ
            && self.MaxX == other.MaxX
            && self.MaxY == other.MaxY
            && self.MaxZ == other.MaxZ
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_AABB {}
impl ::core::default::Default for D3D12_RAYTRACING_AABB {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC {
    pub CompactedSizeInBytes: u64,
}
impl ::core::marker::Copy
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC
{
}
impl ::core::clone::Clone
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC
{
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC")
            .field("CompactedSizeInBytes", &self.CompactedSizeInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC
{
    fn eq(&self, other: &Self) -> bool {
        self.CompactedSizeInBytes == other.CompactedSizeInBytes
    }
}
impl ::core::cmp::Eq
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC
{
}
impl ::core::default::Default
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_COMPACTED_SIZE_DESC
{
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC {
    pub CurrentSizeInBytes: u64,
}
impl ::core::marker::Copy
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC
{
}
impl ::core::clone::Clone
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC
{
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC")
            .field("CurrentSizeInBytes", &self.CurrentSizeInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC
{
    fn eq(&self, other: &Self) -> bool {
        self.CurrentSizeInBytes == other.CurrentSizeInBytes
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC {}
impl ::core::default::Default
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_CURRENT_SIZE_DESC
{
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC {
    pub DestBuffer: u64,
    pub InfoType: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TYPE,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC {}
impl ::core::clone::Clone for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC")
            .field("DestBuffer", &self.DestBuffer)
            .field("InfoType", &self.InfoType)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.DestBuffer == other.DestBuffer && self.InfoType == other.InfoType
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC {}
impl ::core::default::Default for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC {
    pub SerializedSizeInBytes: u64,
    pub NumBottomLevelAccelerationStructurePointers: u64,
}
impl ::core::marker::Copy
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC
{
}
impl ::core::clone::Clone
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC
{
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC")
            .field("SerializedSizeInBytes", &self.SerializedSizeInBytes)
            .field(
                "NumBottomLevelAccelerationStructurePointers",
                &self.NumBottomLevelAccelerationStructurePointers,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC
{
    fn eq(&self, other: &Self) -> bool {
        self.SerializedSizeInBytes == other.SerializedSizeInBytes
            && self.NumBottomLevelAccelerationStructurePointers
                == other.NumBottomLevelAccelerationStructurePointers
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC {}
impl ::core::default::Default
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_SERIALIZATION_DESC
{
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC {
    pub DecodedSizeInBytes: u64,
}
impl ::core::marker::Copy
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC
{
}
impl ::core::clone::Clone
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC
{
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct(
            "D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC",
        )
        .field("DecodedSizeInBytes", &self.DecodedSizeInBytes)
        .finish()
    }
}
impl ::windows::core::TypeKind
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC
{
    fn eq(&self, other: &Self) -> bool {
        self.DecodedSizeInBytes == other.DecodedSizeInBytes
    }
}
impl ::core::cmp::Eq
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC
{
}
impl ::core::default::Default
    for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_TOOLS_VISUALIZATION_DESC
{
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO {
    pub ResultDataMaxSizeInBytes: u64,
    pub ScratchDataSizeInBytes: u64,
    pub UpdateScratchDataSizeInBytes: u64,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO {}
impl ::core::clone::Clone for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO")
            .field("ResultDataMaxSizeInBytes", &self.ResultDataMaxSizeInBytes)
            .field("ScratchDataSizeInBytes", &self.ScratchDataSizeInBytes)
            .field(
                "UpdateScratchDataSizeInBytes",
                &self.UpdateScratchDataSizeInBytes,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.ResultDataMaxSizeInBytes == other.ResultDataMaxSizeInBytes
            && self.ScratchDataSizeInBytes == other.ScratchDataSizeInBytes
            && self.UpdateScratchDataSizeInBytes == other.UpdateScratchDataSizeInBytes
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO {}
impl ::core::default::Default for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV {
    pub Location: u64,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV {}
impl ::core::clone::Clone for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV")
            .field("Location", &self.Location)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.Location == other.Location
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV {}
impl ::core::default::Default for D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_GEOMETRY_AABBS_DESC {
    pub AABBCount: u64,
    pub AABBs: D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_GEOMETRY_AABBS_DESC {}
impl ::core::clone::Clone for D3D12_RAYTRACING_GEOMETRY_AABBS_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_GEOMETRY_AABBS_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_GEOMETRY_AABBS_DESC")
            .field("AABBCount", &self.AABBCount)
            .field("AABBs", &self.AABBs)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_GEOMETRY_AABBS_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RAYTRACING_GEOMETRY_AABBS_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.AABBCount == other.AABBCount && self.AABBs == other.AABBs
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_GEOMETRY_AABBS_DESC {}
impl ::core::default::Default for D3D12_RAYTRACING_GEOMETRY_AABBS_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_GEOMETRY_DESC {
    pub Type: D3D12_RAYTRACING_GEOMETRY_TYPE,
    pub Flags: D3D12_RAYTRACING_GEOMETRY_FLAGS,
    pub Anonymous: D3D12_RAYTRACING_GEOMETRY_DESC_0,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_GEOMETRY_DESC {}
impl ::core::clone::Clone for D3D12_RAYTRACING_GEOMETRY_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_GEOMETRY_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RAYTRACING_GEOMETRY_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_RAYTRACING_GEOMETRY_DESC_0 {
    pub Triangles: D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC,
    pub AABBs: D3D12_RAYTRACING_GEOMETRY_AABBS_DESC,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_GEOMETRY_DESC_0 {}
impl ::core::clone::Clone for D3D12_RAYTRACING_GEOMETRY_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_GEOMETRY_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RAYTRACING_GEOMETRY_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC {
    pub Transform3x4: u64,
    pub IndexFormat: DXGI_FORMAT,
    pub VertexFormat: DXGI_FORMAT,
    pub IndexCount: u32,
    pub VertexCount: u32,
    pub IndexBuffer: u64,
    pub VertexBuffer: D3D12_GPU_VIRTUAL_ADDRESS_AND_STRIDE,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC {}
impl ::core::clone::Clone for D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC")
            .field("Transform3x4", &self.Transform3x4)
            .field("IndexFormat", &self.IndexFormat)
            .field("VertexFormat", &self.VertexFormat)
            .field("IndexCount", &self.IndexCount)
            .field("VertexCount", &self.VertexCount)
            .field("IndexBuffer", &self.IndexBuffer)
            .field("VertexBuffer", &self.VertexBuffer)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Transform3x4 == other.Transform3x4
            && self.IndexFormat == other.IndexFormat
            && self.VertexFormat == other.VertexFormat
            && self.IndexCount == other.IndexCount
            && self.VertexCount == other.VertexCount
            && self.IndexBuffer == other.IndexBuffer
            && self.VertexBuffer == other.VertexBuffer
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC {}
impl ::core::default::Default for D3D12_RAYTRACING_GEOMETRY_TRIANGLES_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_INSTANCE_DESC {
    pub Transform: [f32; 12],
    pub _bitfield1: u32,
    pub _bitfield2: u32,
    pub AccelerationStructure: u64,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_INSTANCE_DESC {}
impl ::core::clone::Clone for D3D12_RAYTRACING_INSTANCE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_INSTANCE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_INSTANCE_DESC")
            .field("Transform", &self.Transform)
            .field("_bitfield1", &self._bitfield1)
            .field("_bitfield2", &self._bitfield2)
            .field("AccelerationStructure", &self.AccelerationStructure)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_INSTANCE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RAYTRACING_INSTANCE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Transform == other.Transform
            && self._bitfield1 == other._bitfield1
            && self._bitfield2 == other._bitfield2
            && self.AccelerationStructure == other.AccelerationStructure
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_INSTANCE_DESC {}
impl ::core::default::Default for D3D12_RAYTRACING_INSTANCE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_PIPELINE_CONFIG {
    pub MaxTraceRecursionDepth: u32,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_PIPELINE_CONFIG {}
impl ::core::clone::Clone for D3D12_RAYTRACING_PIPELINE_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_PIPELINE_CONFIG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_PIPELINE_CONFIG")
            .field("MaxTraceRecursionDepth", &self.MaxTraceRecursionDepth)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_PIPELINE_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RAYTRACING_PIPELINE_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.MaxTraceRecursionDepth == other.MaxTraceRecursionDepth
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_PIPELINE_CONFIG {}
impl ::core::default::Default for D3D12_RAYTRACING_PIPELINE_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_PIPELINE_CONFIG1 {
    pub MaxTraceRecursionDepth: u32,
    pub Flags: D3D12_RAYTRACING_PIPELINE_FLAGS,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_PIPELINE_CONFIG1 {}
impl ::core::clone::Clone for D3D12_RAYTRACING_PIPELINE_CONFIG1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_PIPELINE_CONFIG1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_PIPELINE_CONFIG1")
            .field("MaxTraceRecursionDepth", &self.MaxTraceRecursionDepth)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_PIPELINE_CONFIG1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RAYTRACING_PIPELINE_CONFIG1 {
    fn eq(&self, other: &Self) -> bool {
        self.MaxTraceRecursionDepth == other.MaxTraceRecursionDepth && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_PIPELINE_CONFIG1 {}
impl ::core::default::Default for D3D12_RAYTRACING_PIPELINE_CONFIG1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RAYTRACING_SHADER_CONFIG {
    pub MaxPayloadSizeInBytes: u32,
    pub MaxAttributeSizeInBytes: u32,
}
impl ::core::marker::Copy for D3D12_RAYTRACING_SHADER_CONFIG {}
impl ::core::clone::Clone for D3D12_RAYTRACING_SHADER_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RAYTRACING_SHADER_CONFIG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RAYTRACING_SHADER_CONFIG")
            .field("MaxPayloadSizeInBytes", &self.MaxPayloadSizeInBytes)
            .field("MaxAttributeSizeInBytes", &self.MaxAttributeSizeInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RAYTRACING_SHADER_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RAYTRACING_SHADER_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.MaxPayloadSizeInBytes == other.MaxPayloadSizeInBytes
            && self.MaxAttributeSizeInBytes == other.MaxAttributeSizeInBytes
    }
}
impl ::core::cmp::Eq for D3D12_RAYTRACING_SHADER_CONFIG {}
impl ::core::default::Default for D3D12_RAYTRACING_SHADER_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_PASS_BEGINNING_ACCESS {
    pub Type: D3D12_RENDER_PASS_BEGINNING_ACCESS_TYPE,
    pub Anonymous: D3D12_RENDER_PASS_BEGINNING_ACCESS_0,
}
impl ::core::marker::Copy for D3D12_RENDER_PASS_BEGINNING_ACCESS {}
impl ::core::clone::Clone for D3D12_RENDER_PASS_BEGINNING_ACCESS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_BEGINNING_ACCESS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RENDER_PASS_BEGINNING_ACCESS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_RENDER_PASS_BEGINNING_ACCESS_0 {
    pub Clear: D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS,
    pub PreserveLocal: D3D12_RENDER_PASS_BEGINNING_ACCESS_PRESERVE_LOCAL_PARAMETERS,
}
impl ::core::marker::Copy for D3D12_RENDER_PASS_BEGINNING_ACCESS_0 {}
impl ::core::clone::Clone for D3D12_RENDER_PASS_BEGINNING_ACCESS_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_BEGINNING_ACCESS_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RENDER_PASS_BEGINNING_ACCESS_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS {
    pub ClearValue: D3D12_CLEAR_VALUE,
}
impl ::core::marker::Copy for D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS {}
impl ::core::clone::Clone for D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RENDER_PASS_BEGINNING_ACCESS_CLEAR_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_PASS_BEGINNING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    pub AdditionalWidth: u32,
    pub AdditionalHeight: u32,
}
impl ::core::marker::Copy for D3D12_RENDER_PASS_BEGINNING_ACCESS_PRESERVE_LOCAL_PARAMETERS {}
impl ::core::clone::Clone for D3D12_RENDER_PASS_BEGINNING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RENDER_PASS_BEGINNING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RENDER_PASS_BEGINNING_ACCESS_PRESERVE_LOCAL_PARAMETERS")
            .field("AdditionalWidth", &self.AdditionalWidth)
            .field("AdditionalHeight", &self.AdditionalHeight)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_BEGINNING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RENDER_PASS_BEGINNING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.AdditionalWidth == other.AdditionalWidth
            && self.AdditionalHeight == other.AdditionalHeight
    }
}
impl ::core::cmp::Eq for D3D12_RENDER_PASS_BEGINNING_ACCESS_PRESERVE_LOCAL_PARAMETERS {}
impl ::core::default::Default for D3D12_RENDER_PASS_BEGINNING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_PASS_DEPTH_STENCIL_DESC {
    pub cpuDescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    pub DepthBeginningAccess: D3D12_RENDER_PASS_BEGINNING_ACCESS,
    pub StencilBeginningAccess: D3D12_RENDER_PASS_BEGINNING_ACCESS,
    pub DepthEndingAccess: D3D12_RENDER_PASS_ENDING_ACCESS,
    pub StencilEndingAccess: D3D12_RENDER_PASS_ENDING_ACCESS,
}
impl ::core::clone::Clone for D3D12_RENDER_PASS_DEPTH_STENCIL_DESC {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_DEPTH_STENCIL_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RENDER_PASS_DEPTH_STENCIL_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_PASS_ENDING_ACCESS {
    pub Type: D3D12_RENDER_PASS_ENDING_ACCESS_TYPE,
    pub Anonymous: D3D12_RENDER_PASS_ENDING_ACCESS_0,
}
impl ::core::clone::Clone for D3D12_RENDER_PASS_ENDING_ACCESS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_ENDING_ACCESS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RENDER_PASS_ENDING_ACCESS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_RENDER_PASS_ENDING_ACCESS_0 {
    pub Resolve: ::std::mem::ManuallyDrop<D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS>,
    pub PreserveLocal: D3D12_RENDER_PASS_ENDING_ACCESS_PRESERVE_LOCAL_PARAMETERS,
}
impl ::core::clone::Clone for D3D12_RENDER_PASS_ENDING_ACCESS_0 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_ENDING_ACCESS_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RENDER_PASS_ENDING_ACCESS_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_PASS_ENDING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    pub AdditionalWidth: u32,
    pub AdditionalHeight: u32,
}
impl ::core::marker::Copy for D3D12_RENDER_PASS_ENDING_ACCESS_PRESERVE_LOCAL_PARAMETERS {}
impl ::core::clone::Clone for D3D12_RENDER_PASS_ENDING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RENDER_PASS_ENDING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RENDER_PASS_ENDING_ACCESS_PRESERVE_LOCAL_PARAMETERS")
            .field("AdditionalWidth", &self.AdditionalWidth)
            .field("AdditionalHeight", &self.AdditionalHeight)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_ENDING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RENDER_PASS_ENDING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.AdditionalWidth == other.AdditionalWidth
            && self.AdditionalHeight == other.AdditionalHeight
    }
}
impl ::core::cmp::Eq for D3D12_RENDER_PASS_ENDING_ACCESS_PRESERVE_LOCAL_PARAMETERS {}
impl ::core::default::Default for D3D12_RENDER_PASS_ENDING_ACCESS_PRESERVE_LOCAL_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS {
    pub pSrcResource: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub pDstResource: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub SubresourceCount: u32,
    pub pSubresourceParameters:
        *const D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS,
    pub Format: DXGI_FORMAT,
    pub ResolveMode: D3D12_RESOLVE_MODE,
    pub PreserveResolveSource: ::windows::Win32::Foundation::BOOL,
}
impl ::core::clone::Clone for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS")
            .field("pSrcResource", &self.pSrcResource)
            .field("pDstResource", &self.pDstResource)
            .field("SubresourceCount", &self.SubresourceCount)
            .field("pSubresourceParameters", &self.pSubresourceParameters)
            .field("Format", &self.Format)
            .field("ResolveMode", &self.ResolveMode)
            .field("PreserveResolveSource", &self.PreserveResolveSource)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.pSrcResource == other.pSrcResource
            && self.pDstResource == other.pDstResource
            && self.SubresourceCount == other.SubresourceCount
            && self.pSubresourceParameters == other.pSubresourceParameters
            && self.Format == other.Format
            && self.ResolveMode == other.ResolveMode
            && self.PreserveResolveSource == other.PreserveResolveSource
    }
}
impl ::core::cmp::Eq for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS {}
impl ::core::default::Default for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS {
    pub SrcSubresource: u32,
    pub DstSubresource: u32,
    pub DstX: u32,
    pub DstY: u32,
    pub SrcRect: ::windows::Win32::Foundation::RECT,
}
impl ::core::marker::Copy for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS {}
impl ::core::clone::Clone for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS")
            .field("SrcSubresource", &self.SrcSubresource)
            .field("DstSubresource", &self.DstSubresource)
            .field("DstX", &self.DstX)
            .field("DstY", &self.DstY)
            .field("SrcRect", &self.SrcRect)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS {
    fn eq(&self, other: &Self) -> bool {
        self.SrcSubresource == other.SrcSubresource
            && self.DstSubresource == other.DstSubresource
            && self.DstX == other.DstX
            && self.DstY == other.DstY
            && self.SrcRect == other.SrcRect
    }
}
impl ::core::cmp::Eq for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS {}
impl ::core::default::Default for D3D12_RENDER_PASS_ENDING_ACCESS_RESOLVE_SUBRESOURCE_PARAMETERS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_PASS_RENDER_TARGET_DESC {
    pub cpuDescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
    pub BeginningAccess: D3D12_RENDER_PASS_BEGINNING_ACCESS,
    pub EndingAccess: D3D12_RENDER_PASS_ENDING_ACCESS,
}
impl ::core::clone::Clone for D3D12_RENDER_PASS_RENDER_TARGET_DESC {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_PASS_RENDER_TARGET_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RENDER_PASS_RENDER_TARGET_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_TARGET_BLEND_DESC {
    pub BlendEnable: ::windows::Win32::Foundation::BOOL,
    pub LogicOpEnable: ::windows::Win32::Foundation::BOOL,
    pub SrcBlend: D3D12_BLEND,
    pub DestBlend: D3D12_BLEND,
    pub BlendOp: D3D12_BLEND_OP,
    pub SrcBlendAlpha: D3D12_BLEND,
    pub DestBlendAlpha: D3D12_BLEND,
    pub BlendOpAlpha: D3D12_BLEND_OP,
    pub LogicOp: D3D12_LOGIC_OP,
    pub RenderTargetWriteMask: u8,
}
impl ::core::marker::Copy for D3D12_RENDER_TARGET_BLEND_DESC {}
impl ::core::clone::Clone for D3D12_RENDER_TARGET_BLEND_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RENDER_TARGET_BLEND_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RENDER_TARGET_BLEND_DESC")
            .field("BlendEnable", &self.BlendEnable)
            .field("LogicOpEnable", &self.LogicOpEnable)
            .field("SrcBlend", &self.SrcBlend)
            .field("DestBlend", &self.DestBlend)
            .field("BlendOp", &self.BlendOp)
            .field("SrcBlendAlpha", &self.SrcBlendAlpha)
            .field("DestBlendAlpha", &self.DestBlendAlpha)
            .field("BlendOpAlpha", &self.BlendOpAlpha)
            .field("LogicOp", &self.LogicOp)
            .field("RenderTargetWriteMask", &self.RenderTargetWriteMask)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_TARGET_BLEND_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RENDER_TARGET_BLEND_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.BlendEnable == other.BlendEnable
            && self.LogicOpEnable == other.LogicOpEnable
            && self.SrcBlend == other.SrcBlend
            && self.DestBlend == other.DestBlend
            && self.BlendOp == other.BlendOp
            && self.SrcBlendAlpha == other.SrcBlendAlpha
            && self.DestBlendAlpha == other.DestBlendAlpha
            && self.BlendOpAlpha == other.BlendOpAlpha
            && self.LogicOp == other.LogicOp
            && self.RenderTargetWriteMask == other.RenderTargetWriteMask
    }
}
impl ::core::cmp::Eq for D3D12_RENDER_TARGET_BLEND_DESC {}
impl ::core::default::Default for D3D12_RENDER_TARGET_BLEND_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RENDER_TARGET_VIEW_DESC {
    pub Format: DXGI_FORMAT,
    pub ViewDimension: D3D12_RTV_DIMENSION,
    pub Anonymous: D3D12_RENDER_TARGET_VIEW_DESC_0,
}
impl ::core::marker::Copy for D3D12_RENDER_TARGET_VIEW_DESC {}
impl ::core::clone::Clone for D3D12_RENDER_TARGET_VIEW_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_TARGET_VIEW_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RENDER_TARGET_VIEW_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_RENDER_TARGET_VIEW_DESC_0 {
    pub Buffer: D3D12_BUFFER_RTV,
    pub Texture1D: D3D12_TEX1D_RTV,
    pub Texture1DArray: D3D12_TEX1D_ARRAY_RTV,
    pub Texture2D: D3D12_TEX2D_RTV,
    pub Texture2DArray: D3D12_TEX2D_ARRAY_RTV,
    pub Texture2DMS: D3D12_TEX2DMS_RTV,
    pub Texture2DMSArray: D3D12_TEX2DMS_ARRAY_RTV,
    pub Texture3D: D3D12_TEX3D_RTV,
}
impl ::core::marker::Copy for D3D12_RENDER_TARGET_VIEW_DESC_0 {}
impl ::core::clone::Clone for D3D12_RENDER_TARGET_VIEW_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_RENDER_TARGET_VIEW_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RENDER_TARGET_VIEW_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    pub pMotionVectorHeap:
        ::std::mem::ManuallyDrop<::core::option::Option<ID3D12VideoMotionVectorHeap>>,
    pub PixelWidth: u32,
    pub PixelHeight: u32,
}
impl ::core::clone::Clone for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT")
            .field("pMotionVectorHeap", &self.pMotionVectorHeap)
            .field("PixelWidth", &self.PixelWidth)
            .field("PixelHeight", &self.PixelHeight)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.pMotionVectorHeap == other.pMotionVectorHeap
            && self.PixelWidth == other.PixelWidth
            && self.PixelHeight == other.PixelHeight
    }
}
impl ::core::cmp::Eq for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {}
impl ::core::default::Default for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    pub pMotionVectorTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub MotionVectorCoordinate: D3D12_RESOURCE_COORDINATE,
}
impl ::core::clone::Clone for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT")
            .field("pMotionVectorTexture2D", &self.pMotionVectorTexture2D)
            .field("MotionVectorCoordinate", &self.MotionVectorCoordinate)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.pMotionVectorTexture2D == other.pMotionVectorTexture2D
            && self.MotionVectorCoordinate == other.MotionVectorCoordinate
    }
}
impl ::core::cmp::Eq for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {}
impl ::core::default::Default for D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOURCE_ALIASING_BARRIER {
    pub pResourceBefore: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub pResourceAfter: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
}
impl ::core::clone::Clone for D3D12_RESOURCE_ALIASING_BARRIER {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_RESOURCE_ALIASING_BARRIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOURCE_ALIASING_BARRIER")
            .field("pResourceBefore", &self.pResourceBefore)
            .field("pResourceAfter", &self.pResourceAfter)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_ALIASING_BARRIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOURCE_ALIASING_BARRIER {
    fn eq(&self, other: &Self) -> bool {
        self.pResourceBefore == other.pResourceBefore && self.pResourceAfter == other.pResourceAfter
    }
}
impl ::core::cmp::Eq for D3D12_RESOURCE_ALIASING_BARRIER {}
impl ::core::default::Default for D3D12_RESOURCE_ALIASING_BARRIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOURCE_ALLOCATION_INFO {
    pub SizeInBytes: u64,
    pub Alignment: u64,
}
impl ::core::marker::Copy for D3D12_RESOURCE_ALLOCATION_INFO {}
impl ::core::clone::Clone for D3D12_RESOURCE_ALLOCATION_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RESOURCE_ALLOCATION_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOURCE_ALLOCATION_INFO")
            .field("SizeInBytes", &self.SizeInBytes)
            .field("Alignment", &self.Alignment)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_ALLOCATION_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOURCE_ALLOCATION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.SizeInBytes == other.SizeInBytes && self.Alignment == other.Alignment
    }
}
impl ::core::cmp::Eq for D3D12_RESOURCE_ALLOCATION_INFO {}
impl ::core::default::Default for D3D12_RESOURCE_ALLOCATION_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOURCE_ALLOCATION_INFO1 {
    pub Offset: u64,
    pub Alignment: u64,
    pub SizeInBytes: u64,
}
impl ::core::marker::Copy for D3D12_RESOURCE_ALLOCATION_INFO1 {}
impl ::core::clone::Clone for D3D12_RESOURCE_ALLOCATION_INFO1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RESOURCE_ALLOCATION_INFO1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOURCE_ALLOCATION_INFO1")
            .field("Offset", &self.Offset)
            .field("Alignment", &self.Alignment)
            .field("SizeInBytes", &self.SizeInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_ALLOCATION_INFO1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOURCE_ALLOCATION_INFO1 {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset
            && self.Alignment == other.Alignment
            && self.SizeInBytes == other.SizeInBytes
    }
}
impl ::core::cmp::Eq for D3D12_RESOURCE_ALLOCATION_INFO1 {}
impl ::core::default::Default for D3D12_RESOURCE_ALLOCATION_INFO1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOURCE_BARRIER {
    pub Type: D3D12_RESOURCE_BARRIER_TYPE,
    pub Flags: D3D12_RESOURCE_BARRIER_FLAGS,
    pub Anonymous: D3D12_RESOURCE_BARRIER_0,
}
impl ::core::clone::Clone for D3D12_RESOURCE_BARRIER {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_BARRIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RESOURCE_BARRIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_RESOURCE_BARRIER_0 {
    pub Transition: ::std::mem::ManuallyDrop<D3D12_RESOURCE_TRANSITION_BARRIER>,
    pub Aliasing: ::std::mem::ManuallyDrop<D3D12_RESOURCE_ALIASING_BARRIER>,
    pub UAV: ::std::mem::ManuallyDrop<D3D12_RESOURCE_UAV_BARRIER>,
}
impl ::core::clone::Clone for D3D12_RESOURCE_BARRIER_0 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_BARRIER_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_RESOURCE_BARRIER_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOURCE_COORDINATE {
    pub X: u64,
    pub Y: u32,
    pub Z: u32,
    pub SubresourceIndex: u32,
}
impl ::core::marker::Copy for D3D12_RESOURCE_COORDINATE {}
impl ::core::clone::Clone for D3D12_RESOURCE_COORDINATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RESOURCE_COORDINATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOURCE_COORDINATE")
            .field("X", &self.X)
            .field("Y", &self.Y)
            .field("Z", &self.Z)
            .field("SubresourceIndex", &self.SubresourceIndex)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_COORDINATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOURCE_COORDINATE {
    fn eq(&self, other: &Self) -> bool {
        self.X == other.X
            && self.Y == other.Y
            && self.Z == other.Z
            && self.SubresourceIndex == other.SubresourceIndex
    }
}
impl ::core::cmp::Eq for D3D12_RESOURCE_COORDINATE {}
impl ::core::default::Default for D3D12_RESOURCE_COORDINATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOURCE_DESC {
    pub Dimension: D3D12_RESOURCE_DIMENSION,
    pub Alignment: u64,
    pub Width: u64,
    pub Height: u32,
    pub DepthOrArraySize: u16,
    pub MipLevels: u16,
    pub Format: DXGI_FORMAT,
    pub SampleDesc: ::windows::Win32::Graphics::Dxgi::Common::DXGI_SAMPLE_DESC,
    pub Layout: D3D12_TEXTURE_LAYOUT,
    pub Flags: D3D12_RESOURCE_FLAGS,
}
impl ::core::marker::Copy for D3D12_RESOURCE_DESC {}
impl ::core::clone::Clone for D3D12_RESOURCE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RESOURCE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOURCE_DESC")
            .field("Dimension", &self.Dimension)
            .field("Alignment", &self.Alignment)
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .field("DepthOrArraySize", &self.DepthOrArraySize)
            .field("MipLevels", &self.MipLevels)
            .field("Format", &self.Format)
            .field("SampleDesc", &self.SampleDesc)
            .field("Layout", &self.Layout)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOURCE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Dimension == other.Dimension
            && self.Alignment == other.Alignment
            && self.Width == other.Width
            && self.Height == other.Height
            && self.DepthOrArraySize == other.DepthOrArraySize
            && self.MipLevels == other.MipLevels
            && self.Format == other.Format
            && self.SampleDesc == other.SampleDesc
            && self.Layout == other.Layout
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_RESOURCE_DESC {}
impl ::core::default::Default for D3D12_RESOURCE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOURCE_DESC1 {
    pub Dimension: D3D12_RESOURCE_DIMENSION,
    pub Alignment: u64,
    pub Width: u64,
    pub Height: u32,
    pub DepthOrArraySize: u16,
    pub MipLevels: u16,
    pub Format: DXGI_FORMAT,
    pub SampleDesc: ::windows::Win32::Graphics::Dxgi::Common::DXGI_SAMPLE_DESC,
    pub Layout: D3D12_TEXTURE_LAYOUT,
    pub Flags: D3D12_RESOURCE_FLAGS,
    pub SamplerFeedbackMipRegion: D3D12_MIP_REGION,
}
impl ::core::marker::Copy for D3D12_RESOURCE_DESC1 {}
impl ::core::clone::Clone for D3D12_RESOURCE_DESC1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RESOURCE_DESC1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOURCE_DESC1")
            .field("Dimension", &self.Dimension)
            .field("Alignment", &self.Alignment)
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .field("DepthOrArraySize", &self.DepthOrArraySize)
            .field("MipLevels", &self.MipLevels)
            .field("Format", &self.Format)
            .field("SampleDesc", &self.SampleDesc)
            .field("Layout", &self.Layout)
            .field("Flags", &self.Flags)
            .field("SamplerFeedbackMipRegion", &self.SamplerFeedbackMipRegion)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_DESC1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOURCE_DESC1 {
    fn eq(&self, other: &Self) -> bool {
        self.Dimension == other.Dimension
            && self.Alignment == other.Alignment
            && self.Width == other.Width
            && self.Height == other.Height
            && self.DepthOrArraySize == other.DepthOrArraySize
            && self.MipLevels == other.MipLevels
            && self.Format == other.Format
            && self.SampleDesc == other.SampleDesc
            && self.Layout == other.Layout
            && self.Flags == other.Flags
            && self.SamplerFeedbackMipRegion == other.SamplerFeedbackMipRegion
    }
}
impl ::core::cmp::Eq for D3D12_RESOURCE_DESC1 {}
impl ::core::default::Default for D3D12_RESOURCE_DESC1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOURCE_TRANSITION_BARRIER {
    pub pResource: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub Subresource: u32,
    pub StateBefore: D3D12_RESOURCE_STATES,
    pub StateAfter: D3D12_RESOURCE_STATES,
}
impl ::core::clone::Clone for D3D12_RESOURCE_TRANSITION_BARRIER {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_RESOURCE_TRANSITION_BARRIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOURCE_TRANSITION_BARRIER")
            .field("pResource", &self.pResource)
            .field("Subresource", &self.Subresource)
            .field("StateBefore", &self.StateBefore)
            .field("StateAfter", &self.StateAfter)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_TRANSITION_BARRIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOURCE_TRANSITION_BARRIER {
    fn eq(&self, other: &Self) -> bool {
        self.pResource == other.pResource
            && self.Subresource == other.Subresource
            && self.StateBefore == other.StateBefore
            && self.StateAfter == other.StateAfter
    }
}
impl ::core::cmp::Eq for D3D12_RESOURCE_TRANSITION_BARRIER {}
impl ::core::default::Default for D3D12_RESOURCE_TRANSITION_BARRIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RESOURCE_UAV_BARRIER {
    pub pResource: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
}
impl ::core::clone::Clone for D3D12_RESOURCE_UAV_BARRIER {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_RESOURCE_UAV_BARRIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RESOURCE_UAV_BARRIER")
            .field("pResource", &self.pResource)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RESOURCE_UAV_BARRIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RESOURCE_UAV_BARRIER {
    fn eq(&self, other: &Self) -> bool {
        self.pResource == other.pResource
    }
}
impl ::core::cmp::Eq for D3D12_RESOURCE_UAV_BARRIER {}
impl ::core::default::Default for D3D12_RESOURCE_UAV_BARRIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_ROOT_CONSTANTS {
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
    pub Num32BitValues: u32,
}
impl ::core::marker::Copy for D3D12_ROOT_CONSTANTS {}
impl ::core::clone::Clone for D3D12_ROOT_CONSTANTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_ROOT_CONSTANTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_ROOT_CONSTANTS")
            .field("ShaderRegister", &self.ShaderRegister)
            .field("RegisterSpace", &self.RegisterSpace)
            .field("Num32BitValues", &self.Num32BitValues)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_CONSTANTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_ROOT_CONSTANTS {
    fn eq(&self, other: &Self) -> bool {
        self.ShaderRegister == other.ShaderRegister
            && self.RegisterSpace == other.RegisterSpace
            && self.Num32BitValues == other.Num32BitValues
    }
}
impl ::core::cmp::Eq for D3D12_ROOT_CONSTANTS {}
impl ::core::default::Default for D3D12_ROOT_CONSTANTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_ROOT_DESCRIPTOR {
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
}
impl ::core::marker::Copy for D3D12_ROOT_DESCRIPTOR {}
impl ::core::clone::Clone for D3D12_ROOT_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_ROOT_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_ROOT_DESCRIPTOR")
            .field("ShaderRegister", &self.ShaderRegister)
            .field("RegisterSpace", &self.RegisterSpace)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_DESCRIPTOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_ROOT_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.ShaderRegister == other.ShaderRegister && self.RegisterSpace == other.RegisterSpace
    }
}
impl ::core::cmp::Eq for D3D12_ROOT_DESCRIPTOR {}
impl ::core::default::Default for D3D12_ROOT_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_ROOT_DESCRIPTOR1 {
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
    pub Flags: D3D12_ROOT_DESCRIPTOR_FLAGS,
}
impl ::core::marker::Copy for D3D12_ROOT_DESCRIPTOR1 {}
impl ::core::clone::Clone for D3D12_ROOT_DESCRIPTOR1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_ROOT_DESCRIPTOR1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_ROOT_DESCRIPTOR1")
            .field("ShaderRegister", &self.ShaderRegister)
            .field("RegisterSpace", &self.RegisterSpace)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_DESCRIPTOR1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_ROOT_DESCRIPTOR1 {
    fn eq(&self, other: &Self) -> bool {
        self.ShaderRegister == other.ShaderRegister
            && self.RegisterSpace == other.RegisterSpace
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_ROOT_DESCRIPTOR1 {}
impl ::core::default::Default for D3D12_ROOT_DESCRIPTOR1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_ROOT_DESCRIPTOR_TABLE {
    pub NumDescriptorRanges: u32,
    pub pDescriptorRanges: *const D3D12_DESCRIPTOR_RANGE,
}
impl ::core::marker::Copy for D3D12_ROOT_DESCRIPTOR_TABLE {}
impl ::core::clone::Clone for D3D12_ROOT_DESCRIPTOR_TABLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_ROOT_DESCRIPTOR_TABLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_ROOT_DESCRIPTOR_TABLE")
            .field("NumDescriptorRanges", &self.NumDescriptorRanges)
            .field("pDescriptorRanges", &self.pDescriptorRanges)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_DESCRIPTOR_TABLE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_ROOT_DESCRIPTOR_TABLE {
    fn eq(&self, other: &Self) -> bool {
        self.NumDescriptorRanges == other.NumDescriptorRanges
            && self.pDescriptorRanges == other.pDescriptorRanges
    }
}
impl ::core::cmp::Eq for D3D12_ROOT_DESCRIPTOR_TABLE {}
impl ::core::default::Default for D3D12_ROOT_DESCRIPTOR_TABLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_ROOT_DESCRIPTOR_TABLE1 {
    pub NumDescriptorRanges: u32,
    pub pDescriptorRanges: *const D3D12_DESCRIPTOR_RANGE1,
}
impl ::core::marker::Copy for D3D12_ROOT_DESCRIPTOR_TABLE1 {}
impl ::core::clone::Clone for D3D12_ROOT_DESCRIPTOR_TABLE1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_ROOT_DESCRIPTOR_TABLE1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_ROOT_DESCRIPTOR_TABLE1")
            .field("NumDescriptorRanges", &self.NumDescriptorRanges)
            .field("pDescriptorRanges", &self.pDescriptorRanges)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_DESCRIPTOR_TABLE1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_ROOT_DESCRIPTOR_TABLE1 {
    fn eq(&self, other: &Self) -> bool {
        self.NumDescriptorRanges == other.NumDescriptorRanges
            && self.pDescriptorRanges == other.pDescriptorRanges
    }
}
impl ::core::cmp::Eq for D3D12_ROOT_DESCRIPTOR_TABLE1 {}
impl ::core::default::Default for D3D12_ROOT_DESCRIPTOR_TABLE1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_ROOT_PARAMETER {
    pub ParameterType: D3D12_ROOT_PARAMETER_TYPE,
    pub Anonymous: D3D12_ROOT_PARAMETER_0,
    pub ShaderVisibility: D3D12_SHADER_VISIBILITY,
}
impl ::core::marker::Copy for D3D12_ROOT_PARAMETER {}
impl ::core::clone::Clone for D3D12_ROOT_PARAMETER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_PARAMETER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_ROOT_PARAMETER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_ROOT_PARAMETER_0 {
    pub DescriptorTable: D3D12_ROOT_DESCRIPTOR_TABLE,
    pub Constants: D3D12_ROOT_CONSTANTS,
    pub Descriptor: D3D12_ROOT_DESCRIPTOR,
}
impl ::core::marker::Copy for D3D12_ROOT_PARAMETER_0 {}
impl ::core::clone::Clone for D3D12_ROOT_PARAMETER_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_PARAMETER_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_ROOT_PARAMETER_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_ROOT_PARAMETER1 {
    pub ParameterType: D3D12_ROOT_PARAMETER_TYPE,
    pub Anonymous: D3D12_ROOT_PARAMETER1_0,
    pub ShaderVisibility: D3D12_SHADER_VISIBILITY,
}
impl ::core::marker::Copy for D3D12_ROOT_PARAMETER1 {}
impl ::core::clone::Clone for D3D12_ROOT_PARAMETER1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_PARAMETER1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_ROOT_PARAMETER1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_ROOT_PARAMETER1_0 {
    pub DescriptorTable: D3D12_ROOT_DESCRIPTOR_TABLE1,
    pub Constants: D3D12_ROOT_CONSTANTS,
    pub Descriptor: D3D12_ROOT_DESCRIPTOR1,
}
impl ::core::marker::Copy for D3D12_ROOT_PARAMETER1_0 {}
impl ::core::clone::Clone for D3D12_ROOT_PARAMETER1_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_PARAMETER1_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_ROOT_PARAMETER1_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_ROOT_SIGNATURE_DESC {
    pub NumParameters: u32,
    pub pParameters: *const D3D12_ROOT_PARAMETER,
    pub NumStaticSamplers: u32,
    pub pStaticSamplers: *const D3D12_STATIC_SAMPLER_DESC,
    pub Flags: D3D12_ROOT_SIGNATURE_FLAGS,
}
impl ::core::marker::Copy for D3D12_ROOT_SIGNATURE_DESC {}
impl ::core::clone::Clone for D3D12_ROOT_SIGNATURE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_ROOT_SIGNATURE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_ROOT_SIGNATURE_DESC")
            .field("NumParameters", &self.NumParameters)
            .field("pParameters", &self.pParameters)
            .field("NumStaticSamplers", &self.NumStaticSamplers)
            .field("pStaticSamplers", &self.pStaticSamplers)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_SIGNATURE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_ROOT_SIGNATURE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NumParameters == other.NumParameters
            && self.pParameters == other.pParameters
            && self.NumStaticSamplers == other.NumStaticSamplers
            && self.pStaticSamplers == other.pStaticSamplers
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_ROOT_SIGNATURE_DESC {}
impl ::core::default::Default for D3D12_ROOT_SIGNATURE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_ROOT_SIGNATURE_DESC1 {
    pub NumParameters: u32,
    pub pParameters: *const D3D12_ROOT_PARAMETER1,
    pub NumStaticSamplers: u32,
    pub pStaticSamplers: *const D3D12_STATIC_SAMPLER_DESC,
    pub Flags: D3D12_ROOT_SIGNATURE_FLAGS,
}
impl ::core::marker::Copy for D3D12_ROOT_SIGNATURE_DESC1 {}
impl ::core::clone::Clone for D3D12_ROOT_SIGNATURE_DESC1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_ROOT_SIGNATURE_DESC1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_ROOT_SIGNATURE_DESC1")
            .field("NumParameters", &self.NumParameters)
            .field("pParameters", &self.pParameters)
            .field("NumStaticSamplers", &self.NumStaticSamplers)
            .field("pStaticSamplers", &self.pStaticSamplers)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_SIGNATURE_DESC1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_ROOT_SIGNATURE_DESC1 {
    fn eq(&self, other: &Self) -> bool {
        self.NumParameters == other.NumParameters
            && self.pParameters == other.pParameters
            && self.NumStaticSamplers == other.NumStaticSamplers
            && self.pStaticSamplers == other.pStaticSamplers
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_ROOT_SIGNATURE_DESC1 {}
impl ::core::default::Default for D3D12_ROOT_SIGNATURE_DESC1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_ROOT_SIGNATURE_DESC2 {
    pub NumParameters: u32,
    pub pParameters: *const D3D12_ROOT_PARAMETER1,
    pub NumStaticSamplers: u32,
    pub pStaticSamplers: *const D3D12_STATIC_SAMPLER_DESC1,
    pub Flags: D3D12_ROOT_SIGNATURE_FLAGS,
}
impl ::core::marker::Copy for D3D12_ROOT_SIGNATURE_DESC2 {}
impl ::core::clone::Clone for D3D12_ROOT_SIGNATURE_DESC2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_ROOT_SIGNATURE_DESC2 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_ROOT_SIGNATURE_DESC2")
            .field("NumParameters", &self.NumParameters)
            .field("pParameters", &self.pParameters)
            .field("NumStaticSamplers", &self.NumStaticSamplers)
            .field("pStaticSamplers", &self.pStaticSamplers)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_ROOT_SIGNATURE_DESC2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_ROOT_SIGNATURE_DESC2 {
    fn eq(&self, other: &Self) -> bool {
        self.NumParameters == other.NumParameters
            && self.pParameters == other.pParameters
            && self.NumStaticSamplers == other.NumStaticSamplers
            && self.pStaticSamplers == other.pStaticSamplers
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_ROOT_SIGNATURE_DESC2 {}
impl ::core::default::Default for D3D12_ROOT_SIGNATURE_DESC2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_RT_FORMAT_ARRAY {
    pub RTFormats: [DXGI_FORMAT; 8],
    pub NumRenderTargets: u32,
}
impl ::core::marker::Copy for D3D12_RT_FORMAT_ARRAY {}
impl ::core::clone::Clone for D3D12_RT_FORMAT_ARRAY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_RT_FORMAT_ARRAY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_RT_FORMAT_ARRAY")
            .field("RTFormats", &self.RTFormats)
            .field("NumRenderTargets", &self.NumRenderTargets)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_RT_FORMAT_ARRAY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_RT_FORMAT_ARRAY {
    fn eq(&self, other: &Self) -> bool {
        self.RTFormats == other.RTFormats && self.NumRenderTargets == other.NumRenderTargets
    }
}
impl ::core::cmp::Eq for D3D12_RT_FORMAT_ARRAY {}
impl ::core::default::Default for D3D12_RT_FORMAT_ARRAY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SAMPLER_DESC {
    pub Filter: D3D12_FILTER,
    pub AddressU: D3D12_TEXTURE_ADDRESS_MODE,
    pub AddressV: D3D12_TEXTURE_ADDRESS_MODE,
    pub AddressW: D3D12_TEXTURE_ADDRESS_MODE,
    pub MipLODBias: f32,
    pub MaxAnisotropy: u32,
    pub ComparisonFunc: D3D12_COMPARISON_FUNC,
    pub BorderColor: [f32; 4],
    pub MinLOD: f32,
    pub MaxLOD: f32,
}
impl ::core::marker::Copy for D3D12_SAMPLER_DESC {}
impl ::core::clone::Clone for D3D12_SAMPLER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SAMPLER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SAMPLER_DESC")
            .field("Filter", &self.Filter)
            .field("AddressU", &self.AddressU)
            .field("AddressV", &self.AddressV)
            .field("AddressW", &self.AddressW)
            .field("MipLODBias", &self.MipLODBias)
            .field("MaxAnisotropy", &self.MaxAnisotropy)
            .field("ComparisonFunc", &self.ComparisonFunc)
            .field("BorderColor", &self.BorderColor)
            .field("MinLOD", &self.MinLOD)
            .field("MaxLOD", &self.MaxLOD)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SAMPLER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SAMPLER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Filter == other.Filter
            && self.AddressU == other.AddressU
            && self.AddressV == other.AddressV
            && self.AddressW == other.AddressW
            && self.MipLODBias == other.MipLODBias
            && self.MaxAnisotropy == other.MaxAnisotropy
            && self.ComparisonFunc == other.ComparisonFunc
            && self.BorderColor == other.BorderColor
            && self.MinLOD == other.MinLOD
            && self.MaxLOD == other.MaxLOD
    }
}
impl ::core::cmp::Eq for D3D12_SAMPLER_DESC {}
impl ::core::default::Default for D3D12_SAMPLER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SAMPLER_DESC2 {
    pub Filter: D3D12_FILTER,
    pub AddressU: D3D12_TEXTURE_ADDRESS_MODE,
    pub AddressV: D3D12_TEXTURE_ADDRESS_MODE,
    pub AddressW: D3D12_TEXTURE_ADDRESS_MODE,
    pub MipLODBias: f32,
    pub MaxAnisotropy: u32,
    pub ComparisonFunc: D3D12_COMPARISON_FUNC,
    pub Anonymous: D3D12_SAMPLER_DESC2_0,
    pub MinLOD: f32,
    pub MaxLOD: f32,
    pub Flags: D3D12_SAMPLER_FLAGS,
}
impl ::core::marker::Copy for D3D12_SAMPLER_DESC2 {}
impl ::core::clone::Clone for D3D12_SAMPLER_DESC2 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_SAMPLER_DESC2 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_SAMPLER_DESC2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_SAMPLER_DESC2_0 {
    pub FloatBorderColor: [f32; 4],
    pub UintBorderColor: [u32; 4],
}
impl ::core::marker::Copy for D3D12_SAMPLER_DESC2_0 {}
impl ::core::clone::Clone for D3D12_SAMPLER_DESC2_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_SAMPLER_DESC2_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_SAMPLER_DESC2_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SAMPLE_MASK {
    pub SampleMask: u32,
}
impl ::core::marker::Copy for D3D12_SAMPLE_MASK {}
impl ::core::clone::Clone for D3D12_SAMPLE_MASK {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SAMPLE_MASK {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SAMPLE_MASK")
            .field("SampleMask", &self.SampleMask)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SAMPLE_MASK {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SAMPLE_MASK {
    fn eq(&self, other: &Self) -> bool {
        self.SampleMask == other.SampleMask
    }
}
impl ::core::cmp::Eq for D3D12_SAMPLE_MASK {}
impl ::core::default::Default for D3D12_SAMPLE_MASK {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SAMPLE_POSITION {
    pub X: i8,
    pub Y: i8,
}
impl ::core::marker::Copy for D3D12_SAMPLE_POSITION {}
impl ::core::clone::Clone for D3D12_SAMPLE_POSITION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SAMPLE_POSITION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SAMPLE_POSITION")
            .field("X", &self.X)
            .field("Y", &self.Y)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SAMPLE_POSITION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SAMPLE_POSITION {
    fn eq(&self, other: &Self) -> bool {
        self.X == other.X && self.Y == other.Y
    }
}
impl ::core::cmp::Eq for D3D12_SAMPLE_POSITION {}
impl ::core::default::Default for D3D12_SAMPLE_POSITION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER {
    pub DriverOpaqueGUID: ::windows::core::GUID,
    pub DriverOpaqueVersioningData: [u8; 16],
}
impl ::core::marker::Copy for D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER {}
impl ::core::clone::Clone for D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER")
            .field("DriverOpaqueGUID", &self.DriverOpaqueGUID)
            .field(
                "DriverOpaqueVersioningData",
                &self.DriverOpaqueVersioningData,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER {
    fn eq(&self, other: &Self) -> bool {
        self.DriverOpaqueGUID == other.DriverOpaqueGUID
            && self.DriverOpaqueVersioningData == other.DriverOpaqueVersioningData
    }
}
impl ::core::cmp::Eq for D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER {}
impl ::core::default::Default for D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER {
    pub DriverMatchingIdentifier: D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    pub SerializedSizeInBytesIncludingHeader: u64,
    pub DeserializedSizeInBytes: u64,
    pub NumBottomLevelAccelerationStructurePointersAfterHeader: u64,
}
impl ::core::marker::Copy for D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER {}
impl ::core::clone::Clone for D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER")
            .field("DriverMatchingIdentifier", &self.DriverMatchingIdentifier)
            .field(
                "SerializedSizeInBytesIncludingHeader",
                &self.SerializedSizeInBytesIncludingHeader,
            )
            .field("DeserializedSizeInBytes", &self.DeserializedSizeInBytes)
            .field(
                "NumBottomLevelAccelerationStructurePointersAfterHeader",
                &self.NumBottomLevelAccelerationStructurePointersAfterHeader,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER {
    fn eq(&self, other: &Self) -> bool {
        self.DriverMatchingIdentifier == other.DriverMatchingIdentifier
            && self.SerializedSizeInBytesIncludingHeader
                == other.SerializedSizeInBytesIncludingHeader
            && self.DeserializedSizeInBytes == other.DeserializedSizeInBytes
            && self.NumBottomLevelAccelerationStructurePointersAfterHeader
                == other.NumBottomLevelAccelerationStructurePointersAfterHeader
    }
}
impl ::core::cmp::Eq for D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER {}
impl ::core::default::Default for D3D12_SERIALIZED_RAYTRACING_ACCELERATION_STRUCTURE_HEADER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SET_GENERIC_PIPELINE_DESC {
    pub ProgramIdentifier: D3D12_PROGRAM_IDENTIFIER,
}
impl ::core::marker::Copy for D3D12_SET_GENERIC_PIPELINE_DESC {}
impl ::core::clone::Clone for D3D12_SET_GENERIC_PIPELINE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SET_GENERIC_PIPELINE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SET_GENERIC_PIPELINE_DESC")
            .field("ProgramIdentifier", &self.ProgramIdentifier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SET_GENERIC_PIPELINE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SET_GENERIC_PIPELINE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.ProgramIdentifier == other.ProgramIdentifier
    }
}
impl ::core::cmp::Eq for D3D12_SET_GENERIC_PIPELINE_DESC {}
impl ::core::default::Default for D3D12_SET_GENERIC_PIPELINE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SET_PROGRAM_DESC {
    pub Type: D3D12_PROGRAM_TYPE,
    pub Anonymous: D3D12_SET_PROGRAM_DESC_0,
}
impl ::core::marker::Copy for D3D12_SET_PROGRAM_DESC {}
impl ::core::clone::Clone for D3D12_SET_PROGRAM_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_SET_PROGRAM_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_SET_PROGRAM_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_SET_PROGRAM_DESC_0 {
    pub GenericPipeline: D3D12_SET_GENERIC_PIPELINE_DESC,
    pub RaytracingPipeline: D3D12_SET_RAYTRACING_PIPELINE_DESC,
    pub WorkGraph: D3D12_SET_WORK_GRAPH_DESC,
}
impl ::core::marker::Copy for D3D12_SET_PROGRAM_DESC_0 {}
impl ::core::clone::Clone for D3D12_SET_PROGRAM_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_SET_PROGRAM_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_SET_PROGRAM_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SET_RAYTRACING_PIPELINE_DESC {
    pub ProgramIdentifier: D3D12_PROGRAM_IDENTIFIER,
}
impl ::core::marker::Copy for D3D12_SET_RAYTRACING_PIPELINE_DESC {}
impl ::core::clone::Clone for D3D12_SET_RAYTRACING_PIPELINE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SET_RAYTRACING_PIPELINE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SET_RAYTRACING_PIPELINE_DESC")
            .field("ProgramIdentifier", &self.ProgramIdentifier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SET_RAYTRACING_PIPELINE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SET_RAYTRACING_PIPELINE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.ProgramIdentifier == other.ProgramIdentifier
    }
}
impl ::core::cmp::Eq for D3D12_SET_RAYTRACING_PIPELINE_DESC {}
impl ::core::default::Default for D3D12_SET_RAYTRACING_PIPELINE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SET_WORK_GRAPH_DESC {
    pub ProgramIdentifier: D3D12_PROGRAM_IDENTIFIER,
    pub Flags: D3D12_SET_WORK_GRAPH_FLAGS,
    pub BackingMemory: D3D12_GPU_VIRTUAL_ADDRESS_RANGE,
    pub NodeLocalRootArgumentsTable: D3D12_GPU_VIRTUAL_ADDRESS_RANGE_AND_STRIDE,
}
impl ::core::marker::Copy for D3D12_SET_WORK_GRAPH_DESC {}
impl ::core::clone::Clone for D3D12_SET_WORK_GRAPH_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SET_WORK_GRAPH_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SET_WORK_GRAPH_DESC")
            .field("ProgramIdentifier", &self.ProgramIdentifier)
            .field("Flags", &self.Flags)
            .field("BackingMemory", &self.BackingMemory)
            .field(
                "NodeLocalRootArgumentsTable",
                &self.NodeLocalRootArgumentsTable,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SET_WORK_GRAPH_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SET_WORK_GRAPH_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.ProgramIdentifier == other.ProgramIdentifier
            && self.Flags == other.Flags
            && self.BackingMemory == other.BackingMemory
            && self.NodeLocalRootArgumentsTable == other.NodeLocalRootArgumentsTable
    }
}
impl ::core::cmp::Eq for D3D12_SET_WORK_GRAPH_DESC {}
impl ::core::default::Default for D3D12_SET_WORK_GRAPH_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SHADER_BUFFER_DESC {
    pub Name: ::windows::core::PCSTR,
    pub Type: D3D_CBUFFER_TYPE,
    pub Variables: u32,
    pub Size: u32,
    pub uFlags: u32,
}
impl ::core::marker::Copy for D3D12_SHADER_BUFFER_DESC {}
impl ::core::clone::Clone for D3D12_SHADER_BUFFER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SHADER_BUFFER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SHADER_BUFFER_DESC")
            .field("Name", &self.Name)
            .field("Type", &self.Type)
            .field("Variables", &self.Variables)
            .field("Size", &self.Size)
            .field("uFlags", &self.uFlags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_BUFFER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SHADER_BUFFER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name
            && self.Type == other.Type
            && self.Variables == other.Variables
            && self.Size == other.Size
            && self.uFlags == other.uFlags
    }
}
impl ::core::cmp::Eq for D3D12_SHADER_BUFFER_DESC {}
impl ::core::default::Default for D3D12_SHADER_BUFFER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SHADER_BYTECODE {
    pub pShaderBytecode: *const ::core::ffi::c_void,
    pub BytecodeLength: usize,
}
impl ::core::marker::Copy for D3D12_SHADER_BYTECODE {}
impl ::core::clone::Clone for D3D12_SHADER_BYTECODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SHADER_BYTECODE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SHADER_BYTECODE")
            .field("pShaderBytecode", &self.pShaderBytecode)
            .field("BytecodeLength", &self.BytecodeLength)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_BYTECODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SHADER_BYTECODE {
    fn eq(&self, other: &Self) -> bool {
        self.pShaderBytecode == other.pShaderBytecode && self.BytecodeLength == other.BytecodeLength
    }
}
impl ::core::cmp::Eq for D3D12_SHADER_BYTECODE {}
impl ::core::default::Default for D3D12_SHADER_BYTECODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SHADER_CACHE_SESSION_DESC {
    pub Identifier: ::windows::core::GUID,
    pub Mode: D3D12_SHADER_CACHE_MODE,
    pub Flags: D3D12_SHADER_CACHE_FLAGS,
    pub MaximumInMemoryCacheSizeBytes: u32,
    pub MaximumInMemoryCacheEntries: u32,
    pub MaximumValueFileSizeBytes: u32,
    pub Version: u64,
}
impl ::core::marker::Copy for D3D12_SHADER_CACHE_SESSION_DESC {}
impl ::core::clone::Clone for D3D12_SHADER_CACHE_SESSION_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SHADER_CACHE_SESSION_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SHADER_CACHE_SESSION_DESC")
            .field("Identifier", &self.Identifier)
            .field("Mode", &self.Mode)
            .field("Flags", &self.Flags)
            .field(
                "MaximumInMemoryCacheSizeBytes",
                &self.MaximumInMemoryCacheSizeBytes,
            )
            .field(
                "MaximumInMemoryCacheEntries",
                &self.MaximumInMemoryCacheEntries,
            )
            .field("MaximumValueFileSizeBytes", &self.MaximumValueFileSizeBytes)
            .field("Version", &self.Version)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_CACHE_SESSION_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SHADER_CACHE_SESSION_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Identifier == other.Identifier
            && self.Mode == other.Mode
            && self.Flags == other.Flags
            && self.MaximumInMemoryCacheSizeBytes == other.MaximumInMemoryCacheSizeBytes
            && self.MaximumInMemoryCacheEntries == other.MaximumInMemoryCacheEntries
            && self.MaximumValueFileSizeBytes == other.MaximumValueFileSizeBytes
            && self.Version == other.Version
    }
}
impl ::core::cmp::Eq for D3D12_SHADER_CACHE_SESSION_DESC {}
impl ::core::default::Default for D3D12_SHADER_CACHE_SESSION_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SHADER_DESC {
    pub Version: u32,
    pub Creator: ::windows::core::PCSTR,
    pub Flags: u32,
    pub ConstantBuffers: u32,
    pub BoundResources: u32,
    pub InputParameters: u32,
    pub OutputParameters: u32,
    pub InstructionCount: u32,
    pub TempRegisterCount: u32,
    pub TempArrayCount: u32,
    pub DefCount: u32,
    pub DclCount: u32,
    pub TextureNormalInstructions: u32,
    pub TextureLoadInstructions: u32,
    pub TextureCompInstructions: u32,
    pub TextureBiasInstructions: u32,
    pub TextureGradientInstructions: u32,
    pub FloatInstructionCount: u32,
    pub IntInstructionCount: u32,
    pub UintInstructionCount: u32,
    pub StaticFlowControlCount: u32,
    pub DynamicFlowControlCount: u32,
    pub MacroInstructionCount: u32,
    pub ArrayInstructionCount: u32,
    pub CutInstructionCount: u32,
    pub EmitInstructionCount: u32,
    pub GSOutputTopology: D3D_PRIMITIVE_TOPOLOGY,
    pub GSMaxOutputVertexCount: u32,
    pub InputPrimitive: D3D_PRIMITIVE,
    pub PatchConstantParameters: u32,
    pub cGSInstanceCount: u32,
    pub cControlPoints: u32,
    pub HSOutputPrimitive: D3D_TESSELLATOR_OUTPUT_PRIMITIVE,
    pub HSPartitioning: D3D_TESSELLATOR_PARTITIONING,
    pub TessellatorDomain: D3D_TESSELLATOR_DOMAIN,
    pub cBarrierInstructions: u32,
    pub cInterlockedInstructions: u32,
    pub cTextureStoreInstructions: u32,
}
impl ::core::marker::Copy for D3D12_SHADER_DESC {}
impl ::core::clone::Clone for D3D12_SHADER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SHADER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SHADER_DESC")
            .field("Version", &self.Version)
            .field("Creator", &self.Creator)
            .field("Flags", &self.Flags)
            .field("ConstantBuffers", &self.ConstantBuffers)
            .field("BoundResources", &self.BoundResources)
            .field("InputParameters", &self.InputParameters)
            .field("OutputParameters", &self.OutputParameters)
            .field("InstructionCount", &self.InstructionCount)
            .field("TempRegisterCount", &self.TempRegisterCount)
            .field("TempArrayCount", &self.TempArrayCount)
            .field("DefCount", &self.DefCount)
            .field("DclCount", &self.DclCount)
            .field("TextureNormalInstructions", &self.TextureNormalInstructions)
            .field("TextureLoadInstructions", &self.TextureLoadInstructions)
            .field("TextureCompInstructions", &self.TextureCompInstructions)
            .field("TextureBiasInstructions", &self.TextureBiasInstructions)
            .field(
                "TextureGradientInstructions",
                &self.TextureGradientInstructions,
            )
            .field("FloatInstructionCount", &self.FloatInstructionCount)
            .field("IntInstructionCount", &self.IntInstructionCount)
            .field("UintInstructionCount", &self.UintInstructionCount)
            .field("StaticFlowControlCount", &self.StaticFlowControlCount)
            .field("DynamicFlowControlCount", &self.DynamicFlowControlCount)
            .field("MacroInstructionCount", &self.MacroInstructionCount)
            .field("ArrayInstructionCount", &self.ArrayInstructionCount)
            .field("CutInstructionCount", &self.CutInstructionCount)
            .field("EmitInstructionCount", &self.EmitInstructionCount)
            .field("GSOutputTopology", &self.GSOutputTopology)
            .field("GSMaxOutputVertexCount", &self.GSMaxOutputVertexCount)
            .field("InputPrimitive", &self.InputPrimitive)
            .field("PatchConstantParameters", &self.PatchConstantParameters)
            .field("cGSInstanceCount", &self.cGSInstanceCount)
            .field("cControlPoints", &self.cControlPoints)
            .field("HSOutputPrimitive", &self.HSOutputPrimitive)
            .field("HSPartitioning", &self.HSPartitioning)
            .field("TessellatorDomain", &self.TessellatorDomain)
            .field("cBarrierInstructions", &self.cBarrierInstructions)
            .field("cInterlockedInstructions", &self.cInterlockedInstructions)
            .field("cTextureStoreInstructions", &self.cTextureStoreInstructions)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SHADER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Version == other.Version
            && self.Creator == other.Creator
            && self.Flags == other.Flags
            && self.ConstantBuffers == other.ConstantBuffers
            && self.BoundResources == other.BoundResources
            && self.InputParameters == other.InputParameters
            && self.OutputParameters == other.OutputParameters
            && self.InstructionCount == other.InstructionCount
            && self.TempRegisterCount == other.TempRegisterCount
            && self.TempArrayCount == other.TempArrayCount
            && self.DefCount == other.DefCount
            && self.DclCount == other.DclCount
            && self.TextureNormalInstructions == other.TextureNormalInstructions
            && self.TextureLoadInstructions == other.TextureLoadInstructions
            && self.TextureCompInstructions == other.TextureCompInstructions
            && self.TextureBiasInstructions == other.TextureBiasInstructions
            && self.TextureGradientInstructions == other.TextureGradientInstructions
            && self.FloatInstructionCount == other.FloatInstructionCount
            && self.IntInstructionCount == other.IntInstructionCount
            && self.UintInstructionCount == other.UintInstructionCount
            && self.StaticFlowControlCount == other.StaticFlowControlCount
            && self.DynamicFlowControlCount == other.DynamicFlowControlCount
            && self.MacroInstructionCount == other.MacroInstructionCount
            && self.ArrayInstructionCount == other.ArrayInstructionCount
            && self.CutInstructionCount == other.CutInstructionCount
            && self.EmitInstructionCount == other.EmitInstructionCount
            && self.GSOutputTopology == other.GSOutputTopology
            && self.GSMaxOutputVertexCount == other.GSMaxOutputVertexCount
            && self.InputPrimitive == other.InputPrimitive
            && self.PatchConstantParameters == other.PatchConstantParameters
            && self.cGSInstanceCount == other.cGSInstanceCount
            && self.cControlPoints == other.cControlPoints
            && self.HSOutputPrimitive == other.HSOutputPrimitive
            && self.HSPartitioning == other.HSPartitioning
            && self.TessellatorDomain == other.TessellatorDomain
            && self.cBarrierInstructions == other.cBarrierInstructions
            && self.cInterlockedInstructions == other.cInterlockedInstructions
            && self.cTextureStoreInstructions == other.cTextureStoreInstructions
    }
}
impl ::core::cmp::Eq for D3D12_SHADER_DESC {}
impl ::core::default::Default for D3D12_SHADER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SHADER_INPUT_BIND_DESC {
    pub Name: ::windows::core::PCSTR,
    pub Type: D3D_SHADER_INPUT_TYPE,
    pub BindPoint: u32,
    pub BindCount: u32,
    pub uFlags: u32,
    pub ReturnType: D3D_RESOURCE_RETURN_TYPE,
    pub Dimension: D3D_SRV_DIMENSION,
    pub NumSamples: u32,
    pub Space: u32,
    pub uID: u32,
}
impl ::core::marker::Copy for D3D12_SHADER_INPUT_BIND_DESC {}
impl ::core::clone::Clone for D3D12_SHADER_INPUT_BIND_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SHADER_INPUT_BIND_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SHADER_INPUT_BIND_DESC")
            .field("Name", &self.Name)
            .field("Type", &self.Type)
            .field("BindPoint", &self.BindPoint)
            .field("BindCount", &self.BindCount)
            .field("uFlags", &self.uFlags)
            .field("ReturnType", &self.ReturnType)
            .field("Dimension", &self.Dimension)
            .field("NumSamples", &self.NumSamples)
            .field("Space", &self.Space)
            .field("uID", &self.uID)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_INPUT_BIND_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SHADER_INPUT_BIND_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name
            && self.Type == other.Type
            && self.BindPoint == other.BindPoint
            && self.BindCount == other.BindCount
            && self.uFlags == other.uFlags
            && self.ReturnType == other.ReturnType
            && self.Dimension == other.Dimension
            && self.NumSamples == other.NumSamples
            && self.Space == other.Space
            && self.uID == other.uID
    }
}
impl ::core::cmp::Eq for D3D12_SHADER_INPUT_BIND_DESC {}
impl ::core::default::Default for D3D12_SHADER_INPUT_BIND_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SHADER_NODE {
    pub Shader: ::windows::core::PCWSTR,
    pub OverridesType: D3D12_NODE_OVERRIDES_TYPE,
    pub Anonymous: D3D12_SHADER_NODE_0,
}
impl ::core::marker::Copy for D3D12_SHADER_NODE {}
impl ::core::clone::Clone for D3D12_SHADER_NODE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_NODE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_SHADER_NODE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_SHADER_NODE_0 {
    pub pBroadcastingLaunchOverrides: *const D3D12_BROADCASTING_LAUNCH_OVERRIDES,
    pub pCoalescingLaunchOverrides: *const D3D12_COALESCING_LAUNCH_OVERRIDES,
    pub pThreadLaunchOverrides: *const D3D12_THREAD_LAUNCH_OVERRIDES,
}
impl ::core::marker::Copy for D3D12_SHADER_NODE_0 {}
impl ::core::clone::Clone for D3D12_SHADER_NODE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_NODE_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_SHADER_NODE_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SHADER_RESOURCE_VIEW_DESC {
    pub Format: DXGI_FORMAT,
    pub ViewDimension: D3D12_SRV_DIMENSION,
    pub Shader4ComponentMapping: u32,
    pub Anonymous: D3D12_SHADER_RESOURCE_VIEW_DESC_0,
}
impl ::core::marker::Copy for D3D12_SHADER_RESOURCE_VIEW_DESC {}
impl ::core::clone::Clone for D3D12_SHADER_RESOURCE_VIEW_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_RESOURCE_VIEW_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_SHADER_RESOURCE_VIEW_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_SHADER_RESOURCE_VIEW_DESC_0 {
    pub Buffer: D3D12_BUFFER_SRV,
    pub Texture1D: D3D12_TEX1D_SRV,
    pub Texture1DArray: D3D12_TEX1D_ARRAY_SRV,
    pub Texture2D: D3D12_TEX2D_SRV,
    pub Texture2DArray: D3D12_TEX2D_ARRAY_SRV,
    pub Texture2DMS: D3D12_TEX2DMS_SRV,
    pub Texture2DMSArray: D3D12_TEX2DMS_ARRAY_SRV,
    pub Texture3D: D3D12_TEX3D_SRV,
    pub TextureCube: D3D12_TEXCUBE_SRV,
    pub TextureCubeArray: D3D12_TEXCUBE_ARRAY_SRV,
    pub RaytracingAccelerationStructure: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_SRV,
}
impl ::core::marker::Copy for D3D12_SHADER_RESOURCE_VIEW_DESC_0 {}
impl ::core::clone::Clone for D3D12_SHADER_RESOURCE_VIEW_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_RESOURCE_VIEW_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_SHADER_RESOURCE_VIEW_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SHADER_TYPE_DESC {
    pub Class: D3D_SHADER_VARIABLE_CLASS,
    pub Type: D3D_SHADER_VARIABLE_TYPE,
    pub Rows: u32,
    pub Columns: u32,
    pub Elements: u32,
    pub Members: u32,
    pub Offset: u32,
    pub Name: ::windows::core::PCSTR,
}
impl ::core::marker::Copy for D3D12_SHADER_TYPE_DESC {}
impl ::core::clone::Clone for D3D12_SHADER_TYPE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SHADER_TYPE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SHADER_TYPE_DESC")
            .field("Class", &self.Class)
            .field("Type", &self.Type)
            .field("Rows", &self.Rows)
            .field("Columns", &self.Columns)
            .field("Elements", &self.Elements)
            .field("Members", &self.Members)
            .field("Offset", &self.Offset)
            .field("Name", &self.Name)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_TYPE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SHADER_TYPE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Class == other.Class
            && self.Type == other.Type
            && self.Rows == other.Rows
            && self.Columns == other.Columns
            && self.Elements == other.Elements
            && self.Members == other.Members
            && self.Offset == other.Offset
            && self.Name == other.Name
    }
}
impl ::core::cmp::Eq for D3D12_SHADER_TYPE_DESC {}
impl ::core::default::Default for D3D12_SHADER_TYPE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SHADER_VARIABLE_DESC {
    pub Name: ::windows::core::PCSTR,
    pub StartOffset: u32,
    pub Size: u32,
    pub uFlags: u32,
    pub DefaultValue: *mut ::core::ffi::c_void,
    pub StartTexture: u32,
    pub TextureSize: u32,
    pub StartSampler: u32,
    pub SamplerSize: u32,
}
impl ::core::marker::Copy for D3D12_SHADER_VARIABLE_DESC {}
impl ::core::clone::Clone for D3D12_SHADER_VARIABLE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SHADER_VARIABLE_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SHADER_VARIABLE_DESC")
            .field("Name", &self.Name)
            .field("StartOffset", &self.StartOffset)
            .field("Size", &self.Size)
            .field("uFlags", &self.uFlags)
            .field("DefaultValue", &self.DefaultValue)
            .field("StartTexture", &self.StartTexture)
            .field("TextureSize", &self.TextureSize)
            .field("StartSampler", &self.StartSampler)
            .field("SamplerSize", &self.SamplerSize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SHADER_VARIABLE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SHADER_VARIABLE_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name
            && self.StartOffset == other.StartOffset
            && self.Size == other.Size
            && self.uFlags == other.uFlags
            && self.DefaultValue == other.DefaultValue
            && self.StartTexture == other.StartTexture
            && self.TextureSize == other.TextureSize
            && self.StartSampler == other.StartSampler
            && self.SamplerSize == other.SamplerSize
    }
}
impl ::core::cmp::Eq for D3D12_SHADER_VARIABLE_DESC {}
impl ::core::default::Default for D3D12_SHADER_VARIABLE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SIGNATURE_PARAMETER_DESC {
    pub SemanticName: ::windows::core::PCSTR,
    pub SemanticIndex: u32,
    pub Register: u32,
    pub SystemValueType: D3D_NAME,
    pub ComponentType: D3D_REGISTER_COMPONENT_TYPE,
    pub Mask: u8,
    pub ReadWriteMask: u8,
    pub Stream: u32,
    pub MinPrecision: D3D_MIN_PRECISION,
}
impl ::core::marker::Copy for D3D12_SIGNATURE_PARAMETER_DESC {}
impl ::core::clone::Clone for D3D12_SIGNATURE_PARAMETER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SIGNATURE_PARAMETER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SIGNATURE_PARAMETER_DESC")
            .field("SemanticName", &self.SemanticName)
            .field("SemanticIndex", &self.SemanticIndex)
            .field("Register", &self.Register)
            .field("SystemValueType", &self.SystemValueType)
            .field("ComponentType", &self.ComponentType)
            .field("Mask", &self.Mask)
            .field("ReadWriteMask", &self.ReadWriteMask)
            .field("Stream", &self.Stream)
            .field("MinPrecision", &self.MinPrecision)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SIGNATURE_PARAMETER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SIGNATURE_PARAMETER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.SemanticName == other.SemanticName
            && self.SemanticIndex == other.SemanticIndex
            && self.Register == other.Register
            && self.SystemValueType == other.SystemValueType
            && self.ComponentType == other.ComponentType
            && self.Mask == other.Mask
            && self.ReadWriteMask == other.ReadWriteMask
            && self.Stream == other.Stream
            && self.MinPrecision == other.MinPrecision
    }
}
impl ::core::cmp::Eq for D3D12_SIGNATURE_PARAMETER_DESC {}
impl ::core::default::Default for D3D12_SIGNATURE_PARAMETER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SO_DECLARATION_ENTRY {
    pub Stream: u32,
    pub SemanticName: ::windows::core::PCSTR,
    pub SemanticIndex: u32,
    pub StartComponent: u8,
    pub ComponentCount: u8,
    pub OutputSlot: u8,
}
impl ::core::marker::Copy for D3D12_SO_DECLARATION_ENTRY {}
impl ::core::clone::Clone for D3D12_SO_DECLARATION_ENTRY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SO_DECLARATION_ENTRY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SO_DECLARATION_ENTRY")
            .field("Stream", &self.Stream)
            .field("SemanticName", &self.SemanticName)
            .field("SemanticIndex", &self.SemanticIndex)
            .field("StartComponent", &self.StartComponent)
            .field("ComponentCount", &self.ComponentCount)
            .field("OutputSlot", &self.OutputSlot)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SO_DECLARATION_ENTRY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SO_DECLARATION_ENTRY {
    fn eq(&self, other: &Self) -> bool {
        self.Stream == other.Stream
            && self.SemanticName == other.SemanticName
            && self.SemanticIndex == other.SemanticIndex
            && self.StartComponent == other.StartComponent
            && self.ComponentCount == other.ComponentCount
            && self.OutputSlot == other.OutputSlot
    }
}
impl ::core::cmp::Eq for D3D12_SO_DECLARATION_ENTRY {}
impl ::core::default::Default for D3D12_SO_DECLARATION_ENTRY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_STATE_OBJECT_CONFIG {
    pub Flags: D3D12_STATE_OBJECT_FLAGS,
}
impl ::core::marker::Copy for D3D12_STATE_OBJECT_CONFIG {}
impl ::core::clone::Clone for D3D12_STATE_OBJECT_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_STATE_OBJECT_CONFIG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_STATE_OBJECT_CONFIG")
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_STATE_OBJECT_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_STATE_OBJECT_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_STATE_OBJECT_CONFIG {}
impl ::core::default::Default for D3D12_STATE_OBJECT_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_STATE_OBJECT_DESC {
    pub Type: D3D12_STATE_OBJECT_TYPE,
    pub NumSubobjects: u32,
    pub pSubobjects: *const D3D12_STATE_SUBOBJECT,
}
impl ::core::marker::Copy for D3D12_STATE_OBJECT_DESC {}
impl ::core::clone::Clone for D3D12_STATE_OBJECT_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_STATE_OBJECT_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_STATE_OBJECT_DESC")
            .field("Type", &self.Type)
            .field("NumSubobjects", &self.NumSubobjects)
            .field("pSubobjects", &self.pSubobjects)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_STATE_OBJECT_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_STATE_OBJECT_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type
            && self.NumSubobjects == other.NumSubobjects
            && self.pSubobjects == other.pSubobjects
    }
}
impl ::core::cmp::Eq for D3D12_STATE_OBJECT_DESC {}
impl ::core::default::Default for D3D12_STATE_OBJECT_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_STATE_SUBOBJECT {
    pub Type: D3D12_STATE_SUBOBJECT_TYPE,
    pub pDesc: *const ::core::ffi::c_void,
}
impl ::core::marker::Copy for D3D12_STATE_SUBOBJECT {}
impl ::core::clone::Clone for D3D12_STATE_SUBOBJECT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_STATE_SUBOBJECT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_STATE_SUBOBJECT")
            .field("Type", &self.Type)
            .field("pDesc", &self.pDesc)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_STATE_SUBOBJECT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_STATE_SUBOBJECT {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.pDesc == other.pDesc
    }
}
impl ::core::cmp::Eq for D3D12_STATE_SUBOBJECT {}
impl ::core::default::Default for D3D12_STATE_SUBOBJECT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_STATIC_SAMPLER_DESC {
    pub Filter: D3D12_FILTER,
    pub AddressU: D3D12_TEXTURE_ADDRESS_MODE,
    pub AddressV: D3D12_TEXTURE_ADDRESS_MODE,
    pub AddressW: D3D12_TEXTURE_ADDRESS_MODE,
    pub MipLODBias: f32,
    pub MaxAnisotropy: u32,
    pub ComparisonFunc: D3D12_COMPARISON_FUNC,
    pub BorderColor: D3D12_STATIC_BORDER_COLOR,
    pub MinLOD: f32,
    pub MaxLOD: f32,
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
    pub ShaderVisibility: D3D12_SHADER_VISIBILITY,
}
impl ::core::marker::Copy for D3D12_STATIC_SAMPLER_DESC {}
impl ::core::clone::Clone for D3D12_STATIC_SAMPLER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_STATIC_SAMPLER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_STATIC_SAMPLER_DESC")
            .field("Filter", &self.Filter)
            .field("AddressU", &self.AddressU)
            .field("AddressV", &self.AddressV)
            .field("AddressW", &self.AddressW)
            .field("MipLODBias", &self.MipLODBias)
            .field("MaxAnisotropy", &self.MaxAnisotropy)
            .field("ComparisonFunc", &self.ComparisonFunc)
            .field("BorderColor", &self.BorderColor)
            .field("MinLOD", &self.MinLOD)
            .field("MaxLOD", &self.MaxLOD)
            .field("ShaderRegister", &self.ShaderRegister)
            .field("RegisterSpace", &self.RegisterSpace)
            .field("ShaderVisibility", &self.ShaderVisibility)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_STATIC_SAMPLER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_STATIC_SAMPLER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Filter == other.Filter
            && self.AddressU == other.AddressU
            && self.AddressV == other.AddressV
            && self.AddressW == other.AddressW
            && self.MipLODBias == other.MipLODBias
            && self.MaxAnisotropy == other.MaxAnisotropy
            && self.ComparisonFunc == other.ComparisonFunc
            && self.BorderColor == other.BorderColor
            && self.MinLOD == other.MinLOD
            && self.MaxLOD == other.MaxLOD
            && self.ShaderRegister == other.ShaderRegister
            && self.RegisterSpace == other.RegisterSpace
            && self.ShaderVisibility == other.ShaderVisibility
    }
}
impl ::core::cmp::Eq for D3D12_STATIC_SAMPLER_DESC {}
impl ::core::default::Default for D3D12_STATIC_SAMPLER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_STATIC_SAMPLER_DESC1 {
    pub Filter: D3D12_FILTER,
    pub AddressU: D3D12_TEXTURE_ADDRESS_MODE,
    pub AddressV: D3D12_TEXTURE_ADDRESS_MODE,
    pub AddressW: D3D12_TEXTURE_ADDRESS_MODE,
    pub MipLODBias: f32,
    pub MaxAnisotropy: u32,
    pub ComparisonFunc: D3D12_COMPARISON_FUNC,
    pub BorderColor: D3D12_STATIC_BORDER_COLOR,
    pub MinLOD: f32,
    pub MaxLOD: f32,
    pub ShaderRegister: u32,
    pub RegisterSpace: u32,
    pub ShaderVisibility: D3D12_SHADER_VISIBILITY,
    pub Flags: D3D12_SAMPLER_FLAGS,
}
impl ::core::marker::Copy for D3D12_STATIC_SAMPLER_DESC1 {}
impl ::core::clone::Clone for D3D12_STATIC_SAMPLER_DESC1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_STATIC_SAMPLER_DESC1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_STATIC_SAMPLER_DESC1")
            .field("Filter", &self.Filter)
            .field("AddressU", &self.AddressU)
            .field("AddressV", &self.AddressV)
            .field("AddressW", &self.AddressW)
            .field("MipLODBias", &self.MipLODBias)
            .field("MaxAnisotropy", &self.MaxAnisotropy)
            .field("ComparisonFunc", &self.ComparisonFunc)
            .field("BorderColor", &self.BorderColor)
            .field("MinLOD", &self.MinLOD)
            .field("MaxLOD", &self.MaxLOD)
            .field("ShaderRegister", &self.ShaderRegister)
            .field("RegisterSpace", &self.RegisterSpace)
            .field("ShaderVisibility", &self.ShaderVisibility)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_STATIC_SAMPLER_DESC1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_STATIC_SAMPLER_DESC1 {
    fn eq(&self, other: &Self) -> bool {
        self.Filter == other.Filter
            && self.AddressU == other.AddressU
            && self.AddressV == other.AddressV
            && self.AddressW == other.AddressW
            && self.MipLODBias == other.MipLODBias
            && self.MaxAnisotropy == other.MaxAnisotropy
            && self.ComparisonFunc == other.ComparisonFunc
            && self.BorderColor == other.BorderColor
            && self.MinLOD == other.MinLOD
            && self.MaxLOD == other.MaxLOD
            && self.ShaderRegister == other.ShaderRegister
            && self.RegisterSpace == other.RegisterSpace
            && self.ShaderVisibility == other.ShaderVisibility
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_STATIC_SAMPLER_DESC1 {}
impl ::core::default::Default for D3D12_STATIC_SAMPLER_DESC1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_STREAM_OUTPUT_BUFFER_VIEW {
    pub BufferLocation: u64,
    pub SizeInBytes: u64,
    pub BufferFilledSizeLocation: u64,
}
impl ::core::marker::Copy for D3D12_STREAM_OUTPUT_BUFFER_VIEW {}
impl ::core::clone::Clone for D3D12_STREAM_OUTPUT_BUFFER_VIEW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_STREAM_OUTPUT_BUFFER_VIEW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_STREAM_OUTPUT_BUFFER_VIEW")
            .field("BufferLocation", &self.BufferLocation)
            .field("SizeInBytes", &self.SizeInBytes)
            .field("BufferFilledSizeLocation", &self.BufferFilledSizeLocation)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_STREAM_OUTPUT_BUFFER_VIEW {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_STREAM_OUTPUT_BUFFER_VIEW {
    fn eq(&self, other: &Self) -> bool {
        self.BufferLocation == other.BufferLocation
            && self.SizeInBytes == other.SizeInBytes
            && self.BufferFilledSizeLocation == other.BufferFilledSizeLocation
    }
}
impl ::core::cmp::Eq for D3D12_STREAM_OUTPUT_BUFFER_VIEW {}
impl ::core::default::Default for D3D12_STREAM_OUTPUT_BUFFER_VIEW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_STREAM_OUTPUT_DESC {
    pub pSODeclaration: *const D3D12_SO_DECLARATION_ENTRY,
    pub NumEntries: u32,
    pub pBufferStrides: *const u32,
    pub NumStrides: u32,
    pub RasterizedStream: u32,
}
impl ::core::marker::Copy for D3D12_STREAM_OUTPUT_DESC {}
impl ::core::clone::Clone for D3D12_STREAM_OUTPUT_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_STREAM_OUTPUT_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_STREAM_OUTPUT_DESC")
            .field("pSODeclaration", &self.pSODeclaration)
            .field("NumEntries", &self.NumEntries)
            .field("pBufferStrides", &self.pBufferStrides)
            .field("NumStrides", &self.NumStrides)
            .field("RasterizedStream", &self.RasterizedStream)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_STREAM_OUTPUT_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_STREAM_OUTPUT_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.pSODeclaration == other.pSODeclaration
            && self.NumEntries == other.NumEntries
            && self.pBufferStrides == other.pBufferStrides
            && self.NumStrides == other.NumStrides
            && self.RasterizedStream == other.RasterizedStream
    }
}
impl ::core::cmp::Eq for D3D12_STREAM_OUTPUT_DESC {}
impl ::core::default::Default for D3D12_STREAM_OUTPUT_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    pub pSubobjectToAssociate: *const D3D12_STATE_SUBOBJECT,
    pub NumExports: u32,
    pub pExports: *const ::windows::core::PCWSTR,
}
impl ::core::marker::Copy for D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION {}
impl ::core::clone::Clone for D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION")
            .field("pSubobjectToAssociate", &self.pSubobjectToAssociate)
            .field("NumExports", &self.NumExports)
            .field("pExports", &self.pExports)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    fn eq(&self, other: &Self) -> bool {
        self.pSubobjectToAssociate == other.pSubobjectToAssociate
            && self.NumExports == other.NumExports
            && self.pExports == other.pExports
    }
}
impl ::core::cmp::Eq for D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION {}
impl ::core::default::Default for D3D12_SUBOBJECT_TO_EXPORTS_ASSOCIATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SUBRESOURCE_DATA {
    pub pData: *const ::core::ffi::c_void,
    pub RowPitch: isize,
    pub SlicePitch: isize,
}
impl ::core::marker::Copy for D3D12_SUBRESOURCE_DATA {}
impl ::core::clone::Clone for D3D12_SUBRESOURCE_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SUBRESOURCE_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SUBRESOURCE_DATA")
            .field("pData", &self.pData)
            .field("RowPitch", &self.RowPitch)
            .field("SlicePitch", &self.SlicePitch)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SUBRESOURCE_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SUBRESOURCE_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.pData == other.pData
            && self.RowPitch == other.RowPitch
            && self.SlicePitch == other.SlicePitch
    }
}
impl ::core::cmp::Eq for D3D12_SUBRESOURCE_DATA {}
impl ::core::default::Default for D3D12_SUBRESOURCE_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SUBRESOURCE_FOOTPRINT {
    pub Format: DXGI_FORMAT,
    pub Width: u32,
    pub Height: u32,
    pub Depth: u32,
    pub RowPitch: u32,
}
impl ::core::marker::Copy for D3D12_SUBRESOURCE_FOOTPRINT {}
impl ::core::clone::Clone for D3D12_SUBRESOURCE_FOOTPRINT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SUBRESOURCE_FOOTPRINT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SUBRESOURCE_FOOTPRINT")
            .field("Format", &self.Format)
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .field("Depth", &self.Depth)
            .field("RowPitch", &self.RowPitch)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SUBRESOURCE_FOOTPRINT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SUBRESOURCE_FOOTPRINT {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format
            && self.Width == other.Width
            && self.Height == other.Height
            && self.Depth == other.Depth
            && self.RowPitch == other.RowPitch
    }
}
impl ::core::cmp::Eq for D3D12_SUBRESOURCE_FOOTPRINT {}
impl ::core::default::Default for D3D12_SUBRESOURCE_FOOTPRINT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SUBRESOURCE_INFO {
    pub Offset: u64,
    pub RowPitch: u32,
    pub DepthPitch: u32,
}
impl ::core::marker::Copy for D3D12_SUBRESOURCE_INFO {}
impl ::core::clone::Clone for D3D12_SUBRESOURCE_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SUBRESOURCE_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SUBRESOURCE_INFO")
            .field("Offset", &self.Offset)
            .field("RowPitch", &self.RowPitch)
            .field("DepthPitch", &self.DepthPitch)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SUBRESOURCE_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SUBRESOURCE_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset
            && self.RowPitch == other.RowPitch
            && self.DepthPitch == other.DepthPitch
    }
}
impl ::core::cmp::Eq for D3D12_SUBRESOURCE_INFO {}
impl ::core::default::Default for D3D12_SUBRESOURCE_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SUBRESOURCE_RANGE_UINT64 {
    pub Subresource: u32,
    pub Range: D3D12_RANGE_UINT64,
}
impl ::core::marker::Copy for D3D12_SUBRESOURCE_RANGE_UINT64 {}
impl ::core::clone::Clone for D3D12_SUBRESOURCE_RANGE_UINT64 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SUBRESOURCE_RANGE_UINT64 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SUBRESOURCE_RANGE_UINT64")
            .field("Subresource", &self.Subresource)
            .field("Range", &self.Range)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SUBRESOURCE_RANGE_UINT64 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SUBRESOURCE_RANGE_UINT64 {
    fn eq(&self, other: &Self) -> bool {
        self.Subresource == other.Subresource && self.Range == other.Range
    }
}
impl ::core::cmp::Eq for D3D12_SUBRESOURCE_RANGE_UINT64 {}
impl ::core::default::Default for D3D12_SUBRESOURCE_RANGE_UINT64 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_SUBRESOURCE_TILING {
    pub WidthInTiles: u32,
    pub HeightInTiles: u16,
    pub DepthInTiles: u16,
    pub StartTileIndexInOverallResource: u32,
}
impl ::core::marker::Copy for D3D12_SUBRESOURCE_TILING {}
impl ::core::clone::Clone for D3D12_SUBRESOURCE_TILING {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_SUBRESOURCE_TILING {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_SUBRESOURCE_TILING")
            .field("WidthInTiles", &self.WidthInTiles)
            .field("HeightInTiles", &self.HeightInTiles)
            .field("DepthInTiles", &self.DepthInTiles)
            .field(
                "StartTileIndexInOverallResource",
                &self.StartTileIndexInOverallResource,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_SUBRESOURCE_TILING {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_SUBRESOURCE_TILING {
    fn eq(&self, other: &Self) -> bool {
        self.WidthInTiles == other.WidthInTiles
            && self.HeightInTiles == other.HeightInTiles
            && self.DepthInTiles == other.DepthInTiles
            && self.StartTileIndexInOverallResource == other.StartTileIndexInOverallResource
    }
}
impl ::core::cmp::Eq for D3D12_SUBRESOURCE_TILING {}
impl ::core::default::Default for D3D12_SUBRESOURCE_TILING {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX1D_ARRAY_DSV {
    pub MipSlice: u32,
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
}
impl ::core::marker::Copy for D3D12_TEX1D_ARRAY_DSV {}
impl ::core::clone::Clone for D3D12_TEX1D_ARRAY_DSV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX1D_ARRAY_DSV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX1D_ARRAY_DSV")
            .field("MipSlice", &self.MipSlice)
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX1D_ARRAY_DSV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX1D_ARRAY_DSV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
            && self.FirstArraySlice == other.FirstArraySlice
            && self.ArraySize == other.ArraySize
    }
}
impl ::core::cmp::Eq for D3D12_TEX1D_ARRAY_DSV {}
impl ::core::default::Default for D3D12_TEX1D_ARRAY_DSV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX1D_ARRAY_RTV {
    pub MipSlice: u32,
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
}
impl ::core::marker::Copy for D3D12_TEX1D_ARRAY_RTV {}
impl ::core::clone::Clone for D3D12_TEX1D_ARRAY_RTV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX1D_ARRAY_RTV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX1D_ARRAY_RTV")
            .field("MipSlice", &self.MipSlice)
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX1D_ARRAY_RTV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX1D_ARRAY_RTV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
            && self.FirstArraySlice == other.FirstArraySlice
            && self.ArraySize == other.ArraySize
    }
}
impl ::core::cmp::Eq for D3D12_TEX1D_ARRAY_RTV {}
impl ::core::default::Default for D3D12_TEX1D_ARRAY_RTV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX1D_ARRAY_SRV {
    pub MostDetailedMip: u32,
    pub MipLevels: u32,
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
    pub ResourceMinLODClamp: f32,
}
impl ::core::marker::Copy for D3D12_TEX1D_ARRAY_SRV {}
impl ::core::clone::Clone for D3D12_TEX1D_ARRAY_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX1D_ARRAY_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX1D_ARRAY_SRV")
            .field("MostDetailedMip", &self.MostDetailedMip)
            .field("MipLevels", &self.MipLevels)
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .field("ResourceMinLODClamp", &self.ResourceMinLODClamp)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX1D_ARRAY_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX1D_ARRAY_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.MostDetailedMip == other.MostDetailedMip
            && self.MipLevels == other.MipLevels
            && self.FirstArraySlice == other.FirstArraySlice
            && self.ArraySize == other.ArraySize
            && self.ResourceMinLODClamp == other.ResourceMinLODClamp
    }
}
impl ::core::cmp::Eq for D3D12_TEX1D_ARRAY_SRV {}
impl ::core::default::Default for D3D12_TEX1D_ARRAY_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX1D_ARRAY_UAV {
    pub MipSlice: u32,
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
}
impl ::core::marker::Copy for D3D12_TEX1D_ARRAY_UAV {}
impl ::core::clone::Clone for D3D12_TEX1D_ARRAY_UAV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX1D_ARRAY_UAV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX1D_ARRAY_UAV")
            .field("MipSlice", &self.MipSlice)
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX1D_ARRAY_UAV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX1D_ARRAY_UAV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
            && self.FirstArraySlice == other.FirstArraySlice
            && self.ArraySize == other.ArraySize
    }
}
impl ::core::cmp::Eq for D3D12_TEX1D_ARRAY_UAV {}
impl ::core::default::Default for D3D12_TEX1D_ARRAY_UAV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX1D_DSV {
    pub MipSlice: u32,
}
impl ::core::marker::Copy for D3D12_TEX1D_DSV {}
impl ::core::clone::Clone for D3D12_TEX1D_DSV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX1D_DSV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX1D_DSV")
            .field("MipSlice", &self.MipSlice)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX1D_DSV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX1D_DSV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
    }
}
impl ::core::cmp::Eq for D3D12_TEX1D_DSV {}
impl ::core::default::Default for D3D12_TEX1D_DSV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX1D_RTV {
    pub MipSlice: u32,
}
impl ::core::marker::Copy for D3D12_TEX1D_RTV {}
impl ::core::clone::Clone for D3D12_TEX1D_RTV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX1D_RTV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX1D_RTV")
            .field("MipSlice", &self.MipSlice)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX1D_RTV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX1D_RTV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
    }
}
impl ::core::cmp::Eq for D3D12_TEX1D_RTV {}
impl ::core::default::Default for D3D12_TEX1D_RTV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX1D_SRV {
    pub MostDetailedMip: u32,
    pub MipLevels: u32,
    pub ResourceMinLODClamp: f32,
}
impl ::core::marker::Copy for D3D12_TEX1D_SRV {}
impl ::core::clone::Clone for D3D12_TEX1D_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX1D_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX1D_SRV")
            .field("MostDetailedMip", &self.MostDetailedMip)
            .field("MipLevels", &self.MipLevels)
            .field("ResourceMinLODClamp", &self.ResourceMinLODClamp)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX1D_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX1D_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.MostDetailedMip == other.MostDetailedMip
            && self.MipLevels == other.MipLevels
            && self.ResourceMinLODClamp == other.ResourceMinLODClamp
    }
}
impl ::core::cmp::Eq for D3D12_TEX1D_SRV {}
impl ::core::default::Default for D3D12_TEX1D_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX1D_UAV {
    pub MipSlice: u32,
}
impl ::core::marker::Copy for D3D12_TEX1D_UAV {}
impl ::core::clone::Clone for D3D12_TEX1D_UAV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX1D_UAV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX1D_UAV")
            .field("MipSlice", &self.MipSlice)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX1D_UAV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX1D_UAV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
    }
}
impl ::core::cmp::Eq for D3D12_TEX1D_UAV {}
impl ::core::default::Default for D3D12_TEX1D_UAV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2DMS_ARRAY_DSV {
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
}
impl ::core::marker::Copy for D3D12_TEX2DMS_ARRAY_DSV {}
impl ::core::clone::Clone for D3D12_TEX2DMS_ARRAY_DSV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2DMS_ARRAY_DSV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2DMS_ARRAY_DSV")
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2DMS_ARRAY_DSV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2DMS_ARRAY_DSV {
    fn eq(&self, other: &Self) -> bool {
        self.FirstArraySlice == other.FirstArraySlice && self.ArraySize == other.ArraySize
    }
}
impl ::core::cmp::Eq for D3D12_TEX2DMS_ARRAY_DSV {}
impl ::core::default::Default for D3D12_TEX2DMS_ARRAY_DSV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2DMS_ARRAY_RTV {
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
}
impl ::core::marker::Copy for D3D12_TEX2DMS_ARRAY_RTV {}
impl ::core::clone::Clone for D3D12_TEX2DMS_ARRAY_RTV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2DMS_ARRAY_RTV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2DMS_ARRAY_RTV")
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2DMS_ARRAY_RTV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2DMS_ARRAY_RTV {
    fn eq(&self, other: &Self) -> bool {
        self.FirstArraySlice == other.FirstArraySlice && self.ArraySize == other.ArraySize
    }
}
impl ::core::cmp::Eq for D3D12_TEX2DMS_ARRAY_RTV {}
impl ::core::default::Default for D3D12_TEX2DMS_ARRAY_RTV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2DMS_ARRAY_SRV {
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
}
impl ::core::marker::Copy for D3D12_TEX2DMS_ARRAY_SRV {}
impl ::core::clone::Clone for D3D12_TEX2DMS_ARRAY_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2DMS_ARRAY_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2DMS_ARRAY_SRV")
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2DMS_ARRAY_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2DMS_ARRAY_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.FirstArraySlice == other.FirstArraySlice && self.ArraySize == other.ArraySize
    }
}
impl ::core::cmp::Eq for D3D12_TEX2DMS_ARRAY_SRV {}
impl ::core::default::Default for D3D12_TEX2DMS_ARRAY_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2DMS_ARRAY_UAV {
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
}
impl ::core::marker::Copy for D3D12_TEX2DMS_ARRAY_UAV {}
impl ::core::clone::Clone for D3D12_TEX2DMS_ARRAY_UAV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2DMS_ARRAY_UAV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2DMS_ARRAY_UAV")
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2DMS_ARRAY_UAV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2DMS_ARRAY_UAV {
    fn eq(&self, other: &Self) -> bool {
        self.FirstArraySlice == other.FirstArraySlice && self.ArraySize == other.ArraySize
    }
}
impl ::core::cmp::Eq for D3D12_TEX2DMS_ARRAY_UAV {}
impl ::core::default::Default for D3D12_TEX2DMS_ARRAY_UAV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2DMS_DSV {
    pub UnusedField_NothingToDefine: u32,
}
impl ::core::marker::Copy for D3D12_TEX2DMS_DSV {}
impl ::core::clone::Clone for D3D12_TEX2DMS_DSV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2DMS_DSV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2DMS_DSV")
            .field(
                "UnusedField_NothingToDefine",
                &self.UnusedField_NothingToDefine,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2DMS_DSV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2DMS_DSV {
    fn eq(&self, other: &Self) -> bool {
        self.UnusedField_NothingToDefine == other.UnusedField_NothingToDefine
    }
}
impl ::core::cmp::Eq for D3D12_TEX2DMS_DSV {}
impl ::core::default::Default for D3D12_TEX2DMS_DSV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2DMS_RTV {
    pub UnusedField_NothingToDefine: u32,
}
impl ::core::marker::Copy for D3D12_TEX2DMS_RTV {}
impl ::core::clone::Clone for D3D12_TEX2DMS_RTV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2DMS_RTV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2DMS_RTV")
            .field(
                "UnusedField_NothingToDefine",
                &self.UnusedField_NothingToDefine,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2DMS_RTV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2DMS_RTV {
    fn eq(&self, other: &Self) -> bool {
        self.UnusedField_NothingToDefine == other.UnusedField_NothingToDefine
    }
}
impl ::core::cmp::Eq for D3D12_TEX2DMS_RTV {}
impl ::core::default::Default for D3D12_TEX2DMS_RTV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2DMS_SRV {
    pub UnusedField_NothingToDefine: u32,
}
impl ::core::marker::Copy for D3D12_TEX2DMS_SRV {}
impl ::core::clone::Clone for D3D12_TEX2DMS_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2DMS_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2DMS_SRV")
            .field(
                "UnusedField_NothingToDefine",
                &self.UnusedField_NothingToDefine,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2DMS_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2DMS_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.UnusedField_NothingToDefine == other.UnusedField_NothingToDefine
    }
}
impl ::core::cmp::Eq for D3D12_TEX2DMS_SRV {}
impl ::core::default::Default for D3D12_TEX2DMS_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2DMS_UAV {
    pub UnusedField_NothingToDefine: u32,
}
impl ::core::marker::Copy for D3D12_TEX2DMS_UAV {}
impl ::core::clone::Clone for D3D12_TEX2DMS_UAV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2DMS_UAV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2DMS_UAV")
            .field(
                "UnusedField_NothingToDefine",
                &self.UnusedField_NothingToDefine,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2DMS_UAV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2DMS_UAV {
    fn eq(&self, other: &Self) -> bool {
        self.UnusedField_NothingToDefine == other.UnusedField_NothingToDefine
    }
}
impl ::core::cmp::Eq for D3D12_TEX2DMS_UAV {}
impl ::core::default::Default for D3D12_TEX2DMS_UAV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2D_ARRAY_DSV {
    pub MipSlice: u32,
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
}
impl ::core::marker::Copy for D3D12_TEX2D_ARRAY_DSV {}
impl ::core::clone::Clone for D3D12_TEX2D_ARRAY_DSV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2D_ARRAY_DSV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2D_ARRAY_DSV")
            .field("MipSlice", &self.MipSlice)
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2D_ARRAY_DSV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2D_ARRAY_DSV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
            && self.FirstArraySlice == other.FirstArraySlice
            && self.ArraySize == other.ArraySize
    }
}
impl ::core::cmp::Eq for D3D12_TEX2D_ARRAY_DSV {}
impl ::core::default::Default for D3D12_TEX2D_ARRAY_DSV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2D_ARRAY_RTV {
    pub MipSlice: u32,
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
    pub PlaneSlice: u32,
}
impl ::core::marker::Copy for D3D12_TEX2D_ARRAY_RTV {}
impl ::core::clone::Clone for D3D12_TEX2D_ARRAY_RTV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2D_ARRAY_RTV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2D_ARRAY_RTV")
            .field("MipSlice", &self.MipSlice)
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .field("PlaneSlice", &self.PlaneSlice)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2D_ARRAY_RTV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2D_ARRAY_RTV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
            && self.FirstArraySlice == other.FirstArraySlice
            && self.ArraySize == other.ArraySize
            && self.PlaneSlice == other.PlaneSlice
    }
}
impl ::core::cmp::Eq for D3D12_TEX2D_ARRAY_RTV {}
impl ::core::default::Default for D3D12_TEX2D_ARRAY_RTV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2D_ARRAY_SRV {
    pub MostDetailedMip: u32,
    pub MipLevels: u32,
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
    pub PlaneSlice: u32,
    pub ResourceMinLODClamp: f32,
}
impl ::core::marker::Copy for D3D12_TEX2D_ARRAY_SRV {}
impl ::core::clone::Clone for D3D12_TEX2D_ARRAY_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2D_ARRAY_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2D_ARRAY_SRV")
            .field("MostDetailedMip", &self.MostDetailedMip)
            .field("MipLevels", &self.MipLevels)
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .field("PlaneSlice", &self.PlaneSlice)
            .field("ResourceMinLODClamp", &self.ResourceMinLODClamp)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2D_ARRAY_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2D_ARRAY_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.MostDetailedMip == other.MostDetailedMip
            && self.MipLevels == other.MipLevels
            && self.FirstArraySlice == other.FirstArraySlice
            && self.ArraySize == other.ArraySize
            && self.PlaneSlice == other.PlaneSlice
            && self.ResourceMinLODClamp == other.ResourceMinLODClamp
    }
}
impl ::core::cmp::Eq for D3D12_TEX2D_ARRAY_SRV {}
impl ::core::default::Default for D3D12_TEX2D_ARRAY_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2D_ARRAY_UAV {
    pub MipSlice: u32,
    pub FirstArraySlice: u32,
    pub ArraySize: u32,
    pub PlaneSlice: u32,
}
impl ::core::marker::Copy for D3D12_TEX2D_ARRAY_UAV {}
impl ::core::clone::Clone for D3D12_TEX2D_ARRAY_UAV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2D_ARRAY_UAV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2D_ARRAY_UAV")
            .field("MipSlice", &self.MipSlice)
            .field("FirstArraySlice", &self.FirstArraySlice)
            .field("ArraySize", &self.ArraySize)
            .field("PlaneSlice", &self.PlaneSlice)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2D_ARRAY_UAV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2D_ARRAY_UAV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
            && self.FirstArraySlice == other.FirstArraySlice
            && self.ArraySize == other.ArraySize
            && self.PlaneSlice == other.PlaneSlice
    }
}
impl ::core::cmp::Eq for D3D12_TEX2D_ARRAY_UAV {}
impl ::core::default::Default for D3D12_TEX2D_ARRAY_UAV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2D_DSV {
    pub MipSlice: u32,
}
impl ::core::marker::Copy for D3D12_TEX2D_DSV {}
impl ::core::clone::Clone for D3D12_TEX2D_DSV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2D_DSV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2D_DSV")
            .field("MipSlice", &self.MipSlice)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2D_DSV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2D_DSV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
    }
}
impl ::core::cmp::Eq for D3D12_TEX2D_DSV {}
impl ::core::default::Default for D3D12_TEX2D_DSV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2D_RTV {
    pub MipSlice: u32,
    pub PlaneSlice: u32,
}
impl ::core::marker::Copy for D3D12_TEX2D_RTV {}
impl ::core::clone::Clone for D3D12_TEX2D_RTV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2D_RTV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2D_RTV")
            .field("MipSlice", &self.MipSlice)
            .field("PlaneSlice", &self.PlaneSlice)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2D_RTV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2D_RTV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice && self.PlaneSlice == other.PlaneSlice
    }
}
impl ::core::cmp::Eq for D3D12_TEX2D_RTV {}
impl ::core::default::Default for D3D12_TEX2D_RTV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2D_SRV {
    pub MostDetailedMip: u32,
    pub MipLevels: u32,
    pub PlaneSlice: u32,
    pub ResourceMinLODClamp: f32,
}
impl ::core::marker::Copy for D3D12_TEX2D_SRV {}
impl ::core::clone::Clone for D3D12_TEX2D_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2D_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2D_SRV")
            .field("MostDetailedMip", &self.MostDetailedMip)
            .field("MipLevels", &self.MipLevels)
            .field("PlaneSlice", &self.PlaneSlice)
            .field("ResourceMinLODClamp", &self.ResourceMinLODClamp)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2D_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2D_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.MostDetailedMip == other.MostDetailedMip
            && self.MipLevels == other.MipLevels
            && self.PlaneSlice == other.PlaneSlice
            && self.ResourceMinLODClamp == other.ResourceMinLODClamp
    }
}
impl ::core::cmp::Eq for D3D12_TEX2D_SRV {}
impl ::core::default::Default for D3D12_TEX2D_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX2D_UAV {
    pub MipSlice: u32,
    pub PlaneSlice: u32,
}
impl ::core::marker::Copy for D3D12_TEX2D_UAV {}
impl ::core::clone::Clone for D3D12_TEX2D_UAV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX2D_UAV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX2D_UAV")
            .field("MipSlice", &self.MipSlice)
            .field("PlaneSlice", &self.PlaneSlice)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX2D_UAV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX2D_UAV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice && self.PlaneSlice == other.PlaneSlice
    }
}
impl ::core::cmp::Eq for D3D12_TEX2D_UAV {}
impl ::core::default::Default for D3D12_TEX2D_UAV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX3D_RTV {
    pub MipSlice: u32,
    pub FirstWSlice: u32,
    pub WSize: u32,
}
impl ::core::marker::Copy for D3D12_TEX3D_RTV {}
impl ::core::clone::Clone for D3D12_TEX3D_RTV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX3D_RTV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX3D_RTV")
            .field("MipSlice", &self.MipSlice)
            .field("FirstWSlice", &self.FirstWSlice)
            .field("WSize", &self.WSize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX3D_RTV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX3D_RTV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
            && self.FirstWSlice == other.FirstWSlice
            && self.WSize == other.WSize
    }
}
impl ::core::cmp::Eq for D3D12_TEX3D_RTV {}
impl ::core::default::Default for D3D12_TEX3D_RTV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX3D_SRV {
    pub MostDetailedMip: u32,
    pub MipLevels: u32,
    pub ResourceMinLODClamp: f32,
}
impl ::core::marker::Copy for D3D12_TEX3D_SRV {}
impl ::core::clone::Clone for D3D12_TEX3D_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX3D_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX3D_SRV")
            .field("MostDetailedMip", &self.MostDetailedMip)
            .field("MipLevels", &self.MipLevels)
            .field("ResourceMinLODClamp", &self.ResourceMinLODClamp)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX3D_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX3D_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.MostDetailedMip == other.MostDetailedMip
            && self.MipLevels == other.MipLevels
            && self.ResourceMinLODClamp == other.ResourceMinLODClamp
    }
}
impl ::core::cmp::Eq for D3D12_TEX3D_SRV {}
impl ::core::default::Default for D3D12_TEX3D_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEX3D_UAV {
    pub MipSlice: u32,
    pub FirstWSlice: u32,
    pub WSize: u32,
}
impl ::core::marker::Copy for D3D12_TEX3D_UAV {}
impl ::core::clone::Clone for D3D12_TEX3D_UAV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEX3D_UAV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEX3D_UAV")
            .field("MipSlice", &self.MipSlice)
            .field("FirstWSlice", &self.FirstWSlice)
            .field("WSize", &self.WSize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEX3D_UAV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEX3D_UAV {
    fn eq(&self, other: &Self) -> bool {
        self.MipSlice == other.MipSlice
            && self.FirstWSlice == other.FirstWSlice
            && self.WSize == other.WSize
    }
}
impl ::core::cmp::Eq for D3D12_TEX3D_UAV {}
impl ::core::default::Default for D3D12_TEX3D_UAV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEXCUBE_ARRAY_SRV {
    pub MostDetailedMip: u32,
    pub MipLevels: u32,
    pub First2DArrayFace: u32,
    pub NumCubes: u32,
    pub ResourceMinLODClamp: f32,
}
impl ::core::marker::Copy for D3D12_TEXCUBE_ARRAY_SRV {}
impl ::core::clone::Clone for D3D12_TEXCUBE_ARRAY_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEXCUBE_ARRAY_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEXCUBE_ARRAY_SRV")
            .field("MostDetailedMip", &self.MostDetailedMip)
            .field("MipLevels", &self.MipLevels)
            .field("First2DArrayFace", &self.First2DArrayFace)
            .field("NumCubes", &self.NumCubes)
            .field("ResourceMinLODClamp", &self.ResourceMinLODClamp)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEXCUBE_ARRAY_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEXCUBE_ARRAY_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.MostDetailedMip == other.MostDetailedMip
            && self.MipLevels == other.MipLevels
            && self.First2DArrayFace == other.First2DArrayFace
            && self.NumCubes == other.NumCubes
            && self.ResourceMinLODClamp == other.ResourceMinLODClamp
    }
}
impl ::core::cmp::Eq for D3D12_TEXCUBE_ARRAY_SRV {}
impl ::core::default::Default for D3D12_TEXCUBE_ARRAY_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEXCUBE_SRV {
    pub MostDetailedMip: u32,
    pub MipLevels: u32,
    pub ResourceMinLODClamp: f32,
}
impl ::core::marker::Copy for D3D12_TEXCUBE_SRV {}
impl ::core::clone::Clone for D3D12_TEXCUBE_SRV {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TEXCUBE_SRV {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEXCUBE_SRV")
            .field("MostDetailedMip", &self.MostDetailedMip)
            .field("MipLevels", &self.MipLevels)
            .field("ResourceMinLODClamp", &self.ResourceMinLODClamp)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEXCUBE_SRV {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEXCUBE_SRV {
    fn eq(&self, other: &Self) -> bool {
        self.MostDetailedMip == other.MostDetailedMip
            && self.MipLevels == other.MipLevels
            && self.ResourceMinLODClamp == other.ResourceMinLODClamp
    }
}
impl ::core::cmp::Eq for D3D12_TEXCUBE_SRV {}
impl ::core::default::Default for D3D12_TEXCUBE_SRV {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEXTURE_BARRIER {
    pub SyncBefore: D3D12_BARRIER_SYNC,
    pub SyncAfter: D3D12_BARRIER_SYNC,
    pub AccessBefore: D3D12_BARRIER_ACCESS,
    pub AccessAfter: D3D12_BARRIER_ACCESS,
    pub LayoutBefore: D3D12_BARRIER_LAYOUT,
    pub LayoutAfter: D3D12_BARRIER_LAYOUT,
    pub pResource: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub Subresources: D3D12_BARRIER_SUBRESOURCE_RANGE,
    pub Flags: D3D12_TEXTURE_BARRIER_FLAGS,
}
impl ::core::clone::Clone for D3D12_TEXTURE_BARRIER {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_TEXTURE_BARRIER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TEXTURE_BARRIER")
            .field("SyncBefore", &self.SyncBefore)
            .field("SyncAfter", &self.SyncAfter)
            .field("AccessBefore", &self.AccessBefore)
            .field("AccessAfter", &self.AccessAfter)
            .field("LayoutBefore", &self.LayoutBefore)
            .field("LayoutAfter", &self.LayoutAfter)
            .field("pResource", &self.pResource)
            .field("Subresources", &self.Subresources)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TEXTURE_BARRIER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TEXTURE_BARRIER {
    fn eq(&self, other: &Self) -> bool {
        self.SyncBefore == other.SyncBefore
            && self.SyncAfter == other.SyncAfter
            && self.AccessBefore == other.AccessBefore
            && self.AccessAfter == other.AccessAfter
            && self.LayoutBefore == other.LayoutBefore
            && self.LayoutAfter == other.LayoutAfter
            && self.pResource == other.pResource
            && self.Subresources == other.Subresources
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_TEXTURE_BARRIER {}
impl ::core::default::Default for D3D12_TEXTURE_BARRIER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TEXTURE_COPY_LOCATION {
    pub pResource: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub Type: D3D12_TEXTURE_COPY_TYPE,
    pub Anonymous: D3D12_TEXTURE_COPY_LOCATION_0,
}
impl ::core::clone::Clone for D3D12_TEXTURE_COPY_LOCATION {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::windows::core::TypeKind for D3D12_TEXTURE_COPY_LOCATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_TEXTURE_COPY_LOCATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_TEXTURE_COPY_LOCATION_0 {
    pub PlacedFootprint: D3D12_PLACED_SUBRESOURCE_FOOTPRINT,
    pub SubresourceIndex: u32,
}
impl ::core::marker::Copy for D3D12_TEXTURE_COPY_LOCATION_0 {}
impl ::core::clone::Clone for D3D12_TEXTURE_COPY_LOCATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_TEXTURE_COPY_LOCATION_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_TEXTURE_COPY_LOCATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_THREAD_LAUNCH_OVERRIDES {
    pub pLocalRootArgumentsTableIndex: *const u32,
    pub pProgramEntry: *const ::windows::Win32::Foundation::BOOL,
    pub pNewName: *const D3D12_NODE_ID,
    pub pShareInputOf: *const D3D12_NODE_ID,
    pub NumOutputOverrides: u32,
    pub pOutputOverrides: *const D3D12_NODE_OUTPUT_OVERRIDES,
}
impl ::core::marker::Copy for D3D12_THREAD_LAUNCH_OVERRIDES {}
impl ::core::clone::Clone for D3D12_THREAD_LAUNCH_OVERRIDES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_THREAD_LAUNCH_OVERRIDES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_THREAD_LAUNCH_OVERRIDES")
            .field(
                "pLocalRootArgumentsTableIndex",
                &self.pLocalRootArgumentsTableIndex,
            )
            .field("pProgramEntry", &self.pProgramEntry)
            .field("pNewName", &self.pNewName)
            .field("pShareInputOf", &self.pShareInputOf)
            .field("NumOutputOverrides", &self.NumOutputOverrides)
            .field("pOutputOverrides", &self.pOutputOverrides)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_THREAD_LAUNCH_OVERRIDES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_THREAD_LAUNCH_OVERRIDES {
    fn eq(&self, other: &Self) -> bool {
        self.pLocalRootArgumentsTableIndex == other.pLocalRootArgumentsTableIndex
            && self.pProgramEntry == other.pProgramEntry
            && self.pNewName == other.pNewName
            && self.pShareInputOf == other.pShareInputOf
            && self.NumOutputOverrides == other.NumOutputOverrides
            && self.pOutputOverrides == other.pOutputOverrides
    }
}
impl ::core::cmp::Eq for D3D12_THREAD_LAUNCH_OVERRIDES {}
impl ::core::default::Default for D3D12_THREAD_LAUNCH_OVERRIDES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TILED_RESOURCE_COORDINATE {
    pub X: u32,
    pub Y: u32,
    pub Z: u32,
    pub Subresource: u32,
}
impl ::core::marker::Copy for D3D12_TILED_RESOURCE_COORDINATE {}
impl ::core::clone::Clone for D3D12_TILED_RESOURCE_COORDINATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TILED_RESOURCE_COORDINATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TILED_RESOURCE_COORDINATE")
            .field("X", &self.X)
            .field("Y", &self.Y)
            .field("Z", &self.Z)
            .field("Subresource", &self.Subresource)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TILED_RESOURCE_COORDINATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TILED_RESOURCE_COORDINATE {
    fn eq(&self, other: &Self) -> bool {
        self.X == other.X
            && self.Y == other.Y
            && self.Z == other.Z
            && self.Subresource == other.Subresource
    }
}
impl ::core::cmp::Eq for D3D12_TILED_RESOURCE_COORDINATE {}
impl ::core::default::Default for D3D12_TILED_RESOURCE_COORDINATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TILE_REGION_SIZE {
    pub NumTiles: u32,
    pub UseBox: ::windows::Win32::Foundation::BOOL,
    pub Width: u32,
    pub Height: u16,
    pub Depth: u16,
}
impl ::core::marker::Copy for D3D12_TILE_REGION_SIZE {}
impl ::core::clone::Clone for D3D12_TILE_REGION_SIZE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TILE_REGION_SIZE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TILE_REGION_SIZE")
            .field("NumTiles", &self.NumTiles)
            .field("UseBox", &self.UseBox)
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .field("Depth", &self.Depth)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TILE_REGION_SIZE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TILE_REGION_SIZE {
    fn eq(&self, other: &Self) -> bool {
        self.NumTiles == other.NumTiles
            && self.UseBox == other.UseBox
            && self.Width == other.Width
            && self.Height == other.Height
            && self.Depth == other.Depth
    }
}
impl ::core::cmp::Eq for D3D12_TILE_REGION_SIZE {}
impl ::core::default::Default for D3D12_TILE_REGION_SIZE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_TILE_SHAPE {
    pub WidthInTexels: u32,
    pub HeightInTexels: u32,
    pub DepthInTexels: u32,
}
impl ::core::marker::Copy for D3D12_TILE_SHAPE {}
impl ::core::clone::Clone for D3D12_TILE_SHAPE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_TILE_SHAPE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_TILE_SHAPE")
            .field("WidthInTexels", &self.WidthInTexels)
            .field("HeightInTexels", &self.HeightInTexels)
            .field("DepthInTexels", &self.DepthInTexels)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_TILE_SHAPE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_TILE_SHAPE {
    fn eq(&self, other: &Self) -> bool {
        self.WidthInTexels == other.WidthInTexels
            && self.HeightInTexels == other.HeightInTexels
            && self.DepthInTexels == other.DepthInTexels
    }
}
impl ::core::cmp::Eq for D3D12_TILE_SHAPE {}
impl ::core::default::Default for D3D12_TILE_SHAPE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_UNORDERED_ACCESS_VIEW_DESC {
    pub Format: DXGI_FORMAT,
    pub ViewDimension: D3D12_UAV_DIMENSION,
    pub Anonymous: D3D12_UNORDERED_ACCESS_VIEW_DESC_0,
}
impl ::core::marker::Copy for D3D12_UNORDERED_ACCESS_VIEW_DESC {}
impl ::core::clone::Clone for D3D12_UNORDERED_ACCESS_VIEW_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_UNORDERED_ACCESS_VIEW_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_UNORDERED_ACCESS_VIEW_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_UNORDERED_ACCESS_VIEW_DESC_0 {
    pub Buffer: D3D12_BUFFER_UAV,
    pub Texture1D: D3D12_TEX1D_UAV,
    pub Texture1DArray: D3D12_TEX1D_ARRAY_UAV,
    pub Texture2D: D3D12_TEX2D_UAV,
    pub Texture2DArray: D3D12_TEX2D_ARRAY_UAV,
    pub Texture2DMS: D3D12_TEX2DMS_UAV,
    pub Texture2DMSArray: D3D12_TEX2DMS_ARRAY_UAV,
    pub Texture3D: D3D12_TEX3D_UAV,
}
impl ::core::marker::Copy for D3D12_UNORDERED_ACCESS_VIEW_DESC_0 {}
impl ::core::clone::Clone for D3D12_UNORDERED_ACCESS_VIEW_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_UNORDERED_ACCESS_VIEW_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_UNORDERED_ACCESS_VIEW_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA {
    pub Version: D3D12_DRED_VERSION,
    pub Anonymous: D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA_0,
}
impl ::core::marker::Copy for D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA {}
impl ::core::clone::Clone for D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA_0 {
    pub Dred_1_0: D3D12_DEVICE_REMOVED_EXTENDED_DATA,
    pub Dred_1_1: D3D12_DEVICE_REMOVED_EXTENDED_DATA1,
    pub Dred_1_2: D3D12_DEVICE_REMOVED_EXTENDED_DATA2,
    pub Dred_1_3: D3D12_DEVICE_REMOVED_EXTENDED_DATA3,
}
impl ::core::marker::Copy for D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA_0 {}
impl ::core::clone::Clone for D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VERSIONED_DEVICE_REMOVED_EXTENDED_DATA_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VERSIONED_ROOT_SIGNATURE_DESC {
    pub Version: D3D_ROOT_SIGNATURE_VERSION,
    pub Anonymous: D3D12_VERSIONED_ROOT_SIGNATURE_DESC_0,
}
impl ::core::marker::Copy for D3D12_VERSIONED_ROOT_SIGNATURE_DESC {}
impl ::core::clone::Clone for D3D12_VERSIONED_ROOT_SIGNATURE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VERSIONED_ROOT_SIGNATURE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VERSIONED_ROOT_SIGNATURE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VERSIONED_ROOT_SIGNATURE_DESC_0 {
    pub Desc_1_0: D3D12_ROOT_SIGNATURE_DESC,
    pub Desc_1_1: D3D12_ROOT_SIGNATURE_DESC1,
    pub Desc_1_2: D3D12_ROOT_SIGNATURE_DESC2,
}
impl ::core::marker::Copy for D3D12_VERSIONED_ROOT_SIGNATURE_DESC_0 {}
impl ::core::clone::Clone for D3D12_VERSIONED_ROOT_SIGNATURE_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VERSIONED_ROOT_SIGNATURE_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VERSIONED_ROOT_SIGNATURE_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VERTEX_BUFFER_VIEW {
    pub BufferLocation: u64,
    pub SizeInBytes: u32,
    pub StrideInBytes: u32,
}
impl ::core::marker::Copy for D3D12_VERTEX_BUFFER_VIEW {}
impl ::core::clone::Clone for D3D12_VERTEX_BUFFER_VIEW {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VERTEX_BUFFER_VIEW {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VERTEX_BUFFER_VIEW")
            .field("BufferLocation", &self.BufferLocation)
            .field("SizeInBytes", &self.SizeInBytes)
            .field("StrideInBytes", &self.StrideInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VERTEX_BUFFER_VIEW {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VERTEX_BUFFER_VIEW {
    fn eq(&self, other: &Self) -> bool {
        self.BufferLocation == other.BufferLocation
            && self.SizeInBytes == other.SizeInBytes
            && self.StrideInBytes == other.StrideInBytes
    }
}
impl ::core::cmp::Eq for D3D12_VERTEX_BUFFER_VIEW {}
impl ::core::default::Default for D3D12_VERTEX_BUFFER_VIEW {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODER_DESC {
    pub NodeMask: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
}
impl ::core::marker::Copy for D3D12_VIDEO_DECODER_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODER_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODER_DESC")
            .field("NodeMask", &self.NodeMask)
            .field("Configuration", &self.Configuration)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODER_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask && self.Configuration == other.Configuration
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODER_DESC {}
impl ::core::default::Default for D3D12_VIDEO_DECODER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODER_HEAP_DESC {
    pub NodeMask: u32,
    pub Configuration: D3D12_VIDEO_DECODE_CONFIGURATION,
    pub DecodeWidth: u32,
    pub DecodeHeight: u32,
    pub Format: DXGI_FORMAT,
    pub FrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub BitRate: u32,
    pub MaxDecodePictureBufferCount: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_DECODER_HEAP_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODER_HEAP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODER_HEAP_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODER_HEAP_DESC")
            .field("NodeMask", &self.NodeMask)
            .field("Configuration", &self.Configuration)
            .field("DecodeWidth", &self.DecodeWidth)
            .field("DecodeHeight", &self.DecodeHeight)
            .field("Format", &self.Format)
            .field("FrameRate", &self.FrameRate)
            .field("BitRate", &self.BitRate)
            .field(
                "MaxDecodePictureBufferCount",
                &self.MaxDecodePictureBufferCount,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODER_HEAP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODER_HEAP_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask
            && self.Configuration == other.Configuration
            && self.DecodeWidth == other.DecodeWidth
            && self.DecodeHeight == other.DecodeHeight
            && self.Format == other.Format
            && self.FrameRate == other.FrameRate
            && self.BitRate == other.BitRate
            && self.MaxDecodePictureBufferCount == other.MaxDecodePictureBufferCount
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODER_HEAP_DESC {}
impl ::core::default::Default for D3D12_VIDEO_DECODER_HEAP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    pub pBuffer: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub Offset: u64,
    pub Size: u64,
}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM")
            .field("pBuffer", &self.pBuffer)
            .field("Offset", &self.Offset)
            .field("Size", &self.Size)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    fn eq(&self, other: &Self) -> bool {
        self.pBuffer == other.pBuffer && self.Offset == other.Offset && self.Size == other.Size
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODE_CONFIGURATION {
    pub DecodeProfile: ::windows::core::GUID,
    pub BitstreamEncryption: D3D12_BITSTREAM_ENCRYPTION_TYPE,
    pub InterlaceType: D3D12_VIDEO_FRAME_CODED_INTERLACE_TYPE,
}
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_CONFIGURATION {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_CONFIGURATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_CONFIGURATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_CONFIGURATION")
            .field("DecodeProfile", &self.DecodeProfile)
            .field("BitstreamEncryption", &self.BitstreamEncryption)
            .field("InterlaceType", &self.InterlaceType)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_CONFIGURATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_CONFIGURATION {
    fn eq(&self, other: &Self) -> bool {
        self.DecodeProfile == other.DecodeProfile
            && self.BitstreamEncryption == other.BitstreamEncryption
            && self.InterlaceType == other.InterlaceType
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_CONFIGURATION {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_CONFIGURATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    pub Enable: ::windows::Win32::Foundation::BOOL,
    pub pReferenceTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub ReferenceSubresource: u32,
    pub OutputColorSpace: ::windows::Win32::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
    pub DecodeColorSpace: ::windows::Win32::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS")
            .field("Enable", &self.Enable)
            .field("pReferenceTexture2D", &self.pReferenceTexture2D)
            .field("ReferenceSubresource", &self.ReferenceSubresource)
            .field("OutputColorSpace", &self.OutputColorSpace)
            .field("DecodeColorSpace", &self.DecodeColorSpace)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable
            && self.pReferenceTexture2D == other.pReferenceTexture2D
            && self.ReferenceSubresource == other.ReferenceSubresource
            && self.OutputColorSpace == other.OutputColorSpace
            && self.DecodeColorSpace == other.DecodeColorSpace
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    pub Enable: ::windows::Win32::Foundation::BOOL,
    pub pReferenceTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub ReferenceSubresource: u32,
    pub OutputColorSpace: ::windows::Win32::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
    pub DecodeColorSpace: ::windows::Win32::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
    pub OutputWidth: u32,
    pub OutputHeight: u32,
}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1")
            .field("Enable", &self.Enable)
            .field("pReferenceTexture2D", &self.pReferenceTexture2D)
            .field("ReferenceSubresource", &self.ReferenceSubresource)
            .field("OutputColorSpace", &self.OutputColorSpace)
            .field("DecodeColorSpace", &self.DecodeColorSpace)
            .field("OutputWidth", &self.OutputWidth)
            .field("OutputHeight", &self.OutputHeight)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable
            && self.pReferenceTexture2D == other.pReferenceTexture2D
            && self.ReferenceSubresource == other.ReferenceSubresource
            && self.OutputColorSpace == other.OutputColorSpace
            && self.DecodeColorSpace == other.DecodeColorSpace
            && self.OutputWidth == other.OutputWidth
            && self.OutputHeight == other.OutputHeight
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    pub Type: D3D12_VIDEO_DECODE_ARGUMENT_TYPE,
    pub Size: u32,
    pub pData: *mut ::core::ffi::c_void,
}
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_FRAME_ARGUMENT")
            .field("Type", &self.Type)
            .field("Size", &self.Size)
            .field("pData", &self.pData)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    fn eq(&self, other: &Self) -> bool {
        self.Type == other.Type && self.Size == other.Size && self.pData == other.pData
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_FRAME_ARGUMENT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    pub NumFrameArguments: u32,
    pub FrameArguments: [D3D12_VIDEO_DECODE_FRAME_ARGUMENT; 10],
    pub ReferenceFrames: D3D12_VIDEO_DECODE_REFERENCE_FRAMES,
    pub CompressedBitstream: D3D12_VIDEO_DECODE_COMPRESSED_BITSTREAM,
    pub pHeap: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12VideoDecoderHeap>>,
}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS")
            .field("NumFrameArguments", &self.NumFrameArguments)
            .field("FrameArguments", &self.FrameArguments)
            .field("ReferenceFrames", &self.ReferenceFrames)
            .field("CompressedBitstream", &self.CompressedBitstream)
            .field("pHeap", &self.pHeap)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.NumFrameArguments == other.NumFrameArguments
            && self.FrameArguments == other.FrameArguments
            && self.ReferenceFrames == other.ReferenceFrames
            && self.CompressedBitstream == other.CompressedBitstream
            && self.pHeap == other.pHeap
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    pub Offset: u64,
    pub pBuffer: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM")
            .field("Offset", &self.Offset)
            .field("pBuffer", &self.pBuffer)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    fn eq(&self, other: &Self) -> bool {
        self.Offset == other.Offset && self.pBuffer == other.pBuffer
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    pub pOutputTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub OutputSubresource: u32,
    pub ConversionArguments: D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS,
}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS")
            .field("pOutputTexture2D", &self.pOutputTexture2D)
            .field("OutputSubresource", &self.OutputSubresource)
            .field("ConversionArguments", &self.ConversionArguments)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.pOutputTexture2D == other.pOutputTexture2D
            && self.OutputSubresource == other.OutputSubresource
            && self.ConversionArguments == other.ConversionArguments
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    pub pOutputTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub OutputSubresource: u32,
    pub ConversionArguments: D3D12_VIDEO_DECODE_CONVERSION_ARGUMENTS1,
    pub Histograms: [D3D12_VIDEO_DECODE_OUTPUT_HISTOGRAM; 4],
}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1")
            .field("pOutputTexture2D", &self.pOutputTexture2D)
            .field("OutputSubresource", &self.OutputSubresource)
            .field("ConversionArguments", &self.ConversionArguments)
            .field("Histograms", &self.Histograms)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    fn eq(&self, other: &Self) -> bool {
        self.pOutputTexture2D == other.pOutputTexture2D
            && self.OutputSubresource == other.OutputSubresource
            && self.ConversionArguments == other.ConversionArguments
            && self.Histograms == other.Histograms
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    pub NumTexture2Ds: u32,
    pub ppTexture2Ds: *mut ::core::option::Option<ID3D12Resource>,
    pub pSubresources: *mut u32,
    pub ppHeaps: *mut ::core::option::Option<ID3D12VideoDecoderHeap>,
}
impl ::core::marker::Copy for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {}
impl ::core::clone::Clone for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_DECODE_REFERENCE_FRAMES")
            .field("NumTexture2Ds", &self.NumTexture2Ds)
            .field("ppTexture2Ds", &self.ppTexture2Ds)
            .field("pSubresources", &self.pSubresources)
            .field("ppHeaps", &self.ppHeaps)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    fn eq(&self, other: &Self) -> bool {
        self.NumTexture2Ds == other.NumTexture2Ds
            && self.ppTexture2Ds == other.ppTexture2Ds
            && self.pSubresources == other.pSubresources
            && self.ppHeaps == other.ppHeaps
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {}
impl ::core::default::Default for D3D12_VIDEO_DECODE_REFERENCE_FRAMES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG {
    pub CdefBits: u64,
    pub CdefDampingMinus3: u64,
    pub CdefYPriStrength: [u64; 8],
    pub CdefUVPriStrength: [u64; 8],
    pub CdefYSecStrength: [u64; 8],
    pub CdefUVSecStrength: [u64; 8],
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG")
            .field("CdefBits", &self.CdefBits)
            .field("CdefDampingMinus3", &self.CdefDampingMinus3)
            .field("CdefYPriStrength", &self.CdefYPriStrength)
            .field("CdefUVPriStrength", &self.CdefUVPriStrength)
            .field("CdefYSecStrength", &self.CdefYSecStrength)
            .field("CdefUVSecStrength", &self.CdefUVSecStrength)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.CdefBits == other.CdefBits
            && self.CdefDampingMinus3 == other.CdefDampingMinus3
            && self.CdefYPriStrength == other.CdefYPriStrength
            && self.CdefUVPriStrength == other.CdefUVPriStrength
            && self.CdefYSecStrength == other.CdefYSecStrength
            && self.CdefUVSecStrength == other.CdefUVSecStrength
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION {
    pub FeatureFlags: D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS,
    pub OrderHintBitsMinus1: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION")
            .field("FeatureFlags", &self.FeatureFlags)
            .field("OrderHintBitsMinus1", &self.OrderHintBitsMinus1)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION {
    fn eq(&self, other: &Self) -> bool {
        self.FeatureFlags == other.FeatureFlags
            && self.OrderHintBitsMinus1 == other.OrderHintBitsMinus1
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION_SUPPORT {
    pub SupportedFeatureFlags: D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS,
    pub RequiredFeatureFlags: D3D12_VIDEO_ENCODER_AV1_FEATURE_FLAGS,
    pub SupportedInterpolationFilters: D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS_FLAGS,
    pub SupportedRestorationParams: [D3D12_VIDEO_ENCODER_AV1_RESTORATION_SUPPORT_FLAGS; 9],
    pub SupportedSegmentationModes: D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MODE_FLAGS,
    pub SupportedTxModes: [D3D12_VIDEO_ENCODER_AV1_TX_MODE_FLAGS; 4],
    pub SegmentationBlockSize: D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_BLOCK_SIZE,
    pub PostEncodeValuesFlags: D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES_FLAGS,
    pub MaxTemporalLayers: u32,
    pub MaxSpatialLayers: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION_SUPPORT {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION_SUPPORT")
            .field("SupportedFeatureFlags", &self.SupportedFeatureFlags)
            .field("RequiredFeatureFlags", &self.RequiredFeatureFlags)
            .field(
                "SupportedInterpolationFilters",
                &self.SupportedInterpolationFilters,
            )
            .field(
                "SupportedRestorationParams",
                &self.SupportedRestorationParams,
            )
            .field(
                "SupportedSegmentationModes",
                &self.SupportedSegmentationModes,
            )
            .field("SupportedTxModes", &self.SupportedTxModes)
            .field("SegmentationBlockSize", &self.SegmentationBlockSize)
            .field("PostEncodeValuesFlags", &self.PostEncodeValuesFlags)
            .field("MaxTemporalLayers", &self.MaxTemporalLayers)
            .field("MaxSpatialLayers", &self.MaxSpatialLayers)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.SupportedFeatureFlags == other.SupportedFeatureFlags
            && self.RequiredFeatureFlags == other.RequiredFeatureFlags
            && self.SupportedInterpolationFilters == other.SupportedInterpolationFilters
            && self.SupportedRestorationParams == other.SupportedRestorationParams
            && self.SupportedSegmentationModes == other.SupportedSegmentationModes
            && self.SupportedTxModes == other.SupportedTxModes
            && self.SegmentationBlockSize == other.SegmentationBlockSize
            && self.PostEncodeValuesFlags == other.PostEncodeValuesFlags
            && self.MaxTemporalLayers == other.MaxTemporalLayers
            && self.MaxSpatialLayers == other.MaxSpatialLayers
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION_SUPPORT {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {
    pub Use128SuperBlocks: ::windows::Win32::Foundation::BOOL,
    pub TilesConfiguration: D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES,
    pub ValidationFlags: D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_VALIDATION_FLAGS,
    pub MinTileRows: u32,
    pub MaxTileRows: u32,
    pub MinTileCols: u32,
    pub MaxTileCols: u32,
    pub MinTileWidth: u32,
    pub MaxTileWidth: u32,
    pub MinTileArea: u32,
    pub MaxTileArea: u32,
    pub TileSizeBytesMinus1: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT")
            .field("Use128SuperBlocks", &self.Use128SuperBlocks)
            .field("TilesConfiguration", &self.TilesConfiguration)
            .field("ValidationFlags", &self.ValidationFlags)
            .field("MinTileRows", &self.MinTileRows)
            .field("MaxTileRows", &self.MaxTileRows)
            .field("MinTileCols", &self.MinTileCols)
            .field("MaxTileCols", &self.MaxTileCols)
            .field("MinTileWidth", &self.MinTileWidth)
            .field("MaxTileWidth", &self.MaxTileWidth)
            .field("MinTileArea", &self.MinTileArea)
            .field("MaxTileArea", &self.MaxTileArea)
            .field("TileSizeBytesMinus1", &self.TileSizeBytesMinus1)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.Use128SuperBlocks == other.Use128SuperBlocks
            && self.TilesConfiguration == other.TilesConfiguration
            && self.ValidationFlags == other.ValidationFlags
            && self.MinTileRows == other.MinTileRows
            && self.MaxTileRows == other.MaxTileRows
            && self.MinTileCols == other.MinTileCols
            && self.MaxTileCols == other.MaxTileCols
            && self.MinTileWidth == other.MinTileWidth
            && self.MaxTileWidth == other.MaxTileWidth
            && self.MinTileArea == other.MinTileArea
            && self.MaxTileArea == other.MaxTileArea
            && self.TileSizeBytesMinus1 == other.TileSizeBytesMinus1
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_LEVEL_TIER_CONSTRAINTS {
    pub Level: D3D12_VIDEO_ENCODER_AV1_LEVELS,
    pub Tier: D3D12_VIDEO_ENCODER_AV1_TIER,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_LEVEL_TIER_CONSTRAINTS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_LEVEL_TIER_CONSTRAINTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_LEVEL_TIER_CONSTRAINTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_LEVEL_TIER_CONSTRAINTS")
            .field("Level", &self.Level)
            .field("Tier", &self.Tier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_LEVEL_TIER_CONSTRAINTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_LEVEL_TIER_CONSTRAINTS {
    fn eq(&self, other: &Self) -> bool {
        self.Level == other.Level && self.Tier == other.Tier
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_LEVEL_TIER_CONSTRAINTS {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_LEVEL_TIER_CONSTRAINTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_CODEC_DATA {
    pub Flags: D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_FLAGS,
    pub FrameType: D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE,
    pub CompoundPredictionType: D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE,
    pub InterpolationFilter: D3D12_VIDEO_ENCODER_AV1_INTERPOLATION_FILTERS,
    pub FrameRestorationConfig: D3D12_VIDEO_ENCODER_AV1_RESTORATION_CONFIG,
    pub TxMode: D3D12_VIDEO_ENCODER_AV1_TX_MODE,
    pub SuperResDenominator: u32,
    pub OrderHint: u32,
    pub PictureIndex: u32,
    pub TemporalLayerIndexPlus1: u32,
    pub SpatialLayerIndexPlus1: u32,
    pub ReferenceFramesReconPictureDescriptors:
        [D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_DESCRIPTOR; 8],
    pub ReferenceIndices: [u32; 7],
    pub PrimaryRefFrame: u32,
    pub RefreshFrameFlags: u32,
    pub LoopFilter: D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG,
    pub LoopFilterDelta: D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG,
    pub Quantization: D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG,
    pub QuantizationDelta: D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG,
    pub CDEF: D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG,
    pub QPMapValuesCount: u32,
    pub pRateControlQPMap: *mut i16,
    pub CustomSegmentation: D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG,
    pub CustomSegmentsMap: D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MAP,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_CODEC_DATA {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_CODEC_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_CODEC_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_CODEC_DATA")
            .field("Flags", &self.Flags)
            .field("FrameType", &self.FrameType)
            .field("CompoundPredictionType", &self.CompoundPredictionType)
            .field("InterpolationFilter", &self.InterpolationFilter)
            .field("FrameRestorationConfig", &self.FrameRestorationConfig)
            .field("TxMode", &self.TxMode)
            .field("SuperResDenominator", &self.SuperResDenominator)
            .field("OrderHint", &self.OrderHint)
            .field("PictureIndex", &self.PictureIndex)
            .field("TemporalLayerIndexPlus1", &self.TemporalLayerIndexPlus1)
            .field("SpatialLayerIndexPlus1", &self.SpatialLayerIndexPlus1)
            .field(
                "ReferenceFramesReconPictureDescriptors",
                &self.ReferenceFramesReconPictureDescriptors,
            )
            .field("ReferenceIndices", &self.ReferenceIndices)
            .field("PrimaryRefFrame", &self.PrimaryRefFrame)
            .field("RefreshFrameFlags", &self.RefreshFrameFlags)
            .field("LoopFilter", &self.LoopFilter)
            .field("LoopFilterDelta", &self.LoopFilterDelta)
            .field("Quantization", &self.Quantization)
            .field("QuantizationDelta", &self.QuantizationDelta)
            .field("CDEF", &self.CDEF)
            .field("QPMapValuesCount", &self.QPMapValuesCount)
            .field("pRateControlQPMap", &self.pRateControlQPMap)
            .field("CustomSegmentation", &self.CustomSegmentation)
            .field("CustomSegmentsMap", &self.CustomSegmentsMap)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_CODEC_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_CODEC_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.FrameType == other.FrameType
            && self.CompoundPredictionType == other.CompoundPredictionType
            && self.InterpolationFilter == other.InterpolationFilter
            && self.FrameRestorationConfig == other.FrameRestorationConfig
            && self.TxMode == other.TxMode
            && self.SuperResDenominator == other.SuperResDenominator
            && self.OrderHint == other.OrderHint
            && self.PictureIndex == other.PictureIndex
            && self.TemporalLayerIndexPlus1 == other.TemporalLayerIndexPlus1
            && self.SpatialLayerIndexPlus1 == other.SpatialLayerIndexPlus1
            && self.ReferenceFramesReconPictureDescriptors
                == other.ReferenceFramesReconPictureDescriptors
            && self.ReferenceIndices == other.ReferenceIndices
            && self.PrimaryRefFrame == other.PrimaryRefFrame
            && self.RefreshFrameFlags == other.RefreshFrameFlags
            && self.LoopFilter == other.LoopFilter
            && self.LoopFilterDelta == other.LoopFilterDelta
            && self.Quantization == other.Quantization
            && self.QuantizationDelta == other.QuantizationDelta
            && self.CDEF == other.CDEF
            && self.QPMapValuesCount == other.QPMapValuesCount
            && self.pRateControlQPMap == other.pRateControlQPMap
            && self.CustomSegmentation == other.CustomSegmentation
            && self.CustomSegmentsMap == other.CustomSegmentsMap
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_CODEC_DATA {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_CODEC_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES {
    pub RowCount: u64,
    pub ColCount: u64,
    pub RowHeights: [u64; 64],
    pub ColWidths: [u64; 64],
    pub ContextUpdateTileId: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES")
            .field("RowCount", &self.RowCount)
            .field("ColCount", &self.ColCount)
            .field("RowHeights", &self.RowHeights)
            .field("ColWidths", &self.ColWidths)
            .field("ContextUpdateTileId", &self.ContextUpdateTileId)
            .finish()
    }
}
impl ::windows::core::TypeKind
    for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq
    for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES
{
    fn eq(&self, other: &Self) -> bool {
        self.RowCount == other.RowCount
            && self.ColCount == other.ColCount
            && self.RowHeights == other.RowHeights
            && self.ColWidths == other.ColWidths
            && self.ContextUpdateTileId == other.ContextUpdateTileId
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES {}
impl ::core::default::Default
    for D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES
{
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES {
    pub CompoundPredictionType: u64,
    pub LoopFilter: D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG,
    pub LoopFilterDelta: D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG,
    pub Quantization: D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG,
    pub QuantizationDelta: D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG,
    pub CDEF: D3D12_VIDEO_ENCODER_AV1_CDEF_CONFIG,
    pub SegmentationConfig: D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG,
    pub PrimaryRefFrame: u64,
    pub ReferenceIndices: [u64; 7],
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES")
            .field("CompoundPredictionType", &self.CompoundPredictionType)
            .field("LoopFilter", &self.LoopFilter)
            .field("LoopFilterDelta", &self.LoopFilterDelta)
            .field("Quantization", &self.Quantization)
            .field("QuantizationDelta", &self.QuantizationDelta)
            .field("CDEF", &self.CDEF)
            .field("SegmentationConfig", &self.SegmentationConfig)
            .field("PrimaryRefFrame", &self.PrimaryRefFrame)
            .field("ReferenceIndices", &self.ReferenceIndices)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES {
    fn eq(&self, other: &Self) -> bool {
        self.CompoundPredictionType == other.CompoundPredictionType
            && self.LoopFilter == other.LoopFilter
            && self.LoopFilterDelta == other.LoopFilterDelta
            && self.Quantization == other.Quantization
            && self.QuantizationDelta == other.QuantizationDelta
            && self.CDEF == other.CDEF
            && self.SegmentationConfig == other.SegmentationConfig
            && self.PrimaryRefFrame == other.PrimaryRefFrame
            && self.ReferenceIndices == other.ReferenceIndices
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_POST_ENCODE_VALUES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_DESCRIPTOR {
    pub ReconstructedPictureResourceIndex: u32,
    pub TemporalLayerIndexPlus1: u32,
    pub SpatialLayerIndexPlus1: u32,
    pub FrameType: D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE,
    pub WarpedMotionInfo: D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_WARPED_MOTION_INFO,
    pub OrderHint: u32,
    pub PictureIndex: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_DESCRIPTOR {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_DESCRIPTOR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_DESCRIPTOR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_DESCRIPTOR")
            .field(
                "ReconstructedPictureResourceIndex",
                &self.ReconstructedPictureResourceIndex,
            )
            .field("TemporalLayerIndexPlus1", &self.TemporalLayerIndexPlus1)
            .field("SpatialLayerIndexPlus1", &self.SpatialLayerIndexPlus1)
            .field("FrameType", &self.FrameType)
            .field("WarpedMotionInfo", &self.WarpedMotionInfo)
            .field("OrderHint", &self.OrderHint)
            .field("PictureIndex", &self.PictureIndex)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_DESCRIPTOR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_DESCRIPTOR {
    fn eq(&self, other: &Self) -> bool {
        self.ReconstructedPictureResourceIndex == other.ReconstructedPictureResourceIndex
            && self.TemporalLayerIndexPlus1 == other.TemporalLayerIndexPlus1
            && self.SpatialLayerIndexPlus1 == other.SpatialLayerIndexPlus1
            && self.FrameType == other.FrameType
            && self.WarpedMotionInfo == other.WarpedMotionInfo
            && self.OrderHint == other.OrderHint
            && self.PictureIndex == other.PictureIndex
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_DESCRIPTOR {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_DESCRIPTOR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_WARPED_MOTION_INFO {
    pub TransformationType: D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION,
    pub TransformationMatrix: [i32; 8],
    pub InvalidAffineSet: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_WARPED_MOTION_INFO {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_WARPED_MOTION_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_WARPED_MOTION_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_WARPED_MOTION_INFO")
            .field("TransformationType", &self.TransformationType)
            .field("TransformationMatrix", &self.TransformationMatrix)
            .field("InvalidAffineSet", &self.InvalidAffineSet)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_WARPED_MOTION_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_WARPED_MOTION_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.TransformationType == other.TransformationType
            && self.TransformationMatrix == other.TransformationMatrix
            && self.InvalidAffineSet == other.InvalidAffineSet
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_WARPED_MOTION_INFO {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_REFERENCE_PICTURE_WARPED_MOTION_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_RESTORATION_CONFIG {
    pub FrameRestorationType: [D3D12_VIDEO_ENCODER_AV1_RESTORATION_TYPE; 3],
    pub LoopRestorationPixelSize: [D3D12_VIDEO_ENCODER_AV1_RESTORATION_TILESIZE; 3],
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_RESTORATION_CONFIG {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_RESTORATION_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_RESTORATION_CONFIG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_RESTORATION_CONFIG")
            .field("FrameRestorationType", &self.FrameRestorationType)
            .field("LoopRestorationPixelSize", &self.LoopRestorationPixelSize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_RESTORATION_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_RESTORATION_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.FrameRestorationType == other.FrameRestorationType
            && self.LoopRestorationPixelSize == other.LoopRestorationPixelSize
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_RESTORATION_CONFIG {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_RESTORATION_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG {
    pub UpdateMap: u64,
    pub TemporalUpdate: u64,
    pub UpdateData: u64,
    pub NumSegments: u64,
    pub SegmentsData: [D3D12_VIDEO_ENCODER_AV1_SEGMENT_DATA; 8],
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG")
            .field("UpdateMap", &self.UpdateMap)
            .field("TemporalUpdate", &self.TemporalUpdate)
            .field("UpdateData", &self.UpdateData)
            .field("NumSegments", &self.NumSegments)
            .field("SegmentsData", &self.SegmentsData)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.UpdateMap == other.UpdateMap
            && self.TemporalUpdate == other.TemporalUpdate
            && self.UpdateData == other.UpdateData
            && self.NumSegments == other.NumSegments
            && self.SegmentsData == other.SegmentsData
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MAP {
    pub SegmentsMapByteSize: u32,
    pub pSegmentsMap: *mut u8,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MAP {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MAP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MAP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MAP")
            .field("SegmentsMapByteSize", &self.SegmentsMapByteSize)
            .field("pSegmentsMap", &self.pSegmentsMap)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MAP {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MAP {
    fn eq(&self, other: &Self) -> bool {
        self.SegmentsMapByteSize == other.SegmentsMapByteSize
            && self.pSegmentsMap == other.pSegmentsMap
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MAP {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_SEGMENTATION_MAP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_SEGMENT_DATA {
    pub EnabledFeatures: u64,
    pub FeatureValue: [i64; 8],
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_SEGMENT_DATA {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_SEGMENT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_SEGMENT_DATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_SEGMENT_DATA")
            .field("EnabledFeatures", &self.EnabledFeatures)
            .field("FeatureValue", &self.FeatureValue)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_SEGMENT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_SEGMENT_DATA {
    fn eq(&self, other: &Self) -> bool {
        self.EnabledFeatures == other.EnabledFeatures && self.FeatureValue == other.FeatureValue
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_SEGMENT_DATA {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_SEGMENT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_AV1_SEQUENCE_STRUCTURE {
    pub IntraDistance: u32,
    pub InterFramePeriod: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_AV1_SEQUENCE_STRUCTURE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_AV1_SEQUENCE_STRUCTURE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_AV1_SEQUENCE_STRUCTURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_AV1_SEQUENCE_STRUCTURE")
            .field("IntraDistance", &self.IntraDistance)
            .field("InterFramePeriod", &self.InterFramePeriod)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_AV1_SEQUENCE_STRUCTURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_AV1_SEQUENCE_STRUCTURE {
    fn eq(&self, other: &Self) -> bool {
        self.IntraDistance == other.IntraDistance && self.InterFramePeriod == other.InterFramePeriod
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_AV1_SEQUENCE_STRUCTURE {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_AV1_SEQUENCE_STRUCTURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG {
    pub LoopFilterLevel: [u64; 2],
    pub LoopFilterLevelU: u64,
    pub LoopFilterLevelV: u64,
    pub LoopFilterSharpnessLevel: u64,
    pub LoopFilterDeltaEnabled: u64,
    pub UpdateRefDelta: u64,
    pub RefDeltas: [i64; 8],
    pub UpdateModeDelta: u64,
    pub ModeDeltas: [i64; 2],
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG")
            .field("LoopFilterLevel", &self.LoopFilterLevel)
            .field("LoopFilterLevelU", &self.LoopFilterLevelU)
            .field("LoopFilterLevelV", &self.LoopFilterLevelV)
            .field("LoopFilterSharpnessLevel", &self.LoopFilterSharpnessLevel)
            .field("LoopFilterDeltaEnabled", &self.LoopFilterDeltaEnabled)
            .field("UpdateRefDelta", &self.UpdateRefDelta)
            .field("RefDeltas", &self.RefDeltas)
            .field("UpdateModeDelta", &self.UpdateModeDelta)
            .field("ModeDeltas", &self.ModeDeltas)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.LoopFilterLevel == other.LoopFilterLevel
            && self.LoopFilterLevelU == other.LoopFilterLevelU
            && self.LoopFilterLevelV == other.LoopFilterLevelV
            && self.LoopFilterSharpnessLevel == other.LoopFilterSharpnessLevel
            && self.LoopFilterDeltaEnabled == other.LoopFilterDeltaEnabled
            && self.UpdateRefDelta == other.UpdateRefDelta
            && self.RefDeltas == other.RefDeltas
            && self.UpdateModeDelta == other.UpdateModeDelta
            && self.ModeDeltas == other.ModeDeltas
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG {
    pub DeltaLFPresent: u64,
    pub DeltaLFMulti: u64,
    pub DeltaLFRes: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG")
            .field("DeltaLFPresent", &self.DeltaLFPresent)
            .field("DeltaLFMulti", &self.DeltaLFMulti)
            .field("DeltaLFRes", &self.DeltaLFRes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.DeltaLFPresent == other.DeltaLFPresent
            && self.DeltaLFMulti == other.DeltaLFMulti
            && self.DeltaLFRes == other.DeltaLFRes
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_AV1_LOOP_FILTER_DELTA_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_AV1_PICTURE_CONTROL_SUPPORT {
    pub PredictionMode: D3D12_VIDEO_ENCODER_AV1_COMP_PREDICTION_TYPE,
    pub MaxUniqueReferencesPerFrame: u32,
    pub SupportedFrameTypes: D3D12_VIDEO_ENCODER_AV1_FRAME_TYPE_FLAGS,
    pub SupportedReferenceWarpedMotionFlags:
        D3D12_VIDEO_ENCODER_AV1_REFERENCE_WARPED_MOTION_TRANSFORMATION_FLAGS,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_AV1_PICTURE_CONTROL_SUPPORT {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_AV1_PICTURE_CONTROL_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_AV1_PICTURE_CONTROL_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_AV1_PICTURE_CONTROL_SUPPORT")
            .field("PredictionMode", &self.PredictionMode)
            .field(
                "MaxUniqueReferencesPerFrame",
                &self.MaxUniqueReferencesPerFrame,
            )
            .field("SupportedFrameTypes", &self.SupportedFrameTypes)
            .field(
                "SupportedReferenceWarpedMotionFlags",
                &self.SupportedReferenceWarpedMotionFlags,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_AV1_PICTURE_CONTROL_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_AV1_PICTURE_CONTROL_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.PredictionMode == other.PredictionMode
            && self.MaxUniqueReferencesPerFrame == other.MaxUniqueReferencesPerFrame
            && self.SupportedFrameTypes == other.SupportedFrameTypes
            && self.SupportedReferenceWarpedMotionFlags == other.SupportedReferenceWarpedMotionFlags
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_AV1_PICTURE_CONTROL_SUPPORT {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_AV1_PICTURE_CONTROL_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG {
    pub BaseQIndex: u64,
    pub YDCDeltaQ: i64,
    pub UDCDeltaQ: i64,
    pub UACDeltaQ: i64,
    pub VDCDeltaQ: i64,
    pub VACDeltaQ: i64,
    pub UsingQMatrix: u64,
    pub QMY: u64,
    pub QMU: u64,
    pub QMV: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG")
            .field("BaseQIndex", &self.BaseQIndex)
            .field("YDCDeltaQ", &self.YDCDeltaQ)
            .field("UDCDeltaQ", &self.UDCDeltaQ)
            .field("UACDeltaQ", &self.UACDeltaQ)
            .field("VDCDeltaQ", &self.VDCDeltaQ)
            .field("VACDeltaQ", &self.VACDeltaQ)
            .field("UsingQMatrix", &self.UsingQMatrix)
            .field("QMY", &self.QMY)
            .field("QMU", &self.QMU)
            .field("QMV", &self.QMV)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.BaseQIndex == other.BaseQIndex
            && self.YDCDeltaQ == other.YDCDeltaQ
            && self.UDCDeltaQ == other.UDCDeltaQ
            && self.UACDeltaQ == other.UACDeltaQ
            && self.VDCDeltaQ == other.VDCDeltaQ
            && self.VACDeltaQ == other.VACDeltaQ
            && self.UsingQMatrix == other.UsingQMatrix
            && self.QMY == other.QMY
            && self.QMU == other.QMU
            && self.QMV == other.QMV
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG {
    pub DeltaQPresent: u64,
    pub DeltaQRes: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG")
            .field("DeltaQPresent", &self.DeltaQPresent)
            .field("DeltaQRes", &self.DeltaQRes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG {
    fn eq(&self, other: &Self) -> bool {
        self.DeltaQPresent == other.DeltaQPresent && self.DeltaQRes == other.DeltaQRes
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_AV1_QUANTIZATION_DELTA_CONFIG {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0 {
    pub pH264Config: *mut D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264,
    pub pHEVCConfig: *mut D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC,
    pub pAV1Config: *mut D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    pub ConfigurationFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_FLAGS,
    pub DirectModeConfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_DIRECT_MODES,
    pub DisableDeblockingFilterConfig:
        D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODES,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264")
            .field("ConfigurationFlags", &self.ConfigurationFlags)
            .field("DirectModeConfig", &self.DirectModeConfig)
            .field(
                "DisableDeblockingFilterConfig",
                &self.DisableDeblockingFilterConfig,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.ConfigurationFlags == other.ConfigurationFlags
            && self.DirectModeConfig == other.DirectModeConfig
            && self.DisableDeblockingFilterConfig == other.DisableDeblockingFilterConfig
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    pub ConfigurationFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_FLAGS,
    pub MinLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    pub MaxLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    pub MinLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    pub MaxLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    pub max_transform_hierarchy_depth_inter: u8,
    pub max_transform_hierarchy_depth_intra: u8,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC")
            .field("ConfigurationFlags", &self.ConfigurationFlags)
            .field("MinLumaCodingUnitSize", &self.MinLumaCodingUnitSize)
            .field("MaxLumaCodingUnitSize", &self.MaxLumaCodingUnitSize)
            .field("MinLumaTransformUnitSize", &self.MinLumaTransformUnitSize)
            .field("MaxLumaTransformUnitSize", &self.MaxLumaTransformUnitSize)
            .field(
                "max_transform_hierarchy_depth_inter",
                &self.max_transform_hierarchy_depth_inter,
            )
            .field(
                "max_transform_hierarchy_depth_intra",
                &self.max_transform_hierarchy_depth_intra,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.ConfigurationFlags == other.ConfigurationFlags
            && self.MinLumaCodingUnitSize == other.MinLumaCodingUnitSize
            && self.MaxLumaCodingUnitSize == other.MaxLumaCodingUnitSize
            && self.MinLumaTransformUnitSize == other.MinLumaTransformUnitSize
            && self.MaxLumaTransformUnitSize == other.MaxLumaTransformUnitSize
            && self.max_transform_hierarchy_depth_inter == other.max_transform_hierarchy_depth_inter
            && self.max_transform_hierarchy_depth_intra == other.max_transform_hierarchy_depth_intra
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0 {
    pub pH264Support: *mut D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264,
    pub pHEVCSupport: *mut D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC,
    pub pAV1Support: *mut D3D12_VIDEO_ENCODER_AV1_CODEC_CONFIGURATION_SUPPORT,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    pub SupportFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264_FLAGS,
    pub DisableDeblockingFilterSupportedModes:
        D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_H264_SLICES_DEBLOCKING_MODE_FLAGS,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264")
            .field("SupportFlags", &self.SupportFlags)
            .field(
                "DisableDeblockingFilterSupportedModes",
                &self.DisableDeblockingFilterSupportedModes,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.SupportFlags == other.SupportFlags
            && self.DisableDeblockingFilterSupportedModes
                == other.DisableDeblockingFilterSupportedModes
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    pub SupportFlags: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC_FLAGS,
    pub MinLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    pub MaxLumaCodingUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_CUSIZE,
    pub MinLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    pub MaxLumaTransformUnitSize: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_HEVC_TUSIZE,
    pub max_transform_hierarchy_depth_inter: u8,
    pub max_transform_hierarchy_depth_intra: u8,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC")
            .field("SupportFlags", &self.SupportFlags)
            .field("MinLumaCodingUnitSize", &self.MinLumaCodingUnitSize)
            .field("MaxLumaCodingUnitSize", &self.MaxLumaCodingUnitSize)
            .field("MinLumaTransformUnitSize", &self.MinLumaTransformUnitSize)
            .field("MaxLumaTransformUnitSize", &self.MaxLumaTransformUnitSize)
            .field(
                "max_transform_hierarchy_depth_inter",
                &self.max_transform_hierarchy_depth_inter,
            )
            .field(
                "max_transform_hierarchy_depth_intra",
                &self.max_transform_hierarchy_depth_intra,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.SupportFlags == other.SupportFlags
            && self.MinLumaCodingUnitSize == other.MinLumaCodingUnitSize
            && self.MaxLumaCodingUnitSize == other.MaxLumaCodingUnitSize
            && self.MinLumaTransformUnitSize == other.MinLumaTransformUnitSize
            && self.MaxLumaTransformUnitSize == other.MaxLumaTransformUnitSize
            && self.max_transform_hierarchy_depth_inter == other.max_transform_hierarchy_depth_inter
            && self.max_transform_hierarchy_depth_intra == other.max_transform_hierarchy_depth_intra
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION_SUPPORT_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0 {
    pub pH264Support: *mut D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264,
    pub pHEVCSupport: *mut D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC,
    pub pAV1Support: *mut D3D12_VIDEO_ENCODER_CODEC_AV1_PICTURE_CONTROL_SUPPORT,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    pub MaxL0ReferencesForP: u32,
    pub MaxL0ReferencesForB: u32,
    pub MaxL1ReferencesForB: u32,
    pub MaxLongTermReferences: u32,
    pub MaxDPBCapacity: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264")
            .field("MaxL0ReferencesForP", &self.MaxL0ReferencesForP)
            .field("MaxL0ReferencesForB", &self.MaxL0ReferencesForB)
            .field("MaxL1ReferencesForB", &self.MaxL1ReferencesForB)
            .field("MaxLongTermReferences", &self.MaxLongTermReferences)
            .field("MaxDPBCapacity", &self.MaxDPBCapacity)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.MaxL0ReferencesForP == other.MaxL0ReferencesForP
            && self.MaxL0ReferencesForB == other.MaxL0ReferencesForB
            && self.MaxL1ReferencesForB == other.MaxL1ReferencesForB
            && self.MaxLongTermReferences == other.MaxLongTermReferences
            && self.MaxDPBCapacity == other.MaxDPBCapacity
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    pub MaxL0ReferencesForP: u32,
    pub MaxL0ReferencesForB: u32,
    pub MaxL1ReferencesForB: u32,
    pub MaxLongTermReferences: u32,
    pub MaxDPBCapacity: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC")
            .field("MaxL0ReferencesForP", &self.MaxL0ReferencesForP)
            .field("MaxL0ReferencesForB", &self.MaxL0ReferencesForB)
            .field("MaxL1ReferencesForB", &self.MaxL1ReferencesForB)
            .field("MaxLongTermReferences", &self.MaxLongTermReferences)
            .field("MaxDPBCapacity", &self.MaxDPBCapacity)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.MaxL0ReferencesForP == other.MaxL0ReferencesForP
            && self.MaxL0ReferencesForB == other.MaxL0ReferencesForB
            && self.MaxL1ReferencesForB == other.MaxL1ReferencesForB
            && self.MaxLongTermReferences == other.MaxLongTermReferences
            && self.MaxDPBCapacity == other.MaxDPBCapacity
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_CODEC_PICTURE_CONTROL_SUPPORT_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    pub pBuffer: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub FrameStartOffset: u64,
}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM")
            .field("pBuffer", &self.pBuffer)
            .field("FrameStartOffset", &self.FrameStartOffset)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    fn eq(&self, other: &Self) -> bool {
        self.pBuffer == other.pBuffer && self.FrameStartOffset == other.FrameStartOffset
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_DESC {
    pub NodeMask: u32,
    pub Flags: D3D12_VIDEO_ENCODER_FLAGS,
    pub EncodeCodec: D3D12_VIDEO_ENCODER_CODEC,
    pub EncodeProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub InputFormat: DXGI_FORMAT,
    pub CodecConfiguration: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
    pub MaxMotionEstimationPrecision: D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS {
    pub SequenceControlDesc: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC,
    pub PictureControlDesc: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC,
    pub pInputFrame: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub InputFrameSubresource: u32,
    pub CurrentFrameBitstreamMetadataSize: u32,
}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    pub Bitstream: D3D12_VIDEO_ENCODER_COMPRESSED_BITSTREAM,
    pub ReconstructedPicture: D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE,
    pub EncoderOutputMetadata: D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER,
}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS")
            .field("Bitstream", &self.Bitstream)
            .field("ReconstructedPicture", &self.ReconstructedPicture)
            .field("EncoderOutputMetadata", &self.EncoderOutputMetadata)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.Bitstream == other.Bitstream
            && self.ReconstructedPicture == other.ReconstructedPicture
            && self.EncoderOutputMetadata == other.EncoderOutputMetadata
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    pub pBuffer: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub Offset: u64,
}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER")
            .field("pBuffer", &self.pBuffer)
            .field("Offset", &self.Offset)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    fn eq(&self, other: &Self) -> bool {
        self.pBuffer == other.pBuffer && self.Offset == other.Offset
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT_0 {
    pub pAV1Support: *mut D3D12_VIDEO_ENCODER_AV1_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_CONFIG_SUPPORT_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    pub bSize: u64,
    pub bStartOffset: u64,
    pub bHeaderSize: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA")
            .field("bSize", &self.bSize)
            .field("bStartOffset", &self.bStartOffset)
            .field("bHeaderSize", &self.bHeaderSize)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    fn eq(&self, other: &Self) -> bool {
        self.bSize == other.bSize
            && self.bStartOffset == other.bStartOffset
            && self.bHeaderSize == other.bHeaderSize
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_FRAME_SUBREGION_METADATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_HEAP_DESC {
    pub NodeMask: u32,
    pub Flags: D3D12_VIDEO_ENCODER_HEAP_FLAGS,
    pub EncodeCodec: D3D12_VIDEO_ENCODER_CODEC,
    pub EncodeProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub EncodeLevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    pub ResolutionsListCount: u32,
    pub pResolutionList: *const D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_HEAP_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_HEAP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_HEAP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_HEAP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    pub Mode: D3D12_VIDEO_ENCODER_INTRA_REFRESH_MODE,
    pub IntraRefreshDuration: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_INTRA_REFRESH {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_INTRA_REFRESH")
            .field("Mode", &self.Mode)
            .field("IntraRefreshDuration", &self.IntraRefreshDuration)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    fn eq(&self, other: &Self) -> bool {
        self.Mode == other.Mode && self.IntraRefreshDuration == other.IntraRefreshDuration
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_INTRA_REFRESH {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_INTRA_REFRESH {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_LEVEL_SETTING {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_LEVEL_SETTING_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_LEVEL_SETTING {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_LEVEL_SETTING {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_LEVEL_SETTING {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_LEVEL_SETTING {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_LEVEL_SETTING_0 {
    pub pH264LevelSetting: *mut D3D12_VIDEO_ENCODER_LEVELS_H264,
    pub pHEVCLevelSetting: *mut D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC,
    pub pAV1LevelSetting: *mut D3D12_VIDEO_ENCODER_AV1_LEVEL_TIER_CONSTRAINTS,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_LEVEL_SETTING_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_LEVEL_SETTING_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_LEVEL_SETTING_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_LEVEL_SETTING_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    pub Level: D3D12_VIDEO_ENCODER_LEVELS_HEVC,
    pub Tier: D3D12_VIDEO_ENCODER_TIER_HEVC,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC")
            .field("Level", &self.Level)
            .field("Tier", &self.Tier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.Level == other.Level && self.Tier == other.Tier
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_LEVEL_TIER_CONSTRAINTS_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    pub EncodeErrorFlags: u64,
    pub EncodeStats: D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS,
    pub EncodedBitstreamWrittenBytesCount: u64,
    pub WrittenSubregionsCount: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_OUTPUT_METADATA")
            .field("EncodeErrorFlags", &self.EncodeErrorFlags)
            .field("EncodeStats", &self.EncodeStats)
            .field(
                "EncodedBitstreamWrittenBytesCount",
                &self.EncodedBitstreamWrittenBytesCount,
            )
            .field("WrittenSubregionsCount", &self.WrittenSubregionsCount)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    fn eq(&self, other: &Self) -> bool {
        self.EncodeErrorFlags == other.EncodeErrorFlags
            && self.EncodeStats == other.EncodeStats
            && self.EncodedBitstreamWrittenBytesCount == other.EncodedBitstreamWrittenBytesCount
            && self.WrittenSubregionsCount == other.WrittenSubregionsCount
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_OUTPUT_METADATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    pub AverageQP: u64,
    pub IntraCodingUnitsCount: u64,
    pub InterCodingUnitsCount: u64,
    pub SkipCodingUnitsCount: u64,
    pub AverageMotionEstimationXDirection: u64,
    pub AverageMotionEstimationYDirection: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS")
            .field("AverageQP", &self.AverageQP)
            .field("IntraCodingUnitsCount", &self.IntraCodingUnitsCount)
            .field("InterCodingUnitsCount", &self.InterCodingUnitsCount)
            .field("SkipCodingUnitsCount", &self.SkipCodingUnitsCount)
            .field(
                "AverageMotionEstimationXDirection",
                &self.AverageMotionEstimationXDirection,
            )
            .field(
                "AverageMotionEstimationYDirection",
                &self.AverageMotionEstimationYDirection,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    fn eq(&self, other: &Self) -> bool {
        self.AverageQP == other.AverageQP
            && self.IntraCodingUnitsCount == other.IntraCodingUnitsCount
            && self.InterCodingUnitsCount == other.InterCodingUnitsCount
            && self.SkipCodingUnitsCount == other.SkipCodingUnitsCount
            && self.AverageMotionEstimationXDirection == other.AverageMotionEstimationXDirection
            && self.AverageMotionEstimationYDirection == other.AverageMotionEstimationYDirection
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_OUTPUT_METADATA_STATISTICS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0 {
    pub pH264PicData: *mut D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264,
    pub pHEVCPicData: *mut D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC,
    pub pAV1PicData: *mut D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_CODEC_DATA,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 { pub Flags : D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_FLAGS , pub FrameType : D3D12_VIDEO_ENCODER_FRAME_TYPE_H264 , pub pic_parameter_set_id : u32 , pub idr_pic_id : u32 , pub PictureOrderCountNumber : u32 , pub FrameDecodingOrderNumber : u32 , pub TemporalLayerIndex : u32 , pub List0ReferenceFramesCount : u32 , pub pList0ReferenceFrames : *mut u32 , pub List1ReferenceFramesCount : u32 , pub pList1ReferenceFrames : *mut u32 , pub ReferenceFramesReconPictureDescriptorsCount : u32 , pub pReferenceFramesReconPictureDescriptors : *mut D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 , pub adaptive_ref_pic_marking_mode_flag : u8 , pub RefPicMarkingOperationsCommandsCount : u32 , pub pRefPicMarkingOperationsCommands : *mut D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION , pub List0RefPicModificationsCount : u32 , pub pList0RefPicModifications : *mut D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION , pub List1RefPicModificationsCount : u32 , pub pList1RefPicModifications : *mut D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION , pub QPMapValuesCount : u32 , pub pRateControlQPMap : *mut i8 , }
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264")
            .field("Flags", &self.Flags)
            .field("FrameType", &self.FrameType)
            .field("pic_parameter_set_id", &self.pic_parameter_set_id)
            .field("idr_pic_id", &self.idr_pic_id)
            .field("PictureOrderCountNumber", &self.PictureOrderCountNumber)
            .field("FrameDecodingOrderNumber", &self.FrameDecodingOrderNumber)
            .field("TemporalLayerIndex", &self.TemporalLayerIndex)
            .field("List0ReferenceFramesCount", &self.List0ReferenceFramesCount)
            .field("pList0ReferenceFrames", &self.pList0ReferenceFrames)
            .field("List1ReferenceFramesCount", &self.List1ReferenceFramesCount)
            .field("pList1ReferenceFrames", &self.pList1ReferenceFrames)
            .field(
                "ReferenceFramesReconPictureDescriptorsCount",
                &self.ReferenceFramesReconPictureDescriptorsCount,
            )
            .field(
                "pReferenceFramesReconPictureDescriptors",
                &self.pReferenceFramesReconPictureDescriptors,
            )
            .field(
                "adaptive_ref_pic_marking_mode_flag",
                &self.adaptive_ref_pic_marking_mode_flag,
            )
            .field(
                "RefPicMarkingOperationsCommandsCount",
                &self.RefPicMarkingOperationsCommandsCount,
            )
            .field(
                "pRefPicMarkingOperationsCommands",
                &self.pRefPicMarkingOperationsCommands,
            )
            .field(
                "List0RefPicModificationsCount",
                &self.List0RefPicModificationsCount,
            )
            .field("pList0RefPicModifications", &self.pList0RefPicModifications)
            .field(
                "List1RefPicModificationsCount",
                &self.List1RefPicModificationsCount,
            )
            .field("pList1RefPicModifications", &self.pList1RefPicModifications)
            .field("QPMapValuesCount", &self.QPMapValuesCount)
            .field("pRateControlQPMap", &self.pRateControlQPMap)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.FrameType == other.FrameType
            && self.pic_parameter_set_id == other.pic_parameter_set_id
            && self.idr_pic_id == other.idr_pic_id
            && self.PictureOrderCountNumber == other.PictureOrderCountNumber
            && self.FrameDecodingOrderNumber == other.FrameDecodingOrderNumber
            && self.TemporalLayerIndex == other.TemporalLayerIndex
            && self.List0ReferenceFramesCount == other.List0ReferenceFramesCount
            && self.pList0ReferenceFrames == other.pList0ReferenceFrames
            && self.List1ReferenceFramesCount == other.List1ReferenceFramesCount
            && self.pList1ReferenceFrames == other.pList1ReferenceFrames
            && self.ReferenceFramesReconPictureDescriptorsCount
                == other.ReferenceFramesReconPictureDescriptorsCount
            && self.pReferenceFramesReconPictureDescriptors
                == other.pReferenceFramesReconPictureDescriptors
            && self.adaptive_ref_pic_marking_mode_flag == other.adaptive_ref_pic_marking_mode_flag
            && self.RefPicMarkingOperationsCommandsCount
                == other.RefPicMarkingOperationsCommandsCount
            && self.pRefPicMarkingOperationsCommands == other.pRefPicMarkingOperationsCommands
            && self.List0RefPicModificationsCount == other.List0RefPicModificationsCount
            && self.pList0RefPicModifications == other.pList0RefPicModifications
            && self.List1RefPicModificationsCount == other.List1RefPicModificationsCount
            && self.pList1RefPicModifications == other.pList1RefPicModifications
            && self.QPMapValuesCount == other.QPMapValuesCount
            && self.pRateControlQPMap == other.pRateControlQPMap
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION
{
    pub modification_of_pic_nums_idc: u8,
    pub abs_diff_pic_num_minus1: u32,
    pub long_term_pic_num: u32,
}
impl::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION { }
impl::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION { fn clone ( & self ) -> Self { * self } }
impl::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION { fn fmt ( & self , f : & mut::core::fmt::Formatter < '_ > ) ->::core::fmt::Result { f . debug_struct ( "D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION" ) . field ( "modification_of_pic_nums_idc" , & self . modification_of_pic_nums_idc ) . field ( "abs_diff_pic_num_minus1" , & self . abs_diff_pic_num_minus1 ) . field ( "long_term_pic_num" , & self . long_term_pic_num ) . finish ( ) } }
impl::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION { type TypeKind =::windows::core:: CopyType ; }
impl::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION { fn eq ( & self , other : & Self ) -> bool { self . modification_of_pic_nums_idc == other . modification_of_pic_nums_idc && self . abs_diff_pic_num_minus1 == other . abs_diff_pic_num_minus1 && self . long_term_pic_num == other . long_term_pic_num } }
impl::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION { }
impl::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_LIST_MODIFICATION_OPERATION { fn default ( ) -> Self { unsafe { ::core::mem::zeroed ( ) } } }
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION {
    pub memory_management_control_operation: u8,
    pub difference_of_pic_nums_minus1: u32,
    pub long_term_pic_num: u32,
    pub long_term_frame_idx: u32,
    pub max_long_term_frame_idx_plus1: u32,
}
impl ::core::marker::Copy
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION
{
}
impl ::core::clone::Clone
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION
{
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION
{
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f . debug_struct ( "D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION" ) . field ( "memory_management_control_operation" , & self . memory_management_control_operation ) . field ( "difference_of_pic_nums_minus1" , & self . difference_of_pic_nums_minus1 ) . field ( "long_term_pic_num" , & self . long_term_pic_num ) . field ( "long_term_frame_idx" , & self . long_term_frame_idx ) . field ( "max_long_term_frame_idx_plus1" , & self . max_long_term_frame_idx_plus1 ) . finish ( )
    }
}
impl ::windows::core::TypeKind
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION
{
    fn eq(&self, other: &Self) -> bool {
        self.memory_management_control_operation == other.memory_management_control_operation
            && self.difference_of_pic_nums_minus1 == other.difference_of_pic_nums_minus1
            && self.long_term_pic_num == other.long_term_pic_num
            && self.long_term_frame_idx == other.long_term_frame_idx
            && self.max_long_term_frame_idx_plus1 == other.max_long_term_frame_idx_plus1
    }
}
impl ::core::cmp::Eq
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION
{
}
impl ::core::default::Default
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_H264_REFERENCE_PICTURE_MARKING_OPERATION
{
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    pub Flags: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC_FLAGS,
    pub FrameType: D3D12_VIDEO_ENCODER_FRAME_TYPE_HEVC,
    pub slice_pic_parameter_set_id: u32,
    pub PictureOrderCountNumber: u32,
    pub TemporalLayerIndex: u32,
    pub List0ReferenceFramesCount: u32,
    pub pList0ReferenceFrames: *mut u32,
    pub List1ReferenceFramesCount: u32,
    pub pList1ReferenceFrames: *mut u32,
    pub ReferenceFramesReconPictureDescriptorsCount: u32,
    pub pReferenceFramesReconPictureDescriptors:
        *mut D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC,
    pub List0RefPicModificationsCount: u32,
    pub pList0RefPicModifications: *mut u32,
    pub List1RefPicModificationsCount: u32,
    pub pList1RefPicModifications: *mut u32,
    pub QPMapValuesCount: u32,
    pub pRateControlQPMap: *mut i8,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC")
            .field("Flags", &self.Flags)
            .field("FrameType", &self.FrameType)
            .field(
                "slice_pic_parameter_set_id",
                &self.slice_pic_parameter_set_id,
            )
            .field("PictureOrderCountNumber", &self.PictureOrderCountNumber)
            .field("TemporalLayerIndex", &self.TemporalLayerIndex)
            .field("List0ReferenceFramesCount", &self.List0ReferenceFramesCount)
            .field("pList0ReferenceFrames", &self.pList0ReferenceFrames)
            .field("List1ReferenceFramesCount", &self.List1ReferenceFramesCount)
            .field("pList1ReferenceFrames", &self.pList1ReferenceFrames)
            .field(
                "ReferenceFramesReconPictureDescriptorsCount",
                &self.ReferenceFramesReconPictureDescriptorsCount,
            )
            .field(
                "pReferenceFramesReconPictureDescriptors",
                &self.pReferenceFramesReconPictureDescriptors,
            )
            .field(
                "List0RefPicModificationsCount",
                &self.List0RefPicModificationsCount,
            )
            .field("pList0RefPicModifications", &self.pList0RefPicModifications)
            .field(
                "List1RefPicModificationsCount",
                &self.List1RefPicModificationsCount,
            )
            .field("pList1RefPicModifications", &self.pList1RefPicModifications)
            .field("QPMapValuesCount", &self.QPMapValuesCount)
            .field("pRateControlQPMap", &self.pRateControlQPMap)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.Flags == other.Flags
            && self.FrameType == other.FrameType
            && self.slice_pic_parameter_set_id == other.slice_pic_parameter_set_id
            && self.PictureOrderCountNumber == other.PictureOrderCountNumber
            && self.TemporalLayerIndex == other.TemporalLayerIndex
            && self.List0ReferenceFramesCount == other.List0ReferenceFramesCount
            && self.pList0ReferenceFrames == other.pList0ReferenceFrames
            && self.List1ReferenceFramesCount == other.List1ReferenceFramesCount
            && self.pList1ReferenceFrames == other.pList1ReferenceFrames
            && self.ReferenceFramesReconPictureDescriptorsCount
                == other.ReferenceFramesReconPictureDescriptorsCount
            && self.pReferenceFramesReconPictureDescriptors
                == other.pReferenceFramesReconPictureDescriptors
            && self.List0RefPicModificationsCount == other.List0RefPicModificationsCount
            && self.pList0RefPicModifications == other.pList0RefPicModifications
            && self.List1RefPicModificationsCount == other.List1RefPicModificationsCount
            && self.pList1RefPicModifications == other.pList1RefPicModifications
            && self.QPMapValuesCount == other.QPMapValuesCount
            && self.pRateControlQPMap == other.pRateControlQPMap
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC {
    pub IntraRefreshFrameIndex: u32,
    pub Flags: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_FLAGS,
    pub PictureControlCodecData: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_CODEC_DATA,
    pub ReferenceFrames: D3D12_VIDEO_ENCODE_REFERENCE_FRAMES,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0 {
    pub pSlicesPartition_H264:
        *const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES,
    pub pSlicesPartition_HEVC:
        *const D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES,
    pub pTilesPartition_AV1:
        *const D3D12_VIDEO_ENCODER_AV1_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_TILES,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES {
    pub Anonymous: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES
{
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0 {
    pub MaxBytesPerSlice: u32,
    pub NumberOfCodingUnitsPerSlice: u32,
    pub NumberOfRowsPerSlice: u32,
    pub NumberOfSlicesPerFrame: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0
{
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default
    for D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA_SLICES_0
{
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    pub Width: u32,
    pub Height: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC")
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Width == other.Width && self.Height == other.Height
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    pub WidthRatio: u32,
    pub HeightRatio: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC")
            .field("WidthRatio", &self.WidthRatio)
            .field("HeightRatio", &self.HeightRatio)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.WidthRatio == other.WidthRatio && self.HeightRatio == other.HeightRatio
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_RATIO_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_PROFILE_DESC {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_PROFILE_DESC_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PROFILE_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PROFILE_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PROFILE_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PROFILE_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_PROFILE_DESC_0 {
    pub pH264Profile: *mut D3D12_VIDEO_ENCODER_PROFILE_H264,
    pub pHEVCProfile: *mut D3D12_VIDEO_ENCODER_PROFILE_HEVC,
    pub pAV1Profile: *mut D3D12_VIDEO_ENCODER_AV1_PROFILE,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_PROFILE_DESC_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_PROFILE_DESC_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_PROFILE_DESC_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_PROFILE_DESC_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL {
    pub Mode: D3D12_VIDEO_ENCODER_RATE_CONTROL_MODE,
    pub Flags: D3D12_VIDEO_ENCODER_RATE_CONTROL_FLAGS,
    pub ConfigParams: D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS,
    pub TargetFrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    pub InitialQP: u32,
    pub MinQP: u32,
    pub MaxQP: u32,
    pub MaxFrameBitSize: u64,
    pub TargetBitRate: u64,
    pub VBVCapacity: u64,
    pub InitialVBVFullness: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR")
            .field("InitialQP", &self.InitialQP)
            .field("MinQP", &self.MinQP)
            .field("MaxQP", &self.MaxQP)
            .field("MaxFrameBitSize", &self.MaxFrameBitSize)
            .field("TargetBitRate", &self.TargetBitRate)
            .field("VBVCapacity", &self.VBVCapacity)
            .field("InitialVBVFullness", &self.InitialVBVFullness)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    fn eq(&self, other: &Self) -> bool {
        self.InitialQP == other.InitialQP
            && self.MinQP == other.MinQP
            && self.MaxQP == other.MaxQP
            && self.MaxFrameBitSize == other.MaxFrameBitSize
            && self.TargetBitRate == other.TargetBitRate
            && self.VBVCapacity == other.VBVCapacity
            && self.InitialVBVFullness == other.InitialVBVFullness
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0 {
    pub pConfiguration_CQP: *const D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP,
    pub pConfiguration_CBR: *const D3D12_VIDEO_ENCODER_RATE_CONTROL_CBR,
    pub pConfiguration_VBR: *const D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR,
    pub pConfiguration_QVBR: *const D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR,
    pub pConfiguration_QVBR1: *const D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR1,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_CONFIGURATION_PARAMS_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    pub ConstantQP_FullIntracodedFrame: u32,
    pub ConstantQP_InterPredictedFrame_PrevRefOnly: u32,
    pub ConstantQP_InterPredictedFrame_BiDirectionalRef: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP")
            .field(
                "ConstantQP_FullIntracodedFrame",
                &self.ConstantQP_FullIntracodedFrame,
            )
            .field(
                "ConstantQP_InterPredictedFrame_PrevRefOnly",
                &self.ConstantQP_InterPredictedFrame_PrevRefOnly,
            )
            .field(
                "ConstantQP_InterPredictedFrame_BiDirectionalRef",
                &self.ConstantQP_InterPredictedFrame_BiDirectionalRef,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    fn eq(&self, other: &Self) -> bool {
        self.ConstantQP_FullIntracodedFrame == other.ConstantQP_FullIntracodedFrame
            && self.ConstantQP_InterPredictedFrame_PrevRefOnly
                == other.ConstantQP_InterPredictedFrame_PrevRefOnly
            && self.ConstantQP_InterPredictedFrame_BiDirectionalRef
                == other.ConstantQP_InterPredictedFrame_BiDirectionalRef
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_CQP {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    pub InitialQP: u32,
    pub MinQP: u32,
    pub MaxQP: u32,
    pub MaxFrameBitSize: u64,
    pub TargetAvgBitRate: u64,
    pub PeakBitRate: u64,
    pub ConstantQualityTarget: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR")
            .field("InitialQP", &self.InitialQP)
            .field("MinQP", &self.MinQP)
            .field("MaxQP", &self.MaxQP)
            .field("MaxFrameBitSize", &self.MaxFrameBitSize)
            .field("TargetAvgBitRate", &self.TargetAvgBitRate)
            .field("PeakBitRate", &self.PeakBitRate)
            .field("ConstantQualityTarget", &self.ConstantQualityTarget)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    fn eq(&self, other: &Self) -> bool {
        self.InitialQP == other.InitialQP
            && self.MinQP == other.MinQP
            && self.MaxQP == other.MaxQP
            && self.MaxFrameBitSize == other.MaxFrameBitSize
            && self.TargetAvgBitRate == other.TargetAvgBitRate
            && self.PeakBitRate == other.PeakBitRate
            && self.ConstantQualityTarget == other.ConstantQualityTarget
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR1 {
    pub InitialQP: u32,
    pub MinQP: u32,
    pub MaxQP: u32,
    pub MaxFrameBitSize: u64,
    pub TargetAvgBitRate: u64,
    pub PeakBitRate: u64,
    pub VBVCapacity: u64,
    pub InitialVBVFullness: u64,
    pub ConstantQualityTarget: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR1 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR1 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR1")
            .field("InitialQP", &self.InitialQP)
            .field("MinQP", &self.MinQP)
            .field("MaxQP", &self.MaxQP)
            .field("MaxFrameBitSize", &self.MaxFrameBitSize)
            .field("TargetAvgBitRate", &self.TargetAvgBitRate)
            .field("PeakBitRate", &self.PeakBitRate)
            .field("VBVCapacity", &self.VBVCapacity)
            .field("InitialVBVFullness", &self.InitialVBVFullness)
            .field("ConstantQualityTarget", &self.ConstantQualityTarget)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR1 {
    fn eq(&self, other: &Self) -> bool {
        self.InitialQP == other.InitialQP
            && self.MinQP == other.MinQP
            && self.MaxQP == other.MaxQP
            && self.MaxFrameBitSize == other.MaxFrameBitSize
            && self.TargetAvgBitRate == other.TargetAvgBitRate
            && self.PeakBitRate == other.PeakBitRate
            && self.VBVCapacity == other.VBVCapacity
            && self.InitialVBVFullness == other.InitialVBVFullness
            && self.ConstantQualityTarget == other.ConstantQualityTarget
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR1 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_QVBR1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    pub InitialQP: u32,
    pub MinQP: u32,
    pub MaxQP: u32,
    pub MaxFrameBitSize: u64,
    pub TargetAvgBitRate: u64,
    pub PeakBitRate: u64,
    pub VBVCapacity: u64,
    pub InitialVBVFullness: u64,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR")
            .field("InitialQP", &self.InitialQP)
            .field("MinQP", &self.MinQP)
            .field("MaxQP", &self.MaxQP)
            .field("MaxFrameBitSize", &self.MaxFrameBitSize)
            .field("TargetAvgBitRate", &self.TargetAvgBitRate)
            .field("PeakBitRate", &self.PeakBitRate)
            .field("VBVCapacity", &self.VBVCapacity)
            .field("InitialVBVFullness", &self.InitialVBVFullness)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    fn eq(&self, other: &Self) -> bool {
        self.InitialQP == other.InitialQP
            && self.MinQP == other.MinQP
            && self.MaxQP == other.MaxQP
            && self.MaxFrameBitSize == other.MaxFrameBitSize
            && self.TargetAvgBitRate == other.TargetAvgBitRate
            && self.PeakBitRate == other.PeakBitRate
            && self.VBVCapacity == other.VBVCapacity
            && self.InitialVBVFullness == other.InitialVBVFullness
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RATE_CONTROL_VBR {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    pub pReconstructedPicture: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub ReconstructedPictureSubresource: u32,
}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE")
            .field("pReconstructedPicture", &self.pReconstructedPicture)
            .field(
                "ReconstructedPictureSubresource",
                &self.ReconstructedPictureSubresource,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    fn eq(&self, other: &Self) -> bool {
        self.pReconstructedPicture == other.pReconstructedPicture
            && self.ReconstructedPictureSubresource == other.ReconstructedPictureSubresource
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RECONSTRUCTED_PICTURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    pub ReconstructedPictureResourceIndex: u32,
    pub IsLongTermReference: ::windows::Win32::Foundation::BOOL,
    pub LongTermPictureIdx: u32,
    pub PictureOrderCountNumber: u32,
    pub FrameDecodingOrderNumber: u32,
    pub TemporalLayerIndex: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264")
            .field(
                "ReconstructedPictureResourceIndex",
                &self.ReconstructedPictureResourceIndex,
            )
            .field("IsLongTermReference", &self.IsLongTermReference)
            .field("LongTermPictureIdx", &self.LongTermPictureIdx)
            .field("PictureOrderCountNumber", &self.PictureOrderCountNumber)
            .field("FrameDecodingOrderNumber", &self.FrameDecodingOrderNumber)
            .field("TemporalLayerIndex", &self.TemporalLayerIndex)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.ReconstructedPictureResourceIndex == other.ReconstructedPictureResourceIndex
            && self.IsLongTermReference == other.IsLongTermReference
            && self.LongTermPictureIdx == other.LongTermPictureIdx
            && self.PictureOrderCountNumber == other.PictureOrderCountNumber
            && self.FrameDecodingOrderNumber == other.FrameDecodingOrderNumber
            && self.TemporalLayerIndex == other.TemporalLayerIndex
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    pub ReconstructedPictureResourceIndex: u32,
    pub IsRefUsedByCurrentPic: ::windows::Win32::Foundation::BOOL,
    pub IsLongTermReference: ::windows::Win32::Foundation::BOOL,
    pub PictureOrderCountNumber: u32,
    pub TemporalLayerIndex: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC")
            .field(
                "ReconstructedPictureResourceIndex",
                &self.ReconstructedPictureResourceIndex,
            )
            .field("IsRefUsedByCurrentPic", &self.IsRefUsedByCurrentPic)
            .field("IsLongTermReference", &self.IsLongTermReference)
            .field("PictureOrderCountNumber", &self.PictureOrderCountNumber)
            .field("TemporalLayerIndex", &self.TemporalLayerIndex)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.ReconstructedPictureResourceIndex == other.ReconstructedPictureResourceIndex
            && self.IsRefUsedByCurrentPic == other.IsRefUsedByCurrentPic
            && self.IsLongTermReference == other.IsLongTermReference
            && self.PictureOrderCountNumber == other.PictureOrderCountNumber
            && self.TemporalLayerIndex == other.TemporalLayerIndex
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_REFERENCE_PICTURE_DESCRIPTOR_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS {
    pub EncoderCodec: D3D12_VIDEO_ENCODER_CODEC,
    pub EncoderProfile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
    pub EncoderInputFormat: DXGI_FORMAT,
    pub EncodedPictureEffectiveResolution: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub HWLayoutMetadata: D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER,
}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    pub ResolvedLayoutMetadata: D3D12_VIDEO_ENCODER_ENCODE_OPERATION_METADATA_BUFFER,
}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS")
            .field("ResolvedLayoutMetadata", &self.ResolvedLayoutMetadata)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.ResolvedLayoutMetadata == other.ResolvedLayoutMetadata
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC {
    pub Flags: D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_FLAGS,
    pub IntraRefreshConfig: D3D12_VIDEO_ENCODER_INTRA_REFRESH,
    pub RateControl: D3D12_VIDEO_ENCODER_RATE_CONTROL,
    pub PictureTargetResolution: D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    pub SelectedLayoutMode: D3D12_VIDEO_ENCODER_FRAME_SUBREGION_LAYOUT_MODE,
    pub FrameSubregionsLayoutData: D3D12_VIDEO_ENCODER_PICTURE_CONTROL_SUBREGIONS_LAYOUT_DATA,
    pub CodecGopSequence: D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_CONTROL_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE {
    pub DataSize: u32,
    pub Anonymous: D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub union D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0 {
    pub pH264GroupOfPictures: *mut D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264,
    pub pHEVCGroupOfPictures: *mut D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC,
    pub pAV1SequenceStructure: *mut D3D12_VIDEO_ENCODER_AV1_SEQUENCE_STRUCTURE,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_0 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    pub GOPLength: u32,
    pub PPicturePeriod: u32,
    pub pic_order_cnt_type: u8,
    pub log2_max_frame_num_minus4: u8,
    pub log2_max_pic_order_cnt_lsb_minus4: u8,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264")
            .field("GOPLength", &self.GOPLength)
            .field("PPicturePeriod", &self.PPicturePeriod)
            .field("pic_order_cnt_type", &self.pic_order_cnt_type)
            .field("log2_max_frame_num_minus4", &self.log2_max_frame_num_minus4)
            .field(
                "log2_max_pic_order_cnt_lsb_minus4",
                &self.log2_max_pic_order_cnt_lsb_minus4,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    fn eq(&self, other: &Self) -> bool {
        self.GOPLength == other.GOPLength
            && self.PPicturePeriod == other.PPicturePeriod
            && self.pic_order_cnt_type == other.pic_order_cnt_type
            && self.log2_max_frame_num_minus4 == other.log2_max_frame_num_minus4
            && self.log2_max_pic_order_cnt_lsb_minus4 == other.log2_max_pic_order_cnt_lsb_minus4
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_H264 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    pub GOPLength: u32,
    pub PPicturePeriod: u32,
    pub log2_max_pic_order_cnt_lsb_minus4: u8,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC")
            .field("GOPLength", &self.GOPLength)
            .field("PPicturePeriod", &self.PPicturePeriod)
            .field(
                "log2_max_pic_order_cnt_lsb_minus4",
                &self.log2_max_pic_order_cnt_lsb_minus4,
            )
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    fn eq(&self, other: &Self) -> bool {
        self.GOPLength == other.GOPLength
            && self.PPicturePeriod == other.PPicturePeriod
            && self.log2_max_pic_order_cnt_lsb_minus4 == other.log2_max_pic_order_cnt_lsb_minus4
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {}
impl ::core::default::Default for D3D12_VIDEO_ENCODER_SEQUENCE_GOP_STRUCTURE_HEVC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    pub NumTexture2Ds: u32,
    pub ppTexture2Ds: *mut ::core::option::Option<ID3D12Resource>,
    pub pSubresources: *mut u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {}
impl ::core::clone::Clone for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_ENCODE_REFERENCE_FRAMES")
            .field("NumTexture2Ds", &self.NumTexture2Ds)
            .field("ppTexture2Ds", &self.ppTexture2Ds)
            .field("pSubresources", &self.pSubresources)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    fn eq(&self, other: &Self) -> bool {
        self.NumTexture2Ds == other.NumTexture2Ds
            && self.ppTexture2Ds == other.ppTexture2Ds
            && self.pSubresources == other.pSubresources
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {}
impl ::core::default::Default for D3D12_VIDEO_ENCODE_REFERENCE_FRAMES {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    pub NodeMask: u32,
    pub CommandId: ::windows::core::GUID,
}
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_EXTENSION_COMMAND_DESC")
            .field("NodeMask", &self.NodeMask)
            .field("CommandId", &self.CommandId)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask && self.CommandId == other.CommandId
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_EXTENSION_COMMAND_DESC {}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    pub CommandId: ::windows::core::GUID,
    pub Name: ::windows::core::PCWSTR,
    pub CommandListSupportFlags: D3D12_COMMAND_LIST_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_INFO {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_EXTENSION_COMMAND_INFO")
            .field("CommandId", &self.CommandId)
            .field("Name", &self.Name)
            .field("CommandListSupportFlags", &self.CommandListSupportFlags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.CommandId == other.CommandId
            && self.Name == other.Name
            && self.CommandListSupportFlags == other.CommandListSupportFlags
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_EXTENSION_COMMAND_INFO {}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    pub Name: ::windows::core::PCWSTR,
    pub Type: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_TYPE,
    pub Flags: D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_FLAGS,
}
impl ::core::marker::Copy for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {}
impl ::core::clone::Clone for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO")
            .field("Name", &self.Name)
            .field("Type", &self.Type)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name && self.Type == other.Type && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {}
impl ::core::default::Default for D3D12_VIDEO_EXTENSION_COMMAND_PARAMETER_INFO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_FORMAT {
    pub Format: DXGI_FORMAT,
    pub ColorSpace: ::windows::Win32::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
}
impl ::core::marker::Copy for D3D12_VIDEO_FORMAT {}
impl ::core::clone::Clone for D3D12_VIDEO_FORMAT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_FORMAT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_FORMAT")
            .field("Format", &self.Format)
            .field("ColorSpace", &self.ColorSpace)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_FORMAT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_FORMAT {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format && self.ColorSpace == other.ColorSpace
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_FORMAT {}
impl ::core::default::Default for D3D12_VIDEO_FORMAT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    pub NodeMask: u32,
    pub InputFormat: DXGI_FORMAT,
    pub BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    pub Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    pub SizeRange: D3D12_VIDEO_SIZE_RANGE,
}
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_MOTION_ESTIMATOR_DESC")
            .field("NodeMask", &self.NodeMask)
            .field("InputFormat", &self.InputFormat)
            .field("BlockSize", &self.BlockSize)
            .field("Precision", &self.Precision)
            .field("SizeRange", &self.SizeRange)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask
            && self.InputFormat == other.InputFormat
            && self.BlockSize == other.BlockSize
            && self.Precision == other.Precision
            && self.SizeRange == other.SizeRange
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    pub pInputTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub InputSubresourceIndex: u32,
    pub pReferenceTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub ReferenceSubresourceIndex: u32,
    pub pHintMotionVectorHeap:
        ::std::mem::ManuallyDrop<::core::option::Option<ID3D12VideoMotionVectorHeap>>,
}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_MOTION_ESTIMATOR_INPUT")
            .field("pInputTexture2D", &self.pInputTexture2D)
            .field("InputSubresourceIndex", &self.InputSubresourceIndex)
            .field("pReferenceTexture2D", &self.pReferenceTexture2D)
            .field("ReferenceSubresourceIndex", &self.ReferenceSubresourceIndex)
            .field("pHintMotionVectorHeap", &self.pHintMotionVectorHeap)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    fn eq(&self, other: &Self) -> bool {
        self.pInputTexture2D == other.pInputTexture2D
            && self.InputSubresourceIndex == other.InputSubresourceIndex
            && self.pReferenceTexture2D == other.pReferenceTexture2D
            && self.ReferenceSubresourceIndex == other.ReferenceSubresourceIndex
            && self.pHintMotionVectorHeap == other.pHintMotionVectorHeap
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_INPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    pub pMotionVectorHeap:
        ::std::mem::ManuallyDrop<::core::option::Option<ID3D12VideoMotionVectorHeap>>,
}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT")
            .field("pMotionVectorHeap", &self.pMotionVectorHeap)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    fn eq(&self, other: &Self) -> bool {
        self.pMotionVectorHeap == other.pMotionVectorHeap
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {}
impl ::core::default::Default for D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    pub NodeMask: u32,
    pub InputFormat: DXGI_FORMAT,
    pub BlockSize: D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE,
    pub Precision: D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION,
    pub SizeRange: D3D12_VIDEO_SIZE_RANGE,
}
impl ::core::marker::Copy for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC")
            .field("NodeMask", &self.NodeMask)
            .field("InputFormat", &self.InputFormat)
            .field("BlockSize", &self.BlockSize)
            .field("Precision", &self.Precision)
            .field("SizeRange", &self.SizeRange)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.NodeMask == other.NodeMask
            && self.InputFormat == other.InputFormat
            && self.BlockSize == other.BlockSize
            && self.Precision == other.Precision
            && self.SizeRange == other.SizeRange
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {}
impl ::core::default::Default for D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    pub Enable: ::windows::Win32::Foundation::BOOL,
    pub Alpha: f32,
}
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_ALPHA_BLENDING")
            .field("Enable", &self.Enable)
            .field("Alpha", &self.Alpha)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.Alpha == other.Alpha
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_ALPHA_BLENDING {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_FILTER_RANGE {
    pub Minimum: i32,
    pub Maximum: i32,
    pub Default: i32,
    pub Multiplier: f32,
}
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_FILTER_RANGE {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_FILTER_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_FILTER_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_FILTER_RANGE")
            .field("Minimum", &self.Minimum)
            .field("Maximum", &self.Maximum)
            .field("Default", &self.Default)
            .field("Multiplier", &self.Multiplier)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_FILTER_RANGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_FILTER_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.Minimum == other.Minimum
            && self.Maximum == other.Maximum
            && self.Default == other.Default
            && self.Multiplier == other.Multiplier
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_FILTER_RANGE {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_FILTER_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM {
    pub pTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub Subresource: u32,
    pub ReferenceSet: D3D12_VIDEO_PROCESS_REFERENCE_SET,
}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_INPUT_STREAM")
            .field("pTexture2D", &self.pTexture2D)
            .field("Subresource", &self.Subresource)
            .field("ReferenceSet", &self.ReferenceSet)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_INPUT_STREAM {
    fn eq(&self, other: &Self) -> bool {
        self.pTexture2D == other.pTexture2D
            && self.Subresource == other.Subresource
            && self.ReferenceSet == other.ReferenceSet
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_INPUT_STREAM {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    pub InputStream: [D3D12_VIDEO_PROCESS_INPUT_STREAM; 2],
    pub Transform: D3D12_VIDEO_PROCESS_TRANSFORM,
    pub Flags: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS,
    pub RateInfo: D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE,
    pub FilterLevels: [i32; 32],
    pub AlphaBlending: D3D12_VIDEO_PROCESS_ALPHA_BLENDING,
}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS")
            .field("InputStream", &self.InputStream)
            .field("Transform", &self.Transform)
            .field("Flags", &self.Flags)
            .field("RateInfo", &self.RateInfo)
            .field("FilterLevels", &self.FilterLevels)
            .field("AlphaBlending", &self.AlphaBlending)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.InputStream == other.InputStream
            && self.Transform == other.Transform
            && self.Flags == other.Flags
            && self.RateInfo == other.RateInfo
            && self.FilterLevels == other.FilterLevels
            && self.AlphaBlending == other.AlphaBlending
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    pub InputStream: [D3D12_VIDEO_PROCESS_INPUT_STREAM; 2],
    pub Transform: D3D12_VIDEO_PROCESS_TRANSFORM,
    pub Flags: D3D12_VIDEO_PROCESS_INPUT_STREAM_FLAGS,
    pub RateInfo: D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE,
    pub FilterLevels: [i32; 32],
    pub AlphaBlending: D3D12_VIDEO_PROCESS_ALPHA_BLENDING,
    pub FieldType: D3D12_VIDEO_FIELD_TYPE,
}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1")
            .field("InputStream", &self.InputStream)
            .field("Transform", &self.Transform)
            .field("Flags", &self.Flags)
            .field("RateInfo", &self.RateInfo)
            .field("FilterLevels", &self.FilterLevels)
            .field("AlphaBlending", &self.AlphaBlending)
            .field("FieldType", &self.FieldType)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    fn eq(&self, other: &Self) -> bool {
        self.InputStream == other.InputStream
            && self.Transform == other.Transform
            && self.Flags == other.Flags
            && self.RateInfo == other.RateInfo
            && self.FilterLevels == other.FilterLevels
            && self.AlphaBlending == other.AlphaBlending
            && self.FieldType == other.FieldType
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    pub Format: DXGI_FORMAT,
    pub ColorSpace: ::windows::Win32::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
    pub SourceAspectRatio: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub DestinationAspectRatio: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub FrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub SourceSizeRange: D3D12_VIDEO_SIZE_RANGE,
    pub DestinationSizeRange: D3D12_VIDEO_SIZE_RANGE,
    pub EnableOrientation: ::windows::Win32::Foundation::BOOL,
    pub FilterFlags: D3D12_VIDEO_PROCESS_FILTER_FLAGS,
    pub StereoFormat: D3D12_VIDEO_FRAME_STEREO_FORMAT,
    pub FieldType: D3D12_VIDEO_FIELD_TYPE,
    pub DeinterlaceMode: D3D12_VIDEO_PROCESS_DEINTERLACE_FLAGS,
    pub EnableAlphaBlending: ::windows::Win32::Foundation::BOOL,
    pub LumaKey: D3D12_VIDEO_PROCESS_LUMA_KEY,
    pub NumPastFrames: u32,
    pub NumFutureFrames: u32,
    pub EnableAutoProcessing: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC")
            .field("Format", &self.Format)
            .field("ColorSpace", &self.ColorSpace)
            .field("SourceAspectRatio", &self.SourceAspectRatio)
            .field("DestinationAspectRatio", &self.DestinationAspectRatio)
            .field("FrameRate", &self.FrameRate)
            .field("SourceSizeRange", &self.SourceSizeRange)
            .field("DestinationSizeRange", &self.DestinationSizeRange)
            .field("EnableOrientation", &self.EnableOrientation)
            .field("FilterFlags", &self.FilterFlags)
            .field("StereoFormat", &self.StereoFormat)
            .field("FieldType", &self.FieldType)
            .field("DeinterlaceMode", &self.DeinterlaceMode)
            .field("EnableAlphaBlending", &self.EnableAlphaBlending)
            .field("LumaKey", &self.LumaKey)
            .field("NumPastFrames", &self.NumPastFrames)
            .field("NumFutureFrames", &self.NumFutureFrames)
            .field("EnableAutoProcessing", &self.EnableAutoProcessing)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format
            && self.ColorSpace == other.ColorSpace
            && self.SourceAspectRatio == other.SourceAspectRatio
            && self.DestinationAspectRatio == other.DestinationAspectRatio
            && self.FrameRate == other.FrameRate
            && self.SourceSizeRange == other.SourceSizeRange
            && self.DestinationSizeRange == other.DestinationSizeRange
            && self.EnableOrientation == other.EnableOrientation
            && self.FilterFlags == other.FilterFlags
            && self.StereoFormat == other.StereoFormat
            && self.FieldType == other.FieldType
            && self.DeinterlaceMode == other.DeinterlaceMode
            && self.EnableAlphaBlending == other.EnableAlphaBlending
            && self.LumaKey == other.LumaKey
            && self.NumPastFrames == other.NumPastFrames
            && self.NumFutureFrames == other.NumFutureFrames
            && self.EnableAutoProcessing == other.EnableAutoProcessing
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    pub OutputIndex: u32,
    pub InputFrameOrField: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE")
            .field("OutputIndex", &self.OutputIndex)
            .field("InputFrameOrField", &self.InputFrameOrField)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    fn eq(&self, other: &Self) -> bool {
        self.OutputIndex == other.OutputIndex && self.InputFrameOrField == other.InputFrameOrField
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_INPUT_STREAM_RATE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_LUMA_KEY {
    pub Enable: ::windows::Win32::Foundation::BOOL,
    pub Lower: f32,
    pub Upper: f32,
}
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_LUMA_KEY {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_LUMA_KEY {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_LUMA_KEY {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_LUMA_KEY")
            .field("Enable", &self.Enable)
            .field("Lower", &self.Lower)
            .field("Upper", &self.Upper)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_LUMA_KEY {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_LUMA_KEY {
    fn eq(&self, other: &Self) -> bool {
        self.Enable == other.Enable && self.Lower == other.Lower && self.Upper == other.Upper
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_LUMA_KEY {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_LUMA_KEY {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    pub pTexture2D: ::std::mem::ManuallyDrop<::core::option::Option<ID3D12Resource>>,
    pub Subresource: u32,
}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_OUTPUT_STREAM")
            .field("pTexture2D", &self.pTexture2D)
            .field("Subresource", &self.Subresource)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    fn eq(&self, other: &Self) -> bool {
        self.pTexture2D == other.pTexture2D && self.Subresource == other.Subresource
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_OUTPUT_STREAM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    pub OutputStream: [D3D12_VIDEO_PROCESS_OUTPUT_STREAM; 2],
    pub TargetRectangle: ::windows::Win32::Foundation::RECT,
}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    fn clone(&self) -> Self {
        unsafe { ::core::mem::transmute_copy(self) }
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS")
            .field("OutputStream", &self.OutputStream)
            .field("TargetRectangle", &self.TargetRectangle)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.OutputStream == other.OutputStream && self.TargetRectangle == other.TargetRectangle
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    pub Format: DXGI_FORMAT,
    pub ColorSpace: ::windows::Win32::Graphics::Dxgi::Common::DXGI_COLOR_SPACE_TYPE,
    pub AlphaFillMode: D3D12_VIDEO_PROCESS_ALPHA_FILL_MODE,
    pub AlphaFillModeSourceStreamIndex: u32,
    pub BackgroundColor: [f32; 4],
    pub FrameRate: ::windows::Win32::Graphics::Dxgi::Common::DXGI_RATIONAL,
    pub EnableStereo: ::windows::Win32::Foundation::BOOL,
}
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC")
            .field("Format", &self.Format)
            .field("ColorSpace", &self.ColorSpace)
            .field("AlphaFillMode", &self.AlphaFillMode)
            .field(
                "AlphaFillModeSourceStreamIndex",
                &self.AlphaFillModeSourceStreamIndex,
            )
            .field("BackgroundColor", &self.BackgroundColor)
            .field("FrameRate", &self.FrameRate)
            .field("EnableStereo", &self.EnableStereo)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.Format == other.Format
            && self.ColorSpace == other.ColorSpace
            && self.AlphaFillMode == other.AlphaFillMode
            && self.AlphaFillModeSourceStreamIndex == other.AlphaFillModeSourceStreamIndex
            && self.BackgroundColor == other.BackgroundColor
            && self.FrameRate == other.FrameRate
            && self.EnableStereo == other.EnableStereo
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_REFERENCE_SET {
    pub NumPastFrames: u32,
    pub ppPastFrames: *mut ::core::option::Option<ID3D12Resource>,
    pub pPastSubresources: *mut u32,
    pub NumFutureFrames: u32,
    pub ppFutureFrames: *mut ::core::option::Option<ID3D12Resource>,
    pub pFutureSubresources: *mut u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_REFERENCE_SET {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_REFERENCE_SET {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_REFERENCE_SET {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_REFERENCE_SET")
            .field("NumPastFrames", &self.NumPastFrames)
            .field("ppPastFrames", &self.ppPastFrames)
            .field("pPastSubresources", &self.pPastSubresources)
            .field("NumFutureFrames", &self.NumFutureFrames)
            .field("ppFutureFrames", &self.ppFutureFrames)
            .field("pFutureSubresources", &self.pFutureSubresources)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_REFERENCE_SET {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_REFERENCE_SET {
    fn eq(&self, other: &Self) -> bool {
        self.NumPastFrames == other.NumPastFrames
            && self.ppPastFrames == other.ppPastFrames
            && self.pPastSubresources == other.pPastSubresources
            && self.NumFutureFrames == other.NumFutureFrames
            && self.ppFutureFrames == other.ppFutureFrames
            && self.pFutureSubresources == other.pFutureSubresources
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_REFERENCE_SET {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_REFERENCE_SET {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_PROCESS_TRANSFORM {
    pub SourceRectangle: ::windows::Win32::Foundation::RECT,
    pub DestinationRectangle: ::windows::Win32::Foundation::RECT,
    pub Orientation: D3D12_VIDEO_PROCESS_ORIENTATION,
}
impl ::core::marker::Copy for D3D12_VIDEO_PROCESS_TRANSFORM {}
impl ::core::clone::Clone for D3D12_VIDEO_PROCESS_TRANSFORM {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_PROCESS_TRANSFORM {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_PROCESS_TRANSFORM")
            .field("SourceRectangle", &self.SourceRectangle)
            .field("DestinationRectangle", &self.DestinationRectangle)
            .field("Orientation", &self.Orientation)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_PROCESS_TRANSFORM {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_PROCESS_TRANSFORM {
    fn eq(&self, other: &Self) -> bool {
        self.SourceRectangle == other.SourceRectangle
            && self.DestinationRectangle == other.DestinationRectangle
            && self.Orientation == other.Orientation
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_PROCESS_TRANSFORM {}
impl ::core::default::Default for D3D12_VIDEO_PROCESS_TRANSFORM {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_SAMPLE {
    pub Width: u32,
    pub Height: u32,
    pub Format: D3D12_VIDEO_FORMAT,
}
impl ::core::marker::Copy for D3D12_VIDEO_SAMPLE {}
impl ::core::clone::Clone for D3D12_VIDEO_SAMPLE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_SAMPLE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_SAMPLE")
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .field("Format", &self.Format)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_SAMPLE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_SAMPLE {
    fn eq(&self, other: &Self) -> bool {
        self.Width == other.Width && self.Height == other.Height && self.Format == other.Format
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_SAMPLE {}
impl ::core::default::Default for D3D12_VIDEO_SAMPLE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_SCALE_SUPPORT {
    pub OutputSizeRange: D3D12_VIDEO_SIZE_RANGE,
    pub Flags: D3D12_VIDEO_SCALE_SUPPORT_FLAGS,
}
impl ::core::marker::Copy for D3D12_VIDEO_SCALE_SUPPORT {}
impl ::core::clone::Clone for D3D12_VIDEO_SCALE_SUPPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_SCALE_SUPPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_SCALE_SUPPORT")
            .field("OutputSizeRange", &self.OutputSizeRange)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_SCALE_SUPPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_SCALE_SUPPORT {
    fn eq(&self, other: &Self) -> bool {
        self.OutputSizeRange == other.OutputSizeRange && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_SCALE_SUPPORT {}
impl ::core::default::Default for D3D12_VIDEO_SCALE_SUPPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIDEO_SIZE_RANGE {
    pub MaxWidth: u32,
    pub MaxHeight: u32,
    pub MinWidth: u32,
    pub MinHeight: u32,
}
impl ::core::marker::Copy for D3D12_VIDEO_SIZE_RANGE {}
impl ::core::clone::Clone for D3D12_VIDEO_SIZE_RANGE {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIDEO_SIZE_RANGE {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIDEO_SIZE_RANGE")
            .field("MaxWidth", &self.MaxWidth)
            .field("MaxHeight", &self.MaxHeight)
            .field("MinWidth", &self.MinWidth)
            .field("MinHeight", &self.MinHeight)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIDEO_SIZE_RANGE {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIDEO_SIZE_RANGE {
    fn eq(&self, other: &Self) -> bool {
        self.MaxWidth == other.MaxWidth
            && self.MaxHeight == other.MaxHeight
            && self.MinWidth == other.MinWidth
            && self.MinHeight == other.MinHeight
    }
}
impl ::core::cmp::Eq for D3D12_VIDEO_SIZE_RANGE {}
impl ::core::default::Default for D3D12_VIDEO_SIZE_RANGE {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIEWPORT {
    pub TopLeftX: f32,
    pub TopLeftY: f32,
    pub Width: f32,
    pub Height: f32,
    pub MinDepth: f32,
    pub MaxDepth: f32,
}
impl ::core::marker::Copy for D3D12_VIEWPORT {}
impl ::core::clone::Clone for D3D12_VIEWPORT {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIEWPORT {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIEWPORT")
            .field("TopLeftX", &self.TopLeftX)
            .field("TopLeftY", &self.TopLeftY)
            .field("Width", &self.Width)
            .field("Height", &self.Height)
            .field("MinDepth", &self.MinDepth)
            .field("MaxDepth", &self.MaxDepth)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIEWPORT {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIEWPORT {
    fn eq(&self, other: &Self) -> bool {
        self.TopLeftX == other.TopLeftX
            && self.TopLeftY == other.TopLeftY
            && self.Width == other.Width
            && self.Height == other.Height
            && self.MinDepth == other.MinDepth
            && self.MaxDepth == other.MaxDepth
    }
}
impl ::core::cmp::Eq for D3D12_VIEWPORT {}
impl ::core::default::Default for D3D12_VIEWPORT {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIEW_INSTANCE_LOCATION {
    pub ViewportArrayIndex: u32,
    pub RenderTargetArrayIndex: u32,
}
impl ::core::marker::Copy for D3D12_VIEW_INSTANCE_LOCATION {}
impl ::core::clone::Clone for D3D12_VIEW_INSTANCE_LOCATION {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIEW_INSTANCE_LOCATION {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIEW_INSTANCE_LOCATION")
            .field("ViewportArrayIndex", &self.ViewportArrayIndex)
            .field("RenderTargetArrayIndex", &self.RenderTargetArrayIndex)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIEW_INSTANCE_LOCATION {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIEW_INSTANCE_LOCATION {
    fn eq(&self, other: &Self) -> bool {
        self.ViewportArrayIndex == other.ViewportArrayIndex
            && self.RenderTargetArrayIndex == other.RenderTargetArrayIndex
    }
}
impl ::core::cmp::Eq for D3D12_VIEW_INSTANCE_LOCATION {}
impl ::core::default::Default for D3D12_VIEW_INSTANCE_LOCATION {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_VIEW_INSTANCING_DESC {
    pub ViewInstanceCount: u32,
    pub pViewInstanceLocations: *const D3D12_VIEW_INSTANCE_LOCATION,
    pub Flags: D3D12_VIEW_INSTANCING_FLAGS,
}
impl ::core::marker::Copy for D3D12_VIEW_INSTANCING_DESC {}
impl ::core::clone::Clone for D3D12_VIEW_INSTANCING_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_VIEW_INSTANCING_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_VIEW_INSTANCING_DESC")
            .field("ViewInstanceCount", &self.ViewInstanceCount)
            .field("pViewInstanceLocations", &self.pViewInstanceLocations)
            .field("Flags", &self.Flags)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_VIEW_INSTANCING_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_VIEW_INSTANCING_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.ViewInstanceCount == other.ViewInstanceCount
            && self.pViewInstanceLocations == other.pViewInstanceLocations
            && self.Flags == other.Flags
    }
}
impl ::core::cmp::Eq for D3D12_VIEW_INSTANCING_DESC {}
impl ::core::default::Default for D3D12_VIEW_INSTANCING_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_WORK_GRAPH_DESC {
    pub ProgramName: ::windows::core::PCWSTR,
    pub Flags: D3D12_WORK_GRAPH_FLAGS,
    pub NumEntrypoints: u32,
    pub pEntrypoints: *const D3D12_NODE_ID,
    pub NumExplicitlyDefinedNodes: u32,
    pub pExplicitlyDefinedNodes: *const D3D12_NODE,
}
impl ::core::marker::Copy for D3D12_WORK_GRAPH_DESC {}
impl ::core::clone::Clone for D3D12_WORK_GRAPH_DESC {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_WORK_GRAPH_DESC {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_WORK_GRAPH_DESC")
            .field("ProgramName", &self.ProgramName)
            .field("Flags", &self.Flags)
            .field("NumEntrypoints", &self.NumEntrypoints)
            .field("pEntrypoints", &self.pEntrypoints)
            .field("NumExplicitlyDefinedNodes", &self.NumExplicitlyDefinedNodes)
            .field("pExplicitlyDefinedNodes", &self.pExplicitlyDefinedNodes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_WORK_GRAPH_DESC {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_WORK_GRAPH_DESC {
    fn eq(&self, other: &Self) -> bool {
        self.ProgramName == other.ProgramName
            && self.Flags == other.Flags
            && self.NumEntrypoints == other.NumEntrypoints
            && self.pEntrypoints == other.pEntrypoints
            && self.NumExplicitlyDefinedNodes == other.NumExplicitlyDefinedNodes
            && self.pExplicitlyDefinedNodes == other.pExplicitlyDefinedNodes
    }
}
impl ::core::cmp::Eq for D3D12_WORK_GRAPH_DESC {}
impl ::core::default::Default for D3D12_WORK_GRAPH_DESC {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS {
    pub MinSizeInBytes: u64,
    pub MaxSizeInBytes: u64,
    pub SizeGranularityInBytes: u32,
}
impl ::core::marker::Copy for D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS {}
impl ::core::clone::Clone for D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS")
            .field("MinSizeInBytes", &self.MinSizeInBytes)
            .field("MaxSizeInBytes", &self.MaxSizeInBytes)
            .field("SizeGranularityInBytes", &self.SizeGranularityInBytes)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS {
    fn eq(&self, other: &Self) -> bool {
        self.MinSizeInBytes == other.MinSizeInBytes
            && self.MaxSizeInBytes == other.MaxSizeInBytes
            && self.SizeGranularityInBytes == other.SizeGranularityInBytes
    }
}
impl ::core::cmp::Eq for D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS {}
impl ::core::default::Default for D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D12_WRITEBUFFERIMMEDIATE_PARAMETER {
    pub Dest: u64,
    pub Value: u32,
}
impl ::core::marker::Copy for D3D12_WRITEBUFFERIMMEDIATE_PARAMETER {}
impl ::core::clone::Clone for D3D12_WRITEBUFFERIMMEDIATE_PARAMETER {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D12_WRITEBUFFERIMMEDIATE_PARAMETER {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D12_WRITEBUFFERIMMEDIATE_PARAMETER")
            .field("Dest", &self.Dest)
            .field("Value", &self.Value)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D12_WRITEBUFFERIMMEDIATE_PARAMETER {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D12_WRITEBUFFERIMMEDIATE_PARAMETER {
    fn eq(&self, other: &Self) -> bool {
        self.Dest == other.Dest && self.Value == other.Value
    }
}
impl ::core::cmp::Eq for D3D12_WRITEBUFFERIMMEDIATE_PARAMETER {}
impl ::core::default::Default for D3D12_WRITEBUFFERIMMEDIATE_PARAMETER {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct D3D_SHADER_MACRO {
    pub Name: ::windows::core::PCSTR,
    pub Definition: ::windows::core::PCSTR,
}
impl ::core::marker::Copy for D3D_SHADER_MACRO {}
impl ::core::clone::Clone for D3D_SHADER_MACRO {
    fn clone(&self) -> Self {
        *self
    }
}
impl ::core::fmt::Debug for D3D_SHADER_MACRO {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("D3D_SHADER_MACRO")
            .field("Name", &self.Name)
            .field("Definition", &self.Definition)
            .finish()
    }
}
impl ::windows::core::TypeKind for D3D_SHADER_MACRO {
    type TypeKind = ::windows::core::CopyType;
}
impl ::core::cmp::PartialEq for D3D_SHADER_MACRO {
    fn eq(&self, other: &Self) -> bool {
        self.Name == other.Name && self.Definition == other.Definition
    }
}
impl ::core::cmp::Eq for D3D_SHADER_MACRO {}
impl ::core::default::Default for D3D_SHADER_MACRO {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type D3D12MessageFunc = ::core::option::Option<
    unsafe extern "system" fn(
        category: D3D12_MESSAGE_CATEGORY,
        severity: D3D12_MESSAGE_SEVERITY,
        id: D3D12_MESSAGE_ID,
        pdescription: ::windows::core::PCSTR,
        pcontext: *mut ::core::ffi::c_void,
    ) -> (),
>;
pub type PFN_D3D12_CREATE_DEVICE = ::core::option::Option<
    unsafe extern "system" fn(
        param0: ::core::option::Option<::windows::core::IUnknown>,
        param1: D3D_FEATURE_LEVEL,
        param2: *const ::windows::core::GUID,
        param3: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
>;
pub type PFN_D3D12_CREATE_ROOT_SIGNATURE_DESERIALIZER = ::core::option::Option<
    unsafe extern "system" fn(
        psrcdata: *const ::core::ffi::c_void,
        srcdatasizeinbytes: usize,
        prootsignaturedeserializerinterface: *const ::windows::core::GUID,
        pprootsignaturedeserializer: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
>;
pub type PFN_D3D12_CREATE_VERSIONED_ROOT_SIGNATURE_DESERIALIZER = ::core::option::Option<
    unsafe extern "system" fn(
        psrcdata: *const ::core::ffi::c_void,
        srcdatasizeinbytes: usize,
        prootsignaturedeserializerinterface: *const ::windows::core::GUID,
        pprootsignaturedeserializer: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
>;
pub type PFN_D3D12_GET_DEBUG_INTERFACE = ::core::option::Option<
    unsafe extern "system" fn(
        param0: *const ::windows::core::GUID,
        param1: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
>;
pub type PFN_D3D12_GET_INTERFACE = ::core::option::Option<
    unsafe extern "system" fn(
        param0: *const ::windows::core::GUID,
        param1: *const ::windows::core::GUID,
        param2: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::HRESULT,
>;
pub type PFN_D3D12_SERIALIZE_ROOT_SIGNATURE = ::core::option::Option<
    unsafe extern "system" fn(
        prootsignature: *const D3D12_ROOT_SIGNATURE_DESC,
        version: D3D_ROOT_SIGNATURE_VERSION,
        ppblob: *mut ::core::option::Option<ID3DBlob>,
        pperrorblob: *mut ::core::option::Option<ID3DBlob>,
    ) -> ::windows::core::HRESULT,
>;
pub type PFN_D3D12_SERIALIZE_VERSIONED_ROOT_SIGNATURE = ::core::option::Option<
    unsafe extern "system" fn(
        prootsignature: *const D3D12_VERSIONED_ROOT_SIGNATURE_DESC,
        ppblob: *mut ::core::option::Option<ID3DBlob>,
        pperrorblob: *mut ::core::option::Option<ID3DBlob>,
    ) -> ::windows::core::HRESULT,
>;
pub type PFN_DESTRUCTION_CALLBACK =
    ::core::option::Option<unsafe extern "system" fn(pdata: *mut ::core::ffi::c_void) -> ()>;
pub trait D3D11On12CreatorID_Impl: Sized {}
impl ::windows::core::RuntimeName for D3D11On12CreatorID {}
impl D3D11On12CreatorID_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: D3D11On12CreatorID_Impl,
        const OFFSET: isize,
    >() -> D3D11On12CreatorID_Vtbl {
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<D3D11On12CreatorID as ::windows::core::ComInterface>::IID
    }
}
pub trait D3D9On12CreatorID_Impl: Sized {}
impl ::windows::core::RuntimeName for D3D9On12CreatorID {}
impl D3D9On12CreatorID_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: D3D9On12CreatorID_Impl,
        const OFFSET: isize,
    >() -> D3D9On12CreatorID_Vtbl {
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<D3D9On12CreatorID as ::windows::core::ComInterface>::IID
    }
}
pub trait DirectMLPyTorchCreatorID_Impl: Sized {}
impl ::windows::core::RuntimeName for DirectMLPyTorchCreatorID {}
impl DirectMLPyTorchCreatorID_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: DirectMLPyTorchCreatorID_Impl,
        const OFFSET: isize,
    >() -> DirectMLPyTorchCreatorID_Vtbl {
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<DirectMLPyTorchCreatorID as ::windows::core::ComInterface>::IID
    }
}
pub trait DirectMLTensorFlowCreatorID_Impl: Sized {}
impl ::windows::core::RuntimeName for DirectMLTensorFlowCreatorID {}
impl DirectMLTensorFlowCreatorID_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: DirectMLTensorFlowCreatorID_Impl,
        const OFFSET: isize,
    >() -> DirectMLTensorFlowCreatorID_Vtbl {
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<DirectMLTensorFlowCreatorID as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12CommandAllocator_Impl: Sized + ID3D12Pageable_Impl {
    fn Reset(&self) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12CommandAllocator {}
impl ID3D12CommandAllocator_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12CommandAllocator_Impl,
        const OFFSET: isize,
    >() -> ID3D12CommandAllocator_Vtbl {
        unsafe extern "system" fn Reset<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandAllocator_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset().into()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            Reset: Reset::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12CommandAllocator as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12CommandList_Impl: Sized + ID3D12DeviceChild_Impl {
    fn GetType(&self) -> D3D12_COMMAND_LIST_TYPE;
}
impl ::windows::core::RuntimeName for ID3D12CommandList {}
impl ID3D12CommandList_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12CommandList_Impl,
        const OFFSET: isize,
    >() -> ID3D12CommandList_Vtbl {
        unsafe extern "system" fn GetType<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_COMMAND_LIST_TYPE {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetType()
        }
        Self {
            base__: ID3D12DeviceChild_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetType: GetType::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12CommandQueue_Impl: Sized + ID3D12Pageable_Impl {
    fn UpdateTileMappings(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        numresourceregions: u32,
        presourceregionstartcoordinates: *const D3D12_TILED_RESOURCE_COORDINATE,
        presourceregionsizes: *const D3D12_TILE_REGION_SIZE,
        pheap: ::core::option::Option<&ID3D12Heap>,
        numranges: u32,
        prangeflags: *const D3D12_TILE_RANGE_FLAGS,
        pheaprangestartoffsets: *const u32,
        prangetilecounts: *const u32,
        flags: D3D12_TILE_MAPPING_FLAGS,
    );
    fn CopyTileMappings(
        &self,
        pdstresource: ::core::option::Option<&ID3D12Resource>,
        pdstregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        psrcresource: ::core::option::Option<&ID3D12Resource>,
        psrcregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        pregionsize: *const D3D12_TILE_REGION_SIZE,
        flags: D3D12_TILE_MAPPING_FLAGS,
    );
    fn ExecuteCommandLists(
        &self,
        numcommandlists: u32,
        ppcommandlists: *const ::core::option::Option<ID3D12CommandList>,
    );
    fn SetMarker(&self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn BeginEvent(&self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn EndEvent(&self);
    fn Signal(
        &self,
        pfence: ::core::option::Option<&ID3D12Fence>,
        value: u64,
    ) -> ::windows::core::Result<()>;
    fn Wait(
        &self,
        pfence: ::core::option::Option<&ID3D12Fence>,
        value: u64,
    ) -> ::windows::core::Result<()>;
    fn GetTimestampFrequency(&self) -> ::windows::core::Result<u64>;
    fn GetClockCalibration(
        &self,
        pgputimestamp: *mut u64,
        pcputimestamp: *mut u64,
    ) -> ::windows::core::Result<()>;
    fn GetDesc(&self) -> D3D12_COMMAND_QUEUE_DESC;
}
impl ::windows::core::RuntimeName for ID3D12CommandQueue {}
impl ID3D12CommandQueue_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12CommandQueue_Impl,
        const OFFSET: isize,
    >() -> ID3D12CommandQueue_Vtbl {
        unsafe extern "system" fn UpdateTileMappings<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            numresourceregions: u32,
            presourceregionstartcoordinates: *const D3D12_TILED_RESOURCE_COORDINATE,
            presourceregionsizes: *const D3D12_TILE_REGION_SIZE,
            pheap: *mut ::core::ffi::c_void,
            numranges: u32,
            prangeflags: *const D3D12_TILE_RANGE_FLAGS,
            pheaprangestartoffsets: *const u32,
            prangetilecounts: *const u32,
            flags: D3D12_TILE_MAPPING_FLAGS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.UpdateTileMappings(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&numresourceregions),
                ::core::mem::transmute_copy(&presourceregionstartcoordinates),
                ::core::mem::transmute_copy(&presourceregionsizes),
                ::windows::core::from_raw_borrowed(&pheap),
                ::core::mem::transmute_copy(&numranges),
                ::core::mem::transmute_copy(&prangeflags),
                ::core::mem::transmute_copy(&pheaprangestartoffsets),
                ::core::mem::transmute_copy(&prangetilecounts),
                ::core::mem::transmute_copy(&flags),
            )
        }
        unsafe extern "system" fn CopyTileMappings<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdstresource: *mut ::core::ffi::c_void,
            pdstregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
            psrcresource: *mut ::core::ffi::c_void,
            psrcregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
            pregionsize: *const D3D12_TILE_REGION_SIZE,
            flags: D3D12_TILE_MAPPING_FLAGS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CopyTileMappings(
                ::windows::core::from_raw_borrowed(&pdstresource),
                ::core::mem::transmute_copy(&pdstregionstartcoordinate),
                ::windows::core::from_raw_borrowed(&psrcresource),
                ::core::mem::transmute_copy(&psrcregionstartcoordinate),
                ::core::mem::transmute_copy(&pregionsize),
                ::core::mem::transmute_copy(&flags),
            )
        }
        unsafe extern "system" fn ExecuteCommandLists<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numcommandlists: u32,
            ppcommandlists: *const *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ExecuteCommandLists(
                ::core::mem::transmute_copy(&numcommandlists),
                ::core::mem::transmute_copy(&ppcommandlists),
            )
        }
        unsafe extern "system" fn SetMarker<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            metadata: u32,
            pdata: *const ::core::ffi::c_void,
            size: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetMarker(
                ::core::mem::transmute_copy(&metadata),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&size),
            )
        }
        unsafe extern "system" fn BeginEvent<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            metadata: u32,
            pdata: *const ::core::ffi::c_void,
            size: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginEvent(
                ::core::mem::transmute_copy(&metadata),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&size),
            )
        }
        unsafe extern "system" fn EndEvent<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndEvent()
        }
        unsafe extern "system" fn Signal<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfence: *mut ::core::ffi::c_void,
            value: u64,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Signal(
                ::windows::core::from_raw_borrowed(&pfence),
                ::core::mem::transmute_copy(&value),
            )
            .into()
        }
        unsafe extern "system" fn Wait<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfence: *mut ::core::ffi::c_void,
            value: u64,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Wait(
                ::windows::core::from_raw_borrowed(&pfence),
                ::core::mem::transmute_copy(&value),
            )
            .into()
        }
        unsafe extern "system" fn GetTimestampFrequency<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfrequency: *mut u64,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.GetTimestampFrequency() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pfrequency, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetClockCalibration<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pgputimestamp: *mut u64,
            pcputimestamp: *mut u64,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetClockCalibration(
                ::core::mem::transmute_copy(&pgputimestamp),
                ::core::mem::transmute_copy(&pcputimestamp),
            )
            .into()
        }
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_COMMAND_QUEUE_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            UpdateTileMappings: UpdateTileMappings::<Identity, Impl, OFFSET>,
            CopyTileMappings: CopyTileMappings::<Identity, Impl, OFFSET>,
            ExecuteCommandLists: ExecuteCommandLists::<Identity, Impl, OFFSET>,
            SetMarker: SetMarker::<Identity, Impl, OFFSET>,
            BeginEvent: BeginEvent::<Identity, Impl, OFFSET>,
            EndEvent: EndEvent::<Identity, Impl, OFFSET>,
            Signal: Signal::<Identity, Impl, OFFSET>,
            Wait: Wait::<Identity, Impl, OFFSET>,
            GetTimestampFrequency: GetTimestampFrequency::<Identity, Impl, OFFSET>,
            GetClockCalibration: GetClockCalibration::<Identity, Impl, OFFSET>,
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12CommandQueue as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12CommandSignature_Impl: Sized + ID3D12Pageable_Impl {}
impl ::windows::core::RuntimeName for ID3D12CommandSignature {}
impl ID3D12CommandSignature_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12CommandSignature_Impl,
        const OFFSET: isize,
    >() -> ID3D12CommandSignature_Vtbl {
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12CommandSignature as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12CompatibilityDevice_Impl: Sized {
    fn CreateSharedResource(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pflags11: *const ::windows::Win32::Graphics::Direct3D11on12::D3D11_RESOURCE_FLAGS,
        compatibilityflags: D3D12_COMPATIBILITY_SHARED_FLAGS,
        plifetimetracker: ::core::option::Option<&ID3D12LifetimeTracker>,
        powningswapchain: ::core::option::Option<&ID3D12SwapChainAssistant>,
        riid: *const ::windows::core::GUID,
        ppresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateSharedHeap(
        &self,
        pheapdesc: *const D3D12_HEAP_DESC,
        compatibilityflags: D3D12_COMPATIBILITY_SHARED_FLAGS,
        riid: *const ::windows::core::GUID,
        ppheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn ReflectSharedProperties(
        &self,
        pheaporresource: ::core::option::Option<&ID3D12Object>,
        reflecttype: D3D12_REFLECT_SHARED_PROPERTY,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12CompatibilityDevice {}
impl ID3D12CompatibilityDevice_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12CompatibilityDevice_Impl,
        const OFFSET: isize,
    >() -> ID3D12CompatibilityDevice_Vtbl {
        unsafe extern "system" fn CreateSharedResource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CompatibilityDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheapproperties: *const D3D12_HEAP_PROPERTIES,
            heapflags: D3D12_HEAP_FLAGS,
            pdesc: *const D3D12_RESOURCE_DESC,
            initialresourcestate: D3D12_RESOURCE_STATES,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            pflags11: *const ::windows::Win32::Graphics::Direct3D11on12::D3D11_RESOURCE_FLAGS,
            compatibilityflags: D3D12_COMPATIBILITY_SHARED_FLAGS,
            plifetimetracker: *mut ::core::ffi::c_void,
            powningswapchain: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateSharedResource(
                ::core::mem::transmute_copy(&pheapproperties),
                ::core::mem::transmute_copy(&heapflags),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initialresourcestate),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::core::mem::transmute_copy(&pflags11),
                ::core::mem::transmute_copy(&compatibilityflags),
                ::windows::core::from_raw_borrowed(&plifetimetracker),
                ::windows::core::from_raw_borrowed(&powningswapchain),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppresource),
            )
            .into()
        }
        unsafe extern "system" fn CreateSharedHeap<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CompatibilityDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheapdesc: *const D3D12_HEAP_DESC,
            compatibilityflags: D3D12_COMPATIBILITY_SHARED_FLAGS,
            riid: *const ::windows::core::GUID,
            ppheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateSharedHeap(
                ::core::mem::transmute_copy(&pheapdesc),
                ::core::mem::transmute_copy(&compatibilityflags),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppheap),
            )
            .into()
        }
        unsafe extern "system" fn ReflectSharedProperties<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12CompatibilityDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheaporresource: *mut ::core::ffi::c_void,
            reflecttype: D3D12_REFLECT_SHARED_PROPERTY,
            pdata: *mut ::core::ffi::c_void,
            datasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ReflectSharedProperties(
                ::windows::core::from_raw_borrowed(&pheaporresource),
                ::core::mem::transmute_copy(&reflecttype),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&datasize),
            )
            .into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CreateSharedResource: CreateSharedResource::<Identity, Impl, OFFSET>,
            CreateSharedHeap: CreateSharedHeap::<Identity, Impl, OFFSET>,
            ReflectSharedProperties: ReflectSharedProperties::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12CompatibilityDevice as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Debug_Impl: Sized {
    fn EnableDebugLayer(&self);
}
impl ::windows::core::RuntimeName for ID3D12Debug {}
impl ID3D12Debug_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Debug_Impl,
        const OFFSET: isize,
    >() -> ID3D12Debug_Vtbl {
        unsafe extern "system" fn EnableDebugLayer<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EnableDebugLayer()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            EnableDebugLayer: EnableDebugLayer::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Debug as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Debug1_Impl: Sized {
    fn EnableDebugLayer(&self);
    fn SetEnableGPUBasedValidation(&self, enable: ::windows::Win32::Foundation::BOOL);
    fn SetEnableSynchronizedCommandQueueValidation(
        &self,
        enable: ::windows::Win32::Foundation::BOOL,
    );
}
impl ::windows::core::RuntimeName for ID3D12Debug1 {}
impl ID3D12Debug1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Debug1_Impl,
        const OFFSET: isize,
    >() -> ID3D12Debug1_Vtbl {
        unsafe extern "system" fn EnableDebugLayer<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EnableDebugLayer()
        }
        unsafe extern "system" fn SetEnableGPUBasedValidation<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enable: ::windows::Win32::Foundation::BOOL,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetEnableGPUBasedValidation(::core::mem::transmute_copy(&enable))
        }
        unsafe extern "system" fn SetEnableSynchronizedCommandQueueValidation<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enable: ::windows::Win32::Foundation::BOOL,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetEnableSynchronizedCommandQueueValidation(::core::mem::transmute_copy(&enable))
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            EnableDebugLayer: EnableDebugLayer::<Identity, Impl, OFFSET>,
            SetEnableGPUBasedValidation: SetEnableGPUBasedValidation::<Identity, Impl, OFFSET>,
            SetEnableSynchronizedCommandQueueValidation:
                SetEnableSynchronizedCommandQueueValidation::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Debug1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Debug2_Impl: Sized {
    fn SetGPUBasedValidationFlags(&self, flags: D3D12_GPU_BASED_VALIDATION_FLAGS);
}
impl ::windows::core::RuntimeName for ID3D12Debug2 {}
impl ID3D12Debug2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Debug2_Impl,
        const OFFSET: isize,
    >() -> ID3D12Debug2_Vtbl {
        unsafe extern "system" fn SetGPUBasedValidationFlags<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            flags: D3D12_GPU_BASED_VALIDATION_FLAGS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetGPUBasedValidationFlags(::core::mem::transmute_copy(&flags))
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetGPUBasedValidationFlags: SetGPUBasedValidationFlags::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Debug2 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Debug3_Impl: Sized + ID3D12Debug_Impl {
    fn SetEnableGPUBasedValidation(&self, enable: ::windows::Win32::Foundation::BOOL);
    fn SetEnableSynchronizedCommandQueueValidation(
        &self,
        enable: ::windows::Win32::Foundation::BOOL,
    );
    fn SetGPUBasedValidationFlags(&self, flags: D3D12_GPU_BASED_VALIDATION_FLAGS);
}
impl ::windows::core::RuntimeName for ID3D12Debug3 {}
impl ID3D12Debug3_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Debug3_Impl,
        const OFFSET: isize,
    >() -> ID3D12Debug3_Vtbl {
        unsafe extern "system" fn SetEnableGPUBasedValidation<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enable: ::windows::Win32::Foundation::BOOL,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetEnableGPUBasedValidation(::core::mem::transmute_copy(&enable))
        }
        unsafe extern "system" fn SetEnableSynchronizedCommandQueueValidation<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enable: ::windows::Win32::Foundation::BOOL,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetEnableSynchronizedCommandQueueValidation(::core::mem::transmute_copy(&enable))
        }
        unsafe extern "system" fn SetGPUBasedValidationFlags<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            flags: D3D12_GPU_BASED_VALIDATION_FLAGS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetGPUBasedValidationFlags(::core::mem::transmute_copy(&flags))
        }
        Self {
            base__: ID3D12Debug_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetEnableGPUBasedValidation: SetEnableGPUBasedValidation::<Identity, Impl, OFFSET>,
            SetEnableSynchronizedCommandQueueValidation:
                SetEnableSynchronizedCommandQueueValidation::<Identity, Impl, OFFSET>,
            SetGPUBasedValidationFlags: SetGPUBasedValidationFlags::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Debug3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Debug as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Debug4_Impl: Sized + ID3D12Debug3_Impl {
    fn DisableDebugLayer(&self);
}
impl ::windows::core::RuntimeName for ID3D12Debug4 {}
impl ID3D12Debug4_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Debug4_Impl,
        const OFFSET: isize,
    >() -> ID3D12Debug4_Vtbl {
        unsafe extern "system" fn DisableDebugLayer<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DisableDebugLayer()
        }
        Self {
            base__: ID3D12Debug3_Vtbl::new::<Identity, Impl, OFFSET>(),
            DisableDebugLayer: DisableDebugLayer::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Debug4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Debug as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Debug3 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Debug5_Impl: Sized + ID3D12Debug4_Impl {
    fn SetEnableAutoName(&self, enable: ::windows::Win32::Foundation::BOOL);
}
impl ::windows::core::RuntimeName for ID3D12Debug5 {}
impl ID3D12Debug5_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Debug5_Impl,
        const OFFSET: isize,
    >() -> ID3D12Debug5_Vtbl {
        unsafe extern "system" fn SetEnableAutoName<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enable: ::windows::Win32::Foundation::BOOL,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetEnableAutoName(::core::mem::transmute_copy(&enable))
        }
        Self {
            base__: ID3D12Debug4_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetEnableAutoName: SetEnableAutoName::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Debug5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Debug as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Debug3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Debug4 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Debug6_Impl: Sized + ID3D12Debug5_Impl {
    fn SetForceLegacyBarrierValidation(&self, enable: ::windows::Win32::Foundation::BOOL);
}
impl ::windows::core::RuntimeName for ID3D12Debug6 {}
impl ID3D12Debug6_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Debug6_Impl,
        const OFFSET: isize,
    >() -> ID3D12Debug6_Vtbl {
        unsafe extern "system" fn SetForceLegacyBarrierValidation<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Debug6_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enable: ::windows::Win32::Foundation::BOOL,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetForceLegacyBarrierValidation(::core::mem::transmute_copy(&enable))
        }
        Self {
            base__: ID3D12Debug5_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetForceLegacyBarrierValidation: SetForceLegacyBarrierValidation::<
                Identity,
                Impl,
                OFFSET,
            >,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Debug6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Debug as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Debug3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Debug4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Debug5 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DebugCommandList_Impl: Sized {
    fn AssertResourceState(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL;
    fn SetFeatureMask(&self, mask: D3D12_DEBUG_FEATURE) -> ::windows::core::Result<()>;
    fn GetFeatureMask(&self) -> D3D12_DEBUG_FEATURE;
}
impl ::windows::core::RuntimeName for ID3D12DebugCommandList {}
impl ID3D12DebugCommandList_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DebugCommandList_Impl,
        const OFFSET: isize,
    >() -> ID3D12DebugCommandList_Vtbl {
        unsafe extern "system" fn AssertResourceState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            subresource: u32,
            state: u32,
        ) -> ::windows::Win32::Foundation::BOOL {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AssertResourceState(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&state),
            )
        }
        unsafe extern "system" fn SetFeatureMask<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            mask: D3D12_DEBUG_FEATURE,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetFeatureMask(::core::mem::transmute_copy(&mask))
                .into()
        }
        unsafe extern "system" fn GetFeatureMask<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_DEBUG_FEATURE {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetFeatureMask()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AssertResourceState: AssertResourceState::<Identity, Impl, OFFSET>,
            SetFeatureMask: SetFeatureMask::<Identity, Impl, OFFSET>,
            GetFeatureMask: GetFeatureMask::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DebugCommandList as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DebugCommandList1_Impl: Sized {
    fn AssertResourceState(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL;
    fn SetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()>;
    fn GetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12DebugCommandList1 {}
impl ID3D12DebugCommandList1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DebugCommandList1_Impl,
        const OFFSET: isize,
    >() -> ID3D12DebugCommandList1_Vtbl {
        unsafe extern "system" fn AssertResourceState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            subresource: u32,
            state: u32,
        ) -> ::windows::Win32::Foundation::BOOL {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AssertResourceState(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&state),
            )
        }
        unsafe extern "system" fn SetDebugParameter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
            pdata: *const ::core::ffi::c_void,
            datasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetDebugParameter(
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&datasize),
            )
            .into()
        }
        unsafe extern "system" fn GetDebugParameter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
            pdata: *mut ::core::ffi::c_void,
            datasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetDebugParameter(
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&datasize),
            )
            .into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AssertResourceState: AssertResourceState::<Identity, Impl, OFFSET>,
            SetDebugParameter: SetDebugParameter::<Identity, Impl, OFFSET>,
            GetDebugParameter: GetDebugParameter::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DebugCommandList1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DebugCommandList2_Impl: Sized + ID3D12DebugCommandList_Impl {
    fn SetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()>;
    fn GetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12DebugCommandList2 {}
impl ID3D12DebugCommandList2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DebugCommandList2_Impl,
        const OFFSET: isize,
    >() -> ID3D12DebugCommandList2_Vtbl {
        unsafe extern "system" fn SetDebugParameter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
            pdata: *const ::core::ffi::c_void,
            datasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetDebugParameter(
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&datasize),
            )
            .into()
        }
        unsafe extern "system" fn GetDebugParameter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            r#type: D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE,
            pdata: *mut ::core::ffi::c_void,
            datasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetDebugParameter(
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&datasize),
            )
            .into()
        }
        Self {
            base__: ID3D12DebugCommandList_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetDebugParameter: SetDebugParameter::<Identity, Impl, OFFSET>,
            GetDebugParameter: GetDebugParameter::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DebugCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DebugCommandList as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DebugCommandList3_Impl: Sized + ID3D12DebugCommandList2_Impl {
    fn AssertResourceAccess(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        subresource: u32,
        access: D3D12_BARRIER_ACCESS,
    );
    fn AssertTextureLayout(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        subresource: u32,
        layout: D3D12_BARRIER_LAYOUT,
    );
}
impl ::windows::core::RuntimeName for ID3D12DebugCommandList3 {}
impl ID3D12DebugCommandList3_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DebugCommandList3_Impl,
        const OFFSET: isize,
    >() -> ID3D12DebugCommandList3_Vtbl {
        unsafe extern "system" fn AssertResourceAccess<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandList3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            subresource: u32,
            access: D3D12_BARRIER_ACCESS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AssertResourceAccess(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&access),
            )
        }
        unsafe extern "system" fn AssertTextureLayout<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandList3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            subresource: u32,
            layout: D3D12_BARRIER_LAYOUT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AssertTextureLayout(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&layout),
            )
        }
        Self {
            base__: ID3D12DebugCommandList2_Vtbl::new::<Identity, Impl, OFFSET>(),
            AssertResourceAccess: AssertResourceAccess::<Identity, Impl, OFFSET>,
            AssertTextureLayout: AssertTextureLayout::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DebugCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DebugCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DebugCommandList2 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DebugCommandQueue_Impl: Sized {
    fn AssertResourceState(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        subresource: u32,
        state: u32,
    ) -> ::windows::Win32::Foundation::BOOL;
}
impl ::windows::core::RuntimeName for ID3D12DebugCommandQueue {}
impl ID3D12DebugCommandQueue_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DebugCommandQueue_Impl,
        const OFFSET: isize,
    >() -> ID3D12DebugCommandQueue_Vtbl {
        unsafe extern "system" fn AssertResourceState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            subresource: u32,
            state: u32,
        ) -> ::windows::Win32::Foundation::BOOL {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AssertResourceState(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&state),
            )
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            AssertResourceState: AssertResourceState::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DebugCommandQueue as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DebugCommandQueue1_Impl: Sized + ID3D12DebugCommandQueue_Impl {
    fn AssertResourceAccess(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        subresource: u32,
        access: D3D12_BARRIER_ACCESS,
    );
    fn AssertTextureLayout(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        subresource: u32,
        layout: D3D12_BARRIER_LAYOUT,
    );
}
impl ::windows::core::RuntimeName for ID3D12DebugCommandQueue1 {}
impl ID3D12DebugCommandQueue1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DebugCommandQueue1_Impl,
        const OFFSET: isize,
    >() -> ID3D12DebugCommandQueue1_Vtbl {
        unsafe extern "system" fn AssertResourceAccess<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandQueue1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            subresource: u32,
            access: D3D12_BARRIER_ACCESS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AssertResourceAccess(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&access),
            )
        }
        unsafe extern "system" fn AssertTextureLayout<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugCommandQueue1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            subresource: u32,
            layout: D3D12_BARRIER_LAYOUT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AssertTextureLayout(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&layout),
            )
        }
        Self {
            base__: ID3D12DebugCommandQueue_Vtbl::new::<Identity, Impl, OFFSET>(),
            AssertResourceAccess: AssertResourceAccess::<Identity, Impl, OFFSET>,
            AssertTextureLayout: AssertTextureLayout::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DebugCommandQueue1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DebugCommandQueue as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DebugDevice_Impl: Sized {
    fn SetFeatureMask(&self, mask: D3D12_DEBUG_FEATURE) -> ::windows::core::Result<()>;
    fn GetFeatureMask(&self) -> D3D12_DEBUG_FEATURE;
    fn ReportLiveDeviceObjects(&self, flags: D3D12_RLDO_FLAGS) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12DebugDevice {}
impl ID3D12DebugDevice_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DebugDevice_Impl,
        const OFFSET: isize,
    >() -> ID3D12DebugDevice_Vtbl {
        unsafe extern "system" fn SetFeatureMask<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            mask: D3D12_DEBUG_FEATURE,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetFeatureMask(::core::mem::transmute_copy(&mask))
                .into()
        }
        unsafe extern "system" fn GetFeatureMask<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_DEBUG_FEATURE {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetFeatureMask()
        }
        unsafe extern "system" fn ReportLiveDeviceObjects<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            flags: D3D12_RLDO_FLAGS,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ReportLiveDeviceObjects(::core::mem::transmute_copy(&flags))
                .into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetFeatureMask: SetFeatureMask::<Identity, Impl, OFFSET>,
            GetFeatureMask: GetFeatureMask::<Identity, Impl, OFFSET>,
            ReportLiveDeviceObjects: ReportLiveDeviceObjects::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DebugDevice as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DebugDevice1_Impl: Sized {
    fn SetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()>;
    fn GetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()>;
    fn ReportLiveDeviceObjects(&self, flags: D3D12_RLDO_FLAGS) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12DebugDevice1 {}
impl ID3D12DebugDevice1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DebugDevice1_Impl,
        const OFFSET: isize,
    >() -> ID3D12DebugDevice1_Vtbl {
        unsafe extern "system" fn SetDebugParameter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugDevice1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
            pdata: *const ::core::ffi::c_void,
            datasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetDebugParameter(
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&datasize),
            )
            .into()
        }
        unsafe extern "system" fn GetDebugParameter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugDevice1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
            pdata: *mut ::core::ffi::c_void,
            datasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetDebugParameter(
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&datasize),
            )
            .into()
        }
        unsafe extern "system" fn ReportLiveDeviceObjects<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugDevice1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            flags: D3D12_RLDO_FLAGS,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ReportLiveDeviceObjects(::core::mem::transmute_copy(&flags))
                .into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetDebugParameter: SetDebugParameter::<Identity, Impl, OFFSET>,
            GetDebugParameter: GetDebugParameter::<Identity, Impl, OFFSET>,
            ReportLiveDeviceObjects: ReportLiveDeviceObjects::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DebugDevice1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DebugDevice2_Impl: Sized + ID3D12DebugDevice_Impl {
    fn SetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *const ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()>;
    fn GetDebugParameter(
        &self,
        r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
        pdata: *mut ::core::ffi::c_void,
        datasize: u32,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12DebugDevice2 {}
impl ID3D12DebugDevice2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DebugDevice2_Impl,
        const OFFSET: isize,
    >() -> ID3D12DebugDevice2_Vtbl {
        unsafe extern "system" fn SetDebugParameter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugDevice2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
            pdata: *const ::core::ffi::c_void,
            datasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetDebugParameter(
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&datasize),
            )
            .into()
        }
        unsafe extern "system" fn GetDebugParameter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DebugDevice2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            r#type: D3D12_DEBUG_DEVICE_PARAMETER_TYPE,
            pdata: *mut ::core::ffi::c_void,
            datasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetDebugParameter(
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&datasize),
            )
            .into()
        }
        Self {
            base__: ID3D12DebugDevice_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetDebugParameter: SetDebugParameter::<Identity, Impl, OFFSET>,
            GetDebugParameter: GetDebugParameter::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DebugDevice2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DebugDevice as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DescriptorHeap_Impl: Sized + ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_DESCRIPTOR_HEAP_DESC;
    fn GetCPUDescriptorHandleForHeapStart(&self) -> D3D12_CPU_DESCRIPTOR_HANDLE;
    fn GetGPUDescriptorHandleForHeapStart(&self) -> D3D12_GPU_DESCRIPTOR_HANDLE;
}
impl ::windows::core::RuntimeName for ID3D12DescriptorHeap {}
impl ID3D12DescriptorHeap_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DescriptorHeap_Impl,
        const OFFSET: isize,
    >() -> ID3D12DescriptorHeap_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DescriptorHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_DESCRIPTOR_HEAP_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        unsafe extern "system" fn GetCPUDescriptorHandleForHeapStart<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DescriptorHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_CPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetCPUDescriptorHandleForHeapStart()
        }
        unsafe extern "system" fn GetGPUDescriptorHandleForHeapStart<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DescriptorHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_GPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetGPUDescriptorHandleForHeapStart()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
            GetCPUDescriptorHandleForHeapStart: GetCPUDescriptorHandleForHeapStart::<
                Identity,
                Impl,
                OFFSET,
            >,
            GetGPUDescriptorHandleForHeapStart: GetGPUDescriptorHandleForHeapStart::<
                Identity,
                Impl,
                OFFSET,
            >,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DescriptorHeap as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device_Impl: Sized + ID3D12Object_Impl {
    fn GetNodeCount(&self) -> u32;
    fn CreateCommandQueue(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
        riid: *const ::windows::core::GUID,
        ppcommandqueue: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateCommandAllocator(
        &self,
        r#type: D3D12_COMMAND_LIST_TYPE,
        riid: *const ::windows::core::GUID,
        ppcommandallocator: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateGraphicsPipelineState(
        &self,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateComputePipelineState(
        &self,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateCommandList(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        pcommandallocator: ::core::option::Option<&ID3D12CommandAllocator>,
        pinitialstate: ::core::option::Option<&ID3D12PipelineState>,
        riid: *const ::windows::core::GUID,
        ppcommandlist: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CheckFeatureSupport(
        &self,
        feature: D3D12_FEATURE,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()>;
    fn CreateDescriptorHeap(
        &self,
        pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn GetDescriptorHandleIncrementSize(
        &self,
        descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
    ) -> u32;
    fn CreateRootSignature(
        &self,
        nodemask: u32,
        pblobwithrootsignature: *const ::core::ffi::c_void,
        bloblengthinbytes: usize,
        riid: *const ::windows::core::GUID,
        ppvrootsignature: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateConstantBufferView(
        &self,
        pdesc: *const D3D12_CONSTANT_BUFFER_VIEW_DESC,
        destdescriptor: &D3D12_CPU_DESCRIPTOR_HANDLE,
    );
    fn CreateShaderResourceView(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        pdesc: *const D3D12_SHADER_RESOURCE_VIEW_DESC,
        destdescriptor: &D3D12_CPU_DESCRIPTOR_HANDLE,
    );
    fn CreateUnorderedAccessView(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        pcounterresource: ::core::option::Option<&ID3D12Resource>,
        pdesc: *const D3D12_UNORDERED_ACCESS_VIEW_DESC,
        destdescriptor: &D3D12_CPU_DESCRIPTOR_HANDLE,
    );
    fn CreateRenderTargetView(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        pdesc: *const D3D12_RENDER_TARGET_VIEW_DESC,
        destdescriptor: &D3D12_CPU_DESCRIPTOR_HANDLE,
    );
    fn CreateDepthStencilView(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        pdesc: *const D3D12_DEPTH_STENCIL_VIEW_DESC,
        destdescriptor: &D3D12_CPU_DESCRIPTOR_HANDLE,
    );
    fn CreateSampler(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC,
        destdescriptor: &D3D12_CPU_DESCRIPTOR_HANDLE,
    );
    fn CopyDescriptors(
        &self,
        numdestdescriptorranges: u32,
        pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        pdestdescriptorrangesizes: *const u32,
        numsrcdescriptorranges: u32,
        psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        psrcdescriptorrangesizes: *const u32,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    );
    fn CopyDescriptorsSimple(
        &self,
        numdescriptors: u32,
        destdescriptorrangestart: &D3D12_CPU_DESCRIPTOR_HANDLE,
        srcdescriptorrangestart: &D3D12_CPU_DESCRIPTOR_HANDLE,
        descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
    );
    fn GetResourceAllocationInfo(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO;
    fn GetCustomHeapProperties(
        &self,
        nodemask: u32,
        heaptype: D3D12_HEAP_TYPE,
    ) -> D3D12_HEAP_PROPERTIES;
    fn CreateCommittedResource(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateHeap(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreatePlacedResource(
        &self,
        pheap: ::core::option::Option<&ID3D12Heap>,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateReservedResource(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateSharedHandle(
        &self,
        pobject: ::core::option::Option<&ID3D12DeviceChild>,
        pattributes: *const ::windows::Win32::Security::SECURITY_ATTRIBUTES,
        access: u32,
        name: &::windows::core::PCWSTR,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>;
    fn OpenSharedHandle(
        &self,
        nthandle: ::windows::Win32::Foundation::HANDLE,
        riid: *const ::windows::core::GUID,
        ppvobj: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn OpenSharedHandleByName(
        &self,
        name: &::windows::core::PCWSTR,
        access: u32,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>;
    fn MakeResident(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
    ) -> ::windows::core::Result<()>;
    fn Evict(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
    ) -> ::windows::core::Result<()>;
    fn CreateFence(
        &self,
        initialvalue: u64,
        flags: D3D12_FENCE_FLAGS,
        riid: *const ::windows::core::GUID,
        ppfence: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn GetDeviceRemovedReason(&self) -> ::windows::core::Result<()>;
    fn GetCopyableFootprints(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: *mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT,
        pnumrows: *mut u32,
        prowsizeinbytes: *mut u64,
        ptotalbytes: *mut u64,
    );
    fn CreateQueryHeap(
        &self,
        pdesc: *const D3D12_QUERY_HEAP_DESC,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn SetStablePowerState(
        &self,
        enable: ::windows::Win32::Foundation::BOOL,
    ) -> ::windows::core::Result<()>;
    fn CreateCommandSignature(
        &self,
        pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
        prootsignature: ::core::option::Option<&ID3D12RootSignature>,
        riid: *const ::windows::core::GUID,
        ppvcommandsignature: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn GetResourceTiling(
        &self,
        ptiledresource: ::core::option::Option<&ID3D12Resource>,
        pnumtilesforentireresource: *mut u32,
        ppackedmipdesc: *mut D3D12_PACKED_MIP_INFO,
        pstandardtileshapefornonpackedmips: *mut D3D12_TILE_SHAPE,
        pnumsubresourcetilings: *mut u32,
        firstsubresourcetilingtoget: u32,
        psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
    );
    fn GetAdapterLuid(&self) -> ::windows::Win32::Foundation::LUID;
}
impl ::windows::core::RuntimeName for ID3D12Device {}
impl ID3D12Device_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device_Vtbl {
        unsafe extern "system" fn GetNodeCount<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNodeCount()
        }
        unsafe extern "system" fn CreateCommandQueue<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_COMMAND_QUEUE_DESC,
            riid: *const ::windows::core::GUID,
            ppcommandqueue: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateCommandQueue(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppcommandqueue),
            )
            .into()
        }
        unsafe extern "system" fn CreateCommandAllocator<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            r#type: D3D12_COMMAND_LIST_TYPE,
            riid: *const ::windows::core::GUID,
            ppcommandallocator: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateCommandAllocator(
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppcommandallocator),
            )
            .into()
        }
        unsafe extern "system" fn CreateGraphicsPipelineState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
            riid: *const ::windows::core::GUID,
            pppipelinestate: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateGraphicsPipelineState(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&pppipelinestate),
            )
            .into()
        }
        unsafe extern "system" fn CreateComputePipelineState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
            riid: *const ::windows::core::GUID,
            pppipelinestate: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateComputePipelineState(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&pppipelinestate),
            )
            .into()
        }
        unsafe extern "system" fn CreateCommandList<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            nodemask: u32,
            r#type: D3D12_COMMAND_LIST_TYPE,
            pcommandallocator: *mut ::core::ffi::c_void,
            pinitialstate: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppcommandlist: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateCommandList(
                ::core::mem::transmute_copy(&nodemask),
                ::core::mem::transmute_copy(&r#type),
                ::windows::core::from_raw_borrowed(&pcommandallocator),
                ::windows::core::from_raw_borrowed(&pinitialstate),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppcommandlist),
            )
            .into()
        }
        unsafe extern "system" fn CheckFeatureSupport<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            feature: D3D12_FEATURE,
            pfeaturesupportdata: *mut ::core::ffi::c_void,
            featuresupportdatasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CheckFeatureSupport(
                ::core::mem::transmute_copy(&feature),
                ::core::mem::transmute_copy(&pfeaturesupportdata),
                ::core::mem::transmute_copy(&featuresupportdatasize),
            )
            .into()
        }
        unsafe extern "system" fn CreateDescriptorHeap<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdescriptorheapdesc: *const D3D12_DESCRIPTOR_HEAP_DESC,
            riid: *const ::windows::core::GUID,
            ppvheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateDescriptorHeap(
                ::core::mem::transmute_copy(&pdescriptorheapdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvheap),
            )
            .into()
        }
        unsafe extern "system" fn GetDescriptorHandleIncrementSize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            descriptorheaptype: D3D12_DESCRIPTOR_HEAP_TYPE,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetDescriptorHandleIncrementSize(::core::mem::transmute_copy(&descriptorheaptype))
        }
        unsafe extern "system" fn CreateRootSignature<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            nodemask: u32,
            pblobwithrootsignature: *const ::core::ffi::c_void,
            bloblengthinbytes: usize,
            riid: *const ::windows::core::GUID,
            ppvrootsignature: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateRootSignature(
                ::core::mem::transmute_copy(&nodemask),
                ::core::mem::transmute_copy(&pblobwithrootsignature),
                ::core::mem::transmute_copy(&bloblengthinbytes),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvrootsignature),
            )
            .into()
        }
        unsafe extern "system" fn CreateConstantBufferView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_CONSTANT_BUFFER_VIEW_DESC,
            destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateConstantBufferView(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute(&destdescriptor),
            )
        }
        unsafe extern "system" fn CreateShaderResourceView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_SHADER_RESOURCE_VIEW_DESC,
            destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateShaderResourceView(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute(&destdescriptor),
            )
        }
        unsafe extern "system" fn CreateUnorderedAccessView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            pcounterresource: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_UNORDERED_ACCESS_VIEW_DESC,
            destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateUnorderedAccessView(
                ::windows::core::from_raw_borrowed(&presource),
                ::windows::core::from_raw_borrowed(&pcounterresource),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute(&destdescriptor),
            )
        }
        unsafe extern "system" fn CreateRenderTargetView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_RENDER_TARGET_VIEW_DESC,
            destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateRenderTargetView(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute(&destdescriptor),
            )
        }
        unsafe extern "system" fn CreateDepthStencilView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_DEPTH_STENCIL_VIEW_DESC,
            destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateDepthStencilView(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute(&destdescriptor),
            )
        }
        unsafe extern "system" fn CreateSampler<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_SAMPLER_DESC,
            destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateSampler(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute(&destdescriptor),
            )
        }
        unsafe extern "system" fn CopyDescriptors<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numdestdescriptorranges: u32,
            pdestdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
            pdestdescriptorrangesizes: *const u32,
            numsrcdescriptorranges: u32,
            psrcdescriptorrangestarts: *const D3D12_CPU_DESCRIPTOR_HANDLE,
            psrcdescriptorrangesizes: *const u32,
            descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CopyDescriptors(
                ::core::mem::transmute_copy(&numdestdescriptorranges),
                ::core::mem::transmute_copy(&pdestdescriptorrangestarts),
                ::core::mem::transmute_copy(&pdestdescriptorrangesizes),
                ::core::mem::transmute_copy(&numsrcdescriptorranges),
                ::core::mem::transmute_copy(&psrcdescriptorrangestarts),
                ::core::mem::transmute_copy(&psrcdescriptorrangesizes),
                ::core::mem::transmute_copy(&descriptorheapstype),
            )
        }
        unsafe extern "system" fn CopyDescriptorsSimple<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numdescriptors: u32,
            destdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
            srcdescriptorrangestart: D3D12_CPU_DESCRIPTOR_HANDLE,
            descriptorheapstype: D3D12_DESCRIPTOR_HEAP_TYPE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CopyDescriptorsSimple(
                ::core::mem::transmute_copy(&numdescriptors),
                ::core::mem::transmute(&destdescriptorrangestart),
                ::core::mem::transmute(&srcdescriptorrangestart),
                ::core::mem::transmute_copy(&descriptorheapstype),
            )
        }
        unsafe extern "system" fn GetResourceAllocationInfo<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_RESOURCE_ALLOCATION_INFO,
            visiblemask: u32,
            numresourcedescs: u32,
            presourcedescs: *const D3D12_RESOURCE_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetResourceAllocationInfo(
                ::core::mem::transmute_copy(&visiblemask),
                ::core::mem::transmute_copy(&numresourcedescs),
                ::core::mem::transmute_copy(&presourcedescs),
            )
        }
        unsafe extern "system" fn GetCustomHeapProperties<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_HEAP_PROPERTIES,
            nodemask: u32,
            heaptype: D3D12_HEAP_TYPE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetCustomHeapProperties(
                ::core::mem::transmute_copy(&nodemask),
                ::core::mem::transmute_copy(&heaptype),
            )
        }
        unsafe extern "system" fn CreateCommittedResource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheapproperties: *const D3D12_HEAP_PROPERTIES,
            heapflags: D3D12_HEAP_FLAGS,
            pdesc: *const D3D12_RESOURCE_DESC,
            initialresourcestate: D3D12_RESOURCE_STATES,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            riidresource: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateCommittedResource(
                ::core::mem::transmute_copy(&pheapproperties),
                ::core::mem::transmute_copy(&heapflags),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initialresourcestate),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::core::mem::transmute_copy(&riidresource),
                ::core::mem::transmute_copy(&ppvresource),
            )
            .into()
        }
        unsafe extern "system" fn CreateHeap<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_HEAP_DESC,
            riid: *const ::windows::core::GUID,
            ppvheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateHeap(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvheap),
            )
            .into()
        }
        unsafe extern "system" fn CreatePlacedResource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheap: *mut ::core::ffi::c_void,
            heapoffset: u64,
            pdesc: *const D3D12_RESOURCE_DESC,
            initialstate: D3D12_RESOURCE_STATES,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            riid: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreatePlacedResource(
                ::windows::core::from_raw_borrowed(&pheap),
                ::core::mem::transmute_copy(&heapoffset),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initialstate),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvresource),
            )
            .into()
        }
        unsafe extern "system" fn CreateReservedResource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_RESOURCE_DESC,
            initialstate: D3D12_RESOURCE_STATES,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            riid: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateReservedResource(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initialstate),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvresource),
            )
            .into()
        }
        unsafe extern "system" fn CreateSharedHandle<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pobject: *mut ::core::ffi::c_void,
            pattributes: *const ::windows::Win32::Security::SECURITY_ATTRIBUTES,
            access: u32,
            name: ::windows::core::PCWSTR,
            phandle: *mut ::windows::Win32::Foundation::HANDLE,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.CreateSharedHandle(
                ::windows::core::from_raw_borrowed(&pobject),
                ::core::mem::transmute_copy(&pattributes),
                ::core::mem::transmute_copy(&access),
                ::core::mem::transmute(&name),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(phandle, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn OpenSharedHandle<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            nthandle: ::windows::Win32::Foundation::HANDLE,
            riid: *const ::windows::core::GUID,
            ppvobj: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.OpenSharedHandle(
                ::core::mem::transmute_copy(&nthandle),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvobj),
            )
            .into()
        }
        unsafe extern "system" fn OpenSharedHandleByName<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCWSTR,
            access: u32,
            pnthandle: *mut ::windows::Win32::Foundation::HANDLE,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.OpenSharedHandleByName(
                ::core::mem::transmute(&name),
                ::core::mem::transmute_copy(&access),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pnthandle, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn MakeResident<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numobjects: u32,
            ppobjects: *const *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.MakeResident(
                ::core::mem::transmute_copy(&numobjects),
                ::core::mem::transmute_copy(&ppobjects),
            )
            .into()
        }
        unsafe extern "system" fn Evict<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numobjects: u32,
            ppobjects: *const *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Evict(
                ::core::mem::transmute_copy(&numobjects),
                ::core::mem::transmute_copy(&ppobjects),
            )
            .into()
        }
        unsafe extern "system" fn CreateFence<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            initialvalue: u64,
            flags: D3D12_FENCE_FLAGS,
            riid: *const ::windows::core::GUID,
            ppfence: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateFence(
                ::core::mem::transmute_copy(&initialvalue),
                ::core::mem::transmute_copy(&flags),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppfence),
            )
            .into()
        }
        unsafe extern "system" fn GetDeviceRemovedReason<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetDeviceRemovedReason().into()
        }
        unsafe extern "system" fn GetCopyableFootprints<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presourcedesc: *const D3D12_RESOURCE_DESC,
            firstsubresource: u32,
            numsubresources: u32,
            baseoffset: u64,
            playouts: *mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT,
            pnumrows: *mut u32,
            prowsizeinbytes: *mut u64,
            ptotalbytes: *mut u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCopyableFootprints(
                ::core::mem::transmute_copy(&presourcedesc),
                ::core::mem::transmute_copy(&firstsubresource),
                ::core::mem::transmute_copy(&numsubresources),
                ::core::mem::transmute_copy(&baseoffset),
                ::core::mem::transmute_copy(&playouts),
                ::core::mem::transmute_copy(&pnumrows),
                ::core::mem::transmute_copy(&prowsizeinbytes),
                ::core::mem::transmute_copy(&ptotalbytes),
            )
        }
        unsafe extern "system" fn CreateQueryHeap<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_QUERY_HEAP_DESC,
            riid: *const ::windows::core::GUID,
            ppvheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateQueryHeap(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvheap),
            )
            .into()
        }
        unsafe extern "system" fn SetStablePowerState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enable: ::windows::Win32::Foundation::BOOL,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetStablePowerState(::core::mem::transmute_copy(&enable))
                .into()
        }
        unsafe extern "system" fn CreateCommandSignature<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_COMMAND_SIGNATURE_DESC,
            prootsignature: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvcommandsignature: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateCommandSignature(
                ::core::mem::transmute_copy(&pdesc),
                ::windows::core::from_raw_borrowed(&prootsignature),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvcommandsignature),
            )
            .into()
        }
        unsafe extern "system" fn GetResourceTiling<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            ptiledresource: *mut ::core::ffi::c_void,
            pnumtilesforentireresource: *mut u32,
            ppackedmipdesc: *mut D3D12_PACKED_MIP_INFO,
            pstandardtileshapefornonpackedmips: *mut D3D12_TILE_SHAPE,
            pnumsubresourcetilings: *mut u32,
            firstsubresourcetilingtoget: u32,
            psubresourcetilingsfornonpackedmips: *mut D3D12_SUBRESOURCE_TILING,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetResourceTiling(
                ::windows::core::from_raw_borrowed(&ptiledresource),
                ::core::mem::transmute_copy(&pnumtilesforentireresource),
                ::core::mem::transmute_copy(&ppackedmipdesc),
                ::core::mem::transmute_copy(&pstandardtileshapefornonpackedmips),
                ::core::mem::transmute_copy(&pnumsubresourcetilings),
                ::core::mem::transmute_copy(&firstsubresourcetilingtoget),
                ::core::mem::transmute_copy(&psubresourcetilingsfornonpackedmips),
            )
        }
        unsafe extern "system" fn GetAdapterLuid<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut ::windows::Win32::Foundation::LUID,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetAdapterLuid()
        }
        Self {
            base__: ID3D12Object_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetNodeCount: GetNodeCount::<Identity, Impl, OFFSET>,
            CreateCommandQueue: CreateCommandQueue::<Identity, Impl, OFFSET>,
            CreateCommandAllocator: CreateCommandAllocator::<Identity, Impl, OFFSET>,
            CreateGraphicsPipelineState: CreateGraphicsPipelineState::<Identity, Impl, OFFSET>,
            CreateComputePipelineState: CreateComputePipelineState::<Identity, Impl, OFFSET>,
            CreateCommandList: CreateCommandList::<Identity, Impl, OFFSET>,
            CheckFeatureSupport: CheckFeatureSupport::<Identity, Impl, OFFSET>,
            CreateDescriptorHeap: CreateDescriptorHeap::<Identity, Impl, OFFSET>,
            GetDescriptorHandleIncrementSize: GetDescriptorHandleIncrementSize::<
                Identity,
                Impl,
                OFFSET,
            >,
            CreateRootSignature: CreateRootSignature::<Identity, Impl, OFFSET>,
            CreateConstantBufferView: CreateConstantBufferView::<Identity, Impl, OFFSET>,
            CreateShaderResourceView: CreateShaderResourceView::<Identity, Impl, OFFSET>,
            CreateUnorderedAccessView: CreateUnorderedAccessView::<Identity, Impl, OFFSET>,
            CreateRenderTargetView: CreateRenderTargetView::<Identity, Impl, OFFSET>,
            CreateDepthStencilView: CreateDepthStencilView::<Identity, Impl, OFFSET>,
            CreateSampler: CreateSampler::<Identity, Impl, OFFSET>,
            CopyDescriptors: CopyDescriptors::<Identity, Impl, OFFSET>,
            CopyDescriptorsSimple: CopyDescriptorsSimple::<Identity, Impl, OFFSET>,
            GetResourceAllocationInfo: GetResourceAllocationInfo::<Identity, Impl, OFFSET>,
            GetCustomHeapProperties: GetCustomHeapProperties::<Identity, Impl, OFFSET>,
            CreateCommittedResource: CreateCommittedResource::<Identity, Impl, OFFSET>,
            CreateHeap: CreateHeap::<Identity, Impl, OFFSET>,
            CreatePlacedResource: CreatePlacedResource::<Identity, Impl, OFFSET>,
            CreateReservedResource: CreateReservedResource::<Identity, Impl, OFFSET>,
            CreateSharedHandle: CreateSharedHandle::<Identity, Impl, OFFSET>,
            OpenSharedHandle: OpenSharedHandle::<Identity, Impl, OFFSET>,
            OpenSharedHandleByName: OpenSharedHandleByName::<Identity, Impl, OFFSET>,
            MakeResident: MakeResident::<Identity, Impl, OFFSET>,
            Evict: Evict::<Identity, Impl, OFFSET>,
            CreateFence: CreateFence::<Identity, Impl, OFFSET>,
            GetDeviceRemovedReason: GetDeviceRemovedReason::<Identity, Impl, OFFSET>,
            GetCopyableFootprints: GetCopyableFootprints::<Identity, Impl, OFFSET>,
            CreateQueryHeap: CreateQueryHeap::<Identity, Impl, OFFSET>,
            SetStablePowerState: SetStablePowerState::<Identity, Impl, OFFSET>,
            CreateCommandSignature: CreateCommandSignature::<Identity, Impl, OFFSET>,
            GetResourceTiling: GetResourceTiling::<Identity, Impl, OFFSET>,
            GetAdapterLuid: GetAdapterLuid::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device1_Impl: Sized + ID3D12Device_Impl {
    fn CreatePipelineLibrary(
        &self,
        plibraryblob: *const ::core::ffi::c_void,
        bloblength: usize,
        riid: *const ::windows::core::GUID,
        pppipelinelibrary: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn SetEventOnMultipleFenceCompletion(
        &self,
        ppfences: *const ::core::option::Option<ID3D12Fence>,
        pfencevalues: *const u64,
        numfences: u32,
        flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
        hevent: ::windows::Win32::Foundation::HANDLE,
    ) -> ::windows::core::Result<()>;
    fn SetResidencyPriority(
        &self,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        ppriorities: *const D3D12_RESIDENCY_PRIORITY,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Device1 {}
impl ID3D12Device1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device1_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device1_Vtbl {
        unsafe extern "system" fn CreatePipelineLibrary<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            plibraryblob: *const ::core::ffi::c_void,
            bloblength: usize,
            riid: *const ::windows::core::GUID,
            pppipelinelibrary: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreatePipelineLibrary(
                ::core::mem::transmute_copy(&plibraryblob),
                ::core::mem::transmute_copy(&bloblength),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&pppipelinelibrary),
            )
            .into()
        }
        unsafe extern "system" fn SetEventOnMultipleFenceCompletion<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            ppfences: *const *mut ::core::ffi::c_void,
            pfencevalues: *const u64,
            numfences: u32,
            flags: D3D12_MULTIPLE_FENCE_WAIT_FLAGS,
            hevent: ::windows::Win32::Foundation::HANDLE,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetEventOnMultipleFenceCompletion(
                ::core::mem::transmute_copy(&ppfences),
                ::core::mem::transmute_copy(&pfencevalues),
                ::core::mem::transmute_copy(&numfences),
                ::core::mem::transmute_copy(&flags),
                ::core::mem::transmute_copy(&hevent),
            )
            .into()
        }
        unsafe extern "system" fn SetResidencyPriority<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numobjects: u32,
            ppobjects: *const *mut ::core::ffi::c_void,
            ppriorities: *const D3D12_RESIDENCY_PRIORITY,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetResidencyPriority(
                ::core::mem::transmute_copy(&numobjects),
                ::core::mem::transmute_copy(&ppobjects),
                ::core::mem::transmute_copy(&ppriorities),
            )
            .into()
        }
        Self {
            base__: ID3D12Device_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreatePipelineLibrary: CreatePipelineLibrary::<Identity, Impl, OFFSET>,
            SetEventOnMultipleFenceCompletion: SetEventOnMultipleFenceCompletion::<
                Identity,
                Impl,
                OFFSET,
            >,
            SetResidencyPriority: SetResidencyPriority::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device10_Impl: Sized + ID3D12Device9_Impl {
    fn CreateCommittedResource3(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pprotectedsession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        numcastableformats: u32,
        pcastableformats: *const DXGI_FORMAT,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreatePlacedResource2(
        &self,
        pheap: ::core::option::Option<&ID3D12Heap>,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        numcastableformats: u32,
        pcastableformats: *const DXGI_FORMAT,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateReservedResource2(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initiallayout: D3D12_BARRIER_LAYOUT,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pprotectedsession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        numcastableformats: u32,
        pcastableformats: *const DXGI_FORMAT,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Device10 {}
impl ID3D12Device10_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device10_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device10_Vtbl {
        unsafe extern "system" fn CreateCommittedResource3<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device10_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheapproperties: *const D3D12_HEAP_PROPERTIES,
            heapflags: D3D12_HEAP_FLAGS,
            pdesc: *const D3D12_RESOURCE_DESC1,
            initiallayout: D3D12_BARRIER_LAYOUT,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            pprotectedsession: *mut ::core::ffi::c_void,
            numcastableformats: u32,
            pcastableformats: *const DXGI_FORMAT,
            riidresource: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateCommittedResource3(
                ::core::mem::transmute_copy(&pheapproperties),
                ::core::mem::transmute_copy(&heapflags),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initiallayout),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::windows::core::from_raw_borrowed(&pprotectedsession),
                ::core::mem::transmute_copy(&numcastableformats),
                ::core::mem::transmute_copy(&pcastableformats),
                ::core::mem::transmute_copy(&riidresource),
                ::core::mem::transmute_copy(&ppvresource),
            )
            .into()
        }
        unsafe extern "system" fn CreatePlacedResource2<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device10_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheap: *mut ::core::ffi::c_void,
            heapoffset: u64,
            pdesc: *const D3D12_RESOURCE_DESC1,
            initiallayout: D3D12_BARRIER_LAYOUT,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            numcastableformats: u32,
            pcastableformats: *const DXGI_FORMAT,
            riid: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreatePlacedResource2(
                ::windows::core::from_raw_borrowed(&pheap),
                ::core::mem::transmute_copy(&heapoffset),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initiallayout),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::core::mem::transmute_copy(&numcastableformats),
                ::core::mem::transmute_copy(&pcastableformats),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvresource),
            )
            .into()
        }
        unsafe extern "system" fn CreateReservedResource2<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device10_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_RESOURCE_DESC,
            initiallayout: D3D12_BARRIER_LAYOUT,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            pprotectedsession: *mut ::core::ffi::c_void,
            numcastableformats: u32,
            pcastableformats: *const DXGI_FORMAT,
            riid: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateReservedResource2(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initiallayout),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::windows::core::from_raw_borrowed(&pprotectedsession),
                ::core::mem::transmute_copy(&numcastableformats),
                ::core::mem::transmute_copy(&pcastableformats),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvresource),
            )
            .into()
        }
        Self {
            base__: ID3D12Device9_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateCommittedResource3: CreateCommittedResource3::<Identity, Impl, OFFSET>,
            CreatePlacedResource2: CreatePlacedResource2::<Identity, Impl, OFFSET>,
            CreateReservedResource2: CreateReservedResource2::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device10 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device7 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device8 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device9 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device11_Impl: Sized + ID3D12Device10_Impl {
    fn CreateSampler2(
        &self,
        pdesc: *const D3D12_SAMPLER_DESC2,
        destdescriptor: &D3D12_CPU_DESCRIPTOR_HANDLE,
    );
}
impl ::windows::core::RuntimeName for ID3D12Device11 {}
impl ID3D12Device11_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device11_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device11_Vtbl {
        unsafe extern "system" fn CreateSampler2<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device11_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_SAMPLER_DESC2,
            destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateSampler2(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute(&destdescriptor),
            )
        }
        Self {
            base__: ID3D12Device10_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateSampler2: CreateSampler2::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device11 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device7 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device8 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device9 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device10 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device12_Impl: Sized + ID3D12Device11_Impl {
    fn GetResourceAllocationInfo3(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        pnumcastableformats: *const u32,
        ppcastableformats: *const *const DXGI_FORMAT,
        presourceallocationinfo1: *mut D3D12_RESOURCE_ALLOCATION_INFO1,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO;
}
impl ::windows::core::RuntimeName for ID3D12Device12 {}
impl ID3D12Device12_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device12_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device12_Vtbl {
        unsafe extern "system" fn GetResourceAllocationInfo3<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device12_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_RESOURCE_ALLOCATION_INFO,
            visiblemask: u32,
            numresourcedescs: u32,
            presourcedescs: *const D3D12_RESOURCE_DESC1,
            pnumcastableformats: *const u32,
            ppcastableformats: *const *const DXGI_FORMAT,
            presourceallocationinfo1: *mut D3D12_RESOURCE_ALLOCATION_INFO1,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetResourceAllocationInfo3(
                ::core::mem::transmute_copy(&visiblemask),
                ::core::mem::transmute_copy(&numresourcedescs),
                ::core::mem::transmute_copy(&presourcedescs),
                ::core::mem::transmute_copy(&pnumcastableformats),
                ::core::mem::transmute_copy(&ppcastableformats),
                ::core::mem::transmute_copy(&presourceallocationinfo1),
            )
        }
        Self {
            base__: ID3D12Device11_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetResourceAllocationInfo3: GetResourceAllocationInfo3::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device12 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device7 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device8 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device9 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device10 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device11 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device13_Impl: Sized + ID3D12Device12_Impl {
    fn OpenExistingHeapFromAddress1(
        &self,
        paddress: *const ::core::ffi::c_void,
        size: usize,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Device13 {}
impl ID3D12Device13_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device13_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device13_Vtbl {
        unsafe extern "system" fn OpenExistingHeapFromAddress1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device13_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            paddress: *const ::core::ffi::c_void,
            size: usize,
            riid: *const ::windows::core::GUID,
            ppvheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.OpenExistingHeapFromAddress1(
                ::core::mem::transmute_copy(&paddress),
                ::core::mem::transmute_copy(&size),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvheap),
            )
            .into()
        }
        Self {
            base__: ID3D12Device12_Vtbl::new::<Identity, Impl, OFFSET>(),
            OpenExistingHeapFromAddress1: OpenExistingHeapFromAddress1::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device13 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device7 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device8 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device9 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device10 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device11 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device12 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device2_Impl: Sized + ID3D12Device1_Impl {
    fn CreatePipelineState(
        &self,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Device2 {}
impl ID3D12Device2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device2_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device2_Vtbl {
        unsafe extern "system" fn CreatePipelineState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
            riid: *const ::windows::core::GUID,
            pppipelinestate: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreatePipelineState(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&pppipelinestate),
            )
            .into()
        }
        Self {
            base__: ID3D12Device1_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreatePipelineState: CreatePipelineState::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device3_Impl: Sized + ID3D12Device2_Impl {
    fn OpenExistingHeapFromAddress(
        &self,
        paddress: *const ::core::ffi::c_void,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn OpenExistingHeapFromFileMapping(
        &self,
        hfilemapping: ::windows::Win32::Foundation::HANDLE,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn EnqueueMakeResident(
        &self,
        flags: D3D12_RESIDENCY_FLAGS,
        numobjects: u32,
        ppobjects: *const ::core::option::Option<ID3D12Pageable>,
        pfencetosignal: ::core::option::Option<&ID3D12Fence>,
        fencevaluetosignal: u64,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Device3 {}
impl ID3D12Device3_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device3_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device3_Vtbl {
        unsafe extern "system" fn OpenExistingHeapFromAddress<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            paddress: *const ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.OpenExistingHeapFromAddress(
                ::core::mem::transmute_copy(&paddress),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvheap),
            )
            .into()
        }
        unsafe extern "system" fn OpenExistingHeapFromFileMapping<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            hfilemapping: ::windows::Win32::Foundation::HANDLE,
            riid: *const ::windows::core::GUID,
            ppvheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.OpenExistingHeapFromFileMapping(
                ::core::mem::transmute_copy(&hfilemapping),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvheap),
            )
            .into()
        }
        unsafe extern "system" fn EnqueueMakeResident<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            flags: D3D12_RESIDENCY_FLAGS,
            numobjects: u32,
            ppobjects: *const *mut ::core::ffi::c_void,
            pfencetosignal: *mut ::core::ffi::c_void,
            fencevaluetosignal: u64,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EnqueueMakeResident(
                ::core::mem::transmute_copy(&flags),
                ::core::mem::transmute_copy(&numobjects),
                ::core::mem::transmute_copy(&ppobjects),
                ::windows::core::from_raw_borrowed(&pfencetosignal),
                ::core::mem::transmute_copy(&fencevaluetosignal),
            )
            .into()
        }
        Self {
            base__: ID3D12Device2_Vtbl::new::<Identity, Impl, OFFSET>(),
            OpenExistingHeapFromAddress: OpenExistingHeapFromAddress::<Identity, Impl, OFFSET>,
            OpenExistingHeapFromFileMapping: OpenExistingHeapFromFileMapping::<
                Identity,
                Impl,
                OFFSET,
            >,
            EnqueueMakeResident: EnqueueMakeResident::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device4_Impl: Sized + ID3D12Device3_Impl {
    fn CreateCommandList1(
        &self,
        nodemask: u32,
        r#type: D3D12_COMMAND_LIST_TYPE,
        flags: D3D12_COMMAND_LIST_FLAGS,
        riid: *const ::windows::core::GUID,
        ppcommandlist: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateProtectedResourceSession(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
        riid: *const ::windows::core::GUID,
        ppsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateCommittedResource1(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pprotectedsession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateHeap1(
        &self,
        pdesc: *const D3D12_HEAP_DESC,
        pprotectedsession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        riid: *const ::windows::core::GUID,
        ppvheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateReservedResource1(
        &self,
        pdesc: *const D3D12_RESOURCE_DESC,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pprotectedsession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn GetResourceAllocationInfo1(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC,
        presourceallocationinfo1: *mut D3D12_RESOURCE_ALLOCATION_INFO1,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO;
}
impl ::windows::core::RuntimeName for ID3D12Device4 {}
impl ID3D12Device4_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device4_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device4_Vtbl {
        unsafe extern "system" fn CreateCommandList1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            nodemask: u32,
            r#type: D3D12_COMMAND_LIST_TYPE,
            flags: D3D12_COMMAND_LIST_FLAGS,
            riid: *const ::windows::core::GUID,
            ppcommandlist: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateCommandList1(
                ::core::mem::transmute_copy(&nodemask),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&flags),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppcommandlist),
            )
            .into()
        }
        unsafe extern "system" fn CreateProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC,
            riid: *const ::windows::core::GUID,
            ppsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateProtectedResourceSession(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppsession),
            )
            .into()
        }
        unsafe extern "system" fn CreateCommittedResource1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheapproperties: *const D3D12_HEAP_PROPERTIES,
            heapflags: D3D12_HEAP_FLAGS,
            pdesc: *const D3D12_RESOURCE_DESC,
            initialresourcestate: D3D12_RESOURCE_STATES,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            pprotectedsession: *mut ::core::ffi::c_void,
            riidresource: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateCommittedResource1(
                ::core::mem::transmute_copy(&pheapproperties),
                ::core::mem::transmute_copy(&heapflags),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initialresourcestate),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::windows::core::from_raw_borrowed(&pprotectedsession),
                ::core::mem::transmute_copy(&riidresource),
                ::core::mem::transmute_copy(&ppvresource),
            )
            .into()
        }
        unsafe extern "system" fn CreateHeap1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_HEAP_DESC,
            pprotectedsession: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateHeap1(
                ::core::mem::transmute_copy(&pdesc),
                ::windows::core::from_raw_borrowed(&pprotectedsession),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvheap),
            )
            .into()
        }
        unsafe extern "system" fn CreateReservedResource1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_RESOURCE_DESC,
            initialstate: D3D12_RESOURCE_STATES,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            pprotectedsession: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateReservedResource1(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initialstate),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::windows::core::from_raw_borrowed(&pprotectedsession),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvresource),
            )
            .into()
        }
        unsafe extern "system" fn GetResourceAllocationInfo1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_RESOURCE_ALLOCATION_INFO,
            visiblemask: u32,
            numresourcedescs: u32,
            presourcedescs: *const D3D12_RESOURCE_DESC,
            presourceallocationinfo1: *mut D3D12_RESOURCE_ALLOCATION_INFO1,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetResourceAllocationInfo1(
                ::core::mem::transmute_copy(&visiblemask),
                ::core::mem::transmute_copy(&numresourcedescs),
                ::core::mem::transmute_copy(&presourcedescs),
                ::core::mem::transmute_copy(&presourceallocationinfo1),
            )
        }
        Self {
            base__: ID3D12Device3_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateCommandList1: CreateCommandList1::<Identity, Impl, OFFSET>,
            CreateProtectedResourceSession: CreateProtectedResourceSession::<Identity, Impl, OFFSET>,
            CreateCommittedResource1: CreateCommittedResource1::<Identity, Impl, OFFSET>,
            CreateHeap1: CreateHeap1::<Identity, Impl, OFFSET>,
            CreateReservedResource1: CreateReservedResource1::<Identity, Impl, OFFSET>,
            GetResourceAllocationInfo1: GetResourceAllocationInfo1::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device5_Impl: Sized + ID3D12Device4_Impl {
    fn CreateLifetimeTracker(
        &self,
        powner: ::core::option::Option<&ID3D12LifetimeOwner>,
        riid: *const ::windows::core::GUID,
        ppvtracker: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn RemoveDevice(&self);
    fn EnumerateMetaCommands(
        &self,
        pnummetacommands: *mut u32,
        pdescs: *mut D3D12_META_COMMAND_DESC,
    ) -> ::windows::core::Result<()>;
    fn EnumerateMetaCommandParameters(
        &self,
        commandid: *const ::windows::core::GUID,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        ptotalstructuresizeinbytes: *mut u32,
        pparametercount: *mut u32,
        pparameterdescs: *mut D3D12_META_COMMAND_PARAMETER_DESC,
    ) -> ::windows::core::Result<()>;
    fn CreateMetaCommand(
        &self,
        commandid: *const ::windows::core::GUID,
        nodemask: u32,
        pcreationparametersdata: *const ::core::ffi::c_void,
        creationparametersdatasizeinbytes: usize,
        riid: *const ::windows::core::GUID,
        ppmetacommand: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateStateObject(
        &self,
        pdesc: *const D3D12_STATE_OBJECT_DESC,
        riid: *const ::windows::core::GUID,
        ppstateobject: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn GetRaytracingAccelerationStructurePrebuildInfo(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
        pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
    );
    fn CheckDriverMatchingIdentifier(
        &self,
        serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
        pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
    ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS;
}
impl ::windows::core::RuntimeName for ID3D12Device5 {}
impl ID3D12Device5_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device5_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device5_Vtbl {
        unsafe extern "system" fn CreateLifetimeTracker<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            powner: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvtracker: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateLifetimeTracker(
                ::windows::core::from_raw_borrowed(&powner),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvtracker),
            )
            .into()
        }
        unsafe extern "system" fn RemoveDevice<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RemoveDevice()
        }
        unsafe extern "system" fn EnumerateMetaCommands<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pnummetacommands: *mut u32,
            pdescs: *mut D3D12_META_COMMAND_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EnumerateMetaCommands(
                ::core::mem::transmute_copy(&pnummetacommands),
                ::core::mem::transmute_copy(&pdescs),
            )
            .into()
        }
        unsafe extern "system" fn EnumerateMetaCommandParameters<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            commandid: *const ::windows::core::GUID,
            stage: D3D12_META_COMMAND_PARAMETER_STAGE,
            ptotalstructuresizeinbytes: *mut u32,
            pparametercount: *mut u32,
            pparameterdescs: *mut D3D12_META_COMMAND_PARAMETER_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EnumerateMetaCommandParameters(
                ::core::mem::transmute_copy(&commandid),
                ::core::mem::transmute_copy(&stage),
                ::core::mem::transmute_copy(&ptotalstructuresizeinbytes),
                ::core::mem::transmute_copy(&pparametercount),
                ::core::mem::transmute_copy(&pparameterdescs),
            )
            .into()
        }
        unsafe extern "system" fn CreateMetaCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            commandid: *const ::windows::core::GUID,
            nodemask: u32,
            pcreationparametersdata: *const ::core::ffi::c_void,
            creationparametersdatasizeinbytes: usize,
            riid: *const ::windows::core::GUID,
            ppmetacommand: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateMetaCommand(
                ::core::mem::transmute_copy(&commandid),
                ::core::mem::transmute_copy(&nodemask),
                ::core::mem::transmute_copy(&pcreationparametersdata),
                ::core::mem::transmute_copy(&creationparametersdatasizeinbytes),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppmetacommand),
            )
            .into()
        }
        unsafe extern "system" fn CreateStateObject<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_STATE_OBJECT_DESC,
            riid: *const ::windows::core::GUID,
            ppstateobject: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateStateObject(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppstateobject),
            )
            .into()
        }
        unsafe extern "system" fn GetRaytracingAccelerationStructurePrebuildInfo<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS,
            pinfo: *mut D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetRaytracingAccelerationStructurePrebuildInfo(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&pinfo),
            )
        }
        unsafe extern "system" fn CheckDriverMatchingIdentifier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            serializeddatatype: D3D12_SERIALIZED_DATA_TYPE,
            pidentifiertocheck: *const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER,
        ) -> D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CheckDriverMatchingIdentifier(
                ::core::mem::transmute_copy(&serializeddatatype),
                ::core::mem::transmute_copy(&pidentifiertocheck),
            )
        }
        Self {
            base__: ID3D12Device4_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateLifetimeTracker: CreateLifetimeTracker::<Identity, Impl, OFFSET>,
            RemoveDevice: RemoveDevice::<Identity, Impl, OFFSET>,
            EnumerateMetaCommands: EnumerateMetaCommands::<Identity, Impl, OFFSET>,
            EnumerateMetaCommandParameters: EnumerateMetaCommandParameters::<Identity, Impl, OFFSET>,
            CreateMetaCommand: CreateMetaCommand::<Identity, Impl, OFFSET>,
            CreateStateObject: CreateStateObject::<Identity, Impl, OFFSET>,
            GetRaytracingAccelerationStructurePrebuildInfo:
                GetRaytracingAccelerationStructurePrebuildInfo::<Identity, Impl, OFFSET>,
            CheckDriverMatchingIdentifier: CheckDriverMatchingIdentifier::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device6_Impl: Sized + ID3D12Device5_Impl {
    fn SetBackgroundProcessingMode(
        &self,
        mode: D3D12_BACKGROUND_PROCESSING_MODE,
        measurementsaction: D3D12_MEASUREMENTS_ACTION,
        heventtosignaluponcompletion: ::windows::Win32::Foundation::HANDLE,
        pbfurthermeasurementsdesired: *mut ::windows::Win32::Foundation::BOOL,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Device6 {}
impl ID3D12Device6_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device6_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device6_Vtbl {
        unsafe extern "system" fn SetBackgroundProcessingMode<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device6_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            mode: D3D12_BACKGROUND_PROCESSING_MODE,
            measurementsaction: D3D12_MEASUREMENTS_ACTION,
            heventtosignaluponcompletion: ::windows::Win32::Foundation::HANDLE,
            pbfurthermeasurementsdesired: *mut ::windows::Win32::Foundation::BOOL,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetBackgroundProcessingMode(
                ::core::mem::transmute_copy(&mode),
                ::core::mem::transmute_copy(&measurementsaction),
                ::core::mem::transmute_copy(&heventtosignaluponcompletion),
                ::core::mem::transmute_copy(&pbfurthermeasurementsdesired),
            )
            .into()
        }
        Self {
            base__: ID3D12Device5_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetBackgroundProcessingMode: SetBackgroundProcessingMode::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device5 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device7_Impl: Sized + ID3D12Device6_Impl {
    fn AddToStateObject(
        &self,
        paddition: *const D3D12_STATE_OBJECT_DESC,
        pstateobjecttogrowfrom: ::core::option::Option<&ID3D12StateObject>,
        riid: *const ::windows::core::GUID,
        ppnewstateobject: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateProtectedResourceSession1(
        &self,
        pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
        riid: *const ::windows::core::GUID,
        ppsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Device7 {}
impl ID3D12Device7_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device7_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device7_Vtbl {
        unsafe extern "system" fn AddToStateObject<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device7_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            paddition: *const D3D12_STATE_OBJECT_DESC,
            pstateobjecttogrowfrom: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppnewstateobject: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AddToStateObject(
                ::core::mem::transmute_copy(&paddition),
                ::windows::core::from_raw_borrowed(&pstateobjecttogrowfrom),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppnewstateobject),
            )
            .into()
        }
        unsafe extern "system" fn CreateProtectedResourceSession1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device7_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
            riid: *const ::windows::core::GUID,
            ppsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateProtectedResourceSession1(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppsession),
            )
            .into()
        }
        Self {
            base__: ID3D12Device6_Vtbl::new::<Identity, Impl, OFFSET>(),
            AddToStateObject: AddToStateObject::<Identity, Impl, OFFSET>,
            CreateProtectedResourceSession1: CreateProtectedResourceSession1::<
                Identity,
                Impl,
                OFFSET,
            >,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device7 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device6 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device8_Impl: Sized + ID3D12Device7_Impl {
    fn GetResourceAllocationInfo2(
        &self,
        visiblemask: u32,
        numresourcedescs: u32,
        presourcedescs: *const D3D12_RESOURCE_DESC1,
        presourceallocationinfo1: *mut D3D12_RESOURCE_ALLOCATION_INFO1,
    ) -> D3D12_RESOURCE_ALLOCATION_INFO;
    fn CreateCommittedResource2(
        &self,
        pheapproperties: *const D3D12_HEAP_PROPERTIES,
        heapflags: D3D12_HEAP_FLAGS,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialresourcestate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        pprotectedsession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreatePlacedResource1(
        &self,
        pheap: ::core::option::Option<&ID3D12Heap>,
        heapoffset: u64,
        pdesc: *const D3D12_RESOURCE_DESC1,
        initialstate: D3D12_RESOURCE_STATES,
        poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
        riid: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateSamplerFeedbackUnorderedAccessView(
        &self,
        ptargetedresource: ::core::option::Option<&ID3D12Resource>,
        pfeedbackresource: ::core::option::Option<&ID3D12Resource>,
        destdescriptor: &D3D12_CPU_DESCRIPTOR_HANDLE,
    );
    fn GetCopyableFootprints1(
        &self,
        presourcedesc: *const D3D12_RESOURCE_DESC1,
        firstsubresource: u32,
        numsubresources: u32,
        baseoffset: u64,
        playouts: *mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT,
        pnumrows: *mut u32,
        prowsizeinbytes: *mut u64,
        ptotalbytes: *mut u64,
    );
}
impl ::windows::core::RuntimeName for ID3D12Device8 {}
impl ID3D12Device8_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device8_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device8_Vtbl {
        unsafe extern "system" fn GetResourceAllocationInfo2<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device8_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_RESOURCE_ALLOCATION_INFO,
            visiblemask: u32,
            numresourcedescs: u32,
            presourcedescs: *const D3D12_RESOURCE_DESC1,
            presourceallocationinfo1: *mut D3D12_RESOURCE_ALLOCATION_INFO1,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetResourceAllocationInfo2(
                ::core::mem::transmute_copy(&visiblemask),
                ::core::mem::transmute_copy(&numresourcedescs),
                ::core::mem::transmute_copy(&presourcedescs),
                ::core::mem::transmute_copy(&presourceallocationinfo1),
            )
        }
        unsafe extern "system" fn CreateCommittedResource2<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device8_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheapproperties: *const D3D12_HEAP_PROPERTIES,
            heapflags: D3D12_HEAP_FLAGS,
            pdesc: *const D3D12_RESOURCE_DESC1,
            initialresourcestate: D3D12_RESOURCE_STATES,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            pprotectedsession: *mut ::core::ffi::c_void,
            riidresource: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateCommittedResource2(
                ::core::mem::transmute_copy(&pheapproperties),
                ::core::mem::transmute_copy(&heapflags),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initialresourcestate),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::windows::core::from_raw_borrowed(&pprotectedsession),
                ::core::mem::transmute_copy(&riidresource),
                ::core::mem::transmute_copy(&ppvresource),
            )
            .into()
        }
        unsafe extern "system" fn CreatePlacedResource1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device8_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheap: *mut ::core::ffi::c_void,
            heapoffset: u64,
            pdesc: *const D3D12_RESOURCE_DESC1,
            initialstate: D3D12_RESOURCE_STATES,
            poptimizedclearvalue: *const D3D12_CLEAR_VALUE,
            riid: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreatePlacedResource1(
                ::windows::core::from_raw_borrowed(&pheap),
                ::core::mem::transmute_copy(&heapoffset),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&initialstate),
                ::core::mem::transmute_copy(&poptimizedclearvalue),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvresource),
            )
            .into()
        }
        unsafe extern "system" fn CreateSamplerFeedbackUnorderedAccessView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device8_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            ptargetedresource: *mut ::core::ffi::c_void,
            pfeedbackresource: *mut ::core::ffi::c_void,
            destdescriptor: D3D12_CPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateSamplerFeedbackUnorderedAccessView(
                ::windows::core::from_raw_borrowed(&ptargetedresource),
                ::windows::core::from_raw_borrowed(&pfeedbackresource),
                ::core::mem::transmute(&destdescriptor),
            )
        }
        unsafe extern "system" fn GetCopyableFootprints1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device8_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presourcedesc: *const D3D12_RESOURCE_DESC1,
            firstsubresource: u32,
            numsubresources: u32,
            baseoffset: u64,
            playouts: *mut D3D12_PLACED_SUBRESOURCE_FOOTPRINT,
            pnumrows: *mut u32,
            prowsizeinbytes: *mut u64,
            ptotalbytes: *mut u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCopyableFootprints1(
                ::core::mem::transmute_copy(&presourcedesc),
                ::core::mem::transmute_copy(&firstsubresource),
                ::core::mem::transmute_copy(&numsubresources),
                ::core::mem::transmute_copy(&baseoffset),
                ::core::mem::transmute_copy(&playouts),
                ::core::mem::transmute_copy(&pnumrows),
                ::core::mem::transmute_copy(&prowsizeinbytes),
                ::core::mem::transmute_copy(&ptotalbytes),
            )
        }
        Self {
            base__: ID3D12Device7_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetResourceAllocationInfo2: GetResourceAllocationInfo2::<Identity, Impl, OFFSET>,
            CreateCommittedResource2: CreateCommittedResource2::<Identity, Impl, OFFSET>,
            CreatePlacedResource1: CreatePlacedResource1::<Identity, Impl, OFFSET>,
            CreateSamplerFeedbackUnorderedAccessView: CreateSamplerFeedbackUnorderedAccessView::<
                Identity,
                Impl,
                OFFSET,
            >,
            GetCopyableFootprints1: GetCopyableFootprints1::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device8 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device7 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Device9_Impl: Sized + ID3D12Device8_Impl {
    fn CreateShaderCacheSession(
        &self,
        pdesc: *const D3D12_SHADER_CACHE_SESSION_DESC,
        riid: *const ::windows::core::GUID,
        ppvsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn ShaderCacheControl(
        &self,
        kinds: D3D12_SHADER_CACHE_KIND_FLAGS,
        control: D3D12_SHADER_CACHE_CONTROL_FLAGS,
    ) -> ::windows::core::Result<()>;
    fn CreateCommandQueue1(
        &self,
        pdesc: *const D3D12_COMMAND_QUEUE_DESC,
        creatorid: *const ::windows::core::GUID,
        riid: *const ::windows::core::GUID,
        ppcommandqueue: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Device9 {}
impl ID3D12Device9_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Device9_Impl,
        const OFFSET: isize,
    >() -> ID3D12Device9_Vtbl {
        unsafe extern "system" fn CreateShaderCacheSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device9_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_SHADER_CACHE_SESSION_DESC,
            riid: *const ::windows::core::GUID,
            ppvsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateShaderCacheSession(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvsession),
            )
            .into()
        }
        unsafe extern "system" fn ShaderCacheControl<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device9_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            kinds: D3D12_SHADER_CACHE_KIND_FLAGS,
            control: D3D12_SHADER_CACHE_CONTROL_FLAGS,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ShaderCacheControl(
                ::core::mem::transmute_copy(&kinds),
                ::core::mem::transmute_copy(&control),
            )
            .into()
        }
        unsafe extern "system" fn CreateCommandQueue1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Device9_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_COMMAND_QUEUE_DESC,
            creatorid: *const ::windows::core::GUID,
            riid: *const ::windows::core::GUID,
            ppcommandqueue: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateCommandQueue1(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&creatorid),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppcommandqueue),
            )
            .into()
        }
        Self {
            base__: ID3D12Device8_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateShaderCacheSession: CreateShaderCacheSession::<Identity, Impl, OFFSET>,
            ShaderCacheControl: ShaderCacheControl::<Identity, Impl, OFFSET>,
            CreateCommandQueue1: CreateCommandQueue1::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Device9 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device7 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device8 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceChild_Impl: Sized + ID3D12Object_Impl {
    fn GetDevice(
        &self,
        riid: *const ::windows::core::GUID,
        ppvdevice: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12DeviceChild {}
impl ID3D12DeviceChild_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceChild_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceChild_Vtbl {
        unsafe extern "system" fn GetDevice<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceChild_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvdevice: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetDevice(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvdevice),
            )
            .into()
        }
        Self {
            base__: ID3D12Object_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDevice: GetDevice::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceConfiguration_Impl: Sized {
    fn GetDesc(&self) -> D3D12_DEVICE_CONFIGURATION_DESC;
    fn GetEnabledExperimentalFeatures(
        &self,
        pguids: *mut ::windows::core::GUID,
        numguids: u32,
    ) -> ::windows::core::Result<()>;
    fn SerializeVersionedRootSignature(
        &self,
        pdesc: *const D3D12_VERSIONED_ROOT_SIGNATURE_DESC,
        ppresult: *mut ::core::option::Option<ID3DBlob>,
        pperror: *mut ::core::option::Option<ID3DBlob>,
    ) -> ::windows::core::Result<()>;
    fn CreateVersionedRootSignatureDeserializer(
        &self,
        pblob: *const ::core::ffi::c_void,
        size: usize,
        riid: *const ::windows::core::GUID,
        ppvdeserializer: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12DeviceConfiguration {}
impl ID3D12DeviceConfiguration_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceConfiguration_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceConfiguration_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceConfiguration_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_DEVICE_CONFIGURATION_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        unsafe extern "system" fn GetEnabledExperimentalFeatures<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceConfiguration_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pguids: *mut ::windows::core::GUID,
            numguids: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetEnabledExperimentalFeatures(
                ::core::mem::transmute_copy(&pguids),
                ::core::mem::transmute_copy(&numguids),
            )
            .into()
        }
        unsafe extern "system" fn SerializeVersionedRootSignature<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceConfiguration_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_VERSIONED_ROOT_SIGNATURE_DESC,
            ppresult: *mut *mut ::core::ffi::c_void,
            pperror: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SerializeVersionedRootSignature(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&ppresult),
                ::core::mem::transmute_copy(&pperror),
            )
            .into()
        }
        unsafe extern "system" fn CreateVersionedRootSignatureDeserializer<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceConfiguration_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pblob: *const ::core::ffi::c_void,
            size: usize,
            riid: *const ::windows::core::GUID,
            ppvdeserializer: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVersionedRootSignatureDeserializer(
                ::core::mem::transmute_copy(&pblob),
                ::core::mem::transmute_copy(&size),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvdeserializer),
            )
            .into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
            GetEnabledExperimentalFeatures: GetEnabledExperimentalFeatures::<Identity, Impl, OFFSET>,
            SerializeVersionedRootSignature: SerializeVersionedRootSignature::<
                Identity,
                Impl,
                OFFSET,
            >,
            CreateVersionedRootSignatureDeserializer: CreateVersionedRootSignatureDeserializer::<
                Identity,
                Impl,
                OFFSET,
            >,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceConfiguration as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceConfiguration1_Impl: Sized + ID3D12DeviceConfiguration_Impl {
    fn CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary(
        &self,
        plibraryblob: *const ::core::ffi::c_void,
        size: usize,
        rootsignaturesubobjectname: &::windows::core::PCWSTR,
        riid: *const ::windows::core::GUID,
        ppvdeserializer: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12DeviceConfiguration1 {}
impl ID3D12DeviceConfiguration1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceConfiguration1_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceConfiguration1_Vtbl {
        unsafe extern "system" fn CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceConfiguration1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            plibraryblob: *const ::core::ffi::c_void,
            size: usize,
            rootsignaturesubobjectname: ::windows::core::PCWSTR,
            riid: *const ::windows::core::GUID,
            ppvdeserializer: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary(
                ::core::mem::transmute_copy(&plibraryblob),
                ::core::mem::transmute_copy(&size),
                ::core::mem::transmute(&rootsignaturesubobjectname),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvdeserializer),
            )
            .into()
        }
        Self {
            base__: ID3D12DeviceConfiguration_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary:
                CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary::<
                    Identity,
                    Impl,
                    OFFSET,
                >,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceConfiguration1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceConfiguration as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceExperimental_Impl: Sized + ID3D12Device13_Impl {
    fn CreateRootSignatureFromSubobjectInLibrary(
        &self,
        nodemask: u32,
        plibraryblob: *const ::core::ffi::c_void,
        bloblengthinbytes: usize,
        subobjectname: &::windows::core::PCWSTR,
        riid: *const ::windows::core::GUID,
        ppvrootsignature: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12DeviceExperimental {}
impl ID3D12DeviceExperimental_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceExperimental_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceExperimental_Vtbl {
        unsafe extern "system" fn CreateRootSignatureFromSubobjectInLibrary<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceExperimental_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            nodemask: u32,
            plibraryblob: *const ::core::ffi::c_void,
            bloblengthinbytes: usize,
            subobjectname: ::windows::core::PCWSTR,
            riid: *const ::windows::core::GUID,
            ppvrootsignature: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateRootSignatureFromSubobjectInLibrary(
                ::core::mem::transmute_copy(&nodemask),
                ::core::mem::transmute_copy(&plibraryblob),
                ::core::mem::transmute_copy(&bloblengthinbytes),
                ::core::mem::transmute(&subobjectname),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvrootsignature),
            )
            .into()
        }
        Self {
            base__: ID3D12Device13_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateRootSignatureFromSubobjectInLibrary: CreateRootSignatureFromSubobjectInLibrary::<
                Identity,
                Impl,
                OFFSET,
            >,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceExperimental as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device7 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device8 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device9 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device10 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device11 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device12 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Device13 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceFactory_Impl: Sized {
    fn InitializeFromGlobalState(&self) -> ::windows::core::Result<()>;
    fn ApplyToGlobalState(&self) -> ::windows::core::Result<()>;
    fn SetFlags(&self, flags: D3D12_DEVICE_FACTORY_FLAGS) -> ::windows::core::Result<()>;
    fn GetFlags(&self) -> D3D12_DEVICE_FACTORY_FLAGS;
    fn GetConfigurationInterface(
        &self,
        clsid: *const ::windows::core::GUID,
        iid: *const ::windows::core::GUID,
        ppv: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn EnableExperimentalFeatures(
        &self,
        numfeatures: u32,
        piids: *const ::windows::core::GUID,
        pconfigurationstructs: *const ::core::ffi::c_void,
        pconfigurationstructsizes: *const u32,
    ) -> ::windows::core::Result<()>;
    fn CreateDevice(
        &self,
        adapter: ::core::option::Option<&::windows::core::IUnknown>,
        featurelevel: D3D_FEATURE_LEVEL,
        riid: *const ::windows::core::GUID,
        ppvdevice: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12DeviceFactory {}
impl ID3D12DeviceFactory_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceFactory_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceFactory_Vtbl {
        unsafe extern "system" fn InitializeFromGlobalState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.InitializeFromGlobalState().into()
        }
        unsafe extern "system" fn ApplyToGlobalState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ApplyToGlobalState().into()
        }
        unsafe extern "system" fn SetFlags<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            flags: D3D12_DEVICE_FACTORY_FLAGS,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetFlags(::core::mem::transmute_copy(&flags)).into()
        }
        unsafe extern "system" fn GetFlags<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_DEVICE_FACTORY_FLAGS {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetFlags()
        }
        unsafe extern "system" fn GetConfigurationInterface<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            clsid: *const ::windows::core::GUID,
            iid: *const ::windows::core::GUID,
            ppv: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetConfigurationInterface(
                ::core::mem::transmute_copy(&clsid),
                ::core::mem::transmute_copy(&iid),
                ::core::mem::transmute_copy(&ppv),
            )
            .into()
        }
        unsafe extern "system" fn EnableExperimentalFeatures<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numfeatures: u32,
            piids: *const ::windows::core::GUID,
            pconfigurationstructs: *const ::core::ffi::c_void,
            pconfigurationstructsizes: *const u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EnableExperimentalFeatures(
                ::core::mem::transmute_copy(&numfeatures),
                ::core::mem::transmute_copy(&piids),
                ::core::mem::transmute_copy(&pconfigurationstructs),
                ::core::mem::transmute_copy(&pconfigurationstructsizes),
            )
            .into()
        }
        unsafe extern "system" fn CreateDevice<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceFactory_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            adapter: *mut ::core::ffi::c_void,
            featurelevel: D3D_FEATURE_LEVEL,
            riid: *const ::windows::core::GUID,
            ppvdevice: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateDevice(
                ::windows::core::from_raw_borrowed(&adapter),
                ::core::mem::transmute_copy(&featurelevel),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvdevice),
            )
            .into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            InitializeFromGlobalState: InitializeFromGlobalState::<Identity, Impl, OFFSET>,
            ApplyToGlobalState: ApplyToGlobalState::<Identity, Impl, OFFSET>,
            SetFlags: SetFlags::<Identity, Impl, OFFSET>,
            GetFlags: GetFlags::<Identity, Impl, OFFSET>,
            GetConfigurationInterface: GetConfigurationInterface::<Identity, Impl, OFFSET>,
            EnableExperimentalFeatures: EnableExperimentalFeatures::<Identity, Impl, OFFSET>,
            CreateDevice: CreateDevice::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceFactory as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceRemovedExtendedData_Impl: Sized {
    fn GetAutoBreadcrumbsOutput(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT>;
    fn GetPageFaultAllocationOutput(&self)
        -> ::windows::core::Result<D3D12_DRED_PAGE_FAULT_OUTPUT>;
}
impl ::windows::core::RuntimeName for ID3D12DeviceRemovedExtendedData {}
impl ID3D12DeviceRemovedExtendedData_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceRemovedExtendedData_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceRemovedExtendedData_Vtbl {
        unsafe extern "system" fn GetAutoBreadcrumbsOutput<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedData_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            poutput: *mut D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.GetAutoBreadcrumbsOutput() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(poutput, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPageFaultAllocationOutput<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedData_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            poutput: *mut D3D12_DRED_PAGE_FAULT_OUTPUT,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.GetPageFaultAllocationOutput() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(poutput, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetAutoBreadcrumbsOutput: GetAutoBreadcrumbsOutput::<Identity, Impl, OFFSET>,
            GetPageFaultAllocationOutput: GetPageFaultAllocationOutput::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceRemovedExtendedData as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceRemovedExtendedData1_Impl:
    Sized + ID3D12DeviceRemovedExtendedData_Impl
{
    fn GetAutoBreadcrumbsOutput1(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1>;
    fn GetPageFaultAllocationOutput1(
        &self,
    ) -> ::windows::core::Result<D3D12_DRED_PAGE_FAULT_OUTPUT1>;
}
impl ::windows::core::RuntimeName for ID3D12DeviceRemovedExtendedData1 {}
impl ID3D12DeviceRemovedExtendedData1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceRemovedExtendedData1_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceRemovedExtendedData1_Vtbl {
        unsafe extern "system" fn GetAutoBreadcrumbsOutput1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedData1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            poutput: *mut D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.GetAutoBreadcrumbsOutput1() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(poutput, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetPageFaultAllocationOutput1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedData1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            poutput: *mut D3D12_DRED_PAGE_FAULT_OUTPUT1,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.GetPageFaultAllocationOutput1() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(poutput, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ID3D12DeviceRemovedExtendedData_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetAutoBreadcrumbsOutput1: GetAutoBreadcrumbsOutput1::<Identity, Impl, OFFSET>,
            GetPageFaultAllocationOutput1: GetPageFaultAllocationOutput1::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceRemovedExtendedData1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceRemovedExtendedData as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceRemovedExtendedData2_Impl:
    Sized + ID3D12DeviceRemovedExtendedData1_Impl
{
    fn GetPageFaultAllocationOutput2(
        &self,
        poutput: *mut D3D12_DRED_PAGE_FAULT_OUTPUT2,
    ) -> ::windows::core::Result<()>;
    fn GetDeviceState(&self) -> D3D12_DRED_DEVICE_STATE;
}
impl ::windows::core::RuntimeName for ID3D12DeviceRemovedExtendedData2 {}
impl ID3D12DeviceRemovedExtendedData2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceRemovedExtendedData2_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceRemovedExtendedData2_Vtbl {
        unsafe extern "system" fn GetPageFaultAllocationOutput2<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedData2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            poutput: *mut D3D12_DRED_PAGE_FAULT_OUTPUT2,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetPageFaultAllocationOutput2(::core::mem::transmute_copy(&poutput))
                .into()
        }
        unsafe extern "system" fn GetDeviceState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedData2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_DRED_DEVICE_STATE {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetDeviceState()
        }
        Self {
            base__: ID3D12DeviceRemovedExtendedData1_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetPageFaultAllocationOutput2: GetPageFaultAllocationOutput2::<Identity, Impl, OFFSET>,
            GetDeviceState: GetDeviceState::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceRemovedExtendedData2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceRemovedExtendedData as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceRemovedExtendedData1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceRemovedExtendedDataSettings_Impl: Sized {
    fn SetAutoBreadcrumbsEnablement(&self, enablement: D3D12_DRED_ENABLEMENT);
    fn SetPageFaultEnablement(&self, enablement: D3D12_DRED_ENABLEMENT);
    fn SetWatsonDumpEnablement(&self, enablement: D3D12_DRED_ENABLEMENT);
}
impl ::windows::core::RuntimeName for ID3D12DeviceRemovedExtendedDataSettings {}
impl ID3D12DeviceRemovedExtendedDataSettings_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceRemovedExtendedDataSettings_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceRemovedExtendedDataSettings_Vtbl {
        unsafe extern "system" fn SetAutoBreadcrumbsEnablement<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedDataSettings_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enablement: D3D12_DRED_ENABLEMENT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetAutoBreadcrumbsEnablement(::core::mem::transmute_copy(&enablement))
        }
        unsafe extern "system" fn SetPageFaultEnablement<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedDataSettings_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enablement: D3D12_DRED_ENABLEMENT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetPageFaultEnablement(::core::mem::transmute_copy(&enablement))
        }
        unsafe extern "system" fn SetWatsonDumpEnablement<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedDataSettings_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enablement: D3D12_DRED_ENABLEMENT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetWatsonDumpEnablement(::core::mem::transmute_copy(&enablement))
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetAutoBreadcrumbsEnablement: SetAutoBreadcrumbsEnablement::<Identity, Impl, OFFSET>,
            SetPageFaultEnablement: SetPageFaultEnablement::<Identity, Impl, OFFSET>,
            SetWatsonDumpEnablement: SetWatsonDumpEnablement::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceRemovedExtendedDataSettings as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceRemovedExtendedDataSettings1_Impl:
    Sized + ID3D12DeviceRemovedExtendedDataSettings_Impl
{
    fn SetBreadcrumbContextEnablement(&self, enablement: D3D12_DRED_ENABLEMENT);
}
impl ::windows::core::RuntimeName for ID3D12DeviceRemovedExtendedDataSettings1 {}
impl ID3D12DeviceRemovedExtendedDataSettings1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceRemovedExtendedDataSettings1_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceRemovedExtendedDataSettings1_Vtbl {
        unsafe extern "system" fn SetBreadcrumbContextEnablement<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedDataSettings1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            enablement: D3D12_DRED_ENABLEMENT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetBreadcrumbContextEnablement(::core::mem::transmute_copy(&enablement))
        }
        Self {
            base__: ID3D12DeviceRemovedExtendedDataSettings_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetBreadcrumbContextEnablement: SetBreadcrumbContextEnablement::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceRemovedExtendedDataSettings1 as ::windows::core::ComInterface>::IID
            || iid
                == &<ID3D12DeviceRemovedExtendedDataSettings as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12DeviceRemovedExtendedDataSettings2_Impl:
    Sized + ID3D12DeviceRemovedExtendedDataSettings1_Impl
{
    fn UseMarkersOnlyAutoBreadcrumbs(&self, markersonly: ::windows::Win32::Foundation::BOOL);
}
impl ::windows::core::RuntimeName for ID3D12DeviceRemovedExtendedDataSettings2 {}
impl ID3D12DeviceRemovedExtendedDataSettings2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12DeviceRemovedExtendedDataSettings2_Impl,
        const OFFSET: isize,
    >() -> ID3D12DeviceRemovedExtendedDataSettings2_Vtbl {
        unsafe extern "system" fn UseMarkersOnlyAutoBreadcrumbs<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12DeviceRemovedExtendedDataSettings2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            markersonly: ::windows::Win32::Foundation::BOOL,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.UseMarkersOnlyAutoBreadcrumbs(::core::mem::transmute_copy(&markersonly))
        }
        Self {
            base__: ID3D12DeviceRemovedExtendedDataSettings1_Vtbl::new::<Identity, Impl, OFFSET>(),
            UseMarkersOnlyAutoBreadcrumbs: UseMarkersOnlyAutoBreadcrumbs::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12DeviceRemovedExtendedDataSettings2 as ::windows::core::ComInterface>::IID
            || iid
                == &<ID3D12DeviceRemovedExtendedDataSettings as ::windows::core::ComInterface>::IID
            || iid
                == &<ID3D12DeviceRemovedExtendedDataSettings1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Fence_Impl: Sized + ID3D12Pageable_Impl {
    fn GetCompletedValue(&self) -> u64;
    fn SetEventOnCompletion(
        &self,
        value: u64,
        hevent: ::windows::Win32::Foundation::HANDLE,
    ) -> ::windows::core::Result<()>;
    fn Signal(&self, value: u64) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Fence {}
impl ID3D12Fence_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Fence_Impl,
        const OFFSET: isize,
    >() -> ID3D12Fence_Vtbl {
        unsafe extern "system" fn GetCompletedValue<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Fence_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCompletedValue()
        }
        unsafe extern "system" fn SetEventOnCompletion<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Fence_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            value: u64,
            hevent: ::windows::Win32::Foundation::HANDLE,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetEventOnCompletion(
                ::core::mem::transmute_copy(&value),
                ::core::mem::transmute_copy(&hevent),
            )
            .into()
        }
        unsafe extern "system" fn Signal<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Fence_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            value: u64,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Signal(::core::mem::transmute_copy(&value)).into()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetCompletedValue: GetCompletedValue::<Identity, Impl, OFFSET>,
            SetEventOnCompletion: SetEventOnCompletion::<Identity, Impl, OFFSET>,
            Signal: Signal::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Fence as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Fence1_Impl: Sized + ID3D12Fence_Impl {
    fn GetCreationFlags(&self) -> D3D12_FENCE_FLAGS;
}
impl ::windows::core::RuntimeName for ID3D12Fence1 {}
impl ID3D12Fence1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Fence1_Impl,
        const OFFSET: isize,
    >() -> ID3D12Fence1_Vtbl {
        unsafe extern "system" fn GetCreationFlags<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Fence1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_FENCE_FLAGS {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCreationFlags()
        }
        Self {
            base__: ID3D12Fence_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetCreationFlags: GetCreationFlags::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Fence1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Fence as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12FunctionParameterReflection_Impl: Sized {
    fn GetDesc(&self, pdesc: *mut D3D12_PARAMETER_DESC) -> ::windows::core::Result<()>;
}
impl ID3D12FunctionParameterReflection_Vtbl {
    pub const fn new<Impl: ID3D12FunctionParameterReflection_Impl>(
    ) -> ID3D12FunctionParameterReflection_Vtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12FunctionParameterReflection_Impl>(
            this: *mut ::core::ffi::c_void,
            pdesc: *mut D3D12_PARAMETER_DESC,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetDesc(::core::mem::transmute_copy(&pdesc)).into()
        }
        Self {
            GetDesc: GetDesc::<Impl>,
        }
    }
}
#[doc(hidden)]
struct ID3D12FunctionParameterReflection_ImplVtbl<T: ID3D12FunctionParameterReflection_Impl>(
    ::std::marker::PhantomData<T>,
);
impl<T: ID3D12FunctionParameterReflection_Impl> ID3D12FunctionParameterReflection_ImplVtbl<T> {
    const VTABLE: ID3D12FunctionParameterReflection_Vtbl =
        ID3D12FunctionParameterReflection_Vtbl::new::<T>();
}
impl ID3D12FunctionParameterReflection {
    pub fn new<'a, T: ID3D12FunctionParameterReflection_Impl>(
        this: &'a T,
    ) -> ::windows::core::ScopedInterface<'a, Self> {
        let this = ::windows::core::ScopedHeap {
            vtable: &ID3D12FunctionParameterReflection_ImplVtbl::<T>::VTABLE as *const _
                as *const _,
            this: this as *const _ as *const _,
        };
        let this = ::std::mem::ManuallyDrop::new(::std::boxed::Box::new(this));
        unsafe { ::windows::core::ScopedInterface::new(::std::mem::transmute(&this.vtable)) }
    }
}
pub trait ID3D12FunctionReflection_Impl: Sized {
    fn GetDesc(&self, pdesc: *mut D3D12_FUNCTION_DESC) -> ::windows::core::Result<()>;
    fn GetConstantBufferByIndex(
        &self,
        bufferindex: u32,
    ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer>;
    fn GetConstantBufferByName(
        &self,
        name: &::windows::core::PCSTR,
    ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer>;
    fn GetResourceBindingDesc(
        &self,
        resourceindex: u32,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::Result<()>;
    fn GetVariableByName(
        &self,
        name: &::windows::core::PCSTR,
    ) -> ::core::option::Option<ID3D12ShaderReflectionVariable>;
    fn GetResourceBindingDescByName(
        &self,
        name: &::windows::core::PCSTR,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::Result<()>;
    fn GetFunctionParameter(
        &self,
        parameterindex: i32,
    ) -> ::core::option::Option<ID3D12FunctionParameterReflection>;
}
impl ID3D12FunctionReflection_Vtbl {
    pub const fn new<Impl: ID3D12FunctionReflection_Impl>() -> ID3D12FunctionReflection_Vtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12FunctionReflection_Impl>(
            this: *mut ::core::ffi::c_void,
            pdesc: *mut D3D12_FUNCTION_DESC,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetDesc(::core::mem::transmute_copy(&pdesc)).into()
        }
        unsafe extern "system" fn GetConstantBufferByIndex<Impl: ID3D12FunctionReflection_Impl>(
            this: *mut ::core::ffi::c_void,
            bufferindex: u32,
        ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetConstantBufferByIndex(::core::mem::transmute_copy(&bufferindex))
        }
        unsafe extern "system" fn GetConstantBufferByName<Impl: ID3D12FunctionReflection_Impl>(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCSTR,
        ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetConstantBufferByName(::core::mem::transmute(&name))
        }
        unsafe extern "system" fn GetResourceBindingDesc<Impl: ID3D12FunctionReflection_Impl>(
            this: *mut ::core::ffi::c_void,
            resourceindex: u32,
            pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetResourceBindingDesc(
                ::core::mem::transmute_copy(&resourceindex),
                ::core::mem::transmute_copy(&pdesc),
            )
            .into()
        }
        unsafe extern "system" fn GetVariableByName<Impl: ID3D12FunctionReflection_Impl>(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCSTR,
        ) -> ::core::option::Option<ID3D12ShaderReflectionVariable> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetVariableByName(::core::mem::transmute(&name))
        }
        unsafe extern "system" fn GetResourceBindingDescByName<
            Impl: ID3D12FunctionReflection_Impl,
        >(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCSTR,
            pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetResourceBindingDescByName(
                ::core::mem::transmute(&name),
                ::core::mem::transmute_copy(&pdesc),
            )
            .into()
        }
        unsafe extern "system" fn GetFunctionParameter<Impl: ID3D12FunctionReflection_Impl>(
            this: *mut ::core::ffi::c_void,
            parameterindex: i32,
        ) -> ::core::option::Option<ID3D12FunctionParameterReflection> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetFunctionParameter(::core::mem::transmute_copy(&parameterindex))
        }
        Self {
            GetDesc: GetDesc::<Impl>,
            GetConstantBufferByIndex: GetConstantBufferByIndex::<Impl>,
            GetConstantBufferByName: GetConstantBufferByName::<Impl>,
            GetResourceBindingDesc: GetResourceBindingDesc::<Impl>,
            GetVariableByName: GetVariableByName::<Impl>,
            GetResourceBindingDescByName: GetResourceBindingDescByName::<Impl>,
            GetFunctionParameter: GetFunctionParameter::<Impl>,
        }
    }
}
#[doc(hidden)]
struct ID3D12FunctionReflection_ImplVtbl<T: ID3D12FunctionReflection_Impl>(
    ::std::marker::PhantomData<T>,
);
impl<T: ID3D12FunctionReflection_Impl> ID3D12FunctionReflection_ImplVtbl<T> {
    const VTABLE: ID3D12FunctionReflection_Vtbl = ID3D12FunctionReflection_Vtbl::new::<T>();
}
impl ID3D12FunctionReflection {
    pub fn new<'a, T: ID3D12FunctionReflection_Impl>(
        this: &'a T,
    ) -> ::windows::core::ScopedInterface<'a, Self> {
        let this = ::windows::core::ScopedHeap {
            vtable: &ID3D12FunctionReflection_ImplVtbl::<T>::VTABLE as *const _ as *const _,
            this: this as *const _ as *const _,
        };
        let this = ::std::mem::ManuallyDrop::new(::std::boxed::Box::new(this));
        unsafe { ::windows::core::ScopedInterface::new(::std::mem::transmute(&this.vtable)) }
    }
}
pub trait ID3D12GraphicsCommandList_Impl: Sized + ID3D12CommandList_Impl {
    fn Close(&self) -> ::windows::core::Result<()>;
    fn Reset(
        &self,
        pallocator: ::core::option::Option<&ID3D12CommandAllocator>,
        pinitialstate: ::core::option::Option<&ID3D12PipelineState>,
    ) -> ::windows::core::Result<()>;
    fn ClearState(&self, ppipelinestate: ::core::option::Option<&ID3D12PipelineState>);
    fn DrawInstanced(
        &self,
        vertexcountperinstance: u32,
        instancecount: u32,
        startvertexlocation: u32,
        startinstancelocation: u32,
    );
    fn DrawIndexedInstanced(
        &self,
        indexcountperinstance: u32,
        instancecount: u32,
        startindexlocation: u32,
        basevertexlocation: i32,
        startinstancelocation: u32,
    );
    fn Dispatch(&self, threadgroupcountx: u32, threadgroupcounty: u32, threadgroupcountz: u32);
    fn CopyBufferRegion(
        &self,
        pdstbuffer: ::core::option::Option<&ID3D12Resource>,
        dstoffset: u64,
        psrcbuffer: ::core::option::Option<&ID3D12Resource>,
        srcoffset: u64,
        numbytes: u64,
    );
    fn CopyTextureRegion(
        &self,
        pdst: *const D3D12_TEXTURE_COPY_LOCATION,
        dstx: u32,
        dsty: u32,
        dstz: u32,
        psrc: *const D3D12_TEXTURE_COPY_LOCATION,
        psrcbox: *const D3D12_BOX,
    );
    fn CopyResource(
        &self,
        pdstresource: ::core::option::Option<&ID3D12Resource>,
        psrcresource: ::core::option::Option<&ID3D12Resource>,
    );
    fn CopyTiles(
        &self,
        ptiledresource: ::core::option::Option<&ID3D12Resource>,
        ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
        ptileregionsize: *const D3D12_TILE_REGION_SIZE,
        pbuffer: ::core::option::Option<&ID3D12Resource>,
        bufferstartoffsetinbytes: u64,
        flags: D3D12_TILE_COPY_FLAGS,
    );
    fn ResolveSubresource(
        &self,
        pdstresource: ::core::option::Option<&ID3D12Resource>,
        dstsubresource: u32,
        psrcresource: ::core::option::Option<&ID3D12Resource>,
        srcsubresource: u32,
        format: DXGI_FORMAT,
    );
    fn IASetPrimitiveTopology(&self, primitivetopology: D3D_PRIMITIVE_TOPOLOGY);
    fn RSSetViewports(&self, numviewports: u32, pviewports: *const D3D12_VIEWPORT);
    fn RSSetScissorRects(&self, numrects: u32, prects: *const ::windows::Win32::Foundation::RECT);
    fn OMSetBlendFactor(&self, blendfactor: *const f32);
    fn OMSetStencilRef(&self, stencilref: u32);
    fn SetPipelineState(&self, ppipelinestate: ::core::option::Option<&ID3D12PipelineState>);
    fn ResourceBarrier(&self, numbarriers: u32, pbarriers: *const D3D12_RESOURCE_BARRIER);
    fn ExecuteBundle(&self, pcommandlist: ::core::option::Option<&ID3D12GraphicsCommandList>);
    fn SetDescriptorHeaps(
        &self,
        numdescriptorheaps: u32,
        ppdescriptorheaps: *const ::core::option::Option<ID3D12DescriptorHeap>,
    );
    fn SetComputeRootSignature(&self, prootsignature: ::core::option::Option<&ID3D12RootSignature>);
    fn SetGraphicsRootSignature(
        &self,
        prootsignature: ::core::option::Option<&ID3D12RootSignature>,
    );
    fn SetComputeRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: &D3D12_GPU_DESCRIPTOR_HANDLE,
    );
    fn SetGraphicsRootDescriptorTable(
        &self,
        rootparameterindex: u32,
        basedescriptor: &D3D12_GPU_DESCRIPTOR_HANDLE,
    );
    fn SetComputeRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    );
    fn SetGraphicsRoot32BitConstant(
        &self,
        rootparameterindex: u32,
        srcdata: u32,
        destoffsetin32bitvalues: u32,
    );
    fn SetComputeRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    );
    fn SetGraphicsRoot32BitConstants(
        &self,
        rootparameterindex: u32,
        num32bitvaluestoset: u32,
        psrcdata: *const ::core::ffi::c_void,
        destoffsetin32bitvalues: u32,
    );
    fn SetComputeRootConstantBufferView(&self, rootparameterindex: u32, bufferlocation: u64);
    fn SetGraphicsRootConstantBufferView(&self, rootparameterindex: u32, bufferlocation: u64);
    fn SetComputeRootShaderResourceView(&self, rootparameterindex: u32, bufferlocation: u64);
    fn SetGraphicsRootShaderResourceView(&self, rootparameterindex: u32, bufferlocation: u64);
    fn SetComputeRootUnorderedAccessView(&self, rootparameterindex: u32, bufferlocation: u64);
    fn SetGraphicsRootUnorderedAccessView(&self, rootparameterindex: u32, bufferlocation: u64);
    fn IASetIndexBuffer(&self, pview: *const D3D12_INDEX_BUFFER_VIEW);
    fn IASetVertexBuffers(
        &self,
        startslot: u32,
        numviews: u32,
        pviews: *const D3D12_VERTEX_BUFFER_VIEW,
    );
    fn SOSetTargets(
        &self,
        startslot: u32,
        numviews: u32,
        pviews: *const D3D12_STREAM_OUTPUT_BUFFER_VIEW,
    );
    fn OMSetRenderTargets(
        &self,
        numrendertargetdescriptors: u32,
        prendertargetdescriptors: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        rtssinglehandletodescriptorrange: ::windows::Win32::Foundation::BOOL,
        pdepthstencildescriptor: *const D3D12_CPU_DESCRIPTOR_HANDLE,
    );
    fn ClearDepthStencilView(
        &self,
        depthstencilview: &D3D12_CPU_DESCRIPTOR_HANDLE,
        clearflags: D3D12_CLEAR_FLAGS,
        depth: f32,
        stencil: u8,
        numrects: u32,
        prects: *const ::windows::Win32::Foundation::RECT,
    );
    fn ClearRenderTargetView(
        &self,
        rendertargetview: &D3D12_CPU_DESCRIPTOR_HANDLE,
        colorrgba: *const f32,
        numrects: u32,
        prects: *const ::windows::Win32::Foundation::RECT,
    );
    fn ClearUnorderedAccessViewUint(
        &self,
        viewgpuhandleincurrentheap: &D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: &D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: ::core::option::Option<&ID3D12Resource>,
        values: *const u32,
        numrects: u32,
        prects: *const ::windows::Win32::Foundation::RECT,
    );
    fn ClearUnorderedAccessViewFloat(
        &self,
        viewgpuhandleincurrentheap: &D3D12_GPU_DESCRIPTOR_HANDLE,
        viewcpuhandle: &D3D12_CPU_DESCRIPTOR_HANDLE,
        presource: ::core::option::Option<&ID3D12Resource>,
        values: *const f32,
        numrects: u32,
        prects: *const ::windows::Win32::Foundation::RECT,
    );
    fn DiscardResource(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        pregion: *const D3D12_DISCARD_REGION,
    );
    fn BeginQuery(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    );
    fn EndQuery(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    );
    fn ResolveQueryData(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: ::core::option::Option<&ID3D12Resource>,
        aligneddestinationbufferoffset: u64,
    );
    fn SetPredication(
        &self,
        pbuffer: ::core::option::Option<&ID3D12Resource>,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    );
    fn SetMarker(&self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn BeginEvent(&self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn EndEvent(&self);
    fn ExecuteIndirect(
        &self,
        pcommandsignature: ::core::option::Option<&ID3D12CommandSignature>,
        maxcommandcount: u32,
        pargumentbuffer: ::core::option::Option<&ID3D12Resource>,
        argumentbufferoffset: u64,
        pcountbuffer: ::core::option::Option<&ID3D12Resource>,
        countbufferoffset: u64,
    );
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandList {}
impl ID3D12GraphicsCommandList_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandList_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandList_Vtbl {
        unsafe extern "system" fn Close<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Close().into()
        }
        unsafe extern "system" fn Reset<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pallocator: *mut ::core::ffi::c_void,
            pinitialstate: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset(
                ::windows::core::from_raw_borrowed(&pallocator),
                ::windows::core::from_raw_borrowed(&pinitialstate),
            )
            .into()
        }
        unsafe extern "system" fn ClearState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            ppipelinestate: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearState(::windows::core::from_raw_borrowed(&ppipelinestate))
        }
        unsafe extern "system" fn DrawInstanced<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            vertexcountperinstance: u32,
            instancecount: u32,
            startvertexlocation: u32,
            startinstancelocation: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DrawInstanced(
                ::core::mem::transmute_copy(&vertexcountperinstance),
                ::core::mem::transmute_copy(&instancecount),
                ::core::mem::transmute_copy(&startvertexlocation),
                ::core::mem::transmute_copy(&startinstancelocation),
            )
        }
        unsafe extern "system" fn DrawIndexedInstanced<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            indexcountperinstance: u32,
            instancecount: u32,
            startindexlocation: u32,
            basevertexlocation: i32,
            startinstancelocation: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DrawIndexedInstanced(
                ::core::mem::transmute_copy(&indexcountperinstance),
                ::core::mem::transmute_copy(&instancecount),
                ::core::mem::transmute_copy(&startindexlocation),
                ::core::mem::transmute_copy(&basevertexlocation),
                ::core::mem::transmute_copy(&startinstancelocation),
            )
        }
        unsafe extern "system" fn Dispatch<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            threadgroupcountx: u32,
            threadgroupcounty: u32,
            threadgroupcountz: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Dispatch(
                ::core::mem::transmute_copy(&threadgroupcountx),
                ::core::mem::transmute_copy(&threadgroupcounty),
                ::core::mem::transmute_copy(&threadgroupcountz),
            )
        }
        unsafe extern "system" fn CopyBufferRegion<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdstbuffer: *mut ::core::ffi::c_void,
            dstoffset: u64,
            psrcbuffer: *mut ::core::ffi::c_void,
            srcoffset: u64,
            numbytes: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CopyBufferRegion(
                ::windows::core::from_raw_borrowed(&pdstbuffer),
                ::core::mem::transmute_copy(&dstoffset),
                ::windows::core::from_raw_borrowed(&psrcbuffer),
                ::core::mem::transmute_copy(&srcoffset),
                ::core::mem::transmute_copy(&numbytes),
            )
        }
        unsafe extern "system" fn CopyTextureRegion<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdst: *const D3D12_TEXTURE_COPY_LOCATION,
            dstx: u32,
            dsty: u32,
            dstz: u32,
            psrc: *const D3D12_TEXTURE_COPY_LOCATION,
            psrcbox: *const D3D12_BOX,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CopyTextureRegion(
                ::core::mem::transmute_copy(&pdst),
                ::core::mem::transmute_copy(&dstx),
                ::core::mem::transmute_copy(&dsty),
                ::core::mem::transmute_copy(&dstz),
                ::core::mem::transmute_copy(&psrc),
                ::core::mem::transmute_copy(&psrcbox),
            )
        }
        unsafe extern "system" fn CopyResource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdstresource: *mut ::core::ffi::c_void,
            psrcresource: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CopyResource(
                ::windows::core::from_raw_borrowed(&pdstresource),
                ::windows::core::from_raw_borrowed(&psrcresource),
            )
        }
        unsafe extern "system" fn CopyTiles<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            ptiledresource: *mut ::core::ffi::c_void,
            ptileregionstartcoordinate: *const D3D12_TILED_RESOURCE_COORDINATE,
            ptileregionsize: *const D3D12_TILE_REGION_SIZE,
            pbuffer: *mut ::core::ffi::c_void,
            bufferstartoffsetinbytes: u64,
            flags: D3D12_TILE_COPY_FLAGS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CopyTiles(
                ::windows::core::from_raw_borrowed(&ptiledresource),
                ::core::mem::transmute_copy(&ptileregionstartcoordinate),
                ::core::mem::transmute_copy(&ptileregionsize),
                ::windows::core::from_raw_borrowed(&pbuffer),
                ::core::mem::transmute_copy(&bufferstartoffsetinbytes),
                ::core::mem::transmute_copy(&flags),
            )
        }
        unsafe extern "system" fn ResolveSubresource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdstresource: *mut ::core::ffi::c_void,
            dstsubresource: u32,
            psrcresource: *mut ::core::ffi::c_void,
            srcsubresource: u32,
            format: DXGI_FORMAT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResolveSubresource(
                ::windows::core::from_raw_borrowed(&pdstresource),
                ::core::mem::transmute_copy(&dstsubresource),
                ::windows::core::from_raw_borrowed(&psrcresource),
                ::core::mem::transmute_copy(&srcsubresource),
                ::core::mem::transmute_copy(&format),
            )
        }
        unsafe extern "system" fn IASetPrimitiveTopology<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            primitivetopology: D3D_PRIMITIVE_TOPOLOGY,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.IASetPrimitiveTopology(::core::mem::transmute_copy(&primitivetopology))
        }
        unsafe extern "system" fn RSSetViewports<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numviewports: u32,
            pviewports: *const D3D12_VIEWPORT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RSSetViewports(
                ::core::mem::transmute_copy(&numviewports),
                ::core::mem::transmute_copy(&pviewports),
            )
        }
        unsafe extern "system" fn RSSetScissorRects<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numrects: u32,
            prects: *const ::windows::Win32::Foundation::RECT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RSSetScissorRects(
                ::core::mem::transmute_copy(&numrects),
                ::core::mem::transmute_copy(&prects),
            )
        }
        unsafe extern "system" fn OMSetBlendFactor<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            blendfactor: *const f32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.OMSetBlendFactor(::core::mem::transmute_copy(&blendfactor))
        }
        unsafe extern "system" fn OMSetStencilRef<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            stencilref: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.OMSetStencilRef(::core::mem::transmute_copy(&stencilref))
        }
        unsafe extern "system" fn SetPipelineState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            ppipelinestate: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetPipelineState(::windows::core::from_raw_borrowed(&ppipelinestate))
        }
        unsafe extern "system" fn ResourceBarrier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numbarriers: u32,
            pbarriers: *const D3D12_RESOURCE_BARRIER,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResourceBarrier(
                ::core::mem::transmute_copy(&numbarriers),
                ::core::mem::transmute_copy(&pbarriers),
            )
        }
        unsafe extern "system" fn ExecuteBundle<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pcommandlist: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ExecuteBundle(::windows::core::from_raw_borrowed(&pcommandlist))
        }
        unsafe extern "system" fn SetDescriptorHeaps<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numdescriptorheaps: u32,
            ppdescriptorheaps: *const *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetDescriptorHeaps(
                ::core::mem::transmute_copy(&numdescriptorheaps),
                ::core::mem::transmute_copy(&ppdescriptorheaps),
            )
        }
        unsafe extern "system" fn SetComputeRootSignature<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            prootsignature: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetComputeRootSignature(::windows::core::from_raw_borrowed(&prootsignature))
        }
        unsafe extern "system" fn SetGraphicsRootSignature<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            prootsignature: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetGraphicsRootSignature(::windows::core::from_raw_borrowed(&prootsignature))
        }
        unsafe extern "system" fn SetComputeRootDescriptorTable<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetComputeRootDescriptorTable(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute(&basedescriptor),
            )
        }
        unsafe extern "system" fn SetGraphicsRootDescriptorTable<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            basedescriptor: D3D12_GPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetGraphicsRootDescriptorTable(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute(&basedescriptor),
            )
        }
        unsafe extern "system" fn SetComputeRoot32BitConstant<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            srcdata: u32,
            destoffsetin32bitvalues: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetComputeRoot32BitConstant(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute_copy(&srcdata),
                ::core::mem::transmute_copy(&destoffsetin32bitvalues),
            )
        }
        unsafe extern "system" fn SetGraphicsRoot32BitConstant<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            srcdata: u32,
            destoffsetin32bitvalues: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetGraphicsRoot32BitConstant(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute_copy(&srcdata),
                ::core::mem::transmute_copy(&destoffsetin32bitvalues),
            )
        }
        unsafe extern "system" fn SetComputeRoot32BitConstants<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            num32bitvaluestoset: u32,
            psrcdata: *const ::core::ffi::c_void,
            destoffsetin32bitvalues: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetComputeRoot32BitConstants(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute_copy(&num32bitvaluestoset),
                ::core::mem::transmute_copy(&psrcdata),
                ::core::mem::transmute_copy(&destoffsetin32bitvalues),
            )
        }
        unsafe extern "system" fn SetGraphicsRoot32BitConstants<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            num32bitvaluestoset: u32,
            psrcdata: *const ::core::ffi::c_void,
            destoffsetin32bitvalues: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetGraphicsRoot32BitConstants(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute_copy(&num32bitvaluestoset),
                ::core::mem::transmute_copy(&psrcdata),
                ::core::mem::transmute_copy(&destoffsetin32bitvalues),
            )
        }
        unsafe extern "system" fn SetComputeRootConstantBufferView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            bufferlocation: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetComputeRootConstantBufferView(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute_copy(&bufferlocation),
            )
        }
        unsafe extern "system" fn SetGraphicsRootConstantBufferView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            bufferlocation: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetGraphicsRootConstantBufferView(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute_copy(&bufferlocation),
            )
        }
        unsafe extern "system" fn SetComputeRootShaderResourceView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            bufferlocation: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetComputeRootShaderResourceView(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute_copy(&bufferlocation),
            )
        }
        unsafe extern "system" fn SetGraphicsRootShaderResourceView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            bufferlocation: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetGraphicsRootShaderResourceView(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute_copy(&bufferlocation),
            )
        }
        unsafe extern "system" fn SetComputeRootUnorderedAccessView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            bufferlocation: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetComputeRootUnorderedAccessView(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute_copy(&bufferlocation),
            )
        }
        unsafe extern "system" fn SetGraphicsRootUnorderedAccessView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rootparameterindex: u32,
            bufferlocation: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetGraphicsRootUnorderedAccessView(
                ::core::mem::transmute_copy(&rootparameterindex),
                ::core::mem::transmute_copy(&bufferlocation),
            )
        }
        unsafe extern "system" fn IASetIndexBuffer<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pview: *const D3D12_INDEX_BUFFER_VIEW,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.IASetIndexBuffer(::core::mem::transmute_copy(&pview))
        }
        unsafe extern "system" fn IASetVertexBuffers<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            startslot: u32,
            numviews: u32,
            pviews: *const D3D12_VERTEX_BUFFER_VIEW,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.IASetVertexBuffers(
                ::core::mem::transmute_copy(&startslot),
                ::core::mem::transmute_copy(&numviews),
                ::core::mem::transmute_copy(&pviews),
            )
        }
        unsafe extern "system" fn SOSetTargets<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            startslot: u32,
            numviews: u32,
            pviews: *const D3D12_STREAM_OUTPUT_BUFFER_VIEW,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SOSetTargets(
                ::core::mem::transmute_copy(&startslot),
                ::core::mem::transmute_copy(&numviews),
                ::core::mem::transmute_copy(&pviews),
            )
        }
        unsafe extern "system" fn OMSetRenderTargets<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numrendertargetdescriptors: u32,
            prendertargetdescriptors: *const D3D12_CPU_DESCRIPTOR_HANDLE,
            rtssinglehandletodescriptorrange: ::windows::Win32::Foundation::BOOL,
            pdepthstencildescriptor: *const D3D12_CPU_DESCRIPTOR_HANDLE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.OMSetRenderTargets(
                ::core::mem::transmute_copy(&numrendertargetdescriptors),
                ::core::mem::transmute_copy(&prendertargetdescriptors),
                ::core::mem::transmute_copy(&rtssinglehandletodescriptorrange),
                ::core::mem::transmute_copy(&pdepthstencildescriptor),
            )
        }
        unsafe extern "system" fn ClearDepthStencilView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            depthstencilview: D3D12_CPU_DESCRIPTOR_HANDLE,
            clearflags: D3D12_CLEAR_FLAGS,
            depth: f32,
            stencil: u8,
            numrects: u32,
            prects: *const ::windows::Win32::Foundation::RECT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearDepthStencilView(
                ::core::mem::transmute(&depthstencilview),
                ::core::mem::transmute_copy(&clearflags),
                ::core::mem::transmute_copy(&depth),
                ::core::mem::transmute_copy(&stencil),
                ::core::mem::transmute_copy(&numrects),
                ::core::mem::transmute_copy(&prects),
            )
        }
        unsafe extern "system" fn ClearRenderTargetView<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            rendertargetview: D3D12_CPU_DESCRIPTOR_HANDLE,
            colorrgba: *const f32,
            numrects: u32,
            prects: *const ::windows::Win32::Foundation::RECT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearRenderTargetView(
                ::core::mem::transmute(&rendertargetview),
                ::core::mem::transmute_copy(&colorrgba),
                ::core::mem::transmute_copy(&numrects),
                ::core::mem::transmute_copy(&prects),
            )
        }
        unsafe extern "system" fn ClearUnorderedAccessViewUint<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
            viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
            presource: *mut ::core::ffi::c_void,
            values: *const u32,
            numrects: u32,
            prects: *const ::windows::Win32::Foundation::RECT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearUnorderedAccessViewUint(
                ::core::mem::transmute(&viewgpuhandleincurrentheap),
                ::core::mem::transmute(&viewcpuhandle),
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&values),
                ::core::mem::transmute_copy(&numrects),
                ::core::mem::transmute_copy(&prects),
            )
        }
        unsafe extern "system" fn ClearUnorderedAccessViewFloat<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            viewgpuhandleincurrentheap: D3D12_GPU_DESCRIPTOR_HANDLE,
            viewcpuhandle: D3D12_CPU_DESCRIPTOR_HANDLE,
            presource: *mut ::core::ffi::c_void,
            values: *const f32,
            numrects: u32,
            prects: *const ::windows::Win32::Foundation::RECT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearUnorderedAccessViewFloat(
                ::core::mem::transmute(&viewgpuhandleincurrentheap),
                ::core::mem::transmute(&viewcpuhandle),
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&values),
                ::core::mem::transmute_copy(&numrects),
                ::core::mem::transmute_copy(&prects),
            )
        }
        unsafe extern "system" fn DiscardResource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            pregion: *const D3D12_DISCARD_REGION,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DiscardResource(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&pregion),
            )
        }
        unsafe extern "system" fn BeginQuery<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            index: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginQuery(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&index),
            )
        }
        unsafe extern "system" fn EndQuery<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            index: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndQuery(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&index),
            )
        }
        unsafe extern "system" fn ResolveQueryData<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            startindex: u32,
            numqueries: u32,
            pdestinationbuffer: *mut ::core::ffi::c_void,
            aligneddestinationbufferoffset: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResolveQueryData(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&startindex),
                ::core::mem::transmute_copy(&numqueries),
                ::windows::core::from_raw_borrowed(&pdestinationbuffer),
                ::core::mem::transmute_copy(&aligneddestinationbufferoffset),
            )
        }
        unsafe extern "system" fn SetPredication<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pbuffer: *mut ::core::ffi::c_void,
            alignedbufferoffset: u64,
            operation: D3D12_PREDICATION_OP,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetPredication(
                ::windows::core::from_raw_borrowed(&pbuffer),
                ::core::mem::transmute_copy(&alignedbufferoffset),
                ::core::mem::transmute_copy(&operation),
            )
        }
        unsafe extern "system" fn SetMarker<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            metadata: u32,
            pdata: *const ::core::ffi::c_void,
            size: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetMarker(
                ::core::mem::transmute_copy(&metadata),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&size),
            )
        }
        unsafe extern "system" fn BeginEvent<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            metadata: u32,
            pdata: *const ::core::ffi::c_void,
            size: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginEvent(
                ::core::mem::transmute_copy(&metadata),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&size),
            )
        }
        unsafe extern "system" fn EndEvent<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndEvent()
        }
        unsafe extern "system" fn ExecuteIndirect<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pcommandsignature: *mut ::core::ffi::c_void,
            maxcommandcount: u32,
            pargumentbuffer: *mut ::core::ffi::c_void,
            argumentbufferoffset: u64,
            pcountbuffer: *mut ::core::ffi::c_void,
            countbufferoffset: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ExecuteIndirect(
                ::windows::core::from_raw_borrowed(&pcommandsignature),
                ::core::mem::transmute_copy(&maxcommandcount),
                ::windows::core::from_raw_borrowed(&pargumentbuffer),
                ::core::mem::transmute_copy(&argumentbufferoffset),
                ::windows::core::from_raw_borrowed(&pcountbuffer),
                ::core::mem::transmute_copy(&countbufferoffset),
            )
        }
        Self {
            base__: ID3D12CommandList_Vtbl::new::<Identity, Impl, OFFSET>(),
            Close: Close::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            ClearState: ClearState::<Identity, Impl, OFFSET>,
            DrawInstanced: DrawInstanced::<Identity, Impl, OFFSET>,
            DrawIndexedInstanced: DrawIndexedInstanced::<Identity, Impl, OFFSET>,
            Dispatch: Dispatch::<Identity, Impl, OFFSET>,
            CopyBufferRegion: CopyBufferRegion::<Identity, Impl, OFFSET>,
            CopyTextureRegion: CopyTextureRegion::<Identity, Impl, OFFSET>,
            CopyResource: CopyResource::<Identity, Impl, OFFSET>,
            CopyTiles: CopyTiles::<Identity, Impl, OFFSET>,
            ResolveSubresource: ResolveSubresource::<Identity, Impl, OFFSET>,
            IASetPrimitiveTopology: IASetPrimitiveTopology::<Identity, Impl, OFFSET>,
            RSSetViewports: RSSetViewports::<Identity, Impl, OFFSET>,
            RSSetScissorRects: RSSetScissorRects::<Identity, Impl, OFFSET>,
            OMSetBlendFactor: OMSetBlendFactor::<Identity, Impl, OFFSET>,
            OMSetStencilRef: OMSetStencilRef::<Identity, Impl, OFFSET>,
            SetPipelineState: SetPipelineState::<Identity, Impl, OFFSET>,
            ResourceBarrier: ResourceBarrier::<Identity, Impl, OFFSET>,
            ExecuteBundle: ExecuteBundle::<Identity, Impl, OFFSET>,
            SetDescriptorHeaps: SetDescriptorHeaps::<Identity, Impl, OFFSET>,
            SetComputeRootSignature: SetComputeRootSignature::<Identity, Impl, OFFSET>,
            SetGraphicsRootSignature: SetGraphicsRootSignature::<Identity, Impl, OFFSET>,
            SetComputeRootDescriptorTable: SetComputeRootDescriptorTable::<Identity, Impl, OFFSET>,
            SetGraphicsRootDescriptorTable: SetGraphicsRootDescriptorTable::<Identity, Impl, OFFSET>,
            SetComputeRoot32BitConstant: SetComputeRoot32BitConstant::<Identity, Impl, OFFSET>,
            SetGraphicsRoot32BitConstant: SetGraphicsRoot32BitConstant::<Identity, Impl, OFFSET>,
            SetComputeRoot32BitConstants: SetComputeRoot32BitConstants::<Identity, Impl, OFFSET>,
            SetGraphicsRoot32BitConstants: SetGraphicsRoot32BitConstants::<Identity, Impl, OFFSET>,
            SetComputeRootConstantBufferView: SetComputeRootConstantBufferView::<
                Identity,
                Impl,
                OFFSET,
            >,
            SetGraphicsRootConstantBufferView: SetGraphicsRootConstantBufferView::<
                Identity,
                Impl,
                OFFSET,
            >,
            SetComputeRootShaderResourceView: SetComputeRootShaderResourceView::<
                Identity,
                Impl,
                OFFSET,
            >,
            SetGraphicsRootShaderResourceView: SetGraphicsRootShaderResourceView::<
                Identity,
                Impl,
                OFFSET,
            >,
            SetComputeRootUnorderedAccessView: SetComputeRootUnorderedAccessView::<
                Identity,
                Impl,
                OFFSET,
            >,
            SetGraphicsRootUnorderedAccessView: SetGraphicsRootUnorderedAccessView::<
                Identity,
                Impl,
                OFFSET,
            >,
            IASetIndexBuffer: IASetIndexBuffer::<Identity, Impl, OFFSET>,
            IASetVertexBuffers: IASetVertexBuffers::<Identity, Impl, OFFSET>,
            SOSetTargets: SOSetTargets::<Identity, Impl, OFFSET>,
            OMSetRenderTargets: OMSetRenderTargets::<Identity, Impl, OFFSET>,
            ClearDepthStencilView: ClearDepthStencilView::<Identity, Impl, OFFSET>,
            ClearRenderTargetView: ClearRenderTargetView::<Identity, Impl, OFFSET>,
            ClearUnorderedAccessViewUint: ClearUnorderedAccessViewUint::<Identity, Impl, OFFSET>,
            ClearUnorderedAccessViewFloat: ClearUnorderedAccessViewFloat::<Identity, Impl, OFFSET>,
            DiscardResource: DiscardResource::<Identity, Impl, OFFSET>,
            BeginQuery: BeginQuery::<Identity, Impl, OFFSET>,
            EndQuery: EndQuery::<Identity, Impl, OFFSET>,
            ResolveQueryData: ResolveQueryData::<Identity, Impl, OFFSET>,
            SetPredication: SetPredication::<Identity, Impl, OFFSET>,
            SetMarker: SetMarker::<Identity, Impl, OFFSET>,
            BeginEvent: BeginEvent::<Identity, Impl, OFFSET>,
            EndEvent: EndEvent::<Identity, Impl, OFFSET>,
            ExecuteIndirect: ExecuteIndirect::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12GraphicsCommandList1_Impl: Sized + ID3D12GraphicsCommandList_Impl {
    fn AtomicCopyBufferUINT(
        &self,
        pdstbuffer: ::core::option::Option<&ID3D12Resource>,
        dstoffset: u64,
        psrcbuffer: ::core::option::Option<&ID3D12Resource>,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    );
    fn AtomicCopyBufferUINT64(
        &self,
        pdstbuffer: ::core::option::Option<&ID3D12Resource>,
        dstoffset: u64,
        psrcbuffer: ::core::option::Option<&ID3D12Resource>,
        srcoffset: u64,
        dependencies: u32,
        ppdependentresources: *const ::core::option::Option<ID3D12Resource>,
        pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
    );
    fn OMSetDepthBounds(&self, min: f32, max: f32);
    fn SetSamplePositions(
        &self,
        numsamplesperpixel: u32,
        numpixels: u32,
        psamplepositions: *const D3D12_SAMPLE_POSITION,
    );
    fn ResolveSubresourceRegion(
        &self,
        pdstresource: ::core::option::Option<&ID3D12Resource>,
        dstsubresource: u32,
        dstx: u32,
        dsty: u32,
        psrcresource: ::core::option::Option<&ID3D12Resource>,
        srcsubresource: u32,
        psrcrect: *const ::windows::Win32::Foundation::RECT,
        format: DXGI_FORMAT,
        resolvemode: D3D12_RESOLVE_MODE,
    );
    fn SetViewInstanceMask(&self, mask: u32);
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandList1 {}
impl ID3D12GraphicsCommandList1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandList1_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandList1_Vtbl {
        unsafe extern "system" fn AtomicCopyBufferUINT<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdstbuffer: *mut ::core::ffi::c_void,
            dstoffset: u64,
            psrcbuffer: *mut ::core::ffi::c_void,
            srcoffset: u64,
            dependencies: u32,
            ppdependentresources: *const *mut ::core::ffi::c_void,
            pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AtomicCopyBufferUINT(
                ::windows::core::from_raw_borrowed(&pdstbuffer),
                ::core::mem::transmute_copy(&dstoffset),
                ::windows::core::from_raw_borrowed(&psrcbuffer),
                ::core::mem::transmute_copy(&srcoffset),
                ::core::mem::transmute_copy(&dependencies),
                ::core::mem::transmute_copy(&ppdependentresources),
                ::core::mem::transmute_copy(&pdependentsubresourceranges),
            )
        }
        unsafe extern "system" fn AtomicCopyBufferUINT64<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdstbuffer: *mut ::core::ffi::c_void,
            dstoffset: u64,
            psrcbuffer: *mut ::core::ffi::c_void,
            srcoffset: u64,
            dependencies: u32,
            ppdependentresources: *const *mut ::core::ffi::c_void,
            pdependentsubresourceranges: *const D3D12_SUBRESOURCE_RANGE_UINT64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AtomicCopyBufferUINT64(
                ::windows::core::from_raw_borrowed(&pdstbuffer),
                ::core::mem::transmute_copy(&dstoffset),
                ::windows::core::from_raw_borrowed(&psrcbuffer),
                ::core::mem::transmute_copy(&srcoffset),
                ::core::mem::transmute_copy(&dependencies),
                ::core::mem::transmute_copy(&ppdependentresources),
                ::core::mem::transmute_copy(&pdependentsubresourceranges),
            )
        }
        unsafe extern "system" fn OMSetDepthBounds<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            min: f32,
            max: f32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.OMSetDepthBounds(
                ::core::mem::transmute_copy(&min),
                ::core::mem::transmute_copy(&max),
            )
        }
        unsafe extern "system" fn SetSamplePositions<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numsamplesperpixel: u32,
            numpixels: u32,
            psamplepositions: *const D3D12_SAMPLE_POSITION,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetSamplePositions(
                ::core::mem::transmute_copy(&numsamplesperpixel),
                ::core::mem::transmute_copy(&numpixels),
                ::core::mem::transmute_copy(&psamplepositions),
            )
        }
        unsafe extern "system" fn ResolveSubresourceRegion<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdstresource: *mut ::core::ffi::c_void,
            dstsubresource: u32,
            dstx: u32,
            dsty: u32,
            psrcresource: *mut ::core::ffi::c_void,
            srcsubresource: u32,
            psrcrect: *const ::windows::Win32::Foundation::RECT,
            format: DXGI_FORMAT,
            resolvemode: D3D12_RESOLVE_MODE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResolveSubresourceRegion(
                ::windows::core::from_raw_borrowed(&pdstresource),
                ::core::mem::transmute_copy(&dstsubresource),
                ::core::mem::transmute_copy(&dstx),
                ::core::mem::transmute_copy(&dsty),
                ::windows::core::from_raw_borrowed(&psrcresource),
                ::core::mem::transmute_copy(&srcsubresource),
                ::core::mem::transmute_copy(&psrcrect),
                ::core::mem::transmute_copy(&format),
                ::core::mem::transmute_copy(&resolvemode),
            )
        }
        unsafe extern "system" fn SetViewInstanceMask<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            mask: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetViewInstanceMask(::core::mem::transmute_copy(&mask))
        }
        Self {
            base__: ID3D12GraphicsCommandList_Vtbl::new::<Identity, Impl, OFFSET>(),
            AtomicCopyBufferUINT: AtomicCopyBufferUINT::<Identity, Impl, OFFSET>,
            AtomicCopyBufferUINT64: AtomicCopyBufferUINT64::<Identity, Impl, OFFSET>,
            OMSetDepthBounds: OMSetDepthBounds::<Identity, Impl, OFFSET>,
            SetSamplePositions: SetSamplePositions::<Identity, Impl, OFFSET>,
            ResolveSubresourceRegion: ResolveSubresourceRegion::<Identity, Impl, OFFSET>,
            SetViewInstanceMask: SetViewInstanceMask::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12GraphicsCommandList2_Impl: Sized + ID3D12GraphicsCommandList1_Impl {
    fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
    );
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandList2 {}
impl ID3D12GraphicsCommandList2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandList2_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandList2_Vtbl {
        unsafe extern "system" fn WriteBufferImmediate<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            count: u32,
            pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
            pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.WriteBufferImmediate(
                ::core::mem::transmute_copy(&count),
                ::core::mem::transmute_copy(&pparams),
                ::core::mem::transmute_copy(&pmodes),
            )
        }
        Self {
            base__: ID3D12GraphicsCommandList1_Vtbl::new::<Identity, Impl, OFFSET>(),
            WriteBufferImmediate: WriteBufferImmediate::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12GraphicsCommandList3_Impl: Sized + ID3D12GraphicsCommandList2_Impl {
    fn SetProtectedResourceSession(
        &self,
        pprotectedresourcesession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
    );
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandList3 {}
impl ID3D12GraphicsCommandList3_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandList3_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandList3_Vtbl {
        unsafe extern "system" fn SetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pprotectedresourcesession: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetProtectedResourceSession(::windows::core::from_raw_borrowed(
                &pprotectedresourcesession,
            ))
        }
        Self {
            base__: ID3D12GraphicsCommandList2_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetProtectedResourceSession: SetProtectedResourceSession::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList2 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12GraphicsCommandList4_Impl: Sized + ID3D12GraphicsCommandList3_Impl {
    fn BeginRenderPass(
        &self,
        numrendertargets: u32,
        prendertargets: *const D3D12_RENDER_PASS_RENDER_TARGET_DESC,
        pdepthstencil: *const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC,
        flags: D3D12_RENDER_PASS_FLAGS,
    );
    fn EndRenderPass(&self);
    fn InitializeMetaCommand(
        &self,
        pmetacommand: ::core::option::Option<&ID3D12MetaCommand>,
        pinitializationparametersdata: *const ::core::ffi::c_void,
        initializationparametersdatasizeinbytes: usize,
    );
    fn ExecuteMetaCommand(
        &self,
        pmetacommand: ::core::option::Option<&ID3D12MetaCommand>,
        pexecutionparametersdata: *const ::core::ffi::c_void,
        executionparametersdatasizeinbytes: usize,
    );
    fn BuildRaytracingAccelerationStructure(
        &self,
        pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC,
        numpostbuildinfodescs: u32,
        ppostbuildinfodescs: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
    );
    fn EmitRaytracingAccelerationStructurePostbuildInfo(
        &self,
        pdesc: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
        numsourceaccelerationstructures: u32,
        psourceaccelerationstructuredata: *const u64,
    );
    fn CopyRaytracingAccelerationStructure(
        &self,
        destaccelerationstructuredata: u64,
        sourceaccelerationstructuredata: u64,
        mode: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE,
    );
    fn SetPipelineState1(&self, pstateobject: ::core::option::Option<&ID3D12StateObject>);
    fn DispatchRays(&self, pdesc: *const D3D12_DISPATCH_RAYS_DESC);
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandList4 {}
impl ID3D12GraphicsCommandList4_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandList4_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandList4_Vtbl {
        unsafe extern "system" fn BeginRenderPass<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numrendertargets: u32,
            prendertargets: *const D3D12_RENDER_PASS_RENDER_TARGET_DESC,
            pdepthstencil: *const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC,
            flags: D3D12_RENDER_PASS_FLAGS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginRenderPass(
                ::core::mem::transmute_copy(&numrendertargets),
                ::core::mem::transmute_copy(&prendertargets),
                ::core::mem::transmute_copy(&pdepthstencil),
                ::core::mem::transmute_copy(&flags),
            )
        }
        unsafe extern "system" fn EndRenderPass<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndRenderPass()
        }
        unsafe extern "system" fn InitializeMetaCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pmetacommand: *mut ::core::ffi::c_void,
            pinitializationparametersdata: *const ::core::ffi::c_void,
            initializationparametersdatasizeinbytes: usize,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.InitializeMetaCommand(
                ::windows::core::from_raw_borrowed(&pmetacommand),
                ::core::mem::transmute_copy(&pinitializationparametersdata),
                ::core::mem::transmute_copy(&initializationparametersdatasizeinbytes),
            )
        }
        unsafe extern "system" fn ExecuteMetaCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pmetacommand: *mut ::core::ffi::c_void,
            pexecutionparametersdata: *const ::core::ffi::c_void,
            executionparametersdatasizeinbytes: usize,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ExecuteMetaCommand(
                ::windows::core::from_raw_borrowed(&pmetacommand),
                ::core::mem::transmute_copy(&pexecutionparametersdata),
                ::core::mem::transmute_copy(&executionparametersdatasizeinbytes),
            )
        }
        unsafe extern "system" fn BuildRaytracingAccelerationStructure<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC,
            numpostbuildinfodescs: u32,
            ppostbuildinfodescs: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BuildRaytracingAccelerationStructure(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&numpostbuildinfodescs),
                ::core::mem::transmute_copy(&ppostbuildinfodescs),
            )
        }
        unsafe extern "system" fn EmitRaytracingAccelerationStructurePostbuildInfo<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC,
            numsourceaccelerationstructures: u32,
            psourceaccelerationstructuredata: *const u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EmitRaytracingAccelerationStructurePostbuildInfo(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&numsourceaccelerationstructures),
                ::core::mem::transmute_copy(&psourceaccelerationstructuredata),
            )
        }
        unsafe extern "system" fn CopyRaytracingAccelerationStructure<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            destaccelerationstructuredata: u64,
            sourceaccelerationstructuredata: u64,
            mode: D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CopyRaytracingAccelerationStructure(
                ::core::mem::transmute_copy(&destaccelerationstructuredata),
                ::core::mem::transmute_copy(&sourceaccelerationstructuredata),
                ::core::mem::transmute_copy(&mode),
            )
        }
        unsafe extern "system" fn SetPipelineState1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pstateobject: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetPipelineState1(::windows::core::from_raw_borrowed(&pstateobject))
        }
        unsafe extern "system" fn DispatchRays<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList4_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_DISPATCH_RAYS_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DispatchRays(::core::mem::transmute_copy(&pdesc))
        }
        Self {
            base__: ID3D12GraphicsCommandList3_Vtbl::new::<Identity, Impl, OFFSET>(),
            BeginRenderPass: BeginRenderPass::<Identity, Impl, OFFSET>,
            EndRenderPass: EndRenderPass::<Identity, Impl, OFFSET>,
            InitializeMetaCommand: InitializeMetaCommand::<Identity, Impl, OFFSET>,
            ExecuteMetaCommand: ExecuteMetaCommand::<Identity, Impl, OFFSET>,
            BuildRaytracingAccelerationStructure: BuildRaytracingAccelerationStructure::<
                Identity,
                Impl,
                OFFSET,
            >,
            EmitRaytracingAccelerationStructurePostbuildInfo:
                EmitRaytracingAccelerationStructurePostbuildInfo::<Identity, Impl, OFFSET>,
            CopyRaytracingAccelerationStructure: CopyRaytracingAccelerationStructure::<
                Identity,
                Impl,
                OFFSET,
            >,
            SetPipelineState1: SetPipelineState1::<Identity, Impl, OFFSET>,
            DispatchRays: DispatchRays::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandList4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList3 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12GraphicsCommandList5_Impl: Sized + ID3D12GraphicsCommandList4_Impl {
    fn RSSetShadingRate(
        &self,
        baseshadingrate: D3D12_SHADING_RATE,
        combiners: *const D3D12_SHADING_RATE_COMBINER,
    );
    fn RSSetShadingRateImage(&self, shadingrateimage: ::core::option::Option<&ID3D12Resource>);
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandList5 {}
impl ID3D12GraphicsCommandList5_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandList5_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandList5_Vtbl {
        unsafe extern "system" fn RSSetShadingRate<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            baseshadingrate: D3D12_SHADING_RATE,
            combiners: *const D3D12_SHADING_RATE_COMBINER,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RSSetShadingRate(
                ::core::mem::transmute_copy(&baseshadingrate),
                ::core::mem::transmute_copy(&combiners),
            )
        }
        unsafe extern "system" fn RSSetShadingRateImage<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList5_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            shadingrateimage: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RSSetShadingRateImage(::windows::core::from_raw_borrowed(&shadingrateimage))
        }
        Self {
            base__: ID3D12GraphicsCommandList4_Vtbl::new::<Identity, Impl, OFFSET>(),
            RSSetShadingRate: RSSetShadingRate::<Identity, Impl, OFFSET>,
            RSSetShadingRateImage: RSSetShadingRateImage::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandList5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList4 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12GraphicsCommandList6_Impl: Sized + ID3D12GraphicsCommandList5_Impl {
    fn DispatchMesh(&self, threadgroupcountx: u32, threadgroupcounty: u32, threadgroupcountz: u32);
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandList6 {}
impl ID3D12GraphicsCommandList6_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandList6_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandList6_Vtbl {
        unsafe extern "system" fn DispatchMesh<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList6_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            threadgroupcountx: u32,
            threadgroupcounty: u32,
            threadgroupcountz: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DispatchMesh(
                ::core::mem::transmute_copy(&threadgroupcountx),
                ::core::mem::transmute_copy(&threadgroupcounty),
                ::core::mem::transmute_copy(&threadgroupcountz),
            )
        }
        Self {
            base__: ID3D12GraphicsCommandList5_Vtbl::new::<Identity, Impl, OFFSET>(),
            DispatchMesh: DispatchMesh::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandList6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList5 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12GraphicsCommandList7_Impl: Sized + ID3D12GraphicsCommandList6_Impl {
    fn Barrier(&self, numbarriergroups: u32, pbarriergroups: *const D3D12_BARRIER_GROUP);
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandList7 {}
impl ID3D12GraphicsCommandList7_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandList7_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandList7_Vtbl {
        unsafe extern "system" fn Barrier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList7_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numbarriergroups: u32,
            pbarriergroups: *const D3D12_BARRIER_GROUP,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Barrier(
                ::core::mem::transmute_copy(&numbarriergroups),
                ::core::mem::transmute_copy(&pbarriergroups),
            )
        }
        Self {
            base__: ID3D12GraphicsCommandList6_Vtbl::new::<Identity, Impl, OFFSET>(),
            Barrier: Barrier::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandList7 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList6 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12GraphicsCommandList8_Impl: Sized + ID3D12GraphicsCommandList7_Impl {
    fn OMSetFrontAndBackStencilRef(&self, frontstencilref: u32, backstencilref: u32);
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandList8 {}
impl ID3D12GraphicsCommandList8_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandList8_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandList8_Vtbl {
        unsafe extern "system" fn OMSetFrontAndBackStencilRef<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList8_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            frontstencilref: u32,
            backstencilref: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.OMSetFrontAndBackStencilRef(
                ::core::mem::transmute_copy(&frontstencilref),
                ::core::mem::transmute_copy(&backstencilref),
            )
        }
        Self {
            base__: ID3D12GraphicsCommandList7_Vtbl::new::<Identity, Impl, OFFSET>(),
            OMSetFrontAndBackStencilRef: OMSetFrontAndBackStencilRef::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandList8 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList7 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12GraphicsCommandList9_Impl: Sized + ID3D12GraphicsCommandList8_Impl {
    fn RSSetDepthBias(&self, depthbias: f32, depthbiasclamp: f32, slopescaleddepthbias: f32);
    fn IASetIndexBufferStripCutValue(&self, ibstripcutvalue: D3D12_INDEX_BUFFER_STRIP_CUT_VALUE);
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandList9 {}
impl ID3D12GraphicsCommandList9_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandList9_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandList9_Vtbl {
        unsafe extern "system" fn RSSetDepthBias<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList9_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            depthbias: f32,
            depthbiasclamp: f32,
            slopescaleddepthbias: f32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RSSetDepthBias(
                ::core::mem::transmute_copy(&depthbias),
                ::core::mem::transmute_copy(&depthbiasclamp),
                ::core::mem::transmute_copy(&slopescaleddepthbias),
            )
        }
        unsafe extern "system" fn IASetIndexBufferStripCutValue<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandList9_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            ibstripcutvalue: D3D12_INDEX_BUFFER_STRIP_CUT_VALUE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.IASetIndexBufferStripCutValue(::core::mem::transmute_copy(&ibstripcutvalue))
        }
        Self {
            base__: ID3D12GraphicsCommandList8_Vtbl::new::<Identity, Impl, OFFSET>(),
            RSSetDepthBias: RSSetDepthBias::<Identity, Impl, OFFSET>,
            IASetIndexBufferStripCutValue: IASetIndexBufferStripCutValue::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandList9 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList7 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList8 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12GraphicsCommandListExperimental_Impl:
    Sized + ID3D12GraphicsCommandList9_Impl
{
    fn SetProgram(&self, pdesc: *const D3D12_SET_PROGRAM_DESC);
    fn DispatchGraph(&self, pdesc: *const D3D12_DISPATCH_GRAPH_DESC);
}
impl ::windows::core::RuntimeName for ID3D12GraphicsCommandListExperimental {}
impl ID3D12GraphicsCommandListExperimental_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12GraphicsCommandListExperimental_Impl,
        const OFFSET: isize,
    >() -> ID3D12GraphicsCommandListExperimental_Vtbl {
        unsafe extern "system" fn SetProgram<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandListExperimental_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_SET_PROGRAM_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetProgram(::core::mem::transmute_copy(&pdesc))
        }
        unsafe extern "system" fn DispatchGraph<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12GraphicsCommandListExperimental_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_DISPATCH_GRAPH_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DispatchGraph(::core::mem::transmute_copy(&pdesc))
        }
        Self {
            base__: ID3D12GraphicsCommandList9_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetProgram: SetProgram::<Identity, Impl, OFFSET>,
            DispatchGraph: DispatchGraph::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12GraphicsCommandListExperimental as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList4 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList5 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList6 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList7 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList8 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12GraphicsCommandList9 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Heap_Impl: Sized + ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_HEAP_DESC;
}
impl ::windows::core::RuntimeName for ID3D12Heap {}
impl ID3D12Heap_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Heap_Impl,
        const OFFSET: isize,
    >() -> ID3D12Heap_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Heap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_HEAP_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Heap as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Heap1_Impl: Sized + ID3D12Heap_Impl {
    fn GetProtectedResourceSession(
        &self,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Heap1 {}
impl ID3D12Heap1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Heap1_Impl,
        const OFFSET: isize,
    >() -> ID3D12Heap1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Heap1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppprotectedsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetProtectedResourceSession(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppprotectedsession),
            )
            .into()
        }
        Self {
            base__: ID3D12Heap_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Heap1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Heap as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12InfoQueue_Impl: Sized {
    fn SetMessageCountLimit(&self, messagecountlimit: u64) -> ::windows::core::Result<()>;
    fn ClearStoredMessages(&self);
    fn GetMessageA(
        &self,
        messageindex: u64,
        pmessage: *mut D3D12_MESSAGE,
        pmessagebytelength: *mut usize,
    ) -> ::windows::core::Result<()>;
    fn GetNumMessagesAllowedByStorageFilter(&self) -> u64;
    fn GetNumMessagesDeniedByStorageFilter(&self) -> u64;
    fn GetNumStoredMessages(&self) -> u64;
    fn GetNumStoredMessagesAllowedByRetrievalFilter(&self) -> u64;
    fn GetNumMessagesDiscardedByMessageCountLimit(&self) -> u64;
    fn GetMessageCountLimit(&self) -> u64;
    fn AddStorageFilterEntries(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()>;
    fn GetStorageFilter(
        &self,
        pfilter: *mut D3D12_INFO_QUEUE_FILTER,
        pfilterbytelength: *mut usize,
    ) -> ::windows::core::Result<()>;
    fn ClearStorageFilter(&self);
    fn PushEmptyStorageFilter(&self) -> ::windows::core::Result<()>;
    fn PushCopyOfStorageFilter(&self) -> ::windows::core::Result<()>;
    fn PushStorageFilter(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()>;
    fn PopStorageFilter(&self);
    fn GetStorageFilterStackSize(&self) -> u32;
    fn AddRetrievalFilterEntries(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()>;
    fn GetRetrievalFilter(
        &self,
        pfilter: *mut D3D12_INFO_QUEUE_FILTER,
        pfilterbytelength: *mut usize,
    ) -> ::windows::core::Result<()>;
    fn ClearRetrievalFilter(&self);
    fn PushEmptyRetrievalFilter(&self) -> ::windows::core::Result<()>;
    fn PushCopyOfRetrievalFilter(&self) -> ::windows::core::Result<()>;
    fn PushRetrievalFilter(
        &self,
        pfilter: *const D3D12_INFO_QUEUE_FILTER,
    ) -> ::windows::core::Result<()>;
    fn PopRetrievalFilter(&self);
    fn GetRetrievalFilterStackSize(&self) -> u32;
    fn AddMessage(
        &self,
        category: D3D12_MESSAGE_CATEGORY,
        severity: D3D12_MESSAGE_SEVERITY,
        id: D3D12_MESSAGE_ID,
        pdescription: &::windows::core::PCSTR,
    ) -> ::windows::core::Result<()>;
    fn AddApplicationMessage(
        &self,
        severity: D3D12_MESSAGE_SEVERITY,
        pdescription: &::windows::core::PCSTR,
    ) -> ::windows::core::Result<()>;
    fn SetBreakOnCategory(
        &self,
        category: D3D12_MESSAGE_CATEGORY,
        benable: ::windows::Win32::Foundation::BOOL,
    ) -> ::windows::core::Result<()>;
    fn SetBreakOnSeverity(
        &self,
        severity: D3D12_MESSAGE_SEVERITY,
        benable: ::windows::Win32::Foundation::BOOL,
    ) -> ::windows::core::Result<()>;
    fn SetBreakOnID(
        &self,
        id: D3D12_MESSAGE_ID,
        benable: ::windows::Win32::Foundation::BOOL,
    ) -> ::windows::core::Result<()>;
    fn GetBreakOnCategory(
        &self,
        category: D3D12_MESSAGE_CATEGORY,
    ) -> ::windows::Win32::Foundation::BOOL;
    fn GetBreakOnSeverity(
        &self,
        severity: D3D12_MESSAGE_SEVERITY,
    ) -> ::windows::Win32::Foundation::BOOL;
    fn GetBreakOnID(&self, id: D3D12_MESSAGE_ID) -> ::windows::Win32::Foundation::BOOL;
    fn SetMuteDebugOutput(&self, bmute: ::windows::Win32::Foundation::BOOL);
    fn GetMuteDebugOutput(&self) -> ::windows::Win32::Foundation::BOOL;
}
impl ::windows::core::RuntimeName for ID3D12InfoQueue {}
impl ID3D12InfoQueue_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12InfoQueue_Impl,
        const OFFSET: isize,
    >() -> ID3D12InfoQueue_Vtbl {
        unsafe extern "system" fn SetMessageCountLimit<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            messagecountlimit: u64,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetMessageCountLimit(::core::mem::transmute_copy(&messagecountlimit))
                .into()
        }
        unsafe extern "system" fn ClearStoredMessages<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearStoredMessages()
        }
        unsafe extern "system" fn GetMessageA<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            messageindex: u64,
            pmessage: *mut D3D12_MESSAGE,
            pmessagebytelength: *mut usize,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetMessageA(
                ::core::mem::transmute_copy(&messageindex),
                ::core::mem::transmute_copy(&pmessage),
                ::core::mem::transmute_copy(&pmessagebytelength),
            )
            .into()
        }
        unsafe extern "system" fn GetNumMessagesAllowedByStorageFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNumMessagesAllowedByStorageFilter()
        }
        unsafe extern "system" fn GetNumMessagesDeniedByStorageFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNumMessagesDeniedByStorageFilter()
        }
        unsafe extern "system" fn GetNumStoredMessages<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNumStoredMessages()
        }
        unsafe extern "system" fn GetNumStoredMessagesAllowedByRetrievalFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNumStoredMessagesAllowedByRetrievalFilter()
        }
        unsafe extern "system" fn GetNumMessagesDiscardedByMessageCountLimit<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNumMessagesDiscardedByMessageCountLimit()
        }
        unsafe extern "system" fn GetMessageCountLimit<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetMessageCountLimit()
        }
        unsafe extern "system" fn AddStorageFilterEntries<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfilter: *const D3D12_INFO_QUEUE_FILTER,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AddStorageFilterEntries(::core::mem::transmute_copy(&pfilter))
                .into()
        }
        unsafe extern "system" fn GetStorageFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfilter: *mut D3D12_INFO_QUEUE_FILTER,
            pfilterbytelength: *mut usize,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetStorageFilter(
                ::core::mem::transmute_copy(&pfilter),
                ::core::mem::transmute_copy(&pfilterbytelength),
            )
            .into()
        }
        unsafe extern "system" fn ClearStorageFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearStorageFilter()
        }
        unsafe extern "system" fn PushEmptyStorageFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.PushEmptyStorageFilter().into()
        }
        unsafe extern "system" fn PushCopyOfStorageFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.PushCopyOfStorageFilter().into()
        }
        unsafe extern "system" fn PushStorageFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfilter: *const D3D12_INFO_QUEUE_FILTER,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.PushStorageFilter(::core::mem::transmute_copy(&pfilter))
                .into()
        }
        unsafe extern "system" fn PopStorageFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.PopStorageFilter()
        }
        unsafe extern "system" fn GetStorageFilterStackSize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetStorageFilterStackSize()
        }
        unsafe extern "system" fn AddRetrievalFilterEntries<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfilter: *const D3D12_INFO_QUEUE_FILTER,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AddRetrievalFilterEntries(::core::mem::transmute_copy(&pfilter))
                .into()
        }
        unsafe extern "system" fn GetRetrievalFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfilter: *mut D3D12_INFO_QUEUE_FILTER,
            pfilterbytelength: *mut usize,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetRetrievalFilter(
                ::core::mem::transmute_copy(&pfilter),
                ::core::mem::transmute_copy(&pfilterbytelength),
            )
            .into()
        }
        unsafe extern "system" fn ClearRetrievalFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearRetrievalFilter()
        }
        unsafe extern "system" fn PushEmptyRetrievalFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.PushEmptyRetrievalFilter().into()
        }
        unsafe extern "system" fn PushCopyOfRetrievalFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.PushCopyOfRetrievalFilter().into()
        }
        unsafe extern "system" fn PushRetrievalFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfilter: *const D3D12_INFO_QUEUE_FILTER,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.PushRetrievalFilter(::core::mem::transmute_copy(&pfilter))
                .into()
        }
        unsafe extern "system" fn PopRetrievalFilter<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.PopRetrievalFilter()
        }
        unsafe extern "system" fn GetRetrievalFilterStackSize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetRetrievalFilterStackSize()
        }
        unsafe extern "system" fn AddMessage<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            category: D3D12_MESSAGE_CATEGORY,
            severity: D3D12_MESSAGE_SEVERITY,
            id: D3D12_MESSAGE_ID,
            pdescription: ::windows::core::PCSTR,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AddMessage(
                ::core::mem::transmute_copy(&category),
                ::core::mem::transmute_copy(&severity),
                ::core::mem::transmute_copy(&id),
                ::core::mem::transmute(&pdescription),
            )
            .into()
        }
        unsafe extern "system" fn AddApplicationMessage<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            severity: D3D12_MESSAGE_SEVERITY,
            pdescription: ::windows::core::PCSTR,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.AddApplicationMessage(
                ::core::mem::transmute_copy(&severity),
                ::core::mem::transmute(&pdescription),
            )
            .into()
        }
        unsafe extern "system" fn SetBreakOnCategory<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            category: D3D12_MESSAGE_CATEGORY,
            benable: ::windows::Win32::Foundation::BOOL,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetBreakOnCategory(
                ::core::mem::transmute_copy(&category),
                ::core::mem::transmute_copy(&benable),
            )
            .into()
        }
        unsafe extern "system" fn SetBreakOnSeverity<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            severity: D3D12_MESSAGE_SEVERITY,
            benable: ::windows::Win32::Foundation::BOOL,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetBreakOnSeverity(
                ::core::mem::transmute_copy(&severity),
                ::core::mem::transmute_copy(&benable),
            )
            .into()
        }
        unsafe extern "system" fn SetBreakOnID<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            id: D3D12_MESSAGE_ID,
            benable: ::windows::Win32::Foundation::BOOL,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetBreakOnID(
                ::core::mem::transmute_copy(&id),
                ::core::mem::transmute_copy(&benable),
            )
            .into()
        }
        unsafe extern "system" fn GetBreakOnCategory<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            category: D3D12_MESSAGE_CATEGORY,
        ) -> ::windows::Win32::Foundation::BOOL {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetBreakOnCategory(::core::mem::transmute_copy(&category))
        }
        unsafe extern "system" fn GetBreakOnSeverity<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            severity: D3D12_MESSAGE_SEVERITY,
        ) -> ::windows::Win32::Foundation::BOOL {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetBreakOnSeverity(::core::mem::transmute_copy(&severity))
        }
        unsafe extern "system" fn GetBreakOnID<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            id: D3D12_MESSAGE_ID,
        ) -> ::windows::Win32::Foundation::BOOL {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetBreakOnID(::core::mem::transmute_copy(&id))
        }
        unsafe extern "system" fn SetMuteDebugOutput<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            bmute: ::windows::Win32::Foundation::BOOL,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetMuteDebugOutput(::core::mem::transmute_copy(&bmute))
        }
        unsafe extern "system" fn GetMuteDebugOutput<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::Win32::Foundation::BOOL {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetMuteDebugOutput()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetMessageCountLimit: SetMessageCountLimit::<Identity, Impl, OFFSET>,
            ClearStoredMessages: ClearStoredMessages::<Identity, Impl, OFFSET>,
            GetMessageA: GetMessageA::<Identity, Impl, OFFSET>,
            GetNumMessagesAllowedByStorageFilter: GetNumMessagesAllowedByStorageFilter::<
                Identity,
                Impl,
                OFFSET,
            >,
            GetNumMessagesDeniedByStorageFilter: GetNumMessagesDeniedByStorageFilter::<
                Identity,
                Impl,
                OFFSET,
            >,
            GetNumStoredMessages: GetNumStoredMessages::<Identity, Impl, OFFSET>,
            GetNumStoredMessagesAllowedByRetrievalFilter:
                GetNumStoredMessagesAllowedByRetrievalFilter::<Identity, Impl, OFFSET>,
            GetNumMessagesDiscardedByMessageCountLimit: GetNumMessagesDiscardedByMessageCountLimit::<
                Identity,
                Impl,
                OFFSET,
            >,
            GetMessageCountLimit: GetMessageCountLimit::<Identity, Impl, OFFSET>,
            AddStorageFilterEntries: AddStorageFilterEntries::<Identity, Impl, OFFSET>,
            GetStorageFilter: GetStorageFilter::<Identity, Impl, OFFSET>,
            ClearStorageFilter: ClearStorageFilter::<Identity, Impl, OFFSET>,
            PushEmptyStorageFilter: PushEmptyStorageFilter::<Identity, Impl, OFFSET>,
            PushCopyOfStorageFilter: PushCopyOfStorageFilter::<Identity, Impl, OFFSET>,
            PushStorageFilter: PushStorageFilter::<Identity, Impl, OFFSET>,
            PopStorageFilter: PopStorageFilter::<Identity, Impl, OFFSET>,
            GetStorageFilterStackSize: GetStorageFilterStackSize::<Identity, Impl, OFFSET>,
            AddRetrievalFilterEntries: AddRetrievalFilterEntries::<Identity, Impl, OFFSET>,
            GetRetrievalFilter: GetRetrievalFilter::<Identity, Impl, OFFSET>,
            ClearRetrievalFilter: ClearRetrievalFilter::<Identity, Impl, OFFSET>,
            PushEmptyRetrievalFilter: PushEmptyRetrievalFilter::<Identity, Impl, OFFSET>,
            PushCopyOfRetrievalFilter: PushCopyOfRetrievalFilter::<Identity, Impl, OFFSET>,
            PushRetrievalFilter: PushRetrievalFilter::<Identity, Impl, OFFSET>,
            PopRetrievalFilter: PopRetrievalFilter::<Identity, Impl, OFFSET>,
            GetRetrievalFilterStackSize: GetRetrievalFilterStackSize::<Identity, Impl, OFFSET>,
            AddMessage: AddMessage::<Identity, Impl, OFFSET>,
            AddApplicationMessage: AddApplicationMessage::<Identity, Impl, OFFSET>,
            SetBreakOnCategory: SetBreakOnCategory::<Identity, Impl, OFFSET>,
            SetBreakOnSeverity: SetBreakOnSeverity::<Identity, Impl, OFFSET>,
            SetBreakOnID: SetBreakOnID::<Identity, Impl, OFFSET>,
            GetBreakOnCategory: GetBreakOnCategory::<Identity, Impl, OFFSET>,
            GetBreakOnSeverity: GetBreakOnSeverity::<Identity, Impl, OFFSET>,
            GetBreakOnID: GetBreakOnID::<Identity, Impl, OFFSET>,
            SetMuteDebugOutput: SetMuteDebugOutput::<Identity, Impl, OFFSET>,
            GetMuteDebugOutput: GetMuteDebugOutput::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12InfoQueue as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12InfoQueue1_Impl: Sized + ID3D12InfoQueue_Impl {
    fn RegisterMessageCallback(
        &self,
        callbackfunc: ::windows::Win32::Graphics::Direct3D12::D3D12MessageFunc,
        callbackfilterflags: D3D12_MESSAGE_CALLBACK_FLAGS,
        pcontext: *const ::core::ffi::c_void,
        pcallbackcookie: *mut u32,
    ) -> ::windows::core::Result<()>;
    fn UnregisterMessageCallback(&self, callbackcookie: u32) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12InfoQueue1 {}
impl ID3D12InfoQueue1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12InfoQueue1_Impl,
        const OFFSET: isize,
    >() -> ID3D12InfoQueue1_Vtbl {
        unsafe extern "system" fn RegisterMessageCallback<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            callbackfunc: ::windows::Win32::Graphics::Direct3D12::D3D12MessageFunc,
            callbackfilterflags: D3D12_MESSAGE_CALLBACK_FLAGS,
            pcontext: *const ::core::ffi::c_void,
            pcallbackcookie: *mut u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.RegisterMessageCallback(
                ::core::mem::transmute_copy(&callbackfunc),
                ::core::mem::transmute_copy(&callbackfilterflags),
                ::core::mem::transmute_copy(&pcontext),
                ::core::mem::transmute_copy(&pcallbackcookie),
            )
            .into()
        }
        unsafe extern "system" fn UnregisterMessageCallback<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12InfoQueue1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            callbackcookie: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.UnregisterMessageCallback(::core::mem::transmute_copy(&callbackcookie))
                .into()
        }
        Self {
            base__: ID3D12InfoQueue_Vtbl::new::<Identity, Impl, OFFSET>(),
            RegisterMessageCallback: RegisterMessageCallback::<Identity, Impl, OFFSET>,
            UnregisterMessageCallback: UnregisterMessageCallback::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12InfoQueue1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12InfoQueue as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12LibraryReflection_Impl: Sized {
    fn GetDesc(&self) -> ::windows::core::Result<D3D12_LIBRARY_DESC>;
    fn GetFunctionByIndex(
        &self,
        functionindex: i32,
    ) -> ::core::option::Option<ID3D12FunctionReflection>;
}
impl ::windows::core::RuntimeName for ID3D12LibraryReflection {}
impl ID3D12LibraryReflection_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12LibraryReflection_Impl,
        const OFFSET: isize,
    >() -> ID3D12LibraryReflection_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12LibraryReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *mut D3D12_LIBRARY_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.GetDesc() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pdesc, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetFunctionByIndex<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12LibraryReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            functionindex: i32,
        ) -> ::core::option::Option<ID3D12FunctionReflection> {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetFunctionByIndex(::core::mem::transmute_copy(&functionindex))
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
            GetFunctionByIndex: GetFunctionByIndex::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12LibraryReflection as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12LifetimeOwner_Impl: Sized {
    fn LifetimeStateUpdated(&self, newstate: D3D12_LIFETIME_STATE);
}
impl ::windows::core::RuntimeName for ID3D12LifetimeOwner {}
impl ID3D12LifetimeOwner_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12LifetimeOwner_Impl,
        const OFFSET: isize,
    >() -> ID3D12LifetimeOwner_Vtbl {
        unsafe extern "system" fn LifetimeStateUpdated<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12LifetimeOwner_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            newstate: D3D12_LIFETIME_STATE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.LifetimeStateUpdated(::core::mem::transmute_copy(&newstate))
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            LifetimeStateUpdated: LifetimeStateUpdated::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12LifetimeOwner as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12LifetimeTracker_Impl: Sized + ID3D12DeviceChild_Impl {
    fn DestroyOwnedObject(
        &self,
        pobject: ::core::option::Option<&ID3D12DeviceChild>,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12LifetimeTracker {}
impl ID3D12LifetimeTracker_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12LifetimeTracker_Impl,
        const OFFSET: isize,
    >() -> ID3D12LifetimeTracker_Vtbl {
        unsafe extern "system" fn DestroyOwnedObject<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12LifetimeTracker_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pobject: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DestroyOwnedObject(::windows::core::from_raw_borrowed(&pobject))
                .into()
        }
        Self {
            base__: ID3D12DeviceChild_Vtbl::new::<Identity, Impl, OFFSET>(),
            DestroyOwnedObject: DestroyOwnedObject::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12LifetimeTracker as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12ManualWriteTrackingResource_Impl: Sized {
    fn TrackWrite(&self, subresource: u32, pwrittenrange: *const D3D12_RANGE);
}
impl ::windows::core::RuntimeName for ID3D12ManualWriteTrackingResource {}
impl ID3D12ManualWriteTrackingResource_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12ManualWriteTrackingResource_Impl,
        const OFFSET: isize,
    >() -> ID3D12ManualWriteTrackingResource_Vtbl {
        unsafe extern "system" fn TrackWrite<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ManualWriteTrackingResource_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            subresource: u32,
            pwrittenrange: *const D3D12_RANGE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.TrackWrite(
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&pwrittenrange),
            )
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            TrackWrite: TrackWrite::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12ManualWriteTrackingResource as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12MetaCommand_Impl: Sized + ID3D12Pageable_Impl {
    fn GetRequiredParameterResourceSize(
        &self,
        stage: D3D12_META_COMMAND_PARAMETER_STAGE,
        parameterindex: u32,
    ) -> u64;
}
impl ::windows::core::RuntimeName for ID3D12MetaCommand {}
impl ID3D12MetaCommand_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12MetaCommand_Impl,
        const OFFSET: isize,
    >() -> ID3D12MetaCommand_Vtbl {
        unsafe extern "system" fn GetRequiredParameterResourceSize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12MetaCommand_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            stage: D3D12_META_COMMAND_PARAMETER_STAGE,
            parameterindex: u32,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetRequiredParameterResourceSize(
                ::core::mem::transmute_copy(&stage),
                ::core::mem::transmute_copy(&parameterindex),
            )
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetRequiredParameterResourceSize: GetRequiredParameterResourceSize::<
                Identity,
                Impl,
                OFFSET,
            >,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12MetaCommand as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Object_Impl: Sized {
    fn GetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        pdatasize: *mut u32,
        pdata: *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn SetPrivateData(
        &self,
        guid: *const ::windows::core::GUID,
        datasize: u32,
        pdata: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn SetPrivateDataInterface(
        &self,
        guid: *const ::windows::core::GUID,
        pdata: ::core::option::Option<&::windows::core::IUnknown>,
    ) -> ::windows::core::Result<()>;
    fn SetName(&self, name: &::windows::core::PCWSTR) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Object {}
impl ID3D12Object_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Object_Impl,
        const OFFSET: isize,
    >() -> ID3D12Object_Vtbl {
        unsafe extern "system" fn GetPrivateData<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Object_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            guid: *const ::windows::core::GUID,
            pdatasize: *mut u32,
            pdata: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetPrivateData(
                ::core::mem::transmute_copy(&guid),
                ::core::mem::transmute_copy(&pdatasize),
                ::core::mem::transmute_copy(&pdata),
            )
            .into()
        }
        unsafe extern "system" fn SetPrivateData<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Object_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            guid: *const ::windows::core::GUID,
            datasize: u32,
            pdata: *const ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetPrivateData(
                ::core::mem::transmute_copy(&guid),
                ::core::mem::transmute_copy(&datasize),
                ::core::mem::transmute_copy(&pdata),
            )
            .into()
        }
        unsafe extern "system" fn SetPrivateDataInterface<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Object_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            guid: *const ::windows::core::GUID,
            pdata: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetPrivateDataInterface(
                ::core::mem::transmute_copy(&guid),
                ::windows::core::from_raw_borrowed(&pdata),
            )
            .into()
        }
        unsafe extern "system" fn SetName<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Object_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCWSTR,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetName(::core::mem::transmute(&name)).into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetPrivateData: GetPrivateData::<Identity, Impl, OFFSET>,
            SetPrivateData: SetPrivateData::<Identity, Impl, OFFSET>,
            SetPrivateDataInterface: SetPrivateDataInterface::<Identity, Impl, OFFSET>,
            SetName: SetName::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Pageable_Impl: Sized + ID3D12DeviceChild_Impl {}
impl ::windows::core::RuntimeName for ID3D12Pageable {}
impl ID3D12Pageable_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Pageable_Impl,
        const OFFSET: isize,
    >() -> ID3D12Pageable_Vtbl {
        Self {
            base__: ID3D12DeviceChild_Vtbl::new::<Identity, Impl, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12PipelineLibrary_Impl: Sized + ID3D12DeviceChild_Impl {
    fn StorePipeline(
        &self,
        pname: &::windows::core::PCWSTR,
        ppipeline: ::core::option::Option<&ID3D12PipelineState>,
    ) -> ::windows::core::Result<()>;
    fn LoadGraphicsPipeline(
        &self,
        pname: &::windows::core::PCWSTR,
        pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn LoadComputePipeline(
        &self,
        pname: &::windows::core::PCWSTR,
        pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn GetSerializedSize(&self) -> usize;
    fn Serialize(
        &self,
        pdata: *mut ::core::ffi::c_void,
        datasizeinbytes: usize,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12PipelineLibrary {}
impl ID3D12PipelineLibrary_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12PipelineLibrary_Impl,
        const OFFSET: isize,
    >() -> ID3D12PipelineLibrary_Vtbl {
        unsafe extern "system" fn StorePipeline<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12PipelineLibrary_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pname: ::windows::core::PCWSTR,
            ppipeline: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.StorePipeline(
                ::core::mem::transmute(&pname),
                ::windows::core::from_raw_borrowed(&ppipeline),
            )
            .into()
        }
        unsafe extern "system" fn LoadGraphicsPipeline<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12PipelineLibrary_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pname: ::windows::core::PCWSTR,
            pdesc: *const D3D12_GRAPHICS_PIPELINE_STATE_DESC,
            riid: *const ::windows::core::GUID,
            pppipelinestate: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.LoadGraphicsPipeline(
                ::core::mem::transmute(&pname),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&pppipelinestate),
            )
            .into()
        }
        unsafe extern "system" fn LoadComputePipeline<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12PipelineLibrary_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pname: ::windows::core::PCWSTR,
            pdesc: *const D3D12_COMPUTE_PIPELINE_STATE_DESC,
            riid: *const ::windows::core::GUID,
            pppipelinestate: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.LoadComputePipeline(
                ::core::mem::transmute(&pname),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&pppipelinestate),
            )
            .into()
        }
        unsafe extern "system" fn GetSerializedSize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12PipelineLibrary_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> usize {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetSerializedSize()
        }
        unsafe extern "system" fn Serialize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12PipelineLibrary_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdata: *mut ::core::ffi::c_void,
            datasizeinbytes: usize,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Serialize(
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&datasizeinbytes),
            )
            .into()
        }
        Self {
            base__: ID3D12DeviceChild_Vtbl::new::<Identity, Impl, OFFSET>(),
            StorePipeline: StorePipeline::<Identity, Impl, OFFSET>,
            LoadGraphicsPipeline: LoadGraphicsPipeline::<Identity, Impl, OFFSET>,
            LoadComputePipeline: LoadComputePipeline::<Identity, Impl, OFFSET>,
            GetSerializedSize: GetSerializedSize::<Identity, Impl, OFFSET>,
            Serialize: Serialize::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12PipelineLibrary as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12PipelineLibrary1_Impl: Sized + ID3D12PipelineLibrary_Impl {
    fn LoadPipeline(
        &self,
        pname: &::windows::core::PCWSTR,
        pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
        riid: *const ::windows::core::GUID,
        pppipelinestate: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12PipelineLibrary1 {}
impl ID3D12PipelineLibrary1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12PipelineLibrary1_Impl,
        const OFFSET: isize,
    >() -> ID3D12PipelineLibrary1_Vtbl {
        unsafe extern "system" fn LoadPipeline<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12PipelineLibrary1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pname: ::windows::core::PCWSTR,
            pdesc: *const D3D12_PIPELINE_STATE_STREAM_DESC,
            riid: *const ::windows::core::GUID,
            pppipelinestate: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.LoadPipeline(
                ::core::mem::transmute(&pname),
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&pppipelinestate),
            )
            .into()
        }
        Self {
            base__: ID3D12PipelineLibrary_Vtbl::new::<Identity, Impl, OFFSET>(),
            LoadPipeline: LoadPipeline::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12PipelineLibrary1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12PipelineLibrary as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12PipelineState_Impl: Sized + ID3D12Pageable_Impl {
    fn GetCachedBlob(&self) -> ::windows::core::Result<ID3DBlob>;
}
impl ::windows::core::RuntimeName for ID3D12PipelineState {}
impl ID3D12PipelineState_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12PipelineState_Impl,
        const OFFSET: isize,
    >() -> ID3D12PipelineState_Vtbl {
        unsafe extern "system" fn GetCachedBlob<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12PipelineState_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            ppblob: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.GetCachedBlob() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppblob, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetCachedBlob: GetCachedBlob::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12PipelineState as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12ProtectedResourceSession_Impl: Sized + ID3D12ProtectedSession_Impl {
    fn GetDesc(&self) -> D3D12_PROTECTED_RESOURCE_SESSION_DESC;
}
impl ::windows::core::RuntimeName for ID3D12ProtectedResourceSession {}
impl ID3D12ProtectedResourceSession_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12ProtectedResourceSession_Impl,
        const OFFSET: isize,
    >() -> ID3D12ProtectedResourceSession_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ProtectedResourceSession_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_PROTECTED_RESOURCE_SESSION_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        Self {
            base__: ID3D12ProtectedSession_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12ProtectedResourceSession as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12ProtectedSession as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12ProtectedResourceSession1_Impl:
    Sized + ID3D12ProtectedResourceSession_Impl
{
    fn GetDesc1(&self) -> D3D12_PROTECTED_RESOURCE_SESSION_DESC1;
}
impl ::windows::core::RuntimeName for ID3D12ProtectedResourceSession1 {}
impl ID3D12ProtectedResourceSession1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12ProtectedResourceSession1_Impl,
        const OFFSET: isize,
    >() -> ID3D12ProtectedResourceSession1_Vtbl {
        unsafe extern "system" fn GetDesc1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ProtectedResourceSession1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_PROTECTED_RESOURCE_SESSION_DESC1,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc1()
        }
        Self {
            base__: ID3D12ProtectedResourceSession_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDesc1: GetDesc1::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12ProtectedResourceSession1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12ProtectedSession as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12ProtectedResourceSession as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12ProtectedSession_Impl: Sized + ID3D12DeviceChild_Impl {
    fn GetStatusFence(
        &self,
        riid: *const ::windows::core::GUID,
        ppfence: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn GetSessionStatus(&self) -> D3D12_PROTECTED_SESSION_STATUS;
}
impl ::windows::core::RuntimeName for ID3D12ProtectedSession {}
impl ID3D12ProtectedSession_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12ProtectedSession_Impl,
        const OFFSET: isize,
    >() -> ID3D12ProtectedSession_Vtbl {
        unsafe extern "system" fn GetStatusFence<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ProtectedSession_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppfence: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetStatusFence(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppfence),
            )
            .into()
        }
        unsafe extern "system" fn GetSessionStatus<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ProtectedSession_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_PROTECTED_SESSION_STATUS {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetSessionStatus()
        }
        Self {
            base__: ID3D12DeviceChild_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetStatusFence: GetStatusFence::<Identity, Impl, OFFSET>,
            GetSessionStatus: GetSessionStatus::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12ProtectedSession as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12QueryHeap_Impl: Sized + ID3D12Pageable_Impl {}
impl ::windows::core::RuntimeName for ID3D12QueryHeap {}
impl ID3D12QueryHeap_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12QueryHeap_Impl,
        const OFFSET: isize,
    >() -> ID3D12QueryHeap_Vtbl {
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12QueryHeap as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Resource_Impl: Sized + ID3D12Pageable_Impl {
    fn Map(
        &self,
        subresource: u32,
        preadrange: *const D3D12_RANGE,
        ppdata: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn Unmap(&self, subresource: u32, pwrittenrange: *const D3D12_RANGE);
    fn GetDesc(&self) -> D3D12_RESOURCE_DESC;
    fn GetGPUVirtualAddress(&self) -> u64;
    fn WriteToSubresource(
        &self,
        dstsubresource: u32,
        pdstbox: *const D3D12_BOX,
        psrcdata: *const ::core::ffi::c_void,
        srcrowpitch: u32,
        srcdepthpitch: u32,
    ) -> ::windows::core::Result<()>;
    fn ReadFromSubresource(
        &self,
        pdstdata: *mut ::core::ffi::c_void,
        dstrowpitch: u32,
        dstdepthpitch: u32,
        srcsubresource: u32,
        psrcbox: *const D3D12_BOX,
    ) -> ::windows::core::Result<()>;
    fn GetHeapProperties(
        &self,
        pheapproperties: *mut D3D12_HEAP_PROPERTIES,
        pheapflags: *mut D3D12_HEAP_FLAGS,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Resource {}
impl ID3D12Resource_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Resource_Impl,
        const OFFSET: isize,
    >() -> ID3D12Resource_Vtbl {
        unsafe extern "system" fn Map<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Resource_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            subresource: u32,
            preadrange: *const D3D12_RANGE,
            ppdata: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Map(
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&preadrange),
                ::core::mem::transmute_copy(&ppdata),
            )
            .into()
        }
        unsafe extern "system" fn Unmap<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Resource_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            subresource: u32,
            pwrittenrange: *const D3D12_RANGE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Unmap(
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&pwrittenrange),
            )
        }
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Resource_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_RESOURCE_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        unsafe extern "system" fn GetGPUVirtualAddress<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Resource_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetGPUVirtualAddress()
        }
        unsafe extern "system" fn WriteToSubresource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Resource_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            dstsubresource: u32,
            pdstbox: *const D3D12_BOX,
            psrcdata: *const ::core::ffi::c_void,
            srcrowpitch: u32,
            srcdepthpitch: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.WriteToSubresource(
                ::core::mem::transmute_copy(&dstsubresource),
                ::core::mem::transmute_copy(&pdstbox),
                ::core::mem::transmute_copy(&psrcdata),
                ::core::mem::transmute_copy(&srcrowpitch),
                ::core::mem::transmute_copy(&srcdepthpitch),
            )
            .into()
        }
        unsafe extern "system" fn ReadFromSubresource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Resource_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdstdata: *mut ::core::ffi::c_void,
            dstrowpitch: u32,
            dstdepthpitch: u32,
            srcsubresource: u32,
            psrcbox: *const D3D12_BOX,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ReadFromSubresource(
                ::core::mem::transmute_copy(&pdstdata),
                ::core::mem::transmute_copy(&dstrowpitch),
                ::core::mem::transmute_copy(&dstdepthpitch),
                ::core::mem::transmute_copy(&srcsubresource),
                ::core::mem::transmute_copy(&psrcbox),
            )
            .into()
        }
        unsafe extern "system" fn GetHeapProperties<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Resource_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pheapproperties: *mut D3D12_HEAP_PROPERTIES,
            pheapflags: *mut D3D12_HEAP_FLAGS,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetHeapProperties(
                ::core::mem::transmute_copy(&pheapproperties),
                ::core::mem::transmute_copy(&pheapflags),
            )
            .into()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            Map: Map::<Identity, Impl, OFFSET>,
            Unmap: Unmap::<Identity, Impl, OFFSET>,
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
            GetGPUVirtualAddress: GetGPUVirtualAddress::<Identity, Impl, OFFSET>,
            WriteToSubresource: WriteToSubresource::<Identity, Impl, OFFSET>,
            ReadFromSubresource: ReadFromSubresource::<Identity, Impl, OFFSET>,
            GetHeapProperties: GetHeapProperties::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Resource as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Resource1_Impl: Sized + ID3D12Resource_Impl {
    fn GetProtectedResourceSession(
        &self,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12Resource1 {}
impl ID3D12Resource1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Resource1_Impl,
        const OFFSET: isize,
    >() -> ID3D12Resource1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Resource1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppprotectedsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetProtectedResourceSession(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppprotectedsession),
            )
            .into()
        }
        Self {
            base__: ID3D12Resource_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Resource1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Resource as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Resource2_Impl: Sized + ID3D12Resource1_Impl {
    fn GetDesc1(&self) -> D3D12_RESOURCE_DESC1;
}
impl ::windows::core::RuntimeName for ID3D12Resource2 {}
impl ID3D12Resource2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Resource2_Impl,
        const OFFSET: isize,
    >() -> ID3D12Resource2_Vtbl {
        unsafe extern "system" fn GetDesc1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Resource2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_RESOURCE_DESC1,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc1()
        }
        Self {
            base__: ID3D12Resource1_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDesc1: GetDesc1::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Resource2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Resource as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Resource1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12RootSignature_Impl: Sized + ID3D12DeviceChild_Impl {}
impl ::windows::core::RuntimeName for ID3D12RootSignature {}
impl ID3D12RootSignature_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12RootSignature_Impl,
        const OFFSET: isize,
    >() -> ID3D12RootSignature_Vtbl {
        Self {
            base__: ID3D12DeviceChild_Vtbl::new::<Identity, Impl, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12RootSignature as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12RootSignatureDeserializer_Impl: Sized {
    fn GetRootSignatureDesc(&self) -> *mut D3D12_ROOT_SIGNATURE_DESC;
}
impl ::windows::core::RuntimeName for ID3D12RootSignatureDeserializer {}
impl ID3D12RootSignatureDeserializer_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12RootSignatureDeserializer_Impl,
        const OFFSET: isize,
    >() -> ID3D12RootSignatureDeserializer_Vtbl {
        unsafe extern "system" fn GetRootSignatureDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12RootSignatureDeserializer_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> *mut D3D12_ROOT_SIGNATURE_DESC {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetRootSignatureDesc()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetRootSignatureDesc: GetRootSignatureDesc::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12RootSignatureDeserializer as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12SDKConfiguration_Impl: Sized {
    fn SetSDKVersion(
        &self,
        sdkversion: u32,
        sdkpath: &::windows::core::PCSTR,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12SDKConfiguration {}
impl ID3D12SDKConfiguration_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12SDKConfiguration_Impl,
        const OFFSET: isize,
    >() -> ID3D12SDKConfiguration_Vtbl {
        unsafe extern "system" fn SetSDKVersion<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SDKConfiguration_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            sdkversion: u32,
            sdkpath: ::windows::core::PCSTR,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetSDKVersion(
                ::core::mem::transmute_copy(&sdkversion),
                ::core::mem::transmute(&sdkpath),
            )
            .into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            SetSDKVersion: SetSDKVersion::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12SDKConfiguration as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12SDKConfiguration1_Impl: Sized + ID3D12SDKConfiguration_Impl {
    fn CreateDeviceFactory(
        &self,
        sdkversion: u32,
        sdkpath: &::windows::core::PCSTR,
        riid: *const ::windows::core::GUID,
        ppvfactory: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn FreeUnusedSDKs(&self);
}
impl ::windows::core::RuntimeName for ID3D12SDKConfiguration1 {}
impl ID3D12SDKConfiguration1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12SDKConfiguration1_Impl,
        const OFFSET: isize,
    >() -> ID3D12SDKConfiguration1_Vtbl {
        unsafe extern "system" fn CreateDeviceFactory<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SDKConfiguration1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            sdkversion: u32,
            sdkpath: ::windows::core::PCSTR,
            riid: *const ::windows::core::GUID,
            ppvfactory: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateDeviceFactory(
                ::core::mem::transmute_copy(&sdkversion),
                ::core::mem::transmute(&sdkpath),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvfactory),
            )
            .into()
        }
        unsafe extern "system" fn FreeUnusedSDKs<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SDKConfiguration1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.FreeUnusedSDKs()
        }
        Self {
            base__: ID3D12SDKConfiguration_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateDeviceFactory: CreateDeviceFactory::<Identity, Impl, OFFSET>,
            FreeUnusedSDKs: FreeUnusedSDKs::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12SDKConfiguration1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12SDKConfiguration as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12ShaderCacheSession_Impl: Sized + ID3D12DeviceChild_Impl {
    fn FindValue(
        &self,
        pkey: *const ::core::ffi::c_void,
        keysize: u32,
        pvalue: *mut ::core::ffi::c_void,
        pvaluesize: *mut u32,
    ) -> ::windows::core::Result<()>;
    fn StoreValue(
        &self,
        pkey: *const ::core::ffi::c_void,
        keysize: u32,
        pvalue: *const ::core::ffi::c_void,
        valuesize: u32,
    ) -> ::windows::core::Result<()>;
    fn SetDeleteOnDestroy(&self);
    fn GetDesc(&self) -> D3D12_SHADER_CACHE_SESSION_DESC;
}
impl ::windows::core::RuntimeName for ID3D12ShaderCacheSession {}
impl ID3D12ShaderCacheSession_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12ShaderCacheSession_Impl,
        const OFFSET: isize,
    >() -> ID3D12ShaderCacheSession_Vtbl {
        unsafe extern "system" fn FindValue<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderCacheSession_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pkey: *const ::core::ffi::c_void,
            keysize: u32,
            pvalue: *mut ::core::ffi::c_void,
            pvaluesize: *mut u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.FindValue(
                ::core::mem::transmute_copy(&pkey),
                ::core::mem::transmute_copy(&keysize),
                ::core::mem::transmute_copy(&pvalue),
                ::core::mem::transmute_copy(&pvaluesize),
            )
            .into()
        }
        unsafe extern "system" fn StoreValue<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderCacheSession_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pkey: *const ::core::ffi::c_void,
            keysize: u32,
            pvalue: *const ::core::ffi::c_void,
            valuesize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.StoreValue(
                ::core::mem::transmute_copy(&pkey),
                ::core::mem::transmute_copy(&keysize),
                ::core::mem::transmute_copy(&pvalue),
                ::core::mem::transmute_copy(&valuesize),
            )
            .into()
        }
        unsafe extern "system" fn SetDeleteOnDestroy<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderCacheSession_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetDeleteOnDestroy()
        }
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderCacheSession_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_SHADER_CACHE_SESSION_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        Self {
            base__: ID3D12DeviceChild_Vtbl::new::<Identity, Impl, OFFSET>(),
            FindValue: FindValue::<Identity, Impl, OFFSET>,
            StoreValue: StoreValue::<Identity, Impl, OFFSET>,
            SetDeleteOnDestroy: SetDeleteOnDestroy::<Identity, Impl, OFFSET>,
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12ShaderCacheSession as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12ShaderReflection_Impl: Sized {
    fn GetDesc(&self, pdesc: *mut D3D12_SHADER_DESC) -> ::windows::core::Result<()>;
    fn GetConstantBufferByIndex(
        &self,
        index: u32,
    ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer>;
    fn GetConstantBufferByName(
        &self,
        name: &::windows::core::PCSTR,
    ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer>;
    fn GetResourceBindingDesc(
        &self,
        resourceindex: u32,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::Result<()>;
    fn GetInputParameterDesc(
        &self,
        parameterindex: u32,
        pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
    ) -> ::windows::core::Result<()>;
    fn GetOutputParameterDesc(
        &self,
        parameterindex: u32,
        pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
    ) -> ::windows::core::Result<()>;
    fn GetPatchConstantParameterDesc(
        &self,
        parameterindex: u32,
        pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
    ) -> ::windows::core::Result<()>;
    fn GetVariableByName(
        &self,
        name: &::windows::core::PCSTR,
    ) -> ::core::option::Option<ID3D12ShaderReflectionVariable>;
    fn GetResourceBindingDescByName(
        &self,
        name: &::windows::core::PCSTR,
        pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
    ) -> ::windows::core::Result<()>;
    fn GetMovInstructionCount(&self) -> u32;
    fn GetMovcInstructionCount(&self) -> u32;
    fn GetConversionInstructionCount(&self) -> u32;
    fn GetBitwiseInstructionCount(&self) -> u32;
    fn GetGSInputPrimitive(&self) -> D3D_PRIMITIVE;
    fn IsSampleFrequencyShader(&self) -> ::windows::Win32::Foundation::BOOL;
    fn GetNumInterfaceSlots(&self) -> u32;
    fn GetMinFeatureLevel(&self) -> ::windows::core::Result<D3D_FEATURE_LEVEL>;
    fn GetThreadGroupSize(&self, psizex: *mut u32, psizey: *mut u32, psizez: *mut u32) -> u32;
    fn GetRequiresFlags(&self) -> u64;
}
impl ::windows::core::RuntimeName for ID3D12ShaderReflection {}
impl ID3D12ShaderReflection_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12ShaderReflection_Impl,
        const OFFSET: isize,
    >() -> ID3D12ShaderReflection_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *mut D3D12_SHADER_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetDesc(::core::mem::transmute_copy(&pdesc)).into()
        }
        unsafe extern "system" fn GetConstantBufferByIndex<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            index: u32,
        ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer> {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetConstantBufferByIndex(::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn GetConstantBufferByName<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCSTR,
        ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer> {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetConstantBufferByName(::core::mem::transmute(&name))
        }
        unsafe extern "system" fn GetResourceBindingDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            resourceindex: u32,
            pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetResourceBindingDesc(
                ::core::mem::transmute_copy(&resourceindex),
                ::core::mem::transmute_copy(&pdesc),
            )
            .into()
        }
        unsafe extern "system" fn GetInputParameterDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            parameterindex: u32,
            pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetInputParameterDesc(
                ::core::mem::transmute_copy(&parameterindex),
                ::core::mem::transmute_copy(&pdesc),
            )
            .into()
        }
        unsafe extern "system" fn GetOutputParameterDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            parameterindex: u32,
            pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetOutputParameterDesc(
                ::core::mem::transmute_copy(&parameterindex),
                ::core::mem::transmute_copy(&pdesc),
            )
            .into()
        }
        unsafe extern "system" fn GetPatchConstantParameterDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            parameterindex: u32,
            pdesc: *mut D3D12_SIGNATURE_PARAMETER_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetPatchConstantParameterDesc(
                ::core::mem::transmute_copy(&parameterindex),
                ::core::mem::transmute_copy(&pdesc),
            )
            .into()
        }
        unsafe extern "system" fn GetVariableByName<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCSTR,
        ) -> ::core::option::Option<ID3D12ShaderReflectionVariable> {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetVariableByName(::core::mem::transmute(&name))
        }
        unsafe extern "system" fn GetResourceBindingDescByName<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCSTR,
            pdesc: *mut D3D12_SHADER_INPUT_BIND_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetResourceBindingDescByName(
                ::core::mem::transmute(&name),
                ::core::mem::transmute_copy(&pdesc),
            )
            .into()
        }
        unsafe extern "system" fn GetMovInstructionCount<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetMovInstructionCount()
        }
        unsafe extern "system" fn GetMovcInstructionCount<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetMovcInstructionCount()
        }
        unsafe extern "system" fn GetConversionInstructionCount<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetConversionInstructionCount()
        }
        unsafe extern "system" fn GetBitwiseInstructionCount<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetBitwiseInstructionCount()
        }
        unsafe extern "system" fn GetGSInputPrimitive<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D_PRIMITIVE {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetGSInputPrimitive()
        }
        unsafe extern "system" fn IsSampleFrequencyShader<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::Win32::Foundation::BOOL {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.IsSampleFrequencyShader()
        }
        unsafe extern "system" fn GetNumInterfaceSlots<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNumInterfaceSlots()
        }
        unsafe extern "system" fn GetMinFeatureLevel<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            plevel: *mut D3D_FEATURE_LEVEL,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.GetMinFeatureLevel() {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(plevel, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetThreadGroupSize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            psizex: *mut u32,
            psizey: *mut u32,
            psizez: *mut u32,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetThreadGroupSize(
                ::core::mem::transmute_copy(&psizex),
                ::core::mem::transmute_copy(&psizey),
                ::core::mem::transmute_copy(&psizez),
            )
        }
        unsafe extern "system" fn GetRequiresFlags<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12ShaderReflection_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetRequiresFlags()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
            GetConstantBufferByIndex: GetConstantBufferByIndex::<Identity, Impl, OFFSET>,
            GetConstantBufferByName: GetConstantBufferByName::<Identity, Impl, OFFSET>,
            GetResourceBindingDesc: GetResourceBindingDesc::<Identity, Impl, OFFSET>,
            GetInputParameterDesc: GetInputParameterDesc::<Identity, Impl, OFFSET>,
            GetOutputParameterDesc: GetOutputParameterDesc::<Identity, Impl, OFFSET>,
            GetPatchConstantParameterDesc: GetPatchConstantParameterDesc::<Identity, Impl, OFFSET>,
            GetVariableByName: GetVariableByName::<Identity, Impl, OFFSET>,
            GetResourceBindingDescByName: GetResourceBindingDescByName::<Identity, Impl, OFFSET>,
            GetMovInstructionCount: GetMovInstructionCount::<Identity, Impl, OFFSET>,
            GetMovcInstructionCount: GetMovcInstructionCount::<Identity, Impl, OFFSET>,
            GetConversionInstructionCount: GetConversionInstructionCount::<Identity, Impl, OFFSET>,
            GetBitwiseInstructionCount: GetBitwiseInstructionCount::<Identity, Impl, OFFSET>,
            GetGSInputPrimitive: GetGSInputPrimitive::<Identity, Impl, OFFSET>,
            IsSampleFrequencyShader: IsSampleFrequencyShader::<Identity, Impl, OFFSET>,
            GetNumInterfaceSlots: GetNumInterfaceSlots::<Identity, Impl, OFFSET>,
            GetMinFeatureLevel: GetMinFeatureLevel::<Identity, Impl, OFFSET>,
            GetThreadGroupSize: GetThreadGroupSize::<Identity, Impl, OFFSET>,
            GetRequiresFlags: GetRequiresFlags::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12ShaderReflection as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12ShaderReflectionConstantBuffer_Impl: Sized {
    fn GetDesc(&self, pdesc: *mut D3D12_SHADER_BUFFER_DESC) -> ::windows::core::Result<()>;
    fn GetVariableByIndex(
        &self,
        index: u32,
    ) -> ::core::option::Option<ID3D12ShaderReflectionVariable>;
    fn GetVariableByName(
        &self,
        name: &::windows::core::PCSTR,
    ) -> ::core::option::Option<ID3D12ShaderReflectionVariable>;
}
impl ID3D12ShaderReflectionConstantBuffer_Vtbl {
    pub const fn new<Impl: ID3D12ShaderReflectionConstantBuffer_Impl>(
    ) -> ID3D12ShaderReflectionConstantBuffer_Vtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12ShaderReflectionConstantBuffer_Impl>(
            this: *mut ::core::ffi::c_void,
            pdesc: *mut D3D12_SHADER_BUFFER_DESC,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetDesc(::core::mem::transmute_copy(&pdesc)).into()
        }
        unsafe extern "system" fn GetVariableByIndex<
            Impl: ID3D12ShaderReflectionConstantBuffer_Impl,
        >(
            this: *mut ::core::ffi::c_void,
            index: u32,
        ) -> ::core::option::Option<ID3D12ShaderReflectionVariable> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetVariableByIndex(::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn GetVariableByName<
            Impl: ID3D12ShaderReflectionConstantBuffer_Impl,
        >(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCSTR,
        ) -> ::core::option::Option<ID3D12ShaderReflectionVariable> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetVariableByName(::core::mem::transmute(&name))
        }
        Self {
            GetDesc: GetDesc::<Impl>,
            GetVariableByIndex: GetVariableByIndex::<Impl>,
            GetVariableByName: GetVariableByName::<Impl>,
        }
    }
}
#[doc(hidden)]
struct ID3D12ShaderReflectionConstantBuffer_ImplVtbl<T: ID3D12ShaderReflectionConstantBuffer_Impl>(
    ::std::marker::PhantomData<T>,
);
impl<T: ID3D12ShaderReflectionConstantBuffer_Impl>
    ID3D12ShaderReflectionConstantBuffer_ImplVtbl<T>
{
    const VTABLE: ID3D12ShaderReflectionConstantBuffer_Vtbl =
        ID3D12ShaderReflectionConstantBuffer_Vtbl::new::<T>();
}
impl ID3D12ShaderReflectionConstantBuffer {
    pub fn new<'a, T: ID3D12ShaderReflectionConstantBuffer_Impl>(
        this: &'a T,
    ) -> ::windows::core::ScopedInterface<'a, Self> {
        let this = ::windows::core::ScopedHeap {
            vtable: &ID3D12ShaderReflectionConstantBuffer_ImplVtbl::<T>::VTABLE as *const _
                as *const _,
            this: this as *const _ as *const _,
        };
        let this = ::std::mem::ManuallyDrop::new(::std::boxed::Box::new(this));
        unsafe { ::windows::core::ScopedInterface::new(::std::mem::transmute(&this.vtable)) }
    }
}
pub trait ID3D12ShaderReflectionType_Impl: Sized {
    fn GetDesc(&self, pdesc: *mut D3D12_SHADER_TYPE_DESC) -> ::windows::core::Result<()>;
    fn GetMemberTypeByIndex(
        &self,
        index: u32,
    ) -> ::core::option::Option<ID3D12ShaderReflectionType>;
    fn GetMemberTypeByName(
        &self,
        name: &::windows::core::PCSTR,
    ) -> ::core::option::Option<ID3D12ShaderReflectionType>;
    fn GetMemberTypeName(&self, index: u32) -> ::windows::core::PSTR;
    fn IsEqual(
        &self,
        ptype: ::core::option::Option<&ID3D12ShaderReflectionType>,
    ) -> ::windows::core::Result<()>;
    fn GetSubType(&self) -> ::core::option::Option<ID3D12ShaderReflectionType>;
    fn GetBaseClass(&self) -> ::core::option::Option<ID3D12ShaderReflectionType>;
    fn GetNumInterfaces(&self) -> u32;
    fn GetInterfaceByIndex(
        &self,
        uindex: u32,
    ) -> ::core::option::Option<ID3D12ShaderReflectionType>;
    fn IsOfType(
        &self,
        ptype: ::core::option::Option<&ID3D12ShaderReflectionType>,
    ) -> ::windows::core::Result<()>;
    fn ImplementsInterface(
        &self,
        pbase: ::core::option::Option<&ID3D12ShaderReflectionType>,
    ) -> ::windows::core::Result<()>;
}
impl ID3D12ShaderReflectionType_Vtbl {
    pub const fn new<Impl: ID3D12ShaderReflectionType_Impl>() -> ID3D12ShaderReflectionType_Vtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
            pdesc: *mut D3D12_SHADER_TYPE_DESC,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetDesc(::core::mem::transmute_copy(&pdesc)).into()
        }
        unsafe extern "system" fn GetMemberTypeByIndex<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
            index: u32,
        ) -> ::core::option::Option<ID3D12ShaderReflectionType> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetMemberTypeByIndex(::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn GetMemberTypeByName<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
            name: ::windows::core::PCSTR,
        ) -> ::core::option::Option<ID3D12ShaderReflectionType> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetMemberTypeByName(::core::mem::transmute(&name))
        }
        unsafe extern "system" fn GetMemberTypeName<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
            index: u32,
        ) -> ::windows::core::PSTR {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetMemberTypeName(::core::mem::transmute_copy(&index))
        }
        unsafe extern "system" fn IsEqual<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
            ptype: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.IsEqual(::windows::core::from_raw_borrowed(&ptype))
                .into()
        }
        unsafe extern "system" fn GetSubType<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
        ) -> ::core::option::Option<ID3D12ShaderReflectionType> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetSubType()
        }
        unsafe extern "system" fn GetBaseClass<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
        ) -> ::core::option::Option<ID3D12ShaderReflectionType> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetBaseClass()
        }
        unsafe extern "system" fn GetNumInterfaces<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetNumInterfaces()
        }
        unsafe extern "system" fn GetInterfaceByIndex<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
            uindex: u32,
        ) -> ::core::option::Option<ID3D12ShaderReflectionType> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetInterfaceByIndex(::core::mem::transmute_copy(&uindex))
        }
        unsafe extern "system" fn IsOfType<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
            ptype: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.IsOfType(::windows::core::from_raw_borrowed(&ptype))
                .into()
        }
        unsafe extern "system" fn ImplementsInterface<Impl: ID3D12ShaderReflectionType_Impl>(
            this: *mut ::core::ffi::c_void,
            pbase: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.ImplementsInterface(::windows::core::from_raw_borrowed(&pbase))
                .into()
        }
        Self {
            GetDesc: GetDesc::<Impl>,
            GetMemberTypeByIndex: GetMemberTypeByIndex::<Impl>,
            GetMemberTypeByName: GetMemberTypeByName::<Impl>,
            GetMemberTypeName: GetMemberTypeName::<Impl>,
            IsEqual: IsEqual::<Impl>,
            GetSubType: GetSubType::<Impl>,
            GetBaseClass: GetBaseClass::<Impl>,
            GetNumInterfaces: GetNumInterfaces::<Impl>,
            GetInterfaceByIndex: GetInterfaceByIndex::<Impl>,
            IsOfType: IsOfType::<Impl>,
            ImplementsInterface: ImplementsInterface::<Impl>,
        }
    }
}
#[doc(hidden)]
struct ID3D12ShaderReflectionType_ImplVtbl<T: ID3D12ShaderReflectionType_Impl>(
    ::std::marker::PhantomData<T>,
);
impl<T: ID3D12ShaderReflectionType_Impl> ID3D12ShaderReflectionType_ImplVtbl<T> {
    const VTABLE: ID3D12ShaderReflectionType_Vtbl = ID3D12ShaderReflectionType_Vtbl::new::<T>();
}
impl ID3D12ShaderReflectionType {
    pub fn new<'a, T: ID3D12ShaderReflectionType_Impl>(
        this: &'a T,
    ) -> ::windows::core::ScopedInterface<'a, Self> {
        let this = ::windows::core::ScopedHeap {
            vtable: &ID3D12ShaderReflectionType_ImplVtbl::<T>::VTABLE as *const _ as *const _,
            this: this as *const _ as *const _,
        };
        let this = ::std::mem::ManuallyDrop::new(::std::boxed::Box::new(this));
        unsafe { ::windows::core::ScopedInterface::new(::std::mem::transmute(&this.vtable)) }
    }
}
pub trait ID3D12ShaderReflectionVariable_Impl: Sized {
    fn GetDesc(&self, pdesc: *mut D3D12_SHADER_VARIABLE_DESC) -> ::windows::core::Result<()>;
    fn GetType(&self) -> ::core::option::Option<ID3D12ShaderReflectionType>;
    fn GetBuffer(&self) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer>;
    fn GetInterfaceSlot(&self, uarrayindex: u32) -> u32;
}
impl ID3D12ShaderReflectionVariable_Vtbl {
    pub const fn new<Impl: ID3D12ShaderReflectionVariable_Impl>(
    ) -> ID3D12ShaderReflectionVariable_Vtbl {
        unsafe extern "system" fn GetDesc<Impl: ID3D12ShaderReflectionVariable_Impl>(
            this: *mut ::core::ffi::c_void,
            pdesc: *mut D3D12_SHADER_VARIABLE_DESC,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetDesc(::core::mem::transmute_copy(&pdesc)).into()
        }
        unsafe extern "system" fn GetType<Impl: ID3D12ShaderReflectionVariable_Impl>(
            this: *mut ::core::ffi::c_void,
        ) -> ::core::option::Option<ID3D12ShaderReflectionType> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetType()
        }
        unsafe extern "system" fn GetBuffer<Impl: ID3D12ShaderReflectionVariable_Impl>(
            this: *mut ::core::ffi::c_void,
        ) -> ::core::option::Option<ID3D12ShaderReflectionConstantBuffer> {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetBuffer()
        }
        unsafe extern "system" fn GetInterfaceSlot<Impl: ID3D12ShaderReflectionVariable_Impl>(
            this: *mut ::core::ffi::c_void,
            uarrayindex: u32,
        ) -> u32 {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.GetInterfaceSlot(::core::mem::transmute_copy(&uarrayindex))
        }
        Self {
            GetDesc: GetDesc::<Impl>,
            GetType: GetType::<Impl>,
            GetBuffer: GetBuffer::<Impl>,
            GetInterfaceSlot: GetInterfaceSlot::<Impl>,
        }
    }
}
#[doc(hidden)]
struct ID3D12ShaderReflectionVariable_ImplVtbl<T: ID3D12ShaderReflectionVariable_Impl>(
    ::std::marker::PhantomData<T>,
);
impl<T: ID3D12ShaderReflectionVariable_Impl> ID3D12ShaderReflectionVariable_ImplVtbl<T> {
    const VTABLE: ID3D12ShaderReflectionVariable_Vtbl =
        ID3D12ShaderReflectionVariable_Vtbl::new::<T>();
}
impl ID3D12ShaderReflectionVariable {
    pub fn new<'a, T: ID3D12ShaderReflectionVariable_Impl>(
        this: &'a T,
    ) -> ::windows::core::ScopedInterface<'a, Self> {
        let this = ::windows::core::ScopedHeap {
            vtable: &ID3D12ShaderReflectionVariable_ImplVtbl::<T>::VTABLE as *const _ as *const _,
            this: this as *const _ as *const _,
        };
        let this = ::std::mem::ManuallyDrop::new(::std::boxed::Box::new(this));
        unsafe { ::windows::core::ScopedInterface::new(::std::mem::transmute(&this.vtable)) }
    }
}
pub trait ID3D12SharingContract_Impl: Sized {
    fn Present(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        subresource: u32,
        window: ::windows::Win32::Foundation::HWND,
    );
    fn SharedFenceSignal(&self, pfence: ::core::option::Option<&ID3D12Fence>, fencevalue: u64);
    fn BeginCapturableWork(&self, guid: *const ::windows::core::GUID);
    fn EndCapturableWork(&self, guid: *const ::windows::core::GUID);
}
impl ::windows::core::RuntimeName for ID3D12SharingContract {}
impl ID3D12SharingContract_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12SharingContract_Impl,
        const OFFSET: isize,
    >() -> ID3D12SharingContract_Vtbl {
        unsafe extern "system" fn Present<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SharingContract_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            subresource: u32,
            window: ::windows::Win32::Foundation::HWND,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Present(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&subresource),
                ::core::mem::transmute_copy(&window),
            )
        }
        unsafe extern "system" fn SharedFenceSignal<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SharingContract_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfence: *mut ::core::ffi::c_void,
            fencevalue: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SharedFenceSignal(
                ::windows::core::from_raw_borrowed(&pfence),
                ::core::mem::transmute_copy(&fencevalue),
            )
        }
        unsafe extern "system" fn BeginCapturableWork<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SharingContract_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            guid: *const ::windows::core::GUID,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginCapturableWork(::core::mem::transmute_copy(&guid))
        }
        unsafe extern "system" fn EndCapturableWork<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SharingContract_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            guid: *const ::windows::core::GUID,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndCapturableWork(::core::mem::transmute_copy(&guid))
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            Present: Present::<Identity, Impl, OFFSET>,
            SharedFenceSignal: SharedFenceSignal::<Identity, Impl, OFFSET>,
            BeginCapturableWork: BeginCapturableWork::<Identity, Impl, OFFSET>,
            EndCapturableWork: EndCapturableWork::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12SharingContract as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12StateObject_Impl: Sized + ID3D12Pageable_Impl {}
impl ::windows::core::RuntimeName for ID3D12StateObject {}
impl ID3D12StateObject_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12StateObject_Impl,
        const OFFSET: isize,
    >() -> ID3D12StateObject_Vtbl {
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12StateObject as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12StateObjectProperties_Impl: Sized {
    fn GetShaderIdentifier(
        &self,
        pexportname: &::windows::core::PCWSTR,
    ) -> *mut ::core::ffi::c_void;
    fn GetShaderStackSize(&self, pexportname: &::windows::core::PCWSTR) -> u64;
    fn GetPipelineStackSize(&self) -> u64;
    fn SetPipelineStackSize(&self, pipelinestacksizeinbytes: u64);
}
impl ::windows::core::RuntimeName for ID3D12StateObjectProperties {}
impl ID3D12StateObjectProperties_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12StateObjectProperties_Impl,
        const OFFSET: isize,
    >() -> ID3D12StateObjectProperties_Vtbl {
        unsafe extern "system" fn GetShaderIdentifier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12StateObjectProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pexportname: ::windows::core::PCWSTR,
        ) -> *mut ::core::ffi::c_void {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetShaderIdentifier(::core::mem::transmute(&pexportname))
        }
        unsafe extern "system" fn GetShaderStackSize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12StateObjectProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pexportname: ::windows::core::PCWSTR,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetShaderStackSize(::core::mem::transmute(&pexportname))
        }
        unsafe extern "system" fn GetPipelineStackSize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12StateObjectProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u64 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetPipelineStackSize()
        }
        unsafe extern "system" fn SetPipelineStackSize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12StateObjectProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pipelinestacksizeinbytes: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetPipelineStackSize(::core::mem::transmute_copy(&pipelinestacksizeinbytes))
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetShaderIdentifier: GetShaderIdentifier::<Identity, Impl, OFFSET>,
            GetShaderStackSize: GetShaderStackSize::<Identity, Impl, OFFSET>,
            GetPipelineStackSize: GetPipelineStackSize::<Identity, Impl, OFFSET>,
            SetPipelineStackSize: SetPipelineStackSize::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12StateObjectProperties as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12StateObjectProperties1_Impl: Sized + ID3D12StateObjectProperties_Impl {
    fn GetProgramIdentifier(
        &self,
        pprogramname: &::windows::core::PCWSTR,
    ) -> D3D12_PROGRAM_IDENTIFIER;
}
impl ::windows::core::RuntimeName for ID3D12StateObjectProperties1 {}
impl ID3D12StateObjectProperties1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12StateObjectProperties1_Impl,
        const OFFSET: isize,
    >() -> ID3D12StateObjectProperties1_Vtbl {
        unsafe extern "system" fn GetProgramIdentifier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12StateObjectProperties1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_PROGRAM_IDENTIFIER,
            pprogramname: ::windows::core::PCWSTR,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetProgramIdentifier(::core::mem::transmute(&pprogramname))
        }
        Self {
            base__: ID3D12StateObjectProperties_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetProgramIdentifier: GetProgramIdentifier::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12StateObjectProperties1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12StateObjectProperties as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12SwapChainAssistant_Impl: Sized {
    fn GetLUID(&self) -> ::windows::Win32::Foundation::LUID;
    fn GetSwapChainObject(
        &self,
        riid: *const ::windows::core::GUID,
        ppv: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn GetCurrentResourceAndCommandQueue(
        &self,
        riidresource: *const ::windows::core::GUID,
        ppvresource: *mut *mut ::core::ffi::c_void,
        riidqueue: *const ::windows::core::GUID,
        ppvqueue: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn InsertImplicitSync(&self) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12SwapChainAssistant {}
impl ID3D12SwapChainAssistant_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12SwapChainAssistant_Impl,
        const OFFSET: isize,
    >() -> ID3D12SwapChainAssistant_Vtbl {
        unsafe extern "system" fn GetLUID<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SwapChainAssistant_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut ::windows::Win32::Foundation::LUID,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetLUID()
        }
        unsafe extern "system" fn GetSwapChainObject<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SwapChainAssistant_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppv: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetSwapChainObject(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppv),
            )
            .into()
        }
        unsafe extern "system" fn GetCurrentResourceAndCommandQueue<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SwapChainAssistant_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riidresource: *const ::windows::core::GUID,
            ppvresource: *mut *mut ::core::ffi::c_void,
            riidqueue: *const ::windows::core::GUID,
            ppvqueue: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCurrentResourceAndCommandQueue(
                ::core::mem::transmute_copy(&riidresource),
                ::core::mem::transmute_copy(&ppvresource),
                ::core::mem::transmute_copy(&riidqueue),
                ::core::mem::transmute_copy(&ppvqueue),
            )
            .into()
        }
        unsafe extern "system" fn InsertImplicitSync<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12SwapChainAssistant_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.InsertImplicitSync().into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetLUID: GetLUID::<Identity, Impl, OFFSET>,
            GetSwapChainObject: GetSwapChainObject::<Identity, Impl, OFFSET>,
            GetCurrentResourceAndCommandQueue: GetCurrentResourceAndCommandQueue::<
                Identity,
                Impl,
                OFFSET,
            >,
            InsertImplicitSync: InsertImplicitSync::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12SwapChainAssistant as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12Tools_Impl: Sized {
    fn EnableShaderInstrumentation(&self, benable: ::windows::Win32::Foundation::BOOL);
    fn ShaderInstrumentationEnabled(&self) -> ::windows::Win32::Foundation::BOOL;
}
impl ::windows::core::RuntimeName for ID3D12Tools {}
impl ID3D12Tools_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12Tools_Impl,
        const OFFSET: isize,
    >() -> ID3D12Tools_Vtbl {
        unsafe extern "system" fn EnableShaderInstrumentation<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Tools_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            benable: ::windows::Win32::Foundation::BOOL,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EnableShaderInstrumentation(::core::mem::transmute_copy(&benable))
        }
        unsafe extern "system" fn ShaderInstrumentationEnabled<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12Tools_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::Win32::Foundation::BOOL {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ShaderInstrumentationEnabled()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            EnableShaderInstrumentation: EnableShaderInstrumentation::<Identity, Impl, OFFSET>,
            ShaderInstrumentationEnabled: ShaderInstrumentationEnabled::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12Tools as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VersionedRootSignatureDeserializer_Impl: Sized {
    fn GetRootSignatureDescAtVersion(
        &self,
        converttoversion: D3D_ROOT_SIGNATURE_VERSION,
    ) -> ::windows::core::Result<*mut D3D12_VERSIONED_ROOT_SIGNATURE_DESC>;
    fn GetUnconvertedRootSignatureDesc(&self) -> *mut D3D12_VERSIONED_ROOT_SIGNATURE_DESC;
}
impl ::windows::core::RuntimeName for ID3D12VersionedRootSignatureDeserializer {}
impl ID3D12VersionedRootSignatureDeserializer_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VersionedRootSignatureDeserializer_Impl,
        const OFFSET: isize,
    >() -> ID3D12VersionedRootSignatureDeserializer_Vtbl {
        unsafe extern "system" fn GetRootSignatureDescAtVersion<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VersionedRootSignatureDeserializer_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            converttoversion: D3D_ROOT_SIGNATURE_VERSION,
            ppdesc: *mut *mut D3D12_VERSIONED_ROOT_SIGNATURE_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.GetRootSignatureDescAtVersion(::core::mem::transmute_copy(&converttoversion))
            {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(ppdesc, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn GetUnconvertedRootSignatureDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VersionedRootSignatureDeserializer_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> *mut D3D12_VERSIONED_ROOT_SIGNATURE_DESC {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetUnconvertedRootSignatureDesc()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetRootSignatureDescAtVersion: GetRootSignatureDescAtVersion::<Identity, Impl, OFFSET>,
            GetUnconvertedRootSignatureDesc: GetUnconvertedRootSignatureDesc::<
                Identity,
                Impl,
                OFFSET,
            >,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VersionedRootSignatureDeserializer as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDecodeCommandList_Impl: Sized + ID3D12CommandList_Impl {
    fn Close(&self) -> ::windows::core::Result<()>;
    fn Reset(
        &self,
        pallocator: ::core::option::Option<&ID3D12CommandAllocator>,
    ) -> ::windows::core::Result<()>;
    fn ClearState(&self);
    fn ResourceBarrier(&self, numbarriers: u32, pbarriers: *const D3D12_RESOURCE_BARRIER);
    fn DiscardResource(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        pregion: *const D3D12_DISCARD_REGION,
    );
    fn BeginQuery(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    );
    fn EndQuery(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    );
    fn ResolveQueryData(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: ::core::option::Option<&ID3D12Resource>,
        aligneddestinationbufferoffset: u64,
    );
    fn SetPredication(
        &self,
        pbuffer: ::core::option::Option<&ID3D12Resource>,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    );
    fn SetMarker(&self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn BeginEvent(&self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn EndEvent(&self);
    fn DecodeFrame(
        &self,
        pdecoder: ::core::option::Option<&ID3D12VideoDecoder>,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    );
    fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
    );
}
impl ::windows::core::RuntimeName for ID3D12VideoDecodeCommandList {}
impl ID3D12VideoDecodeCommandList_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDecodeCommandList_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDecodeCommandList_Vtbl {
        unsafe extern "system" fn Close<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Close().into()
        }
        unsafe extern "system" fn Reset<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pallocator: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset(::windows::core::from_raw_borrowed(&pallocator))
                .into()
        }
        unsafe extern "system" fn ClearState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearState()
        }
        unsafe extern "system" fn ResourceBarrier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numbarriers: u32,
            pbarriers: *const D3D12_RESOURCE_BARRIER,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResourceBarrier(
                ::core::mem::transmute_copy(&numbarriers),
                ::core::mem::transmute_copy(&pbarriers),
            )
        }
        unsafe extern "system" fn DiscardResource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            pregion: *const D3D12_DISCARD_REGION,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DiscardResource(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&pregion),
            )
        }
        unsafe extern "system" fn BeginQuery<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            index: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginQuery(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&index),
            )
        }
        unsafe extern "system" fn EndQuery<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            index: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndQuery(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&index),
            )
        }
        unsafe extern "system" fn ResolveQueryData<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            startindex: u32,
            numqueries: u32,
            pdestinationbuffer: *mut ::core::ffi::c_void,
            aligneddestinationbufferoffset: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResolveQueryData(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&startindex),
                ::core::mem::transmute_copy(&numqueries),
                ::windows::core::from_raw_borrowed(&pdestinationbuffer),
                ::core::mem::transmute_copy(&aligneddestinationbufferoffset),
            )
        }
        unsafe extern "system" fn SetPredication<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pbuffer: *mut ::core::ffi::c_void,
            alignedbufferoffset: u64,
            operation: D3D12_PREDICATION_OP,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetPredication(
                ::windows::core::from_raw_borrowed(&pbuffer),
                ::core::mem::transmute_copy(&alignedbufferoffset),
                ::core::mem::transmute_copy(&operation),
            )
        }
        unsafe extern "system" fn SetMarker<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            metadata: u32,
            pdata: *const ::core::ffi::c_void,
            size: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetMarker(
                ::core::mem::transmute_copy(&metadata),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&size),
            )
        }
        unsafe extern "system" fn BeginEvent<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            metadata: u32,
            pdata: *const ::core::ffi::c_void,
            size: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginEvent(
                ::core::mem::transmute_copy(&metadata),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&size),
            )
        }
        unsafe extern "system" fn EndEvent<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndEvent()
        }
        unsafe extern "system" fn DecodeFrame<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdecoder: *mut ::core::ffi::c_void,
            poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS,
            pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DecodeFrame(
                ::windows::core::from_raw_borrowed(&pdecoder),
                ::core::mem::transmute_copy(&poutputarguments),
                ::core::mem::transmute_copy(&pinputarguments),
            )
        }
        unsafe extern "system" fn WriteBufferImmediate<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            count: u32,
            pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
            pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.WriteBufferImmediate(
                ::core::mem::transmute_copy(&count),
                ::core::mem::transmute_copy(&pparams),
                ::core::mem::transmute_copy(&pmodes),
            )
        }
        Self {
            base__: ID3D12CommandList_Vtbl::new::<Identity, Impl, OFFSET>(),
            Close: Close::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            ClearState: ClearState::<Identity, Impl, OFFSET>,
            ResourceBarrier: ResourceBarrier::<Identity, Impl, OFFSET>,
            DiscardResource: DiscardResource::<Identity, Impl, OFFSET>,
            BeginQuery: BeginQuery::<Identity, Impl, OFFSET>,
            EndQuery: EndQuery::<Identity, Impl, OFFSET>,
            ResolveQueryData: ResolveQueryData::<Identity, Impl, OFFSET>,
            SetPredication: SetPredication::<Identity, Impl, OFFSET>,
            SetMarker: SetMarker::<Identity, Impl, OFFSET>,
            BeginEvent: BeginEvent::<Identity, Impl, OFFSET>,
            EndEvent: EndEvent::<Identity, Impl, OFFSET>,
            DecodeFrame: DecodeFrame::<Identity, Impl, OFFSET>,
            WriteBufferImmediate: WriteBufferImmediate::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDecodeCommandList1_Impl: Sized + ID3D12VideoDecodeCommandList_Impl {
    fn DecodeFrame1(
        &self,
        pdecoder: ::core::option::Option<&ID3D12VideoDecoder>,
        poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1,
        pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
    );
}
impl ::windows::core::RuntimeName for ID3D12VideoDecodeCommandList1 {}
impl ID3D12VideoDecodeCommandList1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDecodeCommandList1_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDecodeCommandList1_Vtbl {
        unsafe extern "system" fn DecodeFrame1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdecoder: *mut ::core::ffi::c_void,
            poutputarguments: *const D3D12_VIDEO_DECODE_OUTPUT_STREAM_ARGUMENTS1,
            pinputarguments: *const D3D12_VIDEO_DECODE_INPUT_STREAM_ARGUMENTS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DecodeFrame1(
                ::windows::core::from_raw_borrowed(&pdecoder),
                ::core::mem::transmute_copy(&poutputarguments),
                ::core::mem::transmute_copy(&pinputarguments),
            )
        }
        Self {
            base__: ID3D12VideoDecodeCommandList_Vtbl::new::<Identity, Impl, OFFSET>(),
            DecodeFrame1: DecodeFrame1::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDecodeCommandList as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDecodeCommandList2_Impl: Sized + ID3D12VideoDecodeCommandList1_Impl {
    fn SetProtectedResourceSession(
        &self,
        pprotectedresourcesession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
    );
    fn InitializeExtensionCommand(
        &self,
        pextensioncommand: ::core::option::Option<&ID3D12VideoExtensionCommand>,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    );
    fn ExecuteExtensionCommand(
        &self,
        pextensioncommand: ::core::option::Option<&ID3D12VideoExtensionCommand>,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    );
}
impl ::windows::core::RuntimeName for ID3D12VideoDecodeCommandList2 {}
impl ID3D12VideoDecodeCommandList2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDecodeCommandList2_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDecodeCommandList2_Vtbl {
        unsafe extern "system" fn SetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pprotectedresourcesession: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetProtectedResourceSession(::windows::core::from_raw_borrowed(
                &pprotectedresourcesession,
            ))
        }
        unsafe extern "system" fn InitializeExtensionCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pextensioncommand: *mut ::core::ffi::c_void,
            pinitializationparameters: *const ::core::ffi::c_void,
            initializationparameterssizeinbytes: usize,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.InitializeExtensionCommand(
                ::windows::core::from_raw_borrowed(&pextensioncommand),
                ::core::mem::transmute_copy(&pinitializationparameters),
                ::core::mem::transmute_copy(&initializationparameterssizeinbytes),
            )
        }
        unsafe extern "system" fn ExecuteExtensionCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pextensioncommand: *mut ::core::ffi::c_void,
            pexecutionparameters: *const ::core::ffi::c_void,
            executionparameterssizeinbytes: usize,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ExecuteExtensionCommand(
                ::windows::core::from_raw_borrowed(&pextensioncommand),
                ::core::mem::transmute_copy(&pexecutionparameters),
                ::core::mem::transmute_copy(&executionparameterssizeinbytes),
            )
        }
        Self {
            base__: ID3D12VideoDecodeCommandList1_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetProtectedResourceSession: SetProtectedResourceSession::<Identity, Impl, OFFSET>,
            InitializeExtensionCommand: InitializeExtensionCommand::<Identity, Impl, OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDecodeCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDecodeCommandList1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDecodeCommandList3_Impl: Sized + ID3D12VideoDecodeCommandList2_Impl {
    fn Barrier(&self, numbarriergroups: u32, pbarriergroups: *const D3D12_BARRIER_GROUP);
}
impl ::windows::core::RuntimeName for ID3D12VideoDecodeCommandList3 {}
impl ID3D12VideoDecodeCommandList3_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDecodeCommandList3_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDecodeCommandList3_Vtbl {
        unsafe extern "system" fn Barrier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecodeCommandList3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numbarriergroups: u32,
            pbarriergroups: *const D3D12_BARRIER_GROUP,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Barrier(
                ::core::mem::transmute_copy(&numbarriergroups),
                ::core::mem::transmute_copy(&pbarriergroups),
            )
        }
        Self {
            base__: ID3D12VideoDecodeCommandList2_Vtbl::new::<Identity, Impl, OFFSET>(),
            Barrier: Barrier::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecodeCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDecodeCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDecodeCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDecodeCommandList2 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDecoder_Impl: Sized + ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_VIDEO_DECODER_DESC;
}
impl ::windows::core::RuntimeName for ID3D12VideoDecoder {}
impl ID3D12VideoDecoder_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDecoder_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDecoder_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecoder_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_VIDEO_DECODER_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecoder as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDecoder1_Impl: Sized + ID3D12VideoDecoder_Impl {
    fn GetProtectedResourceSession(
        &self,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoDecoder1 {}
impl ID3D12VideoDecoder1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDecoder1_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDecoder1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecoder1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppprotectedsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetProtectedResourceSession(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppprotectedsession),
            )
            .into()
        }
        Self {
            base__: ID3D12VideoDecoder_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecoder1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDecoder as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDecoderHeap_Impl: Sized + ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_VIDEO_DECODER_HEAP_DESC;
}
impl ::windows::core::RuntimeName for ID3D12VideoDecoderHeap {}
impl ID3D12VideoDecoderHeap_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDecoderHeap_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDecoderHeap_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecoderHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_VIDEO_DECODER_HEAP_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecoderHeap as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDecoderHeap1_Impl: Sized + ID3D12VideoDecoderHeap_Impl {
    fn GetProtectedResourceSession(
        &self,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoDecoderHeap1 {}
impl ID3D12VideoDecoderHeap1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDecoderHeap1_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDecoderHeap1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDecoderHeap1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppprotectedsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetProtectedResourceSession(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppprotectedsession),
            )
            .into()
        }
        Self {
            base__: ID3D12VideoDecoderHeap_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDecoderHeap1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDecoderHeap as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDevice_Impl: Sized {
    fn CheckFeatureSupport(
        &self,
        featurevideo: D3D12_FEATURE_VIDEO,
        pfeaturesupportdata: *mut ::core::ffi::c_void,
        featuresupportdatasize: u32,
    ) -> ::windows::core::Result<()>;
    fn CreateVideoDecoder(
        &self,
        pdesc: *const D3D12_VIDEO_DECODER_DESC,
        riid: *const ::windows::core::GUID,
        ppvideodecoder: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateVideoDecoderHeap(
        &self,
        pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
        riid: *const ::windows::core::GUID,
        ppvideodecoderheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateVideoProcessor(
        &self,
        nodemask: u32,
        poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        numinputstreamdescs: u32,
        pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
        riid: *const ::windows::core::GUID,
        ppvideoprocessor: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoDevice {}
impl ID3D12VideoDevice_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDevice_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDevice_Vtbl {
        unsafe extern "system" fn CheckFeatureSupport<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            featurevideo: D3D12_FEATURE_VIDEO,
            pfeaturesupportdata: *mut ::core::ffi::c_void,
            featuresupportdatasize: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CheckFeatureSupport(
                ::core::mem::transmute_copy(&featurevideo),
                ::core::mem::transmute_copy(&pfeaturesupportdata),
                ::core::mem::transmute_copy(&featuresupportdatasize),
            )
            .into()
        }
        unsafe extern "system" fn CreateVideoDecoder<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_VIDEO_DECODER_DESC,
            riid: *const ::windows::core::GUID,
            ppvideodecoder: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoDecoder(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideodecoder),
            )
            .into()
        }
        unsafe extern "system" fn CreateVideoDecoderHeap<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
            riid: *const ::windows::core::GUID,
            ppvideodecoderheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoDecoderHeap(
                ::core::mem::transmute_copy(&pvideodecoderheapdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideodecoderheap),
            )
            .into()
        }
        unsafe extern "system" fn CreateVideoProcessor<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            nodemask: u32,
            poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
            numinputstreamdescs: u32,
            pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
            riid: *const ::windows::core::GUID,
            ppvideoprocessor: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoProcessor(
                ::core::mem::transmute_copy(&nodemask),
                ::core::mem::transmute_copy(&poutputstreamdesc),
                ::core::mem::transmute_copy(&numinputstreamdescs),
                ::core::mem::transmute_copy(&pinputstreamdescs),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideoprocessor),
            )
            .into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            CheckFeatureSupport: CheckFeatureSupport::<Identity, Impl, OFFSET>,
            CreateVideoDecoder: CreateVideoDecoder::<Identity, Impl, OFFSET>,
            CreateVideoDecoderHeap: CreateVideoDecoderHeap::<Identity, Impl, OFFSET>,
            CreateVideoProcessor: CreateVideoProcessor::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDevice as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDevice1_Impl: Sized + ID3D12VideoDevice_Impl {
    fn CreateVideoMotionEstimator(
        &self,
        pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
        pprotectedresourcesession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        riid: *const ::windows::core::GUID,
        ppvideomotionestimator: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateVideoMotionVectorHeap(
        &self,
        pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
        pprotectedresourcesession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        riid: *const ::windows::core::GUID,
        ppvideomotionvectorheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoDevice1 {}
impl ID3D12VideoDevice1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDevice1_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDevice1_Vtbl {
        unsafe extern "system" fn CreateVideoMotionEstimator<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
            pprotectedresourcesession: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvideomotionestimator: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoMotionEstimator(
                ::core::mem::transmute_copy(&pdesc),
                ::windows::core::from_raw_borrowed(&pprotectedresourcesession),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideomotionestimator),
            )
            .into()
        }
        unsafe extern "system" fn CreateVideoMotionVectorHeap<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
            pprotectedresourcesession: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvideomotionvectorheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoMotionVectorHeap(
                ::core::mem::transmute_copy(&pdesc),
                ::windows::core::from_raw_borrowed(&pprotectedresourcesession),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideomotionvectorheap),
            )
            .into()
        }
        Self {
            base__: ID3D12VideoDevice_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateVideoMotionEstimator: CreateVideoMotionEstimator::<Identity, Impl, OFFSET>,
            CreateVideoMotionVectorHeap: CreateVideoMotionVectorHeap::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDevice1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDevice as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDevice2_Impl: Sized + ID3D12VideoDevice1_Impl {
    fn CreateVideoDecoder1(
        &self,
        pdesc: *const D3D12_VIDEO_DECODER_DESC,
        pprotectedresourcesession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        riid: *const ::windows::core::GUID,
        ppvideodecoder: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateVideoDecoderHeap1(
        &self,
        pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
        pprotectedresourcesession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        riid: *const ::windows::core::GUID,
        ppvideodecoderheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateVideoProcessor1(
        &self,
        nodemask: u32,
        poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        numinputstreamdescs: u32,
        pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
        pprotectedresourcesession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        riid: *const ::windows::core::GUID,
        ppvideoprocessor: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateVideoExtensionCommand(
        &self,
        pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC,
        pcreationparameters: *const ::core::ffi::c_void,
        creationparametersdatasizeinbytes: usize,
        pprotectedresourcesession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
        riid: *const ::windows::core::GUID,
        ppvideoextensioncommand: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn ExecuteExtensionCommand(
        &self,
        pextensioncommand: ::core::option::Option<&ID3D12VideoExtensionCommand>,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
        poutputdata: *mut ::core::ffi::c_void,
        outputdatasizeinbytes: usize,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoDevice2 {}
impl ID3D12VideoDevice2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDevice2_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDevice2_Vtbl {
        unsafe extern "system" fn CreateVideoDecoder1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_VIDEO_DECODER_DESC,
            pprotectedresourcesession: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvideodecoder: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoDecoder1(
                ::core::mem::transmute_copy(&pdesc),
                ::windows::core::from_raw_borrowed(&pprotectedresourcesession),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideodecoder),
            )
            .into()
        }
        unsafe extern "system" fn CreateVideoDecoderHeap1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pvideodecoderheapdesc: *const D3D12_VIDEO_DECODER_HEAP_DESC,
            pprotectedresourcesession: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvideodecoderheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoDecoderHeap1(
                ::core::mem::transmute_copy(&pvideodecoderheapdesc),
                ::windows::core::from_raw_borrowed(&pprotectedresourcesession),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideodecoderheap),
            )
            .into()
        }
        unsafe extern "system" fn CreateVideoProcessor1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            nodemask: u32,
            poutputstreamdesc: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
            numinputstreamdescs: u32,
            pinputstreamdescs: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
            pprotectedresourcesession: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvideoprocessor: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoProcessor1(
                ::core::mem::transmute_copy(&nodemask),
                ::core::mem::transmute_copy(&poutputstreamdesc),
                ::core::mem::transmute_copy(&numinputstreamdescs),
                ::core::mem::transmute_copy(&pinputstreamdescs),
                ::windows::core::from_raw_borrowed(&pprotectedresourcesession),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideoprocessor),
            )
            .into()
        }
        unsafe extern "system" fn CreateVideoExtensionCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_VIDEO_EXTENSION_COMMAND_DESC,
            pcreationparameters: *const ::core::ffi::c_void,
            creationparametersdatasizeinbytes: usize,
            pprotectedresourcesession: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppvideoextensioncommand: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoExtensionCommand(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&pcreationparameters),
                ::core::mem::transmute_copy(&creationparametersdatasizeinbytes),
                ::windows::core::from_raw_borrowed(&pprotectedresourcesession),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideoextensioncommand),
            )
            .into()
        }
        unsafe extern "system" fn ExecuteExtensionCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pextensioncommand: *mut ::core::ffi::c_void,
            pexecutionparameters: *const ::core::ffi::c_void,
            executionparameterssizeinbytes: usize,
            poutputdata: *mut ::core::ffi::c_void,
            outputdatasizeinbytes: usize,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ExecuteExtensionCommand(
                ::windows::core::from_raw_borrowed(&pextensioncommand),
                ::core::mem::transmute_copy(&pexecutionparameters),
                ::core::mem::transmute_copy(&executionparameterssizeinbytes),
                ::core::mem::transmute_copy(&poutputdata),
                ::core::mem::transmute_copy(&outputdatasizeinbytes),
            )
            .into()
        }
        Self {
            base__: ID3D12VideoDevice1_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateVideoDecoder1: CreateVideoDecoder1::<Identity, Impl, OFFSET>,
            CreateVideoDecoderHeap1: CreateVideoDecoderHeap1::<Identity, Impl, OFFSET>,
            CreateVideoProcessor1: CreateVideoProcessor1::<Identity, Impl, OFFSET>,
            CreateVideoExtensionCommand: CreateVideoExtensionCommand::<Identity, Impl, OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDevice2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDevice as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDevice1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoDevice3_Impl: Sized + ID3D12VideoDevice2_Impl {
    fn CreateVideoEncoder(
        &self,
        pdesc: *const D3D12_VIDEO_ENCODER_DESC,
        riid: *const ::windows::core::GUID,
        ppvideoencoder: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
    fn CreateVideoEncoderHeap(
        &self,
        pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC,
        riid: *const ::windows::core::GUID,
        ppvideoencoderheap: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoDevice3 {}
impl ID3D12VideoDevice3_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoDevice3_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoDevice3_Vtbl {
        unsafe extern "system" fn CreateVideoEncoder<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_VIDEO_ENCODER_DESC,
            riid: *const ::windows::core::GUID,
            ppvideoencoder: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoEncoder(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideoencoder),
            )
            .into()
        }
        unsafe extern "system" fn CreateVideoEncoderHeap<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoDevice3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pdesc: *const D3D12_VIDEO_ENCODER_HEAP_DESC,
            riid: *const ::windows::core::GUID,
            ppvideoencoderheap: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.CreateVideoEncoderHeap(
                ::core::mem::transmute_copy(&pdesc),
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppvideoencoderheap),
            )
            .into()
        }
        Self {
            base__: ID3D12VideoDevice2_Vtbl::new::<Identity, Impl, OFFSET>(),
            CreateVideoEncoder: CreateVideoEncoder::<Identity, Impl, OFFSET>,
            CreateVideoEncoderHeap: CreateVideoEncoderHeap::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoDevice3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDevice as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDevice1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoDevice2 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoEncodeCommandList_Impl: Sized + ID3D12CommandList_Impl {
    fn Close(&self) -> ::windows::core::Result<()>;
    fn Reset(
        &self,
        pallocator: ::core::option::Option<&ID3D12CommandAllocator>,
    ) -> ::windows::core::Result<()>;
    fn ClearState(&self);
    fn ResourceBarrier(&self, numbarriers: u32, pbarriers: *const D3D12_RESOURCE_BARRIER);
    fn DiscardResource(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        pregion: *const D3D12_DISCARD_REGION,
    );
    fn BeginQuery(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    );
    fn EndQuery(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    );
    fn ResolveQueryData(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: ::core::option::Option<&ID3D12Resource>,
        aligneddestinationbufferoffset: u64,
    );
    fn SetPredication(
        &self,
        pbuffer: ::core::option::Option<&ID3D12Resource>,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    );
    fn SetMarker(&self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn BeginEvent(&self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn EndEvent(&self);
    fn EstimateMotion(
        &self,
        pmotionestimator: ::core::option::Option<&ID3D12VideoMotionEstimator>,
        poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT,
        pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT,
    );
    fn ResolveMotionVectorHeap(
        &self,
        poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT,
        pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT,
    );
    fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
    );
    fn SetProtectedResourceSession(
        &self,
        pprotectedresourcesession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
    );
}
impl ::windows::core::RuntimeName for ID3D12VideoEncodeCommandList {}
impl ID3D12VideoEncodeCommandList_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoEncodeCommandList_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoEncodeCommandList_Vtbl {
        unsafe extern "system" fn Close<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Close().into()
        }
        unsafe extern "system" fn Reset<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pallocator: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset(::windows::core::from_raw_borrowed(&pallocator))
                .into()
        }
        unsafe extern "system" fn ClearState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearState()
        }
        unsafe extern "system" fn ResourceBarrier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numbarriers: u32,
            pbarriers: *const D3D12_RESOURCE_BARRIER,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResourceBarrier(
                ::core::mem::transmute_copy(&numbarriers),
                ::core::mem::transmute_copy(&pbarriers),
            )
        }
        unsafe extern "system" fn DiscardResource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            pregion: *const D3D12_DISCARD_REGION,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DiscardResource(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&pregion),
            )
        }
        unsafe extern "system" fn BeginQuery<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            index: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginQuery(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&index),
            )
        }
        unsafe extern "system" fn EndQuery<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            index: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndQuery(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&index),
            )
        }
        unsafe extern "system" fn ResolveQueryData<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            startindex: u32,
            numqueries: u32,
            pdestinationbuffer: *mut ::core::ffi::c_void,
            aligneddestinationbufferoffset: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResolveQueryData(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&startindex),
                ::core::mem::transmute_copy(&numqueries),
                ::windows::core::from_raw_borrowed(&pdestinationbuffer),
                ::core::mem::transmute_copy(&aligneddestinationbufferoffset),
            )
        }
        unsafe extern "system" fn SetPredication<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pbuffer: *mut ::core::ffi::c_void,
            alignedbufferoffset: u64,
            operation: D3D12_PREDICATION_OP,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetPredication(
                ::windows::core::from_raw_borrowed(&pbuffer),
                ::core::mem::transmute_copy(&alignedbufferoffset),
                ::core::mem::transmute_copy(&operation),
            )
        }
        unsafe extern "system" fn SetMarker<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            metadata: u32,
            pdata: *const ::core::ffi::c_void,
            size: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetMarker(
                ::core::mem::transmute_copy(&metadata),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&size),
            )
        }
        unsafe extern "system" fn BeginEvent<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            metadata: u32,
            pdata: *const ::core::ffi::c_void,
            size: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginEvent(
                ::core::mem::transmute_copy(&metadata),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&size),
            )
        }
        unsafe extern "system" fn EndEvent<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndEvent()
        }
        unsafe extern "system" fn EstimateMotion<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pmotionestimator: *mut ::core::ffi::c_void,
            poutputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_OUTPUT,
            pinputarguments: *const D3D12_VIDEO_MOTION_ESTIMATOR_INPUT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EstimateMotion(
                ::windows::core::from_raw_borrowed(&pmotionestimator),
                ::core::mem::transmute_copy(&poutputarguments),
                ::core::mem::transmute_copy(&pinputarguments),
            )
        }
        unsafe extern "system" fn ResolveMotionVectorHeap<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            poutputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_OUTPUT,
            pinputarguments: *const D3D12_RESOLVE_VIDEO_MOTION_VECTOR_HEAP_INPUT,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResolveMotionVectorHeap(
                ::core::mem::transmute_copy(&poutputarguments),
                ::core::mem::transmute_copy(&pinputarguments),
            )
        }
        unsafe extern "system" fn WriteBufferImmediate<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            count: u32,
            pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
            pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.WriteBufferImmediate(
                ::core::mem::transmute_copy(&count),
                ::core::mem::transmute_copy(&pparams),
                ::core::mem::transmute_copy(&pmodes),
            )
        }
        unsafe extern "system" fn SetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pprotectedresourcesession: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetProtectedResourceSession(::windows::core::from_raw_borrowed(
                &pprotectedresourcesession,
            ))
        }
        Self {
            base__: ID3D12CommandList_Vtbl::new::<Identity, Impl, OFFSET>(),
            Close: Close::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            ClearState: ClearState::<Identity, Impl, OFFSET>,
            ResourceBarrier: ResourceBarrier::<Identity, Impl, OFFSET>,
            DiscardResource: DiscardResource::<Identity, Impl, OFFSET>,
            BeginQuery: BeginQuery::<Identity, Impl, OFFSET>,
            EndQuery: EndQuery::<Identity, Impl, OFFSET>,
            ResolveQueryData: ResolveQueryData::<Identity, Impl, OFFSET>,
            SetPredication: SetPredication::<Identity, Impl, OFFSET>,
            SetMarker: SetMarker::<Identity, Impl, OFFSET>,
            BeginEvent: BeginEvent::<Identity, Impl, OFFSET>,
            EndEvent: EndEvent::<Identity, Impl, OFFSET>,
            EstimateMotion: EstimateMotion::<Identity, Impl, OFFSET>,
            ResolveMotionVectorHeap: ResolveMotionVectorHeap::<Identity, Impl, OFFSET>,
            WriteBufferImmediate: WriteBufferImmediate::<Identity, Impl, OFFSET>,
            SetProtectedResourceSession: SetProtectedResourceSession::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoEncodeCommandList1_Impl: Sized + ID3D12VideoEncodeCommandList_Impl {
    fn InitializeExtensionCommand(
        &self,
        pextensioncommand: ::core::option::Option<&ID3D12VideoExtensionCommand>,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    );
    fn ExecuteExtensionCommand(
        &self,
        pextensioncommand: ::core::option::Option<&ID3D12VideoExtensionCommand>,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    );
}
impl ::windows::core::RuntimeName for ID3D12VideoEncodeCommandList1 {}
impl ID3D12VideoEncodeCommandList1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoEncodeCommandList1_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoEncodeCommandList1_Vtbl {
        unsafe extern "system" fn InitializeExtensionCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pextensioncommand: *mut ::core::ffi::c_void,
            pinitializationparameters: *const ::core::ffi::c_void,
            initializationparameterssizeinbytes: usize,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.InitializeExtensionCommand(
                ::windows::core::from_raw_borrowed(&pextensioncommand),
                ::core::mem::transmute_copy(&pinitializationparameters),
                ::core::mem::transmute_copy(&initializationparameterssizeinbytes),
            )
        }
        unsafe extern "system" fn ExecuteExtensionCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pextensioncommand: *mut ::core::ffi::c_void,
            pexecutionparameters: *const ::core::ffi::c_void,
            executionparameterssizeinbytes: usize,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ExecuteExtensionCommand(
                ::windows::core::from_raw_borrowed(&pextensioncommand),
                ::core::mem::transmute_copy(&pexecutionparameters),
                ::core::mem::transmute_copy(&executionparameterssizeinbytes),
            )
        }
        Self {
            base__: ID3D12VideoEncodeCommandList_Vtbl::new::<Identity, Impl, OFFSET>(),
            InitializeExtensionCommand: InitializeExtensionCommand::<Identity, Impl, OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoEncodeCommandList as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoEncodeCommandList2_Impl: Sized + ID3D12VideoEncodeCommandList1_Impl {
    fn EncodeFrame(
        &self,
        pencoder: ::core::option::Option<&ID3D12VideoEncoder>,
        pheap: ::core::option::Option<&ID3D12VideoEncoderHeap>,
        pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS,
        poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS,
    );
    fn ResolveEncoderOutputMetadata(
        &self,
        pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS,
        poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS,
    );
}
impl ::windows::core::RuntimeName for ID3D12VideoEncodeCommandList2 {}
impl ID3D12VideoEncodeCommandList2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoEncodeCommandList2_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoEncodeCommandList2_Vtbl {
        unsafe extern "system" fn EncodeFrame<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pencoder: *mut ::core::ffi::c_void,
            pheap: *mut ::core::ffi::c_void,
            pinputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_INPUT_ARGUMENTS,
            poutputarguments: *const D3D12_VIDEO_ENCODER_ENCODEFRAME_OUTPUT_ARGUMENTS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EncodeFrame(
                ::windows::core::from_raw_borrowed(&pencoder),
                ::windows::core::from_raw_borrowed(&pheap),
                ::core::mem::transmute_copy(&pinputarguments),
                ::core::mem::transmute_copy(&poutputarguments),
            )
        }
        unsafe extern "system" fn ResolveEncoderOutputMetadata<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pinputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_INPUT_ARGUMENTS,
            poutputarguments: *const D3D12_VIDEO_ENCODER_RESOLVE_METADATA_OUTPUT_ARGUMENTS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResolveEncoderOutputMetadata(
                ::core::mem::transmute_copy(&pinputarguments),
                ::core::mem::transmute_copy(&poutputarguments),
            )
        }
        Self {
            base__: ID3D12VideoEncodeCommandList1_Vtbl::new::<Identity, Impl, OFFSET>(),
            EncodeFrame: EncodeFrame::<Identity, Impl, OFFSET>,
            ResolveEncoderOutputMetadata: ResolveEncoderOutputMetadata::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoEncodeCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoEncodeCommandList1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoEncodeCommandList3_Impl: Sized + ID3D12VideoEncodeCommandList2_Impl {
    fn Barrier(&self, numbarriergroups: u32, pbarriergroups: *const D3D12_BARRIER_GROUP);
}
impl ::windows::core::RuntimeName for ID3D12VideoEncodeCommandList3 {}
impl ID3D12VideoEncodeCommandList3_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoEncodeCommandList3_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoEncodeCommandList3_Vtbl {
        unsafe extern "system" fn Barrier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncodeCommandList3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numbarriergroups: u32,
            pbarriergroups: *const D3D12_BARRIER_GROUP,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Barrier(
                ::core::mem::transmute_copy(&numbarriergroups),
                ::core::mem::transmute_copy(&pbarriergroups),
            )
        }
        Self {
            base__: ID3D12VideoEncodeCommandList2_Vtbl::new::<Identity, Impl, OFFSET>(),
            Barrier: Barrier::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncodeCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoEncodeCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoEncodeCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoEncodeCommandList2 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoEncoder_Impl: Sized + ID3D12Pageable_Impl {
    fn GetNodeMask(&self) -> u32;
    fn GetEncoderFlags(&self) -> D3D12_VIDEO_ENCODER_FLAGS;
    fn GetCodec(&self) -> D3D12_VIDEO_ENCODER_CODEC;
    fn GetCodecProfile(
        &self,
        dstprofile: &D3D12_VIDEO_ENCODER_PROFILE_DESC,
    ) -> ::windows::core::Result<()>;
    fn GetCodecConfiguration(
        &self,
        dstcodecconfig: &D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
    ) -> ::windows::core::Result<()>;
    fn GetInputFormat(&self) -> DXGI_FORMAT;
    fn GetMaxMotionEstimationPrecision(
        &self,
    ) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE;
}
impl ::windows::core::RuntimeName for ID3D12VideoEncoder {}
impl ID3D12VideoEncoder_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoEncoder_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoEncoder_Vtbl {
        unsafe extern "system" fn GetNodeMask<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoder_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNodeMask()
        }
        unsafe extern "system" fn GetEncoderFlags<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoder_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_VIDEO_ENCODER_FLAGS {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetEncoderFlags()
        }
        unsafe extern "system" fn GetCodec<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoder_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_VIDEO_ENCODER_CODEC {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCodec()
        }
        unsafe extern "system" fn GetCodecProfile<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoder_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCodecProfile(::core::mem::transmute(&dstprofile))
                .into()
        }
        unsafe extern "system" fn GetCodecConfiguration<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoder_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            dstcodecconfig: D3D12_VIDEO_ENCODER_CODEC_CONFIGURATION,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCodecConfiguration(::core::mem::transmute(&dstcodecconfig))
                .into()
        }
        unsafe extern "system" fn GetInputFormat<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoder_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> DXGI_FORMAT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetInputFormat()
        }
        unsafe extern "system" fn GetMaxMotionEstimationPrecision<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoder_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_VIDEO_ENCODER_MOTION_ESTIMATION_PRECISION_MODE {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetMaxMotionEstimationPrecision()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetNodeMask: GetNodeMask::<Identity, Impl, OFFSET>,
            GetEncoderFlags: GetEncoderFlags::<Identity, Impl, OFFSET>,
            GetCodec: GetCodec::<Identity, Impl, OFFSET>,
            GetCodecProfile: GetCodecProfile::<Identity, Impl, OFFSET>,
            GetCodecConfiguration: GetCodecConfiguration::<Identity, Impl, OFFSET>,
            GetInputFormat: GetInputFormat::<Identity, Impl, OFFSET>,
            GetMaxMotionEstimationPrecision: GetMaxMotionEstimationPrecision::<
                Identity,
                Impl,
                OFFSET,
            >,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncoder as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoEncoderHeap_Impl: Sized + ID3D12Pageable_Impl {
    fn GetNodeMask(&self) -> u32;
    fn GetEncoderHeapFlags(&self) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS;
    fn GetCodec(&self) -> D3D12_VIDEO_ENCODER_CODEC;
    fn GetCodecProfile(
        &self,
        dstprofile: &D3D12_VIDEO_ENCODER_PROFILE_DESC,
    ) -> ::windows::core::Result<()>;
    fn GetCodecLevel(
        &self,
        dstlevel: &D3D12_VIDEO_ENCODER_LEVEL_SETTING,
    ) -> ::windows::core::Result<()>;
    fn GetResolutionListCount(&self) -> u32;
    fn GetResolutionList(
        &self,
        resolutionslistcount: u32,
        presolutionlist: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoEncoderHeap {}
impl ID3D12VideoEncoderHeap_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoEncoderHeap_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoEncoderHeap_Vtbl {
        unsafe extern "system" fn GetNodeMask<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoderHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNodeMask()
        }
        unsafe extern "system" fn GetEncoderHeapFlags<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoderHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_VIDEO_ENCODER_HEAP_FLAGS {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetEncoderHeapFlags()
        }
        unsafe extern "system" fn GetCodec<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoderHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> D3D12_VIDEO_ENCODER_CODEC {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCodec()
        }
        unsafe extern "system" fn GetCodecProfile<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoderHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            dstprofile: D3D12_VIDEO_ENCODER_PROFILE_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCodecProfile(::core::mem::transmute(&dstprofile))
                .into()
        }
        unsafe extern "system" fn GetCodecLevel<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoderHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            dstlevel: D3D12_VIDEO_ENCODER_LEVEL_SETTING,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetCodecLevel(::core::mem::transmute(&dstlevel)).into()
        }
        unsafe extern "system" fn GetResolutionListCount<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoderHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetResolutionListCount()
        }
        unsafe extern "system" fn GetResolutionList<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoEncoderHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            resolutionslistcount: u32,
            presolutionlist: *mut D3D12_VIDEO_ENCODER_PICTURE_RESOLUTION_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetResolutionList(
                ::core::mem::transmute_copy(&resolutionslistcount),
                ::core::mem::transmute_copy(&presolutionlist),
            )
            .into()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetNodeMask: GetNodeMask::<Identity, Impl, OFFSET>,
            GetEncoderHeapFlags: GetEncoderHeapFlags::<Identity, Impl, OFFSET>,
            GetCodec: GetCodec::<Identity, Impl, OFFSET>,
            GetCodecProfile: GetCodecProfile::<Identity, Impl, OFFSET>,
            GetCodecLevel: GetCodecLevel::<Identity, Impl, OFFSET>,
            GetResolutionListCount: GetResolutionListCount::<Identity, Impl, OFFSET>,
            GetResolutionList: GetResolutionList::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoEncoderHeap as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoExtensionCommand_Impl: Sized + ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_VIDEO_EXTENSION_COMMAND_DESC;
    fn GetProtectedResourceSession(
        &self,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoExtensionCommand {}
impl ID3D12VideoExtensionCommand_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoExtensionCommand_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoExtensionCommand_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoExtensionCommand_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_VIDEO_EXTENSION_COMMAND_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        unsafe extern "system" fn GetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoExtensionCommand_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppprotectedsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetProtectedResourceSession(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppprotectedsession),
            )
            .into()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoExtensionCommand as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoMotionEstimator_Impl: Sized + ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_VIDEO_MOTION_ESTIMATOR_DESC;
    fn GetProtectedResourceSession(
        &self,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoMotionEstimator {}
impl ID3D12VideoMotionEstimator_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoMotionEstimator_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoMotionEstimator_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoMotionEstimator_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_VIDEO_MOTION_ESTIMATOR_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        unsafe extern "system" fn GetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoMotionEstimator_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppprotectedsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetProtectedResourceSession(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppprotectedsession),
            )
            .into()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoMotionEstimator as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoMotionVectorHeap_Impl: Sized + ID3D12Pageable_Impl {
    fn GetDesc(&self) -> D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC;
    fn GetProtectedResourceSession(
        &self,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoMotionVectorHeap {}
impl ID3D12VideoMotionVectorHeap_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoMotionVectorHeap_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoMotionVectorHeap_Vtbl {
        unsafe extern "system" fn GetDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoMotionVectorHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetDesc()
        }
        unsafe extern "system" fn GetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoMotionVectorHeap_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppprotectedsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetProtectedResourceSession(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppprotectedsession),
            )
            .into()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetDesc: GetDesc::<Identity, Impl, OFFSET>,
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoMotionVectorHeap as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoProcessCommandList_Impl: Sized + ID3D12CommandList_Impl {
    fn Close(&self) -> ::windows::core::Result<()>;
    fn Reset(
        &self,
        pallocator: ::core::option::Option<&ID3D12CommandAllocator>,
    ) -> ::windows::core::Result<()>;
    fn ClearState(&self);
    fn ResourceBarrier(&self, numbarriers: u32, pbarriers: *const D3D12_RESOURCE_BARRIER);
    fn DiscardResource(
        &self,
        presource: ::core::option::Option<&ID3D12Resource>,
        pregion: *const D3D12_DISCARD_REGION,
    );
    fn BeginQuery(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    );
    fn EndQuery(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        index: u32,
    );
    fn ResolveQueryData(
        &self,
        pqueryheap: ::core::option::Option<&ID3D12QueryHeap>,
        r#type: D3D12_QUERY_TYPE,
        startindex: u32,
        numqueries: u32,
        pdestinationbuffer: ::core::option::Option<&ID3D12Resource>,
        aligneddestinationbufferoffset: u64,
    );
    fn SetPredication(
        &self,
        pbuffer: ::core::option::Option<&ID3D12Resource>,
        alignedbufferoffset: u64,
        operation: D3D12_PREDICATION_OP,
    );
    fn SetMarker(&self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn BeginEvent(&self, metadata: u32, pdata: *const ::core::ffi::c_void, size: u32);
    fn EndEvent(&self);
    fn ProcessFrames(
        &self,
        pvideoprocessor: ::core::option::Option<&ID3D12VideoProcessor>,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        numinputstreams: u32,
        pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS,
    );
    fn WriteBufferImmediate(
        &self,
        count: u32,
        pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
        pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
    );
}
impl ::windows::core::RuntimeName for ID3D12VideoProcessCommandList {}
impl ID3D12VideoProcessCommandList_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoProcessCommandList_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoProcessCommandList_Vtbl {
        unsafe extern "system" fn Close<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Close().into()
        }
        unsafe extern "system" fn Reset<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pallocator: *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Reset(::windows::core::from_raw_borrowed(&pallocator))
                .into()
        }
        unsafe extern "system" fn ClearState<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ClearState()
        }
        unsafe extern "system" fn ResourceBarrier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numbarriers: u32,
            pbarriers: *const D3D12_RESOURCE_BARRIER,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResourceBarrier(
                ::core::mem::transmute_copy(&numbarriers),
                ::core::mem::transmute_copy(&pbarriers),
            )
        }
        unsafe extern "system" fn DiscardResource<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            presource: *mut ::core::ffi::c_void,
            pregion: *const D3D12_DISCARD_REGION,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.DiscardResource(
                ::windows::core::from_raw_borrowed(&presource),
                ::core::mem::transmute_copy(&pregion),
            )
        }
        unsafe extern "system" fn BeginQuery<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            index: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginQuery(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&index),
            )
        }
        unsafe extern "system" fn EndQuery<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            index: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndQuery(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&index),
            )
        }
        unsafe extern "system" fn ResolveQueryData<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pqueryheap: *mut ::core::ffi::c_void,
            r#type: D3D12_QUERY_TYPE,
            startindex: u32,
            numqueries: u32,
            pdestinationbuffer: *mut ::core::ffi::c_void,
            aligneddestinationbufferoffset: u64,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ResolveQueryData(
                ::windows::core::from_raw_borrowed(&pqueryheap),
                ::core::mem::transmute_copy(&r#type),
                ::core::mem::transmute_copy(&startindex),
                ::core::mem::transmute_copy(&numqueries),
                ::windows::core::from_raw_borrowed(&pdestinationbuffer),
                ::core::mem::transmute_copy(&aligneddestinationbufferoffset),
            )
        }
        unsafe extern "system" fn SetPredication<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pbuffer: *mut ::core::ffi::c_void,
            alignedbufferoffset: u64,
            operation: D3D12_PREDICATION_OP,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetPredication(
                ::windows::core::from_raw_borrowed(&pbuffer),
                ::core::mem::transmute_copy(&alignedbufferoffset),
                ::core::mem::transmute_copy(&operation),
            )
        }
        unsafe extern "system" fn SetMarker<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            metadata: u32,
            pdata: *const ::core::ffi::c_void,
            size: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetMarker(
                ::core::mem::transmute_copy(&metadata),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&size),
            )
        }
        unsafe extern "system" fn BeginEvent<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            metadata: u32,
            pdata: *const ::core::ffi::c_void,
            size: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.BeginEvent(
                ::core::mem::transmute_copy(&metadata),
                ::core::mem::transmute_copy(&pdata),
                ::core::mem::transmute_copy(&size),
            )
        }
        unsafe extern "system" fn EndEvent<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.EndEvent()
        }
        unsafe extern "system" fn ProcessFrames<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pvideoprocessor: *mut ::core::ffi::c_void,
            poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
            numinputstreams: u32,
            pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ProcessFrames(
                ::windows::core::from_raw_borrowed(&pvideoprocessor),
                ::core::mem::transmute_copy(&poutputarguments),
                ::core::mem::transmute_copy(&numinputstreams),
                ::core::mem::transmute_copy(&pinputarguments),
            )
        }
        unsafe extern "system" fn WriteBufferImmediate<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            count: u32,
            pparams: *const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER,
            pmodes: *const D3D12_WRITEBUFFERIMMEDIATE_MODE,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.WriteBufferImmediate(
                ::core::mem::transmute_copy(&count),
                ::core::mem::transmute_copy(&pparams),
                ::core::mem::transmute_copy(&pmodes),
            )
        }
        Self {
            base__: ID3D12CommandList_Vtbl::new::<Identity, Impl, OFFSET>(),
            Close: Close::<Identity, Impl, OFFSET>,
            Reset: Reset::<Identity, Impl, OFFSET>,
            ClearState: ClearState::<Identity, Impl, OFFSET>,
            ResourceBarrier: ResourceBarrier::<Identity, Impl, OFFSET>,
            DiscardResource: DiscardResource::<Identity, Impl, OFFSET>,
            BeginQuery: BeginQuery::<Identity, Impl, OFFSET>,
            EndQuery: EndQuery::<Identity, Impl, OFFSET>,
            ResolveQueryData: ResolveQueryData::<Identity, Impl, OFFSET>,
            SetPredication: SetPredication::<Identity, Impl, OFFSET>,
            SetMarker: SetMarker::<Identity, Impl, OFFSET>,
            BeginEvent: BeginEvent::<Identity, Impl, OFFSET>,
            EndEvent: EndEvent::<Identity, Impl, OFFSET>,
            ProcessFrames: ProcessFrames::<Identity, Impl, OFFSET>,
            WriteBufferImmediate: WriteBufferImmediate::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoProcessCommandList1_Impl: Sized + ID3D12VideoProcessCommandList_Impl {
    fn ProcessFrames1(
        &self,
        pvideoprocessor: ::core::option::Option<&ID3D12VideoProcessor>,
        poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
        numinputstreams: u32,
        pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1,
    );
}
impl ::windows::core::RuntimeName for ID3D12VideoProcessCommandList1 {}
impl ID3D12VideoProcessCommandList1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoProcessCommandList1_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoProcessCommandList1_Vtbl {
        unsafe extern "system" fn ProcessFrames1<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pvideoprocessor: *mut ::core::ffi::c_void,
            poutputarguments: *const D3D12_VIDEO_PROCESS_OUTPUT_STREAM_ARGUMENTS,
            numinputstreams: u32,
            pinputarguments: *const D3D12_VIDEO_PROCESS_INPUT_STREAM_ARGUMENTS1,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ProcessFrames1(
                ::windows::core::from_raw_borrowed(&pvideoprocessor),
                ::core::mem::transmute_copy(&poutputarguments),
                ::core::mem::transmute_copy(&numinputstreams),
                ::core::mem::transmute_copy(&pinputarguments),
            )
        }
        Self {
            base__: ID3D12VideoProcessCommandList_Vtbl::new::<Identity, Impl, OFFSET>(),
            ProcessFrames1: ProcessFrames1::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoProcessCommandList as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoProcessCommandList2_Impl: Sized + ID3D12VideoProcessCommandList1_Impl {
    fn SetProtectedResourceSession(
        &self,
        pprotectedresourcesession: ::core::option::Option<&ID3D12ProtectedResourceSession>,
    );
    fn InitializeExtensionCommand(
        &self,
        pextensioncommand: ::core::option::Option<&ID3D12VideoExtensionCommand>,
        pinitializationparameters: *const ::core::ffi::c_void,
        initializationparameterssizeinbytes: usize,
    );
    fn ExecuteExtensionCommand(
        &self,
        pextensioncommand: ::core::option::Option<&ID3D12VideoExtensionCommand>,
        pexecutionparameters: *const ::core::ffi::c_void,
        executionparameterssizeinbytes: usize,
    );
}
impl ::windows::core::RuntimeName for ID3D12VideoProcessCommandList2 {}
impl ID3D12VideoProcessCommandList2_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoProcessCommandList2_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoProcessCommandList2_Vtbl {
        unsafe extern "system" fn SetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pprotectedresourcesession: *mut ::core::ffi::c_void,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.SetProtectedResourceSession(::windows::core::from_raw_borrowed(
                &pprotectedresourcesession,
            ))
        }
        unsafe extern "system" fn InitializeExtensionCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pextensioncommand: *mut ::core::ffi::c_void,
            pinitializationparameters: *const ::core::ffi::c_void,
            initializationparameterssizeinbytes: usize,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.InitializeExtensionCommand(
                ::windows::core::from_raw_borrowed(&pextensioncommand),
                ::core::mem::transmute_copy(&pinitializationparameters),
                ::core::mem::transmute_copy(&initializationparameterssizeinbytes),
            )
        }
        unsafe extern "system" fn ExecuteExtensionCommand<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList2_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pextensioncommand: *mut ::core::ffi::c_void,
            pexecutionparameters: *const ::core::ffi::c_void,
            executionparameterssizeinbytes: usize,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.ExecuteExtensionCommand(
                ::windows::core::from_raw_borrowed(&pextensioncommand),
                ::core::mem::transmute_copy(&pexecutionparameters),
                ::core::mem::transmute_copy(&executionparameterssizeinbytes),
            )
        }
        Self {
            base__: ID3D12VideoProcessCommandList1_Vtbl::new::<Identity, Impl, OFFSET>(),
            SetProtectedResourceSession: SetProtectedResourceSession::<Identity, Impl, OFFSET>,
            InitializeExtensionCommand: InitializeExtensionCommand::<Identity, Impl, OFFSET>,
            ExecuteExtensionCommand: ExecuteExtensionCommand::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList2 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoProcessCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoProcessCommandList1 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoProcessCommandList3_Impl: Sized + ID3D12VideoProcessCommandList2_Impl {
    fn Barrier(&self, numbarriergroups: u32, pbarriergroups: *const D3D12_BARRIER_GROUP);
}
impl ::windows::core::RuntimeName for ID3D12VideoProcessCommandList3 {}
impl ID3D12VideoProcessCommandList3_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoProcessCommandList3_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoProcessCommandList3_Vtbl {
        unsafe extern "system" fn Barrier<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessCommandList3_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numbarriergroups: u32,
            pbarriergroups: *const D3D12_BARRIER_GROUP,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.Barrier(
                ::core::mem::transmute_copy(&numbarriergroups),
                ::core::mem::transmute_copy(&pbarriergroups),
            )
        }
        Self {
            base__: ID3D12VideoProcessCommandList2_Vtbl::new::<Identity, Impl, OFFSET>(),
            Barrier: Barrier::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessCommandList3 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12CommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoProcessCommandList as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoProcessCommandList1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoProcessCommandList2 as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoProcessor_Impl: Sized + ID3D12Pageable_Impl {
    fn GetNodeMask(&self) -> u32;
    fn GetNumInputStreamDescs(&self) -> u32;
    fn GetInputStreamDescs(
        &self,
        numinputstreamdescs: u32,
        pinputstreamdescs: *mut D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
    ) -> ::windows::core::Result<()>;
    fn GetOutputStreamDesc(&self) -> D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC;
}
impl ::windows::core::RuntimeName for ID3D12VideoProcessor {}
impl ID3D12VideoProcessor_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoProcessor_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoProcessor_Vtbl {
        unsafe extern "system" fn GetNodeMask<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessor_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNodeMask()
        }
        unsafe extern "system" fn GetNumInputStreamDescs<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessor_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNumInputStreamDescs()
        }
        unsafe extern "system" fn GetInputStreamDescs<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessor_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            numinputstreamdescs: u32,
            pinputstreamdescs: *mut D3D12_VIDEO_PROCESS_INPUT_STREAM_DESC,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetInputStreamDescs(
                ::core::mem::transmute_copy(&numinputstreamdescs),
                ::core::mem::transmute_copy(&pinputstreamdescs),
            )
            .into()
        }
        unsafe extern "system" fn GetOutputStreamDesc<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessor_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_VIDEO_PROCESS_OUTPUT_STREAM_DESC,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetOutputStreamDesc()
        }
        Self {
            base__: ID3D12Pageable_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetNodeMask: GetNodeMask::<Identity, Impl, OFFSET>,
            GetNumInputStreamDescs: GetNumInputStreamDescs::<Identity, Impl, OFFSET>,
            GetInputStreamDescs: GetInputStreamDescs::<Identity, Impl, OFFSET>,
            GetOutputStreamDesc: GetOutputStreamDesc::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessor as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VideoProcessor1_Impl: Sized + ID3D12VideoProcessor_Impl {
    fn GetProtectedResourceSession(
        &self,
        riid: *const ::windows::core::GUID,
        ppprotectedsession: *mut *mut ::core::ffi::c_void,
    ) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3D12VideoProcessor1 {}
impl ID3D12VideoProcessor1_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VideoProcessor1_Impl,
        const OFFSET: isize,
    >() -> ID3D12VideoProcessor1_Vtbl {
        unsafe extern "system" fn GetProtectedResourceSession<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VideoProcessor1_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            riid: *const ::windows::core::GUID,
            ppprotectedsession: *mut *mut ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetProtectedResourceSession(
                ::core::mem::transmute_copy(&riid),
                ::core::mem::transmute_copy(&ppprotectedsession),
            )
            .into()
        }
        Self {
            base__: ID3D12VideoProcessor_Vtbl::new::<Identity, Impl, OFFSET>(),
            GetProtectedResourceSession: GetProtectedResourceSession::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VideoProcessor1 as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Object as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12DeviceChild as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12Pageable as ::windows::core::ComInterface>::IID
            || iid == &<ID3D12VideoProcessor as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12VirtualizationGuestDevice_Impl: Sized {
    fn ShareWithHost(
        &self,
        pobject: ::core::option::Option<&ID3D12DeviceChild>,
    ) -> ::windows::core::Result<::windows::Win32::Foundation::HANDLE>;
    fn CreateFenceFd(
        &self,
        pfence: ::core::option::Option<&ID3D12Fence>,
        fencevalue: u64,
    ) -> ::windows::core::Result<i32>;
}
impl ::windows::core::RuntimeName for ID3D12VirtualizationGuestDevice {}
impl ID3D12VirtualizationGuestDevice_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12VirtualizationGuestDevice_Impl,
        const OFFSET: isize,
    >() -> ID3D12VirtualizationGuestDevice_Vtbl {
        unsafe extern "system" fn ShareWithHost<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VirtualizationGuestDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pobject: *mut ::core::ffi::c_void,
            phandle: *mut ::windows::Win32::Foundation::HANDLE,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.ShareWithHost(::windows::core::from_raw_borrowed(&pobject)) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(phandle, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn CreateFenceFd<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12VirtualizationGuestDevice_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pfence: *mut ::core::ffi::c_void,
            fencevalue: u64,
            pfencefd: *mut i32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.CreateFenceFd(
                ::windows::core::from_raw_borrowed(&pfence),
                ::core::mem::transmute_copy(&fencevalue),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pfencefd, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            ShareWithHost: ShareWithHost::<Identity, Impl, OFFSET>,
            CreateFenceFd: CreateFenceFd::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12VirtualizationGuestDevice as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3D12WorkGraphProperties_Impl: Sized {
    fn GetNumWorkGraphs(&self) -> u32;
    fn GetProgramName(&self, workgraphindex: u32) -> ::windows::core::PWSTR;
    fn GetWorkGraphIndex(&self, pprogramname: &::windows::core::PCWSTR) -> u32;
    fn GetNumNodes(&self, workgraphindex: u32) -> u32;
    fn GetNodeID(&self, workgraphindex: u32, nodeindex: u32) -> D3D12_NODE_ID;
    fn GetNodeIndex(&self, workgraphindex: u32, nodeid: &D3D12_NODE_ID) -> u32;
    fn GetNodeLocalRootArgumentsTableIndex(&self, workgraphindex: u32, nodeindex: u32) -> u32;
    fn GetNumEntrypoints(&self, workgraphindex: u32) -> u32;
    fn GetEntrypointID(&self, workgraphindex: u32, entrypointindex: u32) -> D3D12_NODE_ID;
    fn GetEntrypointIndex(&self, workgraphindex: u32, nodeid: &D3D12_NODE_ID) -> u32;
    fn GetEntrypointRecordSizeInBytes(&self, workgraphindex: u32, entrypointindex: u32) -> u32;
    fn GetWorkGraphMemoryRequirements(
        &self,
        workgraphindex: u32,
        pworkgraphmemoryrequirements: *mut D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS,
    );
}
impl ::windows::core::RuntimeName for ID3D12WorkGraphProperties {}
impl ID3D12WorkGraphProperties_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3D12WorkGraphProperties_Impl,
        const OFFSET: isize,
    >() -> ID3D12WorkGraphProperties_Vtbl {
        unsafe extern "system" fn GetNumWorkGraphs<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNumWorkGraphs()
        }
        unsafe extern "system" fn GetProgramName<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            workgraphindex: u32,
        ) -> ::windows::core::PWSTR {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetProgramName(::core::mem::transmute_copy(&workgraphindex))
        }
        unsafe extern "system" fn GetWorkGraphIndex<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            pprogramname: ::windows::core::PCWSTR,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetWorkGraphIndex(::core::mem::transmute(&pprogramname))
        }
        unsafe extern "system" fn GetNumNodes<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            workgraphindex: u32,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNumNodes(::core::mem::transmute_copy(&workgraphindex))
        }
        unsafe extern "system" fn GetNodeID<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_NODE_ID,
            workgraphindex: u32,
            nodeindex: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetNodeID(
                ::core::mem::transmute_copy(&workgraphindex),
                ::core::mem::transmute_copy(&nodeindex),
            )
        }
        unsafe extern "system" fn GetNodeIndex<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            workgraphindex: u32,
            nodeid: D3D12_NODE_ID,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNodeIndex(
                ::core::mem::transmute_copy(&workgraphindex),
                ::core::mem::transmute(&nodeid),
            )
        }
        unsafe extern "system" fn GetNodeLocalRootArgumentsTableIndex<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            workgraphindex: u32,
            nodeindex: u32,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNodeLocalRootArgumentsTableIndex(
                ::core::mem::transmute_copy(&workgraphindex),
                ::core::mem::transmute_copy(&nodeindex),
            )
        }
        unsafe extern "system" fn GetNumEntrypoints<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            workgraphindex: u32,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetNumEntrypoints(::core::mem::transmute_copy(&workgraphindex))
        }
        unsafe extern "system" fn GetEntrypointID<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            result__: *mut D3D12_NODE_ID,
            workgraphindex: u32,
            entrypointindex: u32,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            *result__ = this.GetEntrypointID(
                ::core::mem::transmute_copy(&workgraphindex),
                ::core::mem::transmute_copy(&entrypointindex),
            )
        }
        unsafe extern "system" fn GetEntrypointIndex<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            workgraphindex: u32,
            nodeid: D3D12_NODE_ID,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetEntrypointIndex(
                ::core::mem::transmute_copy(&workgraphindex),
                ::core::mem::transmute(&nodeid),
            )
        }
        unsafe extern "system" fn GetEntrypointRecordSizeInBytes<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            workgraphindex: u32,
            entrypointindex: u32,
        ) -> u32 {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetEntrypointRecordSizeInBytes(
                ::core::mem::transmute_copy(&workgraphindex),
                ::core::mem::transmute_copy(&entrypointindex),
            )
        }
        unsafe extern "system" fn GetWorkGraphMemoryRequirements<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3D12WorkGraphProperties_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            workgraphindex: u32,
            pworkgraphmemoryrequirements: *mut D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS,
        ) {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetWorkGraphMemoryRequirements(
                ::core::mem::transmute_copy(&workgraphindex),
                ::core::mem::transmute_copy(&pworkgraphmemoryrequirements),
            )
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetNumWorkGraphs: GetNumWorkGraphs::<Identity, Impl, OFFSET>,
            GetProgramName: GetProgramName::<Identity, Impl, OFFSET>,
            GetWorkGraphIndex: GetWorkGraphIndex::<Identity, Impl, OFFSET>,
            GetNumNodes: GetNumNodes::<Identity, Impl, OFFSET>,
            GetNodeID: GetNodeID::<Identity, Impl, OFFSET>,
            GetNodeIndex: GetNodeIndex::<Identity, Impl, OFFSET>,
            GetNodeLocalRootArgumentsTableIndex: GetNodeLocalRootArgumentsTableIndex::<
                Identity,
                Impl,
                OFFSET,
            >,
            GetNumEntrypoints: GetNumEntrypoints::<Identity, Impl, OFFSET>,
            GetEntrypointID: GetEntrypointID::<Identity, Impl, OFFSET>,
            GetEntrypointIndex: GetEntrypointIndex::<Identity, Impl, OFFSET>,
            GetEntrypointRecordSizeInBytes: GetEntrypointRecordSizeInBytes::<Identity, Impl, OFFSET>,
            GetWorkGraphMemoryRequirements: GetWorkGraphMemoryRequirements::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3D12WorkGraphProperties as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3DBlob_Impl: Sized {
    fn GetBufferPointer(&self) -> *mut ::core::ffi::c_void;
    fn GetBufferSize(&self) -> usize;
}
impl ::windows::core::RuntimeName for ID3DBlob {}
impl ID3DBlob_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3DBlob_Impl,
        const OFFSET: isize,
    >() -> ID3DBlob_Vtbl {
        unsafe extern "system" fn GetBufferPointer<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3DBlob_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> *mut ::core::ffi::c_void {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetBufferPointer()
        }
        unsafe extern "system" fn GetBufferSize<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3DBlob_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
        ) -> usize {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.GetBufferSize()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            GetBufferPointer: GetBufferPointer::<Identity, Impl, OFFSET>,
            GetBufferSize: GetBufferSize::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3DBlob as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3DDestructionNotifier_Impl: Sized {
    fn RegisterDestructionCallback(
        &self,
        callbackfn: ::windows::Win32::Graphics::Direct3D::PFN_DESTRUCTION_CALLBACK,
        pdata: *const ::core::ffi::c_void,
    ) -> ::windows::core::Result<u32>;
    fn UnregisterDestructionCallback(&self, callbackid: u32) -> ::windows::core::Result<()>;
}
impl ::windows::core::RuntimeName for ID3DDestructionNotifier {}
impl ID3DDestructionNotifier_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: ID3DDestructionNotifier_Impl,
        const OFFSET: isize,
    >() -> ID3DDestructionNotifier_Vtbl {
        unsafe extern "system" fn RegisterDestructionCallback<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3DDestructionNotifier_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            callbackfn: ::windows::Win32::Graphics::Direct3D::PFN_DESTRUCTION_CALLBACK,
            pdata: *const ::core::ffi::c_void,
            pcallbackid: *mut u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            match this.RegisterDestructionCallback(
                ::core::mem::transmute_copy(&callbackfn),
                ::core::mem::transmute_copy(&pdata),
            ) {
                ::core::result::Result::Ok(ok__) => {
                    ::core::ptr::write(pcallbackid, ::core::mem::transmute(ok__));
                    ::windows::core::HRESULT(0)
                }
                ::core::result::Result::Err(err) => err.into(),
            }
        }
        unsafe extern "system" fn UnregisterDestructionCallback<
            Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
            Impl: ID3DDestructionNotifier_Impl,
            const OFFSET: isize,
        >(
            this: *mut ::core::ffi::c_void,
            callbackid: u32,
        ) -> ::windows::core::HRESULT {
            let this = (this as *const *const ()).offset(OFFSET) as *const Identity;
            let this = (*this).get_impl();
            this.UnregisterDestructionCallback(::core::mem::transmute_copy(&callbackid))
                .into()
        }
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
            RegisterDestructionCallback: RegisterDestructionCallback::<Identity, Impl, OFFSET>,
            UnregisterDestructionCallback: UnregisterDestructionCallback::<Identity, Impl, OFFSET>,
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<ID3DDestructionNotifier as ::windows::core::ComInterface>::IID
    }
}
pub trait ID3DInclude_Impl: Sized {
    fn Open(
        &self,
        includetype: D3D_INCLUDE_TYPE,
        pfilename: &::windows::core::PCSTR,
        pparentdata: *const ::core::ffi::c_void,
        ppdata: *mut *mut ::core::ffi::c_void,
        pbytes: *mut u32,
    ) -> ::windows::core::Result<()>;
    fn Close(&self, pdata: *const ::core::ffi::c_void) -> ::windows::core::Result<()>;
}
impl ID3DInclude_Vtbl {
    pub const fn new<Impl: ID3DInclude_Impl>() -> ID3DInclude_Vtbl {
        unsafe extern "system" fn Open<Impl: ID3DInclude_Impl>(
            this: *mut ::core::ffi::c_void,
            includetype: D3D_INCLUDE_TYPE,
            pfilename: ::windows::core::PCSTR,
            pparentdata: *const ::core::ffi::c_void,
            ppdata: *mut *mut ::core::ffi::c_void,
            pbytes: *mut u32,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.Open(
                ::core::mem::transmute_copy(&includetype),
                ::core::mem::transmute(&pfilename),
                ::core::mem::transmute_copy(&pparentdata),
                ::core::mem::transmute_copy(&ppdata),
                ::core::mem::transmute_copy(&pbytes),
            )
            .into()
        }
        unsafe extern "system" fn Close<Impl: ID3DInclude_Impl>(
            this: *mut ::core::ffi::c_void,
            pdata: *const ::core::ffi::c_void,
        ) -> ::windows::core::HRESULT {
            let this =
                (this as *mut *mut ::core::ffi::c_void) as *const ::windows::core::ScopedHeap;
            let this = &*((*this).this as *const Impl);
            this.Close(::core::mem::transmute_copy(&pdata)).into()
        }
        Self {
            Open: Open::<Impl>,
            Close: Close::<Impl>,
        }
    }
}
#[doc(hidden)]
struct ID3DInclude_ImplVtbl<T: ID3DInclude_Impl>(::std::marker::PhantomData<T>);
impl<T: ID3DInclude_Impl> ID3DInclude_ImplVtbl<T> {
    const VTABLE: ID3DInclude_Vtbl = ID3DInclude_Vtbl::new::<T>();
}
impl ID3DInclude {
    pub fn new<'a, T: ID3DInclude_Impl>(this: &'a T) -> ::windows::core::ScopedInterface<'a, Self> {
        let this = ::windows::core::ScopedHeap {
            vtable: &ID3DInclude_ImplVtbl::<T>::VTABLE as *const _ as *const _,
            this: this as *const _ as *const _,
        };
        let this = ::std::mem::ManuallyDrop::new(::std::boxed::Box::new(this));
        unsafe { ::windows::core::ScopedInterface::new(::std::mem::transmute(&this.vtable)) }
    }
}
pub trait OpenCLOn12CreatorID_Impl: Sized {}
impl ::windows::core::RuntimeName for OpenCLOn12CreatorID {}
impl OpenCLOn12CreatorID_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: OpenCLOn12CreatorID_Impl,
        const OFFSET: isize,
    >() -> OpenCLOn12CreatorID_Vtbl {
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<OpenCLOn12CreatorID as ::windows::core::ComInterface>::IID
    }
}
pub trait OpenGLOn12CreatorID_Impl: Sized {}
impl ::windows::core::RuntimeName for OpenGLOn12CreatorID {}
impl OpenGLOn12CreatorID_Vtbl {
    pub const fn new<
        Identity: ::windows::core::IUnknownImpl<Impl = Impl>,
        Impl: OpenGLOn12CreatorID_Impl,
        const OFFSET: isize,
    >() -> OpenGLOn12CreatorID_Vtbl {
        Self {
            base__: ::windows::core::IUnknown_Vtbl::new::<Identity, OFFSET>(),
        }
    }
    pub fn matches(iid: &windows::core::GUID) -> bool {
        iid == &<OpenGLOn12CreatorID as ::windows::core::ComInterface>::IID
    }
}
